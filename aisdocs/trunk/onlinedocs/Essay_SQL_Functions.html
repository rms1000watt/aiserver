
<HTML>
<HEAD>
<link rel="stylesheet" type="text/css" href="../CoreContent/help.css">
<TITLE>AIS Essay Template</TITLE></HEAD>
<!--Page Parameters -->
<BODY BGCOLOR="#FFFFF0" TEXT="#000000" LINK="#0000ff">

<A NAME="topage"></A>
<A HREF="TOP"></A>



<P>&nbsp;</P>

<FONT COLOR="#000080"><H1>SQL Functions</H1></FONT>
<P>&nbsp;</P>

<UL>
<li><a href="#SOverview"><FONT SIZE=2>Overview</font></a></li><li><a href="#SOperator and Function Reference"><FONT SIZE=2>Operator and Function Reference</font></a></li><li><a href="#SOperators"><FONT SIZE=2>Operators</font></a></li><li><a href="#SOperator Precedence"><FONT SIZE=2>Operator Precedence</font></a></li><li><a href="#SType Conversion in Expression Evaluation"><FONT SIZE=2>Type Conversion in Expression Evaluation</font></a></li><li><a href="#SComparison Functions and Operators"><FONT SIZE=2>Comparison Functions and Operators</font></a></li><li><a href="#SLogical Operators"><FONT SIZE=2>Logical Operators</font></a></li><li><a href="#SControl Flow Functions"><FONT SIZE=2>Control Flow Functions</font></a></li><li><a href="#SString Functions"><FONT SIZE=2>String Functions</font></a></li><li><a href="#SString Comparison Functions"><FONT SIZE=2>String Comparison Functions</font></a></li><li><a href="#SRegular Expressions"><FONT SIZE=2>Regular Expressions</font></a></li><li><a href="#SNumeric Functions"><FONT SIZE=2>Numeric Functions</font></a></li><li><a href="#SArithmetic Operators"><FONT SIZE=2>Arithmetic Operators</font></a></li><li><a href="#SMathematical Functions"><FONT SIZE=2>Mathematical Functions</font></a></li><li><a href="#SDate and Time Functions"><FONT SIZE=2>Date and Time Functions</font></a></li><li><a href="#SCast Functions and Operators"><FONT SIZE=2>Cast Functions and Operators</font></a></li><li><a href="#SOther Functions"><FONT SIZE=2>Other Functions</font></a></li><li><a href="#SBit Functions"><FONT SIZE=2>Bit Functions</font></a></li><li><a href="#SEncryption and Compression Functions"><FONT SIZE=2>Encryption and Compression Functions</font></a></li><li><a href="#SInformation Functions"><FONT SIZE=2>Information Functions</font></a></li><li><a href="#SMiscellaneous Functions"><FONT SIZE=2>Miscellaneous Functions</font></a></li><li><a href="#SGROUP BY (Aggregate) Functions"><FONT SIZE=2>GROUP BY (Aggregate) Functions</font></a></li><li><a href="#SGROUP BY Modifiers"><FONT SIZE=2>GROUP BY Modifiers</font></a></li><li><a href="#SGROUP BY and HAVING with Hidden Fields"><FONT SIZE=2>GROUP BY and HAVING with Hidden Fields</font></a></li>
</UL>

<P><H2><A NAME="SOverview"></A>Overview</H2></P>		
		<p>Expressions can be used at several points in SQL statements,
			such as in the ORDER BY or HAVING clauses of SELECT statements,
			in the WHERE clause of a SELECT, DELETE, or UPDATE statement, or in SET statements.
			Expressions can be written using literal values, column values, NULL,
			built-in functions, stored functions, user-defined functions, and operators.
			This chapter describes the functions and operators that are allowed for writing expressions in MySQL.<p>
		<p>An expression that contains NULL always produces a NULL value unless otherwise
			indicated in the documentation for a particular function or operator.</p>
		<p>Note: By default, there must be no whitespace between a function name and the parenthesis following it.
			This helps the MySQL parser distinguish between function calls and references to tables or columns
			that happen to have the same name as a function. However, spaces around function arguments are permitted.</p>
		<p>You can tell the MySQL server to accept spaces after function names by starting it with the --sql-mode=IGNORE_SPACE option.
			Individual client programs can request this behavior by using the CLIENT_IGNORE_SPACE option for mysql_real_connect().
			In either case, all function names become reserved words.</p>
		<p>For the sake of brevity, most examples in this chapter display the output from the mysql program in abbreviated form.
			Rather than showing examples in this format:</p>
		<pre>(sql sqlHandle {SELECT MOD(29,9)}) <b>Returns</b>
+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+</pre>
		<p>This format is used instead:</p>
		<pre>(sql sqlHandle {SELECT MOD(29,9)}) <b>Returns</b> 2</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SOperator and Function Reference"></A>Operator and Function Reference</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>ABS()</td><td>Return the absolute value</td></tr>
			<tr><td>ACOS()</td><td>Return the arc cosine</td></tr>
			<tr><td>ADDDATE()</td><td>Add dates</td></tr>
			<tr><td>ADDTIME()</td><td>Add time</td></tr>
			<tr><td>AES_DECRYPT()</td><td>Decrypt using AES</td></tr>
			<tr><td>AES_ENCRYPT()</td><td>Encrypt using AES</td></tr>
			<tr><td>AND, &amp;&amp;</td><td>Logical AND</td></tr>
			<tr><td>ASCII()</td><td>Return numeric value of left-most character</td></tr>
			<tr><td>ASIN()</td><td>Return the arc sine</td></tr>
			<tr><td>ATAN2(), ATAN()</td><td>Return the arc tangent of the two arguments</td></tr>
			<tr><td>ATAN()</td><td>Return the arc tangent</td></tr>
			<tr><td>AVG()</td><td>Return the average value of the argument</td></tr>
			<tr><td>BENCHMARK()</td><td>Repeatedly execute an expression</td></tr>
			<tr><td>BETWEEN ... AND ... </td><td>Check whether a value is within a range of values</td></tr>
			<tr><td>BIN()</td><td>Return a string representation of the argument</td></tr>
			<tr><td>BINARY</td><td>Cast a string to a binary string</td></tr>
			<tr><td>BIT_AND()</td><td>Return bitwise and</td></tr>
			<tr><td>BIT_COUNT()</td><td>Return the number of bits that are set</td></tr>
			<tr><td>BIT_LENGTH()</td><td>Return length of argument in bits</td></tr>
			<tr><td>BIT_OR()</td><td>Return bitwise or</td></tr>
			<tr><td>BIT_XOR()</td><td>Return bitwise xor</td></tr>
			<tr><td>&amp;</td><td>Bitwise AND</td></tr>
			<tr><td>~</td><td>Invert bits</td></tr>
			<tr><td>|</td><td>Bitwise OR</td></tr>
			<tr><td>^</td><td>Bitwise XOR</td></tr>
			<tr><td>CASE</td><td>Case operator</td></tr>
			<tr><td>CAST()</td><td>Cast a value as a certain type</td></tr>
			<tr><td>CEIL()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CEILING()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CHAR_LENGTH()</td><td>Return number of characters in argument</td></tr>
			<tr><td>CHAR()</td><td>Return the character for each integer passed</td></tr>
			<tr><td>CHARACTER_LENGTH()</td><td>A synonym for CHAR_LENGTH()</td></tr>
			<tr><td>CHARSET()</td><td>Return the character set of the argument</td></tr>
			<tr><td>COALESCE()</td><td>Return the first non-NULL argument</td></tr>
			<tr><td>COERCIBILITY()</td><td>Return the collation coercibility value of the string  argument</td></tr>
			<tr><td>COLLATION()</td><td>Return the collation of the string argument</td></tr>
			<tr><td>COMPRESS()</td><td>Return result as a binary string</td></tr>
			<tr><td>CONCAT_WS()</td><td>Return concatenate with  separator</td></tr>
			<tr><td>CONCAT()</td><td>Return concatenated string</td></tr>
			<tr><td>CONNECTION_ID()</td><td>Return the connection ID (thread ID)   for the connection</td></tr>
			<tr><td>CONV()</td><td>Convert numbers between different number bases</td></tr>
			<tr><td>CONVERT_TZ()</td><td>Convert from one timezone to another</td></tr>
			<tr><td>Convert()</td><td>Cast a value as a certain type</td></tr>
			<tr><td>COS()</td><td>Return the cosine</td></tr>
			<tr><td>COT()</td><td>Return the cotangent</td></tr>
			<tr><td>COUNT(DISTINCT)</td><td>Return the count of a number of different values</td></tr>
			<tr><td>COUNT()</td><td>Return a count of the number of rows returned</td></tr>
			<tr><td>CRC32()</td><td>Compute a cyclic redundancy check value</td></tr>
			<tr><td>CURDATE()</td><td>Return the current date</td></tr>
			<tr><td>CURRENT_DATE(), CURRENT_DATE</td><td>Synonyms for CURDATE()</td></tr>
			<tr><td>CURRENT_TIME(), CURRENT_TIME</td><td>Synonyms for CURTIME()</td></tr>
			<tr><td>CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP</td><td>Synonyms for NOW()</td></tr>
			<tr><td>CURRENT_USER(), CURRENT_USER</td><td>Return the username and hostname combination</td></tr>
			<tr><td>CURTIME()</td><td>Return the current time</td></tr>
			<tr><td>DATABASE()</td><td>Return the default (current) database name</td></tr>
			<tr><td>DATE_ADD()</td><td>Add two dates</td></tr>
			<tr><td>DATE_FORMAT()</td><td>Format date as specified</td></tr>
			<tr><td>DATE_SUB()</td><td>Subtract two dates</td></tr>
			<tr><td>DATE()</td><td>Extract the date part of a date or datetime expression</td></tr>
			<tr><td>DATEDIFF()</td><td>Subtract two dates</td></tr>
			<tr><td>DAY()</td><td>Synonym for DAYOFMONTH()</td></tr>
			<tr><td>DAYNAME()</td><td>Return the name of the weekday</td></tr>
			<tr><td>DAYOFMONTH()</td><td>Return the day of the month (0-31)</td></tr>
			<tr><td>DAYOFWEEK()</td><td>Return the weekday index of the argument</td></tr>
			<tr><td>DAYOFYEAR()</td><td>Return the day of the year (1-366)</td></tr>
			<tr><td>DECODE()</td><td>Decodes a string encrypted using ENCODE()</td></tr>
			<tr><td>DEFAULT()</td><td>Return the default value for a table column</td></tr>
			<tr><td>DEGREES()</td><td>Convert radians to degrees</td></tr>
			<tr><td>DES_DECRYPT()</td><td>Decrypt a string</td></tr>
			<tr><td>DES_ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>DIV</td><td>Integer division</td></tr>
			<tr><td>/</td><td>Division operator</td></tr>
			<tr><td>ELT()</td><td>Return string at index number</td></tr>
			<tr><td>ENCODE()</td><td>Encode a string</td></tr>
			<tr><td>ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>&lt;=&gt;</td><td>NULL-safe equal to operator</td></tr>
			<tr><td>=</td><td>Equal operator</td></tr>
			<tr><td>EXP()</td><td>Raise to the power of</td></tr>
			<tr><td>EXPORT_SET()</td><td>Return a string such that for every bit set in the value  bits, you get an on string and for every unset bit, you get an off string</td></tr>
			<tr><td>EXTRACT</td><td>Extract part of a date</td></tr>
			<tr><td>ExtractValue()</td><td>Extracts a value from an XML string using XPath notation</td></tr>
			<tr><td>FIELD()</td><td>Return the index (position) of the first argument  in the subsequent arguments</td></tr>
			<tr><td>FIND_IN_SET()</td><td>Return the index position of  the first argument within the second argument</td></tr>
			<tr><td>FLOOR()</td><td>Return the largest integer value not greater than  the argument</td></tr>
			<tr><td>FORMAT()</td><td>Return a number formatted to specified number of decimal places</td></tr>
			<tr><td>FOUND_ROWS()</td><td>For a SELECT with a LIMIT clause, the  number of rows that would be returned were there no LIMIT clause</td></tr>
			<tr><td>FROM_DAYS()</td><td>Convert a day number to a date</td></tr>
			<tr><td>FROM_UNIXTIME()</td><td>Format UNIX timestamp as a date</td></tr>
			<tr><td>GET_FORMAT()</td><td>Return a date format string</td></tr>
			<tr><td>GET_LOCK()</td><td>Get a named lock</td></tr>
			<tr><td>&gt;=</td><td>Greater than or equal operator</td></tr>
			<tr><td>&gt;</td><td>Greater than operator</td></tr>
			<tr><td>GREATEST()</td><td>Return the largest argument</td></tr>
			<tr><td>GROUP_CONCAT()</td><td>Return a concatenated string</td></tr>
			<tr><td>HEX()</td><td>Return a hexadecimal representation of a  decimal or string value</td></tr>
			<tr><td>HOUR()</td><td>Extract the hour</td></tr>
			<tr><td>IF()</td><td>If/else construct</td></tr>
			<tr><td>IFNULL()</td><td>Null if/else construct</td></tr>
			<tr><td>IN()</td><td>Check whether a value is within a set of values</td></tr>
			<tr><td>INET_ATON()</td><td>Return the numeric value of an IP address</td></tr>
			<tr><td>INET_NTOA()</td><td>Return the IP address from a numeric value</td></tr>
			<tr><td>INSERT()</td><td>Insert a substring at the specified position up to  the specified number of characters</td></tr>
			<tr><td>INSTR()</td><td>Return the index of the first occurrence of substring</td></tr>
			<tr><td>INTERVAL()</td><td>Return the index of the argument   that is less than the first argument</td></tr>
			<tr><td>IS_FREE_LOCK()</td><td>Checks whether the named lock  is free</td></tr>
			<tr><td>IS NOT NULL</td><td>NOT NULL value test</td></tr>
			<tr><td>IS NOT</td><td>Test a value against a boolean</td></tr>
			<tr><td>IS NULL</td><td>NULL value test</td></tr>
			<tr><td>IS_USED_LOCK()</td><td>Checks whether the named lock is in use.  Return connection identifier if true.</td></tr>
			<tr><td>IS</td><td>Test a value against a boolean</td></tr>
			<tr><td>ISNULL()</td><td>Test whether the argument is NULL</td></tr>
			<tr><td>LAST_DAY</td><td>Return the last day of the month for the argument</td></tr>
			<tr><td>LAST_INSERT_ID()</td><td>Value of the AUTOINCREMENT column   for the last INSERT</td></tr>
			<tr><td>LCASE()</td><td>Synonym for LOWER() </td></tr>
			<tr><td>LEAST()</td><td>Return the smallest argument</td></tr>
			<tr><td>&lt;&lt;</td><td>Left shift</td></tr>
			<tr><td>LEFT()</td><td>Return the leftmost number of characters as specified</td></tr>
			<tr><td>LENGTH()</td><td>Return the length of a string in bytes</td></tr>
			<tr><td>&lt;=</td><td>Less than or equal operator</td></tr>
			<tr><td>&lt;</td><td>Less than operator</td></tr>
			<tr><td>LIKE</td><td>Simple pattern matching</td></tr>
			<tr><td>LN()</td><td>Return the natural logarithm of the argument</td></tr>
			<tr><td>LOAD_FILE()</td><td>Load the named file</td></tr>
			<tr><td>LOCALTIME(), LOCALTIME</td><td>Synonym for NOW()</td></tr>
			<tr><td>LOCALTIMESTAMP, LOCALTIMESTAMP()(v4.0.6)</td><td>Synonym for NOW()</td></tr>
			<tr><td>LOCATE()</td><td>Return the position of the first occurrence  of substring</td></tr>
			<tr><td>LOG10()</td><td>Return the base-10 logarithm of the argument</td></tr>
			<tr><td>LOG2()</td><td>Return the base-2 logarithm of the argument</td></tr>
			<tr><td>LOG()</td><td>  Return the natural logarithm of the first argument  </td></tr>
			<tr><td>LOWER()</td><td>Return the argument in lowercase </td></tr>
			<tr><td>LPAD()</td><td>Return the string argument, left-padded  with the specified string</td></tr>
			<tr><td>LTRIM()</td><td>Remove leading spaces</td></tr>
			<tr><td>MAKE_SET()</td><td>Return a set of comma-separated strings  that have the corresponding bit in bits set</td></tr>
			<tr><td>MAKEDATE()</td><td>Create a date from the year and day of year</td></tr>
			<tr><td>MAKETIME</td><td>MAKETIME()</td></tr>
			<tr><td>MASTER_POS_WAIT()</td><td>Block until the slave has read and  applied all updates up to the specified position</td></tr>
			<tr><td>MATCH</td><td>Perform full-text search</td></tr>
			<tr><td>MAX()</td><td>Return the maximum value</td></tr>
			<tr><td>MD5()</td><td>Calculate MD5 checksum</td></tr>
			<tr><td>MICROSECOND()</td><td>Return the microseconds from argument</td></tr>
			<tr><td>MID()</td><td>Return a substring starting from the specified position</td></tr>
			<tr><td>MIN()</td><td>Return the minimum value</td></tr>
			<tr><td>-</td><td>Minus operator</td></tr>
			<tr><td>MINUTE()</td><td>Return the minute from the argument</td></tr>
			<tr><td>MOD()</td><td>Return the remainder</td></tr>
			<tr><td>%</td><td>Modulo operator</td></tr>
			<tr><td>MONTH()</td><td>Return the month from the date passed</td></tr>
			<tr><td>MONTHNAME()</td><td>Return the name of the month</td></tr>
			<tr><td>NAME_CONST()</td><td>Causes the column to have the given name</td></tr>
			<tr><td>NOT BETWEEN ... AND ...</td><td>Check whether a value is not within a range of values</td></tr>
			<tr><td>!=, &lt;&gt;</td><td>Not equal operator</td></tr>
			<tr><td>NOT IN()</td><td>Check whether a value is not within a set of values</td></tr>
			<tr><td>NOT LIKE</td><td>Negation of simple pattern matching</td></tr>
			<tr><td>NOT REGEXP</td><td>Negation of REGEXP</td></tr>
			<tr><td>NOT, !</td><td>Negates value</td></tr>
			<tr><td>NOW()</td><td>Return the current date and time</td></tr>
			<tr><td>NULLIF()</td><td>Return NULL if expr1 = expr2</td></tr>
			<tr><td>OCT()</td><td>Return an octal representation of a decimal  number</td></tr>
			<tr><td>OCTET_LENGTH()</td><td>A synonym for LENGTH()</td></tr>
			<tr><td>OLD_PASSWORD()</td><td>Return the value of the  old (pre-4.1) implementation of PASSWORD</td></tr>
			<tr><td>||, OR</td><td>Logical OR</td></tr>
			<tr><td>ORD()</td><td>Return character code for leftmost character of the  argument</td></tr>
			<tr><td>PASSWORD()</td><td>Calculate and return a password string</td></tr>
			<tr><td>PERIOD_ADD()</td><td>Add a period to a year-month</td></tr>
			<tr><td>PERIOD_DIFF()</td><td>Return the number of months between periods</td></tr>
			<tr><td>PI()</td><td>Return the value of pi</td></tr>
			<tr><td>+</td><td>Addition operator</td></tr>
			<tr><td>POSITION()</td><td>A synonym for LOCATE()</td></tr>
			<tr><td>POW()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>POWER()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>PROCEDURE ANALYSE()</td><td>Analyze the results of a query</td></tr>
			<tr><td>QUARTER()</td><td>Return the quarter from a date argument</td></tr>
			<tr><td>QUOTE()</td><td>Escape the argument for use in an SQL statement</td></tr>
			<tr><td>RADIANS()</td><td>Return argument converted to radians</td></tr>
			<tr><td>RAND()</td><td>Return a random floating-point value</td></tr>
			<tr><td>REGEXP</td><td>Pattern matching using regular expressions</td></tr>
			<tr><td>RELEASE_LOCK()</td><td>Releases the named lock</td></tr>
			<tr><td>REPEAT()</td><td>Repeat a string the specified number of times</td></tr>
			<tr><td>REPLACE()</td><td>Replace occurrences of a specified string</td></tr>
			<tr><td>REVERSE()</td><td>Reverse the characters in a string</td></tr>
			<tr><td>&gt;&gt;</td><td>Right shift</td></tr>
			<tr><td>RIGHT()</td><td>Return the specified rightmost number of characters</td></tr>
			<tr><td>RLIKE</td><td>Synonym for REGEXP</td></tr>
			<tr><td>ROUND()</td><td>Round the argument</td></tr>
			<tr><td>ROW_COUNT()</td><td>The number of rows  updated</td></tr>
			<tr><td>RPAD()</td><td>Append string the specified number of times</td></tr>
			<tr><td>RTRIM()</td><td>Remove trailing spaces</td></tr>
			<tr><td>SCHEMA()</td><td>A synonym for DATABASE()</td></tr>
			<tr><td>SEC_TO_TIME()</td><td>Converts seconds to 'HH:MM:SS' format</td></tr>
			<tr><td>SECOND()</td><td>Return the second (0-59)</td></tr>
			<tr><td>SESSION_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>SHA1(), SHA()</td><td>Calculate an SHA-1 160-bit checksum</td></tr>
			<tr><td>SIGN()</td><td>Return the sign of the argument</td></tr>
			<tr><td>SIN()</td><td>Return the sine of the argument</td></tr>
			<tr><td>SLEEP()</td><td>Sleep for a number of seconds</td></tr>
			<tr><td>SOUNDEX()</td><td>Return a soundex string</td></tr>
			<tr><td>SOUNDS LIKE</td><td>Compare sounds</td></tr>
			<tr><td>SPACE()</td><td>Return a string of the specified number of spaces</td></tr>
			<tr><td>SQRT()</td><td>Return the square root of the argument</td></tr>
			<tr><td>STD()</td><td>Return the population standard deviation</td></tr>
			<tr><td>STDDEV_POP()</td><td>Return the population standard deviation</td></tr>
			<tr><td>STDDEV_SAMP()</td><td>Return the sample standard deviation</td></tr>
			<tr><td>STDDEV()</td><td>Return the population standard deviation</td></tr>
			<tr><td>STR_TO_DATE()</td><td>Convert a string to a date</td></tr>
			<tr><td>STRCMP()</td><td>Compare two strings</td></tr>
			<tr><td>SUBDATE()</td><td>A synonym for DATE_SUB() when invoked with three arguments</td></tr>
			<tr><td>SUBSTR()</td><td>Return the substring as specified</td></tr>
			<tr><td>SUBSTRING_INDEX()</td><td>Return a substring from a  string before the specified number of occurrences of the delimiter</td></tr>
			<tr><td>SUBSTRING()</td><td>Return the substring as specified</td></tr>
			<tr><td>SUBTIME()</td><td>Subtract times</td></tr>
			<tr><td>SUM()</td><td>Return the sum</td></tr>
			<tr><td>SYSDATE()</td><td>Return the time at which the function executes</td></tr>
			<tr><td>SYSTEM_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>TAN()</td><td>Return the tangent of the argument</td></tr>
			<tr><td>TIME_FORMAT()</td><td>Format as time</td></tr>
			<tr><td>TIME_TO_SEC()</td><td>Return the argument converted to seconds</td></tr>
			<tr><td>TIME()</td><td>Extract the time portion of the expression passed</td></tr>
			<tr><td>TIMEDIFF()</td><td>Subtract time</td></tr>
			<tr><td>*</td><td>Times operator</td></tr>
			<tr><td>TIMESTAMP()</td><td>With a single argument, this function returns the date or  datetime expression; with two arguments, the sum of the arguments</td></tr>
			<tr><td>TIMESTAMPADD()</td><td>Add an interval to a datetime expression</td></tr>
			<tr><td>TIMESTAMPDIFF()</td><td>Subtract an interval from a datetime expression</td></tr>
			<tr><td>TO_DAYS()</td><td>Return the date argument converted to days</td></tr>
			<tr><td>TRIM()</td><td>Remove leading and trailing spaces</td></tr>
			<tr><td>TRUNCATE()</td><td>Truncate to specified number of decimal places</td></tr>
			<tr><td>UCASE()</td><td>Synonym for UPPER()</td></tr>
			<tr><td>-</td><td>Change the sign of the argument</td></tr>
			<tr><td>UNCOMPRESS()</td><td>Uncompress a string compressed</td></tr>
			<tr><td>UNCOMPRESSED_LENGTH()</td><td>Return the length of a string before compression</td></tr>
			<tr><td>UNHEX()</td><td>Convert each pair of hexadecimal digits  to a character</td></tr>
			<tr><td>UNIX_TIMESTAMP()</td><td>Return a UNIX timestamp</td></tr>
			<tr><td>UpdateXML()</td><td>Return replaced XML fragment</td></tr>
			<tr><td>UPPER()</td><td>Convert to uppercase</td></tr>
			<tr><td>USER()</td><td>Return the current username and hostname</td></tr>
			<tr><td>UTC_DATE()</td><td>Return the current UTC date</td></tr>
			<tr><td>UTC_TIME()</td><td>Return the current UTC time</td></tr>
			<tr><td>UTC_TIMESTAMP()</td><td>Return the current UTC date and time</td></tr>
			<tr><td>UUID_SHORT()</td><td>Return an integer-valued universal identifier</td></tr>
			<tr><td>UUID()</td><td>Return a Universal Unique Identifier (UUID)</td></tr>
			<tr><td>VALUES()</td><td>Defines the values to be used during an INSERT</td></tr>
			<tr><td>VAR_POP()</td><td>Return the population standard variance</td></tr>
			<tr><td>VAR_SAMP()</td><td>Return the sample variance</td></tr>
			<tr><td>VARIANCE()</td><td>Return the population standard variance</td></tr>
			<tr><td>VERSION()</td><td>Returns a string that indicates the MySQL server version</td></tr>
			<tr><td>WEEK()</td><td>Return the week number</td></tr>
			<tr><td>WEEKDAY()</td><td>Return the weekday index</td></tr>
			<tr><td>WEEKOFYEAR()</td><td>Return the calendar week of the date (0-53)</td></tr>
			<tr><td>XOR</td><td>Logical XOR</td></tr>
			<tr><td>YEAR()</td><td>Return the year</td></tr>
			<tr><td>YEARWEEK()</td><td>Return the year and week</td></tr>
		</table>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SOperators"></A>Operators</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>AND, &amp;&amp;</td><td>Logical AND</td></tr>
			<tr><td>BETWEEN ... AND ... </td><td>Check whether a value is within a range of values</td></tr>
			<tr><td>BINARY</td><td>Cast a string to a binary string</td></tr>
			<tr><td>&amp;</td><td>Bitwise AND</td></tr>
			<tr><td>~</td><td>Invert bits</td></tr>
			<tr><td>|</td><td>Bitwise OR</td></tr>
			<tr><td>^</td><td>Bitwise XOR</td></tr>
			<tr><td>CASE</td><td>Case operator</td></tr>
			<tr><td>DIV</td><td>Integer division</td></tr>
			<tr><td>/</td><td>Division operator</td></tr>
			<tr><td>&lt;=&gt;</td><td>NULL-safe equal to operator</td></tr>
			<tr><td>=</td><td>Equal operator</td></tr>
			<tr><td>&gt;=</td><td>Greater than or equal operator</td></tr>
			<tr><td>&gt;</td><td>Greater than operator</td></tr>
			<tr><td>IS NOT NULL</td><td>NOT NULL value test</td></tr>
			<tr><td>IS NOT</td><td>Test a value against a boolean</td></tr>
			<tr><td>IS NULL</td><td>NULL value test</td></tr>
			<tr><td>IS</td><td>Test a value against a boolean</td></tr>
			<tr><td>&lt;&lt;</td><td>Left shift</td></tr>
			<tr><td>&lt;=</td><td>Less than or equal operator</td></tr>
			<tr><td>&lt;</td><td>Less than operator</td></tr>
			<tr><td>LIKE</td><td>Simple pattern matching</td></tr>
			<tr><td>-</td><td>Minus operator</td></tr>
			<tr><td>%</td><td>Modulo operator</td></tr>
			<tr><td>NOT BETWEEN ... AND ...</td><td>Check whether a value is not within a range of values</td></tr>
			<tr><td>!=, &lt;&gt;</td><td>Not equal operator</td></tr>
			<tr><td>NOT LIKE</td><td>Negation of simple pattern matching</td></tr>
			<tr><td>NOT REGEXP</td><td>Negation of REGEXP</td></tr>
			<tr><td>NOT, !</td><td>Negates value</td></tr>
			<tr><td>||, OR</td><td>Logical OR</td></tr>
			<tr><td>+</td><td>Addition operator</td></tr>
			<tr><td>REGEXP</td><td>Pattern matching using regular expressions</td></tr>
			<tr><td>&gt;&gt;</td><td>Right shift</td></tr>
			<tr><td>RLIKE</td><td>Synonym for REGEXP</td></tr>
			<tr><td>SOUNDS LIKE</td><td>Compare sounds</td></tr>
			<tr><td>*</td><td>Times operator</td></tr>
			<tr><td>-</td><td>Change the sign of the argument</td></tr>
			<tr><td>XOR</td><td>Logical XOR</td></tr>
		</table>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SOperator Precedence"></A>Operator Precedence</H2></P>
		<p>Operator precedences are shown in the following list, from highest precedence to the lowest.
			Operators that are shown together on a line have the same precedence.</p>
		<pre>INTERVAL
BINARY, COLLATE
!
- (unary minus), ~ (unary bit inversion)
^
*, /, DIV, %, MOD
-, +
<<, >>
&
|
=, <=>, >=, >, <=, <, <>, !=, IS, LIKE, REGEXP, IN
BETWEEN, CASE, WHEN, THEN, ELSE
NOT
&&, AND
XOR
||, OR
:=</pre>
		<p>The || operator has a precedence between ^ and the unary operators if the PIPES_AS_CONCAT SQL mode is enabled.</p>
		<p>Note: If the HIGH_NOT_PRECEDENCE SQL mode is enabled, the precedence of NOT is the same as that of the ! operator.</p>
		<p>The precedence of operators determines the order of evaluation of terms in an expression.
			To override this order and group terms explicitly, use parentheses. For example:</p>
		<pre>(sql sqlHandle {SELECT 1+2*3}) <b>Returns</b> 7</pre>
		<pre>(sql sqlHandle {SELECT (1+2)*3}) <b>Returns</b> 9</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SType Conversion in Expression Evaluation"></A>Type Conversion in Expression Evaluation</H2></P>
		<p>When an operator is used with operands of different types, type conversion occurs to make the operands compatible.
			Some conversions occur implicitly. For example, MySQL automatically converts numbers to strings as necessary, and vice versa.</p>
		<pre>(sql sqlHandle {SELECT 1+'1'}) <b>Returns</b> 2</pre>
		<pre>(sql sqlHandle {SELECT CONCAT(2,' test')}) <b>Returns</b> '2 test'</pre>
		<p>It is also possible to perform explicit conversions.
			If you want to convert a number to a string explicitly,
			use the CAST() or CONCAT() function (CAST() is preferable):</p>
		<pre>(sql sqlHandle {SELECT 38.8, CAST(38.8 AS CHAR)}) <b>Returns</b> 38.8, '38.8'</pre>
		<pre>(sql sqlHandle {SELECT 38.8, CONCAT(38.8)}) <b>Returns</b> 38.8, '38.8'</pre>
		<p>The following rules describe how conversion occurs for comparison operations:</p>
		<p>If one or both arguments are NULL, the result of the comparison is NULL,
			except for the NULL-safe <=> equality comparison operator. For NULL <=> NULL, the result is true.</p>
		<p>If both arguments in a comparison operation are strings, they are compared as strings.</p>
		<p>If both arguments are integers, they are compared as integers.</p>
		<p>Hexadecimal values are treated as binary strings if not compared to a number.</p>
		<p>If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant,
			the constant is converted to a timestamp before the comparison is performed.
			This is done to be more ODBC-friendly. Note that this is not done for the arguments to IN()!
			To be safe, always use complete datetime, date, or time strings when doing comparisons.</p>
		<p>In all other cases, the arguments are compared as floating-point (real) numbers.</p>
		<p>The following examples illustrate conversion of strings to numbers for comparison operations:</p>
		<pre>(sql sqlHandle {SELECT 1 > '6x'}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {SELECT 7 > '6x'}) <b>Returns</b> 1</pre>
		<pre>(sql sqlHandle {SELECT 0 > 'x6'}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {SELECT 0 = 'x6'}) <b>Returns</b> 1</pre>
		<p>Note that when you are comparing a string column with a number,
			MySQL cannot use an index on the column to look up the value quickly.
			If str_col is an indexed string column, the index cannot be used when performing the lookup in the following statement:</p>
		<pre>(sql sqlHandle {SELECT * FROM tbl_name WHERE str_col=1})</pre>
		<p>The reason for this is that there are many different strings that may convert to the value 1, such as '1', ' 1', or '1a'.</p>
		<p>Comparisons that use floating-point numbers (or values that are converted to floating-point numbers) are approximate because such numbers are inexact.
			This might lead to results that appear inconsistent:</p>
		<pre>(sql sqlHandle {SELECT '18015376320243458' = 18015376320243458}) <b>Returns</b> 1</pre>
		<pre>(sql sqlHandle {SELECT '18015376320243459' = 18015376320243459}) <b>Returns</b> 0</pre>
		<p>Such results can occur because the values are converted to floating-point numbers,
			which have only 53 bits of precision and are subject to rounding:</p>
		<pre>(sql sqlHandle {SELECT '18015376320243459'+0.0}) <b>Returns</b> 1.8015376320243e+16</pre>
		<p>Furthermore, the conversion from string to floating-point and from integer to floating-point do not necessarily occur the same way.
			The integer may be converted to floating-point by the CPU,
			whereas the string is converted digit by digit in an operation that involves floating-point multiplications.</p>
		<p>The results shown will vary on different systems,
			and can be affected by factors such as computer architecture or the compiler version or optimization level.
			One way to avoid such problems is to use CAST() so that a value will not be converted implicitly to a float-point number:</p>
		<pre>(sql sqlHandle {SELECT CAST('18015376320243459' AS UNSIGNED) = 18015376320243459}) <b>Returns</b> 1</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SComparison Functions and Operators"></A>Comparison Functions and Operators</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>BETWEEN ... AND ... </td><td>Check whether a value is within a range of values</td></tr>
			<tr><td>COALESCE()</td><td>Return the first non-NULL argument</td></tr>
			<tr><td>&lt;=&gt;</td><td>NULL-safe equal to operator</td></tr>
			<tr><td>=</td><td>Equal operator</td></tr>
			<tr><td>&gt;=</td><td>Greater than or equal operator</td></tr>
			<tr><td>&gt;</td><td>Greater than operator</td></tr>
			<tr><td>GREATEST()</td><td>Return the largest argument</td></tr>
			<tr><td>IN()</td><td>Check whether a value is within a set of values</td></tr>
			<tr><td>INTERVAL()</td><td>Return the index of the argument   that is less than the first argument</td></tr>
			<tr><td>IS NOT NULL</td><td>NOT NULL value test</td></tr>
			<tr><td>IS NOT</td><td>Test a value against a boolean</td></tr>
			<tr><td>IS NULL</td><td>NULL value test</td></tr>
			<tr><td>IS</td><td>Test a value against a boolean</td></tr>
			<tr><td>ISNULL()</td><td>Test whether the argument is NULL</td></tr>
			<tr><td>LEAST()</td><td>Return the smallest argument</td></tr>
			<tr><td>&lt;=</td><td>Less than or equal operator</td></tr>
			<tr><td>&lt;</td><td>Less than operator</td></tr>
			<tr><td>LIKE</td><td>Simple pattern matching</td></tr>
			<tr><td>NOT BETWEEN ... AND ...</td><td>Check whether a value is not within a range of values</td></tr>
			<tr><td>!=, &lt;&gt;</td><td>Not equal operator</td></tr>
			<tr><td>NOT IN()</td><td>Check whether a value is not within a set of values</td></tr>
			<tr><td>NOT LIKE</td><td>Negation of simple pattern matching</td></tr>
			<tr><td>SOUNDS LIKE</td><td>Compare sounds</td></tr>
		</table>
		
		<p>Comparison operations result in a value of 1 (TRUE), 0 (FALSE), or NULL. These operations work for both numbers and strings.
			Strings are automatically converted to numbers and numbers to strings as necessary.</p>
		<p>Some of the functions in this section return values other than 1 (TRUE), 0 (FALSE), or NULL.
			For example, LEAST() and GREATEST(). However, the value they return is based on comparison operations performed.</p>
		<p>To convert a value to a specific type for comparison purposes, you can use the CAST() function.
			String values can be converted to a different character set using CONVERT().</p>
		<p>By default, string comparisons are not case sensitive and use the current character set.
			The default is latin1 (cp1252 West European), which also works well for English.</p>
		<ul>
			<li>
				<p>=</p>
				<p>Equal:</p>
				<pre>(sql sqlHandle {SELECT 1 = 0}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT '0' = 0}) <b>Returns</b> 1</pre> 
				<pre>(sql sqlHandle {SELECT '0.0' = 0}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT '0.01' = 0}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT '.01' = 0.01}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p><=></p>
				<p>NULL-safe equal. This operator performs an equality comparison like the = operator,
					but returns 1 rather than NULL if both operands are NULL, and 0 rather than NULL if one operand is NULL.</p>
				<pre>(sql sqlHandle {SELECT 1 <=> 1, NULL <=> NULL, 1 <=> NULL}) <b>Returns</b> 1, 1, 0</pre>
				<pre>(sql sqlHandle {SELECT 1 = 1, NULL = NULL, 1 = NULL}) <b>Returns</b> 1, NULL, NULL</pre>
			</li>
			<li>
				<p><>, !=</p>
				<p>Not equal:</p>
				<pre>(sql sqlHandle {SELECT '.01' <> '0.01'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT .01 <> '0.01'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'zapp' <> 'zappp'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p><=</p>
				<p>Less than or equal:</p>
				<pre>(sql sqlHandle {SELECT 0.1 <= 2}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p><</p>
				<p>Less than:</p>
				<pre>(sql sqlHandle {SELECT 2 < 2}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>>=</p>
				<p>Greater than or equal:</p>
				<pre>(sql sqlHandle {SELECT 2 >= 2}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>></p>
				<p>Greater than:</p>
				<pre>(sql sqlHandle {SELECT 2 > 2}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>IS boolean_value</p>
				<p>Tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN.</p>
				<pre>(sql sqlHandle {SELECT 1 IS TRUE, 0 IS FALSE, NULL IS UNKNOWN}) <b>Returns</b> 1, 1, 1</pre>
			</li>
			<li>
				<p>IS NOT boolean_value</p>
				<p>Tests a value against a boolean value, where boolean_value can be TRUE, FALSE, or UNKNOWN.</p>
				<pre>(sql sqlHandle {SELECT 1 IS NOT UNKNOWN, 0 IS NOT UNKNOWN, NULL IS NOT UNKNOWN}) <b>Returns</b> 1, 1, 0</pre>
			</li>
			<li>
				<p>IS NULL</p>
				<p>Tests whether a value is NULL.</p>
				<pre>(sql sqlHandle {SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL}) <b>Returns</b> 0, 0, 1</pre>
				<p>To work well with ODBC programs, MySQL supports the following extra features when using IS NULL:</p>
				<ul>
					<li>
						<p>You can find the row that contains the most recent AUTO_INCREMENT value by issuing a statement of the following form immediately after generating the value:</p>
						<pre>(sql sqlHandle {SELECT * FROM tbl_name WHERE auto_col IS NULL})</pre>
						<p>This behavior can be disabled by setting SQL_AUTO_IS_NULL=0.</p>
					</li>
					<li>
						<p>For DATE and DATETIME columns that are declared as NOT NULL, you can find the special date '0000-00-00' by using a statement like this:</p>
						<pre>(sql sqlHandle {SELECT * FROM tbl_name WHERE date_column IS NULL})</pre>
						<p>This is needed to get some ODBC applications to work because ODBC does not support a '0000-00-00' date value.</p>
					</li>
				</ul>
			</li>
			<li>
				<p>IS NOT NULL</p>
				<p>Tests whether a value is not NULL.</p>
				<pre>(sql sqlHandle {SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL}) <b>Returns</b> 1, 1, 0</pre>
			</li>
			<li>
				<p>expr BETWEEN min AND max</p>
				<p>If expr is greater than or equal to min and expr is less than or equal to max, BETWEEN returns 1, otherwise it returns 0.
					This is equivalent to the expression (min <= expr AND expr <= max) if all the arguments are of the same type.</p>
				<pre>(sql sqlHandle {SELECT 1 BETWEEN 2 AND 3}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'b' BETWEEN 'a' AND 'c'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 2 BETWEEN 2 AND '3'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 2 BETWEEN 2 AND 'x-3'}) <b>Returns</b> 0</pre>
				<p>For best results when using BETWEEN with date or time values, you should use CAST() to explicitly convert the values to the desired data type.
					Examples: If you compare a DATETIME to two DATE values, convert the DATE values to DATETIME values.
					If you use a string constant such as '2001-1-1' in a comparison to a DATE, cast the string to a DATE.</p>
			</li>
			<li>
				<p>expr NOT BETWEEN min AND max</p>
				<p>This is the same as NOT (expr BETWEEN min AND max).</p>
			</li>
			<li>
				<p>COALESCE(value,...)</p>
				<p>Returns the first non-NULL value in the list, or NULL if there are no non-NULL values.</p>
				<pre>(sql sqlHandle {SELECT COALESCE(NULL,1)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT COALESCE(NULL,NULL,NULL)}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>GREATEST(value1,value2,...)</p>
				<p>With two or more arguments, returns the largest (maximum-valued) argument. The arguments are compared using the same rules as for LEAST().</p>
				<pre>(sql sqlHandle {SELECT GREATEST(2,0)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT GREATEST(34.0,3.0,5.0,767.0)}) <b>Returns</b> 767.0</pre>
				<pre>(sql sqlHandle {SELECT GREATEST('B','A','C')}) <b>Returns</b> 'C'</pre>
				<p>GREATEST() returns NULL if any argument is NULL.</p>
			</li>
			<li>
				<p>expr IN (value,...)</p>
				<p>Returns 1 if expr is equal to any of the values in the IN list, else returns 0.
					If all values are constants, they are evaluated according to the type of expr and sorted.
					The search for the item then is done using a binary search. This means IN is very quick if the IN value list consists entirely of constants.</p>
				<pre>(sql sqlHandle {SELECT 2 IN (0,3,5,7)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'wefwf' IN ('wee','wefwf','weg')}) <b>Returns</b> 1</pre>
				<p>You should never mix quoted and unquoted values in an IN list because the comparison rules for quoted values (such as strings) and
					unquoted values (such as numbers) differ. Mixing types may therefore lead to inconsistent results. For example, do not write an IN expression like this:</p>
				<pre>(sql sqlHandle {SELECT val1 FROM tbl1 WHERE val1 IN (1,2,'a')})</pre>
				<p>Instead, write it like this:</p>
				<pre>(sql sqlHandle {SELECT val1 FROM tbl1 WHERE val1 IN ('1','2','a')})</pre>
				<p>The number of values in the IN list is only limited by the max_allowed_packet value.</p>
				<p>To comply with the SQL standard, IN returns NULL not only if the expression on the left hand side is NULL,
					but also if no match is found in the list and one of the expressions in the list is NULL.</p>
				<p>IN() syntax can also be used to write certain types of subqueries.</p>
			</li>
			<li>
				<p>expr NOT IN (value,...)</p>
				<p>This is the same as NOT (expr IN (value,...)).</p>
			</li>
			<li>
				<p>ISNULL(expr)</p>
				<p>If expr is NULL, ISNULL() returns 1, otherwise it returns 0.</p>
				<pre>(sql sqlHandle {SELECT ISNULL(1+1)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT ISNULL(1/0)}) <b>Returns</b> 1</pre>
				<p>ISNULL() can be used instead of = to test whether a value is NULL. (Comparing a value to NULL using = always yields false.)</p>
				<p>The ISNULL() function shares some special behaviors with the IS NULL comparison operator. See the description of IS NULL.</p>
			</li>
			<li>
				<p>INTERVAL(N,N1,N2,N3,...)</p>
				<p>Returns 0 if N < N1, 1 if N < N2 and so on or -1 if N is NULL. All arguments are treated as integers.
					It is required that N1 < N2 < N3 < ... < Nn for this function to work correctly. This is because a binary search is used (very fast).</p>
				<pre>(sql sqlHandle {SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200)}) <b>Returns</b> 3</pre>
				<pre>(sql sqlHandle {SELECT INTERVAL(10, 1, 10, 100, 1000)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT INTERVAL(22, 23, 30, 44, 200)}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>LEAST(value1,value2,...)</p>
				<p>With two or more arguments, returns the smallest (minimum-valued) argument. The arguments are compared using the following rules:</p>
				<ul>
					<li>
						<p>If the return value is used in an INTEGER context or all arguments are integer-valued, they are compared as integers.</p>
					</li						<p>If the return value is used in a REAL context or all arguments are real-valued, they are compared as reals.</p>
					</li>
					<li>
						<p>If any argument is a case-sensitive string, the arguments are compared as case-sensitive strings.</p>
					</li>
					<li>
						<p>In all other cases, the arguments are compared as case-insensitive strings.</p>
					</li>
				</ul>
				<p>LEAST() returns NULL if any argument is NULL.</p>
				<pre>(sql sqlHandle {SELECT LEAST(2,0)}) <b>Returns</b> 0</pre>>
				<pre>(sql sqlHandle {SELECT LEAST(34.0,3.0,5.0,767.0)}) <b>Returns</b> 3.0</pre>
				<pre>(sql sqlHandle {SELECT LEAST('B','A','C')}) <b>Returns</b> 'A'</pre>
				<p>Note that the preceding conversion rules can produce strange results in some borderline cases:</p>
				<pre>(sql sqlHandle {SELECT CAST(LEAST(3600, 9223372036854775808.0) as SIGNED)}) <b>Returns</b> -9223372036854775808</pre>
				<p>This happens because MySQL reads 9223372036854775808.0 in an integer context.
					The integer representation is not good enough to hold the value, so it wraps to a signed integer.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SLogical Operators"></A>Logical Operators</H2></P>
		<table border="3">
			<tr>
				<th align="left">Name</th>
				<th align="left">Description</th>
			</tr>
			<tr>
				<td>AND, &&</td>
				<td>Logical AND</td>
			</tr>
			<tr>
				<td>NOT, !</td>
				<td>Negates value</td>
			</tr>
			<tr>
				<td>||, OR</td>
				<td>Logical OR</td>
			</tr>
			<tr>
				<td>XOR</td>
				<td>Logical XOR</td>
			</tr>
		</table>
		<p>In SQL, all logical operators evaluate to TRUE, FALSE, or NULL (UNKNOWN). In MySQL, these are implemented as 1 (TRUE), 0 (FALSE), and NULL.
			Most of this is common to different SQL database servers, although some servers may return any non-zero value for TRUE.</p>
		<p>Note that MySQL evaluates any non-zero or non-NULL value to TRUE. For example, the following statements all assess to TRUE:</p>
		<pre>(sql sqlHandle {SELECT 10 IS TRUE}) <b>Returns</b> 1</pre>
		<pre>(sql sqlHandle {SELECT -10 IS TRUE}) <b>Returns</b> 1</pre>
		<pre>(sql sqlHandle {SELECT 'string' IS NOT NULL}) <b>Returns</b> 1</pre>
		<ul>
			<li>
				<p>NOT, !</p>
				<p>Logical NOT. Evaluates to 1 if the operand is 0, to 0 if the operand is non-zero, and NOT NULL returns NULL.</p>
				<pre>(sql sqlHandle {SELECT NOT 10}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT NOT 0}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT NOT NULL}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT ! (1+1)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT ! 1+1}) <b>Returns</b> 1</pre>
				<p>The last example produces 1 because the expression evaluates the same way as (!1)+1.</p>
			</li>
			<li>
				<p>AND, &&</p>
				<p>Logical AND. Evaluates to 1 if all operands are non-zero and not NULL, to 0 if one or more operands are 0, otherwise NULL is returned.</p>
				<pre>(sql sqlHandle {SELECT 1 && 1}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 1 && 0}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 1 && NULL}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT 0 && NULL}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT NULL && 0}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>OR, ||</p>
				<p>Logical OR. When both operands are non-NULL, the result is 1 if any operand is non-zero, and 0 otherwise.
					With a NULL operand, the result is 1 if the other operand is non-zero, and NULL otherwise. If both operands are NULL, the result is NULL.</p>
				<pre>(sql sqlHandle {SELECT 1 || 1}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 1 || 0}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 0 || 0}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 0 || NULL}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT 1 || NULL}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>XOR</p>
				<p>Logical XOR. Returns NULL if either operand is NULL. For non-NULL operands, evaluates to 1 if an odd number of operands is non-zero, otherwise 0 is returned.</p>
				<pre>(sql sqlHandle {SELECT 1 XOR 1}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 1 XOR 0}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 1 XOR NULL}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT 1 XOR 1 XOR 1}) <b>Returns</b> 1</pre>
				<p>a XOR b is mathematically equal to (a AND (NOT b)) OR ((NOT a) and b).</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SControl Flow Functions"></A>Control Flow Functions</H2></P>
		<table border="3">
			<tr>
				<th align="left">Name</th><th align="left">Description</th>
			</tr>
			<tr>
				<td>CASE</td><td>Case operator</td>
			</tr>
			<tr>
				<td>IF()</td>If/else construct</td>
			</tr>
			<tr>
				<td>IFNULL()</td><td>Null if/else construct</td>
			</tr>
			<tr>
				<td>NULLIF()</td><td>Return NULL if expr1 = expr2</td>
			</tr>
		</table>
		<ul>
			<li>
				<p>CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END</p>
				<p>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</p>
				<p>The first version returns the result where value=compare_value. The second version returns the result for the first condition that is true.
					If there was no matching result value, the result after ELSE is returned, or NULL if there is no ELSE part.</p>
				<pre>(sql sqlHandle {SELECT CASE 1 WHEN 1 THEN 'one' WHEN 2 THEN 'two' ELSE 'more' END}) <b>Returns</b> 'one'</pre>
				<pre>(sql sqlHandle {SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END}) <b>Returns</b> 'true'</pre>
				<pre>(sql sqlHandle {SELECT CASE BINARY 'B' WHEN 'a' THEN 1 WHEN 'b' THEN 2 END}) <b>Returns</b> NULL</pre>
				<p>The default return type of a CASE expression is the compatible aggregated type of all return values, but also depends on the context in which it is used.
					If used in a string context, the result is returned as a string. If used in a numeric context, then the result is returned as a decimal, real, or integer value.</p>
				<p>Note: The syntax of the CASE expression shown here differs slightly from that of the SQL CASE statement, for use inside stored routines.
					The CASE statement cannot have an ELSE NULL clause, and it is terminated with END CASE instead of END.</p>
			</li>
			<li>
				<p>IF(expr1,expr2,expr3)</p>
				<p>If expr1 is TRUE (expr1 <> 0 and expr1 <> NULL) then IF() returns expr2; otherwise it returns expr3.
					IF() returns a numeric or string value, depending on the context in which it is used.</p>
				<pre>(sql sqlHandle {SELECT IF(1>2,2,3)}) <b>Returns</b> 3</pre>
				<pre>(sql sqlHandle {SELECT IF(1<2,'yes','no')}) <b>Returns</b> 'yes'</pre>
				<pre>(sql sqlHandle {SELECT IF(STRCMP('test','test1'),'no','yes')}) <b>Returns</b> 'no'</pre>
				<p>If only one of expr2 or expr3 is explicitly NULL, the result type of the IF() function is the type of the non-NULL expression.</p>
				<p>expr1 is evaluated as an integer value, which means that if you are testing floating-point or string values, you should do so using a comparison operation.</p>
				<pre>(sql sqlHandle {SELECT IF(0.1,1,0)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandel {SELECT IF(0.1<>0,1,0)}) <b>Returns</b> 1</pre>
				<p>In the first case shown, IF(0.1) returns 0 because 0.1 is converted to an integer value, resulting in a test of IF(0).
					This may not be what you expect. In the second case, the comparison tests the original floating-point value to see whether it is non-zero.
					The result of the comparison is used as an integer.</p>
				<p>The default return type of IF() (which may matter when it is stored into a temporary table) is calculated as follows:</p>
				<table border="3">
					<tr><th>Expression</th><th>Return Value</th></tr>
					<tr><td>expr2 or expr3 returns a string</td><td>string</td></tr>
					<tr><td>expr2 or expr3 returns a floating-point value</td><td>floating-point</td></tr>
					<tr><td>expr2 or expr3 returns an integer</td><td>integer</td></tr>
				</table>
				<p>If expr2 and expr3 are both strings, the result is case sensitive if either string is case sensitive.</p>
				<p>Note: There is also an IF statement, which differs from the IF() function described here.</p>
			</li>
			<li>
				<p>IFNULL(expr1,expr2)</p>
				<p>If expr1 is not NULL, IFNULL() returns expr1; otherwise it returns expr2.
					IFNULL() returns a numeric or string value, depending on the context in which it is used.</p>
				<pre>(sql sqlHandle {SELECT IFNULL(1,0)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT IFNULL(NULL,10)}) <b>Returns</b> 10</pre>
				<pre>(sql sqlHandle {SELECT IFNULL(1/0,10)}) <b>Returns</b> 10</pre>
				<pre>(sql sqlHandel {SELECT IFNULL(1/0,'yes')}) <b>Returns</b> 'yes'</pre>
				<p>The default result value of IFNULL(expr1,expr2) is the more "general" of the two expressions, in the order STRING, REAL, or INTEGER.
					Consider the case of a table based on expressions or where MySQL must internally store a value returned by IFNULL() in a temporary table:</p>
				<pre>(sql sqlHandle {CREATE TABLE tmp SELECT IFNULL(1,'test') AS test})</pre>
				<pre>(sql sqlHandle {DESCRIBE tmp}) <b>Returns</b>
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| test  | char(4) |      |     |         |       |
+-------+---------+------+-----+---------+-------+</pre>
				<p>In this example, the type of the test column is CHAR(4).</p>
			</li>
			<li>
				<p>NULLIF(expr1,expr2)</p>
				<p>Returns NULL if expr1 = expr2 is true, otherwise returns expr1. This is the same as CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END.</p>
				<pre>(sql sqlHandle {SELECT NULLIF(1,1)}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT NULLIF(1,2)}) <b>Returns</b> 1</pre>
				<p>Note that MySQL evaluates expr1 twice if the arguments are not equal.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SString Functions"></A>String Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>ASCII()</td><td>Return numeric value of left-most character</td></tr>
			<tr><td>BIN()</td><td>Return a string representation of the argument</td></tr>
			<tr><td>BIT_LENGTH()</td><td>Return length of argument in bits</td></tr>
			<tr><td>CHAR_LENGTH()</td><td>Return number of characters in argument</td></tr>
			<tr><td>CHAR()</td><td>Return the character for each integer passed</td></tr>
			<tr><td>CHARACTER_LENGTH()</td><td>A synonym for CHAR_LENGTH()</td></tr>
			<tr><td>CONCAT_WS()</td><td>Return concatenate with  separator</td></tr>
			<tr><td>CONCAT()</td><td>Return concatenated string</td></tr>
			<tr><td>ELT()</td><td>Return string at index number</td></tr>
			<tr><td>EXPORT_SET()</td><td>Return a string such that for every bit set in the value  bits, you get an on string and for every unset bit, you get an off string</td></tr>
			<tr><td>FIELD()</td><td>Return the index (position) of the first argument  in the subsequent arguments</td></tr>
			<tr><td>FIND_IN_SET()</td><td>Return the index position of  the first argument within the second argument</td></tr>
			<tr><td>FORMAT()</td><td>Return a number formatted to specified number of decimal places</td></tr>
			<tr><td>HEX()</td><td>Return a hexadecimal representation of a  decimal or string value</td></tr>
			<tr><td>INSERT()</td><td>Insert a substring at the specified position up to  the specified number of characters</td></tr>
			<tr><td>INSTR()</td><td>Return the index of the first occurrence of substring</td></tr>
			<tr><td>LCASE()</td><td>Synonym for LOWER() </td></tr>
			<tr><td>LEFT()</td><td>Return the leftmost number of characters as specified</td></tr>
			<tr><td>LENGTH()</td><td>Return the length of a string in bytes</td></tr>
			<tr><td>LIKE</td><td>Simple pattern matching</td></tr>
			<tr><td>LOAD_FILE()</td><td>Load the named file</td></tr>
			<tr><td>LOCATE()</td><td>Return the position of the first occurrence  of substring</td></tr>
			<tr><td>LOWER()</td><td>Return the argument in lowercase </td></tr>
			<tr><td>LPAD()</td><td>Return the string argument, left-padded  with the specified string</td></tr>
			<tr><td>LTRIM()</td><td>Remove leading spaces</td></tr>
			<tr><td>MAKE_SET()</td><td>Return a set of comma-separated strings  that have the corresponding bit in bits set</td></tr>
			<tr><td>MATCH</td><td>Perform full-text search</td></tr>
			<tr><td>MID()</td><td>Return a substring starting from the specified position</td></tr>
			<tr><td>NOT LIKE</td><td>Negation of simple pattern matching</td></tr>
			<tr><td>NOT REGEXP</td><td>Negation of REGEXP</td></tr>
			<tr><td>OCTET_LENGTH()</td><td>A synonym for LENGTH()</td></tr>
			<tr><td>ORD()</td><td>Return character code for leftmost character of the  argument</td></tr>
			<tr><td>POSITION()</td><td>A synonym for LOCATE()</td></tr>
			<tr><td>QUOTE()</td><td>Escape the argument for use in an SQL statement</td></tr>
			<tr><td>REGEXP</td><td>Pattern matching using regular expressions</td></tr>
			<tr><td>REPEAT()</td><td>Repeat a string the specified number of times</td></tr>
			<tr><td>REPLACE()</td><td>Replace occurrences of a specified string</td></tr>
			<tr><td>REVERSE()</td><td>Reverse the characters in a string</td></tr>
			<tr><td>RIGHT()</td><td>Return the specified rightmost number of characters</td></tr>
			<tr><td>RLIKE</td><td>Synonym for REGEXP</td></tr>
			<tr><td>RPAD()</td><td>Append string the specified number of times</td></tr>
			<tr><td>RTRIM()</td><td>Remove trailing spaces</td></tr>
			<tr><td>SOUNDEX()</td><td>Return a soundex string</td></tr>
			<tr><td>SOUNDS LIKE</td><td>Compare sounds</td></tr>
			<tr><td>SPACE()</td><td>Return a string of the specified number of spaces</td></tr>
			<tr><td>STRCMP()</td><td>Compare two strings</td></tr>
			<tr><td>SUBSTR()</td><td>Return the substring as specified</td></tr>
			<tr><td>SUBSTRING_INDEX()</td><td>Return a substring from a  string before the specified number of occurrences of the delimiter</td></tr>
			<tr><td>SUBSTRING()</td><td>Return the substring as specified</td></tr>
			<tr><td>TRIM()</td><td>Remove leading and trailing spaces</td></tr>
			<tr><td>UCASE()</td><td>Synonym for UPPER()</td></tr>
			<tr><td>UNHEX()</td><td>Convert each pair of hexadecimal digits  to a character</td></tr>
			<tr><td>UPPER()</td><td>Convert to uppercase</td></tr>
		</table>
		<p>String-valued functions return NULL if the length of the result would be greater than the value of the max_allowed_packet system variable.</p>
		<p>For functions that operate on string positions, the first position is numbered 1.</p>
		<p>For functions that take length arguments, non-integer arguments are rounded to the nearest integer.</p>
		<ul>
			<li>
				<p>ASCII(str)</p>
				<p>Returns the numeric value of the leftmost character of the string str. Returns 0 if str is the empty string.
					Returns NULL if str is NULL. ASCII() works for 8-bit characters.</p>
				<pre>(sql sqlHandle {SELECT ASCII('2')}) <b>Returns</b> 50</pre>
				<pre>(sql sqlHandle {SELECT ASCII(2)}) <b>Returns</b> 50</pre>
				<pre>(sql sqlHandle {SELECT ASCII('dx')}) <b>Returns</b> 100</pre>
				<p>See also the ORD() function.</p>
			</li>
			<li>
				<p>BIN(N)</p>
				<p>Returns a string representation of the binary value of N, where N is a longlong (BIGINT) number.
					This is equivalent to CONV(N,10,2). Returns NULL if N is NULL.</p>
				<pre>(sql sqlHandle {SELECT BIN(12)}) <b>Returns</b> '1100'</pre>
			</li>
			<li>
				<p>BIT_LENGTH(str)</p>
				<p>Returns the length of the string str in bits.</p>
				<pre>(sql sqlHandle {SELECT BIT_LENGTH('text')}) <b>Returns</b> 32</pre>
			</li>
			<li>
				<p>CHAR(N,... [USING charset_name])</p>
				<p>CHAR() interprets each argument N as an integer and returns a string consisting of the characters given by the code values of those integers. NULL values are skipped.</p>
				<pre>(sql sqlHandle {SELECT CHAR(77,121,83,81,'76')}) <b>Returns</b> 'MySQL'</pre>
				<pre>(sql sqlHandle {SELECT CHAR(77,77.3,'77.3')}) <b>Returns</b> 'MMM'</pre>
				<p>CHAR() arguments larger than 255 are converted into multiple result bytes. For example, CHAR(256) is equivalent to CHAR(1,0), and CHAR(256*256) is equivalent to CHAR(1,0,0):</p>
				<pre>(sql sqlHandle {SELECT HEX(CHAR(1,0)), HEX(CHAR(256))}) <b>Returns</b>
+----------------+----------------+
| HEX(CHAR(1,0)) | HEX(CHAR(256)) |
+----------------+----------------+
| 0100           | 0100           |
+----------------+----------------+</pre>
				<pre>(sql sqlHandle {SELECT HEX(CHAR(1,0,0)), HEX(CHAR(256*256))}) <b>Returns</b>
+------------------+--------------------+
| HEX(CHAR(1,0,0)) | HEX(CHAR(256*256)) |
+------------------+--------------------+
| 010000           | 010000             |
+------------------+--------------------+</pre>
				<p>By default, CHAR() returns a binary string. To produce a string in a given character set, use the optional USING clause:</p>
<pre>(sql sqlHandle {SELECT CHARSET(CHAR(0x65)), CHARSET(CHAR(0x65 USING utf8))}) <b>Returns</b>
+---------------------+--------------------------------+
| CHARSET(CHAR(0x65)) | CHARSET(CHAR(0x65 USING utf8)) |
+---------------------+--------------------------------+
| binary              | utf8                           |
+---------------------+--------------------------------+</pre>
				<p>If USING is given and the result string is illegal for the given character set, a warning is issued. Also, if strict SQL mode is enabled, the result from CHAR() becomes NULL.</p>
			</li>
			<li>
				<p>CHAR_LENGTH(str)</p>
				<p>Returns the length of the string str, measured in characters. A multi-byte character counts as a single character.
					This means that for a string containing five two-byte characters, LENGTH() returns 10, whereas CHAR_LENGTH() returns 5.</p>
			</li>
			<li>
				<p>CHARACTER_LENGTH(str)</p>
				<p>CHARACTER_LENGTH() is a synonym for CHAR_LENGTH().</p>
			</li>
			<li>
				<p>CONCAT(str1,str2,...)</p>
				<p>Returns the string that results from concatenating the arguments. May have one or more arguments.
					If all arguments are non-binary strings, the result is a non-binary string. If the arguments include any binary strings, the result is a binary string.
					A numeric argument is converted to its equivalent binary string form; if you want to avoid that, you can use an explicit type cast, as in this example:</p>
				<pre>SELECT CONCAT(CAST(int_col AS CHAR), char_col);</pre>
				<p>CONCAT() returns NULL if any argument is NULL.</p>
				<pre>(sql sqlHandle {SELECT CONCAT('My', 'S', 'QL')}) <b>Returns</b> 'MySQL'</pre>
				<pre>(sql sqlHandle {SELECT CONCAT('My', NULL, 'QL')}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT CONCAT(14.3)}) <b>Returns</b> '14.3'</pre>
			</li>
			<li>
				<p>CONCAT_WS(separator,str1,str2,...)</p>
				<p>CONCAT_WS() stands for Concatenate With Separator and is a special form of CONCAT().
					The first argument is the separator for the rest of the arguments. The separator is added between the strings to be concatenated.
					The separator can be a string, as can the rest of the arguments. If the separator is NULL, the result is NULL.</p>
				<pre>(sql sqlHandle {SELECT CONCAT_WS(',','First name','Second name','Last Name')}) <b>Returns</b> 'First name,Second name,Last Name'</pre>
				<pre>(sql sqlHandle {SELECT CONCAT_WS(',','First name',NULL,'Last Name')}) <b>Returns</b> 'First name,Last Name'</pre>
				<p>CONCAT_WS() does not skip empty strings. However, it does skip any NULL values after the separator argument.</p>
			</li>
			<li>
				<p>ELT(N,str1,str2,str3,...)</p>
				<p>Returns str1 if N = 1, str2 if N = 2, and so on. Returns NULL if N is less than 1 or greater than the number of arguments. ELT() is the complement of FIELD().</p>
				<pre>(sql sqlHandle {SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo')}) <b>Returns</b> 'ej'</pre>
				<pre>(sql sqlHandle {SELECT ELT(4, 'ej', 'Heja', 'hej', 'foo')}) <b>Returns</b> 'foo'</pre>
			</li>
			<li>
				<p>EXPORT_SET(bits,on,off[,separator[,number_of_bits]])</p>
				<p>Returns a string such that for every bit set in the value bits, you get an on string and for every bit not set in the value, you get an off string.
					Bits in bits are examined from right to left (from low-order to high-order bits).
					Strings are added to the result from left to right, separated by the separator string (the default being the comma character ",").
					The number of bits examined is given by number_of_bits (defaults to 64).</p>
				<pre>(sql sqlHandle {SELECT EXPORT_SET(5,'Y','N',',',4)}) <b>Returns</b> 'Y,N,Y,N'</pre>
				<pre>(sql sqlHandle {SELECT EXPORT_SET(6,'1','0',',',10)}) <b>Returns</b> '0,1,1,0,0,0,0,0,0,0'</pre>
			</li>
			<li>
				<p>FIELD(str,str1,str2,str3,...)</p>
				<p>Returns the index (position) of str in the str1, str2, str3, ... list. Returns 0 if str is not found.</p>
				<p>If all arguments to FIELD() are strings, all arguments are compared as strings.
					If all arguments are numbers, they are compared as numbers. Otherwise, the arguments are compared as double.</p>
				<p>If str is NULL, the return value is 0 because NULL fails equality comparison with any value. FIELD() is the complement of ELT().</p>
				<pre>(sql sqlHandle {SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo')}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo')}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>FIND_IN_SET(str,strlist)</p>
				<p>Returns a value in the range of 1 to N if the string str is in the string list strlist consisting of N substrings.
					A string list is a string composed of substrings separated by "," characters.
					If the first argument is a constant string and the second is a column of type SET, the FIND_IN_SET() function is optimized to use bit arithmetic.
					Returns 0 if str is not in strlist or if strlist is the empty string. Returns NULL if either argument is NULL.
					This function does not work properly if the first argument contains a comma (",") character.</p>
				<pre>(sql sqlHandle {SELECT FIND_IN_SET('b','a,b,c,d')}) <b>Returns</b> 2</pre>
			</li>
			<li>
				<p>FORMAT(X,D)</p>
				<p>Formats the number X to a format like '#,###,###.##', rounded to D decimal places, and returns the result as a string. If D is 0, the result has no decimal point or fractional part.</p>
				<pre>(sql sqlHandle {SELECT FORMAT(12332.123456, 4)}) <b>Returns</b> '12,332.1235'</pre>
				<pre>(sql sqlHandle {SELECT FORMAT(12332.1,4)}) <b>Returns</b> '12,332.1000'</pre>
				<pre>(sql sqlHandle {SELECT FORMAT(12332.2,0)}) <b>Returns</b> '12,332'</pre>
			</li>
			<li>
				<p>HEX(N_or_S)</p>
				<p>If N_or_S is a number, returns a string representation of the hexadecimal value of N, where N is a longlong (BIGINT) number. This is equivalent to CONV(N,10,16).</p>
				<p>If N_or_S is a string, returns a hexadecimal string representation of N_or_S where each character in N_or_S is converted to two hexadecimal digits. The inverse of this operation is performed by the UNHEX() function.</p>
				<pre>(sql sqlHandle {SELECT HEX(255)}) <b>Returns</b> 'FF'</pre>
				<pre>(sql sqlHandle {SELECT 0x616263)}) <b>Returns</b> 'abc'</pre>
				<pre>(sql sqlHandle {SELECT HEX('abc')}) <b>Returns</b> 616263</pre>
			</li>
			<li>
				<p>INSERT(str,pos,len,newstr)</p>
				<p>Returns the string str, with the substring beginning at position pos and len characters long replaced by the string newstr.
					Returns the original string if pos is not within the length of the string. Replaces the rest of the string from position pos if len is not within the length of the rest of the string. Returns NULL if any argument is NULL.</p>
				<pre>(sql sqlHandle {SELECT INSERT('Quadratic', 3, 4, 'What')}) <b>Returns</b> 'QuWhattic'</pre>
				<pre>(sql sqlHandle {SELECT INSERT('Quadratic', -1, 4, 'What')}) <b>Returns</b> 'Quadratic'</pre>
				<pre>(sql sqlHandle {SELECT INSERT('Quadratic', 3, 100, 'What')}) <b>Returns</b> 'QuWhat'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>INSTR(str,substr)</p>
				<p>Returns the position of the first occurrence of substring substr in string str. This is the same as the two-argument form of LOCATE(), except that the order of the arguments is reversed.</p>
				<pre>(sql sqlHandle {SELECT INSTR('foobarbar', 'bar')}) <b>Returns</b> 4</pre>
				<pre>(sql sqlHandle {SELECT INSTR('xbar', 'foobar')}) <b>Returns</b> 0</pre>
				<p>This function is multi-byte safe, and is case sensitive only if at least one argument is a binary string.</p>
			</li>
			<li>
				<p>LCASE(str)</p>
				<p>LCASE() is a synonym for LOWER().</p>
			</li>
			<li>
				<p>LEFT(str,len)</p>
				<p>Returns the leftmost len characters from the string str, or NULL if any argument is NULL.</p>
				<pre>(sql sqlHandle {SELECT LEFT('foobarbar', 5)}) <b>Returns</b> 'fooba'</pre>
			</li>
			<li>
				<p>LENGTH(str)</p>
				<p>Returns the length of the string str, measured in bytes. A multi-byte character counts as multiple bytes.
					This means that for a string containing five two-byte characters, LENGTH() returns 10, whereas CHAR_LENGTH() returns 5.</p>
				<pre>(sql sqlHandle {SELECT LENGTH('text')}) <b>Returns</b> 4</pre>
			</li>
			<li>
				<p>LOAD_FILE(file_name)</p>
				<p>Reads the file and returns the file contents as a string. To use this function, the file must be located on the server host,
					you must specify the full pathname to the file, and you must have the FILE privilege. The file must be readable by all and its size less than max_allowed_packet bytes.</p>
				<p>If the file does not exist or cannot be read because one of the preceding conditions is not satisfied, the function returns NULL.</p>
				<p>As of MySQL 5.1.6, the character_set_filesystem system variable controls interpretation of filenames that are given as literal strings.</p>
				<pre>(sql sqlHandle {UPDATE t SET blob_col=LOAD_FILE('/tmp/picture') WHERE id=1})</pre>
			</li>
			<li>
				<p>LOCATE(substr,str), LOCATE(substr,str,pos)</p>
				<p>The first syntax returns the position of the first occurrence of substring substr in string str.
					The second syntax returns the position of the first occurrence of substring substr in string str, starting at position pos. Returns 0 if substr is not in str.</p>
				<pre>(sql sqlHandle {SELECT LOCATE('bar', 'foobarbar')}) <b>Returns</b> 4</pre>
				<pre>(sql sqlHandle {SELECT LOCATE('xbar', 'foobar')}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT LOCATE('bar', 'foobarbar', 5)}) <b>Returns</b> 7</pre>
				<p>This function is multi-byte safe, and is case-sensitive only if at least one argument is a binary string.</p>
			</li>
			<li>
				<p>LOWER(str)</p>
				<p>Returns the string str with all characters changed to lowercase according to the current character set mapping. The default is latin1 (cp1252 West European).</p>
				<pre>(sql sqlHandle {SELECT LOWER('QUADRATICALLY')}) <b>Returns</b> 'quadratically'</pre>
				<p>LOWER() (and UPPER()) are ineffective when applied to binary strings (BINARY, VARBINARY, BLOB). To perform lettercase conversion, convert the string to a non-binary string:</p>
				<pre>(sql sqlHandle {SET @str = BINARY 'New York'})</pre>
				<pre>(sql sqlHandle {SELECT LOWER(@str), LOWER(CONVERT(@str USING latin1))}) <b>Returns</b>
+-------------+-----------------------------------+
| LOWER(@str) | LOWER(CONVERT(@str USING latin1)) |
+-------------+-----------------------------------+
| New York    | new york                          | 
+-------------+-----------------------------------+</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>LPAD(str,len,padstr)</p>
				<p>Returns the string str, left-padded with the string padstr to a length of len characters. If str is longer than len, the return value is shortened to len characters.</p>
				<pre>(sql sqlHandle {SELECT LPAD('hi',4,'??')}) <b>Returns</b> '??hi'</pre>
				<pre>(sql sqlHandle {SELECT LPAD('hi',1,'??')}) <b>Returns</b> 'h'</pre>
			</li>
			<li>
				<p>LTRIM(str)</p>
				<p>Returns the string str with leading space characters removed.</p>
				<pre>(sql sqlHandle {SELECT LTRIM('  barbar')}) <b>Returns</b> 'barbar'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>MAKE_SET(bits,str1,str2,...)</p>
				<p>Returns a set value (a string containing substrings separated by "," characters) consisting of the strings that have the corresponding bit in bits set.
					str1 corresponds to bit 0, str2 to bit 1, and so on. NULL values in str1, str2, ... are not appended to the result.</p>
				<pre>(sql sqlHandle {SELECT MAKE_SET(1,'a','b','c')}) <b>Returns</b> 'a'</pre>
				<pre>(sql sqlHandle {SELECT MAKE_SET(1 | 4,'hello','nice','world')}) <b>Returns</b> 'hello,world'</pre>
				<pre>(sql sqlHandle {SELECT MAKE_SET(1 | 4,'hello','nice',NULL,'world')}) <b>Returns</b> 'hello'</pre>
				<pre>(sql sqlHandle {SELECT MAKE_SET(0,'a','b','c')}) <b>Returns</b> ''</pre>
			</li>
			<li>
				<p>MID(str,pos,len)</p>
				<p>MID(str,pos,len) is a synonym for SUBSTRING(str,pos,len).</p>
			</li>
			<li>
				<p>OCTET_LENGTH(str)</p>
				<p>OCTET_LENGTH() is a synonym for LENGTH().</p>
			</li>
			<li>
				<p>ORD(str)</p>
				<p>If the leftmost character of the string str is a multi-byte character, returns the code for that character, calculated from the numeric values of its constituent bytes using this formula:</p>
				<p>(1st byte code) + (2nd byte code  256) + (3rd byte code  2562) ...</p>
				<p>If the leftmost character is not a multi-byte character, ORD() returns the same value as the ASCII() function.</p>
				<pre>(sql sqlHandle {SELECT ORD('2')}) <b>Returns</b> 50</pre>
			</li>
			<li>
				<p>POSITION(substr IN str)</p>
				<p>POSITION(substr IN str) is a synonym for LOCATE(substr,str).</p>
			</li>
			<li>
				<p>QUOTE(str)</p>
				<p>Quotes a string to produce a result that can be used as a properly escaped data value in an SQL statement.
					The string is returned enclosed by single quotes and with each instance of single quote ("'"), backslash ("\"), ASCII NUL, and Control-Z preceded by a backslash.
					If the argument is NULL, the return value is the word "NULL" without enclosing single quotes.</p>
				<pre>(sql sqlHandle {SELECT QUOTE('Don\'t!')}) <b>Returns</b> 'Don\'t!'</pre>
				<pre>(sql sqlHandle {SELECT QUOTE(NULL)}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>REPEAT(str,count)</p>
				<p>Returns a string consisting of the string str repeated count times. If count is less than 1, returns an empty string. Returns NULL if str or count are NULL.</p>
				<pre>(sql sqlHandle {SELECT REPEAT('MySQL', 3)}) <b>Returns</b> 'MySQLMySQLMySQL'</pre>
			</li>
			<li>
				<p>REPLACE(str,from_str,to_str)</p>
				<p>Returns the string str with all occurrences of the string from_str replaced by the string to_str. REPLACE() performs a case-sensitive match when searching for from_str.</p>
				<pre>(sql sqlHandle {SELECT REPLACE('www.mysql.com', 'w', 'Ww')}) <b>Returns</b> 'WwWwWw.mysql.com'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>REVERSE(str)</p>
				<p>Returns the string str with the order of the characters reversed.</p>
				<pre>(sql sqlHandle {SELECT REVERSE('abc')}) <b>Returns</b> 'cba'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>RIGHT(str,len)</p>
				<p>Returns the rightmost len characters from the string str, or NULL if any argument is NULL.</p>
				<pre>(sql sqlHandle {SELECT RIGHT('foobarbar', 4)}) <b>Returns</b> 'rbar'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>RPAD(str,len,padstr)</p>
				<p>Returns the string str, right-padded with the string padstr to a length of len characters. If str is longer than len, the return value is shortened to len characters.</p>
				<pre>(sql sqlHandle {SELECT RPAD('hi',5,'?')}) <b>Returns</b> 'hi???'</pre>
				<pre>(sql sqlHandle {SELECT RPAD('hi',1,'?')}) <b>Returns</b> 'h'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>RTRIM(str)</p>
				<p>Returns the string str with trailing space characters removed.</p>
				<pre>(sql sqlHandle {SELECT RTRIM('barbar   ')}) <b>Returns</b> 'barbar'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>SOUNDEX(str)</p>
				<p>Returns a soundex string from str. Two strings that sound almost the same should have identical soundex strings.
					A standard soundex string is four characters long, but the SOUNDEX() function returns an arbitrarily long string.
					You can use SUBSTRING() on the result to get a standard soundex string.
					All non-alphabetic characters in str are ignored. All international alphabetic characters outside the A-Z range are treated as vowels.</p>
				<p>Important: When using SOUNDEX(), you should be aware of the following limitations:</p>
				<ul>
					<li>
						<p>This function, as currently implemented, is intended to work well with strings that are in the English language only. Strings in other languages may not produce reliable results.</p>
					</li>
					<li>
						<p>This function is not guaranteed to provide consistent results with strings that use multi-byte character sets, including utf-8.</p>
					</li>
				</ul>
				<p>We hope to remove these limitations in a future release. See Bug#22638 for more information.</p>
				<pre>(sql sqlHandle {SELECT SOUNDEX('Hello')}) <b>Returns</b> 'H400'</pre>
				<pre>(sql sqlHandle {SELECT SOUNDEX('Quadratically')}) <b>Returns</b> 'Q36324'</pre>
				<p>Note: This function implements the original Soundex algorithm, not the more popular enhanced version (also described by D. Knuth).
					The difference is that original version discards vowels first and duplicates second, whereas the enhanced version discards duplicates first and vowels second.</p>
			</li>
			<li>
				<p>expr1 SOUNDS LIKE expr2</p>
				<p>This is the same as SOUNDEX(expr1) = SOUNDEX(expr2).</p>
			</li>
			<li>
				<p>SPACE(N)</p>
				<p>Returns a string consisting of N space characters.</p>
				<pre>(sql sqlHandle {SELECT SPACE(6)}) <b>Returns</b> '      '</pre>
			</li>
			<li>
				<p>SUBSTR(str,pos), SUBSTR(str FROM pos), SUBSTR(str,pos,len), SUBSTR(str FROM pos FOR len)</p>
				<p>SUBSTR() is a synonym for SUBSTRING().</p>
			</li>
			<li>
				<p>SUBSTRING(str,pos), SUBSTRING(str FROM pos), SUBSTRING(str,pos,len), SUBSTRING(str FROM pos FOR len)</p>
				<p>The forms without a len argument return a substring from string str starting at position pos.
				The forms with a len argument return a substring len characters long from string str, starting at position pos.
				The forms that use FROM are standard SQL syntax. It is also possible to use a negative value for pos.
				In this case, the beginning of the substring is pos characters from the end of the string, rather than the beginning.
				A negative value may be used for pos in any of the forms of this function.</p>
				<p>For all forms of SUBSTRING(), the position of the first character in the string from which the substring is to be extracted is reckoned as 1.</p>
				<pre>(sql sqlHandle {SELECT SUBSTRING('Quadratically',5)}) <b>Returns</b> 'ratically'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING('foobarbar' FROM 4)}) <b>Returns</b> 'barbar'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING('Quadratically',5,6)}) <b>Returns</b> 'ratica'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING('Sakila', -3)}) <b>Returns</b> 'ila'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING('Sakila', -5, 3)}) <b>Returns</b> 'aki'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING('Sakila' FROM -4 FOR 2)}) <b>Returns</b> 'ki'</pre>
				<p>This function is multi-byte safe.</p>
				<p>If len is less than 1, the result is the empty string.</p>
			</li>
			<li>
				<p>SUBSTRING_INDEX(str,delim,count)</p>
				<p>Returns the substring from string str before count occurrences of the delimiter delim.
					If count is positive, everything to the left of the final delimiter (counting from the left) is returned.
					If count is negative, everything to the right of the final delimiter (counting from the right) is returned.
					SUBSTRING_INDEX() performs a case-sensitive match when searching for delim.</p>
				<pre>(sql sqlHandle {SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2)}) <b>Returns</b> 'www.mysql'</pre>
				<pre>(sql sqlHandle {SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2)}) <b>Returns</b> 'mysql.com'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str), TRIM([remstr FROM] str)</p>
				<p>Returns the string str with all remstr prefixes or suffixes removed. If none of the specifiers BOTH, LEADING, or TRAILING is given, BOTH is assumed. remstr is optional and, if not specified, spaces are removed.</p>
				<pre>(sql sqlHandle {SELECT TRIM('  bar   ')}) <b>Returns</b> 'bar'</pre>
				<pre>(sql sqlHandle {SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx')}) <b>Returns</b> 'barxxx'</pre>
				<pre>(sql sqlHandle {SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx')}) <b>Returns</b> 'bar'</pre>
				<pre>(sql sqlHandle {SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz')}) <b>Returns</b> 'barx'</pre>
				<p>This function is multi-byte safe.</p>
			</li>
			<li>
				<p>UCASE(str)</p>
				<p>UCASE() is a synonym for UPPER().</p>
			</li>
			<li>
				<p>UNHEX(str)</p>
				<p>Performs the inverse operation of HEX(str). That is, it interprets each pair of hexadecimal digits in the argument as a number and converts it to the character represented by the number.
					The resulting characters are returned as a binary string.</p>
				<pre>(sql sqlHandle {SELECT UNHEX('4D7953514C')}) <b>Returns</b> 'MySQL'</pre>
				<pre>(sql sqlHandle {SELECT 0x4D7953514C})}) <b>Returns</b> 'MySQL'</pre>
				<pre>(sql sqlHandle {SELECT UNHEX(HEX('string'))}) <b>Returns</b> 'string'</pre>
				<pre>(sql sqlHandle {SELECT HEX(UNHEX('1267'))}) <b>Returns</b> '1267'</pre>
				<p>The characters in the argument string must be legal hexadecimal digits: '0' .. '9', 'A' .. 'F', 'a' .. 'f'. If UNHEX() encounters any non-hexadecimal digits in the argument, it returns NULL:</p>
				<pre>(sql sqlHandle {SELECT UNHEX('GG')}) <b>Returns</b>
+-------------+
| UNHEX('GG') |
+-------------+
| NULL        | 
+-------------+</pre>
				<p>A NULL result can occur if the argument to UNHEX() is a BINARY column, because values are padded with 0x00 bytes when stored but those bytes are not stripped on retrieval.
					For example 'aa' is stored into a CHAR(3) column as 'aa ' and retrieved as 'aa' (with the trailing pad space stripped),
					so UNHEX() for the column value returns 'A'. By contrast 'aa' is stored into a BINARY(3) column as 'aa\0' and retrieved as 'aa\0' (with the trailing pad 0x00 byte not stripped).
					'\0' is not a legal hexadecimal digit, so UNHEX() for the column value returns NULL.</p>
			</li>
			<li>
				<p>UPPER(str)</p>
				<p>Returns the string str with all characters changed to uppercase according to the current character set mapping. The default is latin1 (cp1252 West European).</p>
				<pre>(sql sqlHandle {SELECT UPPER('Hej')}) <b>Returns</b> 'HEJ'</pre>
				<p>UPPER() is ineffective when applied to binary strings (BINARY, VARBINARY, BLOB). The description of LOWER() shows how to perform lettercase conversion of binary strings.</p>
				<p>This function is multi-byte safe.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SString Comparison Functions"></A>String Comparison Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>LIKE</td><td>Simple pattern matching</td></tr>
			<tr><td>NOT LIKE</td><td>Negation of simple pattern matching</td></tr>
			<tr><td>SOUNDS LIKE</td><td>Compare sounds</td></tr>
		</table>
		<p>If a string function is given a binary string as an argument, the resulting string is also a binary string.
			A number converted to a string is treated as a binary string. This affects only comparisons.</p>
		<p>Normally, if any expression in a string comparison is case sensitive, the comparison is performed in case-sensitive fashion.</p>
		<ul>
			<li>
				<p>expr LIKE pat [ESCAPE 'escape_char']</p>
				<p>Pattern matching using SQL simple regular expression comparison. Returns 1 (TRUE) or 0 (FALSE). If either expr or pat is NULL, the result is NULL.</p>
				<p>The pattern need not be a literal string. For example, it can be specified as a string expression or table column.</p>
				<p>Per the SQL standard, LIKE performs matching on a per-character basis, thus it can produce results different from the = comparison operator:</p>
				<pre>(sql sqlHandle {SELECT '' LIKE 'ae' COLLATE latin1_german2_ci}) <b>Returns</b>
+-----------------------------------------+
| '' LIKE 'ae' COLLATE latin1_german2_ci |
+-----------------------------------------+
|                                       0 |
+-----------------------------------------+</pre>
				<pre>(sql sqlHandle {SELECT '' = 'ae' COLLATE latin1_german2_ci}) <b>Returns</b>
+--------------------------------------+
| '' = 'ae' COLLATE latin1_german2_ci |
+--------------------------------------+
|                                    1 |
+--------------------------------------+</pre>
				<p>In particular, trailing spaces are significant, which is not true for CHAR or VARCHAR comparisons performed with the = operator:</p>
				<pre>(sql sqlHandle {SELECT 'a' = 'a ', 'a' LIKE 'a '}) <b>Returns</b>
+------------+---------------+
| 'a' = 'a ' | 'a' LIKE 'a ' |
+------------+---------------+
|          1 |             0 | 
+------------+---------------+</pre>
				<p>With LIKE you can use the following two wildcard characters in the pattern:</p>
				<table border="3">
					<tr><th>Character</th><th>Description</th></tr>
					<tr><td>%</td><td>Matches any number of characters, even zero characters</td></tr>
					<tr><td>_</td><td>Matches exactly one character</td></tr>
				</table>
				<pre>(sql sqlHandle {SELECT 'David!' LIKE 'David_'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'David!' LIKE '%D%v%'}) <b>Returns</b> 1</pre>
				<p>To test for literal instances of a wildcard character, precede it by the escape character. If you do not specify the ESCAPE character, "\" is assumed.</p>
				<table border="3">
					<tr><th>String</th><th>Description</th></tr>
					<tr><td>\%</td><td>Matches one "%" character</td></tr>
					<tr><td>\_</td>Matches one "_" character</td></tr>
				</table>
				<pre>(sql sqlHandle {SELECT 'David!' LIKE 'David\_'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'David_' LIKE 'David\_'}) <b>Returns</b> 1</pre>
				<p>To specify a different escape character, use the ESCAPE clause:</p>
				<pre>(sql sqlHandle {SELECT 'David_' LIKE 'David|_' ESCAPE '|'}) <b>Returns</b> 1</pre>
				<p>The escape sequence should be empty or one character long. As of MySQL 5.1.2, if the NO_BACKSLASH_ESCAPES SQL mode is enabled, the sequence cannot be empty.</p>
				<p>The following two statements illustrate that string comparisons are not case sensitive unless one of the operands is a binary string:</p>
				<pre>(sql sqlHandle {SELECT 'abc' LIKE 'ABC'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'abc' LIKE BINARY 'ABC'}) </b>Returns</b> 0</pre>
				<p>In MySQL, LIKE is allowed on numeric expressions. (This is an extension to the standard SQL LIKE.)</p>
				<pre>(sql sqlHandle {SELECT 10 LIKE '1%'}) <b>Returns</b> 1</pre>
				<p>Note: Because MySQL uses C escape syntax in strings (for example, "\n" to represent a newline character), you must double any "\" that you use in LIKE strings.
					For example, to search for "\n", specify it as "\\n". To search for "\", specify it as "\\\\";
					this is because the backslashes are stripped once by the parser and again when the pattern match is made, leaving a single backslash to be matched against.
					(Exception: At the end of the pattern string, backslash can be specified as "\\". At the end of the string, backslash stands for itself because there is nothing following to escape.)</p>
			</li>
			<li>
				<p>expr NOT LIKE pat [ESCAPE 'escape_char']</p>
				<p>This is the same as NOT (expr LIKE pat [ESCAPE 'escape_char']).</p>
				<p>Note: Aggregate queries involving NOT LIKE comparisons with columns containing NULL may yield unexpected results. For example, consider the following table and data:</p>
				<pre>(sql sqlHandle {CREATE TABLE foo (bar VARCHAR(10))})</pre>
				<pre>(sql sqlHandle {INSERT INTO foo VALUES (NULL), (NULL)})</pre>
				<p>The query SELECT COUNT(*) FROM foo WHERE bar LIKE '%baz%'; returns 0. You might assume that SELECT COUNT(*) FROM foo WHERE bar NOT LIKE '%baz%';
					would return 2. However, this is not the case: The second query returns 0.
					This is because NULL NOT LIKE expr always returns NULL, regardless of the value of expr.
					The same is true for aggregate queries involving NULL and comparisons using NOT RLIKE or NOT REGEXP.
					In such cases, you must test explicitly for NOT NULL using OR (and not AND), as shown here:</p>
				<pre>(sql sqlHandle {SELECT COUNT(*) FROM foo WHERE bar NOT LIKE '%baz%' OR bar IS NULL})</pre>
			</li>
			<li>
				<p>expr NOT REGEXP pat, expr NOT RLIKE pat</p>
				<p>This is the same as NOT (expr REGEXP pat).</p>
			</li>
			<li>
				<p>expr REGEXP pat, expr RLIKE pat</p>
				<p>Performs a pattern match of a string expression expr against a pattern pat.
					The pattern can be an extended regular expression. Returns 1 if expr matches pat; otherwise it returns 0.
					If either expr or pat is NULL, the result is NULL. RLIKE is a synonym for REGEXP, provided for mSQL compatibility.</p>
				<p>The pattern need not be a literal string. For example, it can be specified as a string expression or table column.</p>
				<p>Note: Because MySQL uses the C escape syntax in strings (for example, "\n" to represent the newline character), you must double any "\" that you use in your REGEXP strings.</p>
				<p>REGEXP is not case sensitive, except when used with binary strings.</p>
				<pre>(sql sqlHandle {SELECT 'Monty!' REGEXP 'm%y%%'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'Monty!' REGEXP '.*'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'new*\n*line' REGEXP 'new\\*.\\*line'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'a' REGEXP 'A', 'a' REGEXP BINARY 'A'}) <b>Returns</b> 1  0</pre>
				<pre>(sql sqlHandle {SELECT 'a' REGEXP '^[a-d]'}) <b>Returns</b> 1</pre>
				<p>REGEXP and RLIKE use the current character set when deciding the type of a character. The default is latin1 (cp1252 West European).</p>
				<p>Warning: The REGEXP and RLIKE operators work in byte-wise fashion, so they are not multi-byte safe and may produce unexpected results with multi-byte character sets.
					In addition, these operators compare characters by their byte values and accented characters may not compare as equal even if a given collation treats them as equal.</p>
			</li>
			<li>
				<p>STRCMP(expr1,expr2)</p>
				<p>STRCMP() returns 0 if the strings are the same, -1 if the first argument is smaller than the second according to the current sort order, and 1 otherwise.</p>
				<pre>(sql sqlHandle {SELECT STRCMP('text', 'text2')}) <b>Returns</b> -1</pre>
				<pre>(sql sqlHandle {SELECT STRCMP('text2', 'text')}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT STRCMP('text', 'text')}) <b>Returns</b> 0</pre>
				<p>STRCMP() uses the current character set when performing comparisons. This makes the default comparison behavior case insensitive unless one or both of the operands are binary strings.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRegular Expressions"></A>Regular Expressions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>NOT REGEXP</td><td>Negation of REGEXP</td></tr>
			<tr><td>REGEXP</td><td>Pattern matching using regular expressions</td></tr>
			<tr><td>RLIKE</td><td>Synonym for REGEXP</td></tr>
		</table>
		<p>A regular expression is a powerful way of specifying a pattern for a complex search.</p>
		<p>MySQL uses Henry Spencer's implementation of regular expressions, which is aimed at conformance with POSIX 1003.2.
			MySQL uses the extended version to support pattern-matching operations performed with the REGEXP operator in SQL statements.</p>
		<p>This section is a summary, with examples, of the special characters and constructs that can be used in MySQL for REGEXP operations.
			It does not contain all the details that can be found in Henry Spencer's regex(7) manual page.</p>
		<p>A regular expression describes a set of strings. The simplest regular expression is one that has no special characters in it.
			For example, the regular expression hello matches hello and nothing else.</p>
		<p>Non-trivial regular expressions use certain special constructs so that they can match more than one string.
			For example, the regular expression hello|word matches either the string hello or the string word.</p>
		<p>As a more complex example, the regular expression B[an]*s matches any of the strings Bananas, Baaaaas, Bs,
			and any other string starting with a B, ending with an s, and containing any number of a or n characters in between.</p>
		<p>A regular expression for the REGEXP operator may use any of the following special characters and constructs:</p>
		<ul>
			<li>
				<p>^</p>
				<p>Match the beginning of a string.</p>
				<pre>(sql sqlHandle {SELECT 'fo\nfo' REGEXP '^fo$'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'fofo' REGEXP '^fo'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>$</p>
				<p>Match the end of a string.</p>
				<pre>(sql sqlHandle {SELECT 'fo\no' REGEXP '^fo\no$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'fo\no' REGEXP '^fo$'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>.</p>
				<p>Match any character (including carriage return and newline).</p>
				<pre>(sql sqlHandle {SELECT 'fofo' REGEXP '^f.*$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'fo\r\nfo' REGEXP '^f.*$'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>a*</p>
				<p>Match any sequence of zero or more a characters.</p>
				<pre>(sql sqlHandle {SELECT 'Ban' REGEXP '^Ba*n'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'Baaan' REGEXP '^Ba*n'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'Bn' REGEXP '^Ba*n'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>a+</p>
				<p>Match any sequence of one or more a characters.</p>
				<pre>(sql sqlHandle {SELECT 'Ban' REGEXP '^Ba+n'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'Bn' REGEXP '^Ba+n'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>a?</p>
				<p>Match either zero or one a character.</p>
				<pre>(sql sqlHandle {SELECT 'Bn' REGEXP '^Ba?n'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'Ban' REGEXP '^Ba?n'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'Baan' REGEXP '^Ba?n'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>de|abc</p>
				<p>Match either of the sequences de or abc.</p>
				<pre>(sql sqlHandle {SELECT 'pi' REGEXP 'pi|apa'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'axe' REGEXP 'pi|apa'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'apa' REGEXP 'pi|apa'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'apa' REGEXP '^(pi|apa)$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'pi' REGEXP '^(pi|apa)$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'pix' REGEXP '^(pi|apa)$'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>(abc)*</p>
				<p>Match zero or more instances of the sequence abc.</p>
				<pre>(sql sqlHandle {SELECT 'pi' REGEXP '^(pi)*$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'pip' REGEXP '^(pi)*$'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'pipi' REGEXP '^(pi)*$'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>{1}, {2,3}</p>
				<p>{n} or {m,n} notation provides a more general way of writing regular expressions that match many occurrences of the previous atom (or "piece") of the pattern. m and n are integers.</p>
			</li>
			<li>
				<p>a*</p>
				<p>Can be written as a{0,}.</p>
			</li>
			<li>
				<p>a+</p>
				<p>Can be written as a{1,}.</p>
			</li>
			<li>
				<p>a?</p>
				<p>Can be written as a{0,1}.</p>
				<p>To be more precise, a{n} matches exactly n instances of a. a{n,} matches n or more instances of a. a{m,n} matches m through n instances of a, inclusive.</p>
				<p>m and n must be in the range from 0 to RE_DUP_MAX (default 255), inclusive. If both m and n are given, m must be less than or equal to n.</p>
				<pre>(sql sqlHandle {SELECT 'abcde' REGEXP 'a[bcd]{2}e'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'abcde' REGEXP 'a[bcd]{3}e'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'abcde' REGEXP 'a[bcd]{1,10}e'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>[a-dX], [^a-dX]</p>
				<p>Matches any character that is (or is not, if ^ is used) either a, b, c, d or X. A - character between two other characters forms a range that matches all characters from the first character to the second.
					For example, [0-9] matches any decimal digit. To include a literal ] character, it must immediately follow the opening bracket [. To include a literal - character, it must be written first or last.
					Any character that does not have a defined special meaning inside a [] pair matches only itself.</p>
				<pre>(sql sqlHandle {SELECT 'aXbc' REGEXP '[a-dXYZ]'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'aXbc' REGEXP '^[a-dXYZ]$'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'aXbc' REGEXP '^[a-dXYZ]+$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'aXbc' REGEXP '^[^a-dXYZ]+$'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'gheis' REGEXP '^[^a-dXYZ]+$'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'gheisa' REGEXP '^[^a-dXYZ]+$'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>[.characters.]</p>
				<p>Within a bracket expression (written using [ and ]), matches the sequence of characters of that collating element.
					characters is either a single character or a character name like newline. The following table lists the allowable character names.</p>
				<p>The following table shows the allowable character names and the characters that they match. For characters given as numeric values, the values are represented in octal.</p>
				<table border="3">
					<tr><td>Name</td><td>Character</td><td>Name</td><td>Character</td></tr>
					<tr><td>NUL</td><td>0</td><td>SOH</td><td>001</td></tr>
					<tr><td>STX</td><td>002</td><td>ETX</td><td>003</td></tr>
					<tr><td>EOT</td><td>004</td><td>ENQ</td><td>005</td></tr>
					<tr><td>ACK</td><td>006</td><td>BEL</td><td>007</td></tr>
					<tr><td>alert</td><td>007</td><td>BS</td><td>010</td></tr>
					<tr><td>backspace</td><td>'\b'</td><td>HT</td><td>011</td></tr>
					<tr><td>tab</td><td>'\t'</td><td>LF</td><td>012</td></tr>
					<tr><td>newline</td><td>'\n'</td><td>VT</td><td>013</td></tr>
					<tr><td>vertical-tab</td><td>'\v'</td><td>FF</td><td>014</td></tr>
					<tr><td>form-feed</td><td>'\f'</td><td>CR</td><td>015</td></tr>
					<tr><td>carriage-return</td><td>'\r'</td><td>SO</td><td>016</td></tr>
					<tr><td>SI</td><td>017</td><td>DLE</td><td>020</td></tr>
					<tr><td>DC1</td><td>021</td><td>DC2</td><td>022</td></tr>
					<tr><td>DC3</td><td>023</td><td>DC4</td><td>024</td></tr>
					<tr><td>NAK</td><td>025</td><td>SYN</td><td>026</td></tr>
					<tr><td>ETB</td><td>027</td><td>CAN</td><td>030</td></tr>
					<tr><td>EM</td><td>031</td><td>SUB</td><td>032</td></tr>
					<tr><td>ESC</td><td>033</td><td>IS4</td><td>034</td></tr>
					<tr><td>FS</td><td>034</td><td>IS3</td><td>035</td></tr>
					<tr><td>GS</td><td>035</td><td>IS2</td><td>036</td></tr>
					<tr><td>RS</td><td>036</td><td>IS1</td><td>037</td></tr>
					<tr><td>US</td><td>037</td><td>space</td><td>' '</td></tr>
					<tr><td>exclamation-mark</td><td>'!'</td><td>quotation-mark</td><td>'"'</td></tr>
					<tr><td>number-sign</td><td>'#'</td><td>dollar-sign</td><td>'$'</td></tr>
					<tr><td>percent-sign</td><td>'%'</td><td>ampersand</td><td>'&amp;'</td></tr>
					<tr><td>apostrophe</td><td>'\''</td><td>left-parenthesis</td><td>'('</td></tr>
					<tr><td>right-parenthesis</td><td>')'</td><td>asterisk</td><td>'*'</td></tr>
					<tr><td>plus-sign</td><td>'+'</td><td>comma</td><td>','</td></tr>
					<tr><td>hyphen</td><td>'-'</td><td>hyphen-minus</td><td>'-'</td></tr>
					<tr><td>period</td><td>'.'</td><td>full-stop</td><td>'.'</td></tr>
					<tr><td>slash</td><td>'/'</td><td>solidus</td><td>'/'</td></tr>
					<tr><td>zero</td><td>'0'</td><td>one</td><td>'1'</td></tr>
					<tr><td>two</td><td>'2'</td><td>three</td><td>'3'</td></tr>
					<tr><td>four</td><td>'4'</td><td>five</td><td>'5'</td></tr>
					<tr><td>six</td><td>'6'</td><td>seven</td><td>'7'</td></tr>
					<tr><td>eight</td><td>'8'</td><td>nine</td><td>'9'</td></tr>
					<tr><td>colon</td><td>':'</td><td>semicolon</td><td>';'</td></tr>
					<tr><td>less-than-sign</td><td>'&lt;'</td><td>equals-sign</td><td>'='</td></tr>
					<tr><td>greater-than-sign</td><td>'&gt;'</td><td>question-mark</td><td>'?'</td></tr>
					<tr><td>commercial-at</td><td>'@'</td><td>left-square-bracket</td><td>'['</td></tr>
					<tr><td>backslash</td><td>'\\'</td><td>reverse-solidus</td><td>'\\'</td></tr>
					<tr><td>right-square-bracket</td><td>']'</td><td>circumflex</td><td>'^'</td></tr>
					<tr><td>circumflex-accent</td><td>'^'</td><td>underscore</td><td>'_'</td></tr>
					<tr><td>low-line</td><td>'_'</td><td>grave-accent</td><td>'`'</td></tr>
					<tr><td>left-brace</td><td>'{'</td><td>left-curly-bracket</td><td>'{'</td></tr>
					<tr><td>vertical-line</td><td>'|'</td><td>right-brace</td><td>'}'</td></tr>
					<tr><td>right-curly-bracket</td><td>'}'</td><td>tilde</td><td>'~'</td></tr>
					<tr><td>DEL</td><td>177</td><td> </td><td> </td></tr>
				</table>
				<pre>(sql sqlHandle {SELECT '~' REGEXP '[[.~.]]'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT '~' REGEXP '[[.tilde.]]'}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>[=character_class=]</p>
				<p>Within a bracket expression (written using [ and ]), [=character_class=] represents an equivalence class.
					It matches all characters with the same collation value, including itself. For example, if o and (+) are the members of an equivalence class, then [[=o=]], [[=(+)=]], and [o(+)] are all synonymous.
					An equivalence class may not be used as an endpoint of a range.</p>
			</li>
			<li>
				<p>[:character_class:]</p>
				<p>Within a bracket expression (written using [ and ]), [:character_class:] represents a character class that matches all characters belonging to that class.
					The following table lists the standard class names. These names stand for the character classes defined in the ctype(3) manual page.
					A particular locale may provide other class names. A character class may not be used as an endpoint of a range.</p>
				<table border="3">
					<tr><td>alnum</td><td>Alphanumeric characters</td></tr>
					<tr><td>alpha</td><td>Alphabetic characters</td></tr>
					<tr><td>blank</td><td>Whitespace characters</td></tr>
					<tr><td>cntrl</td><td>Control characters</td></tr>
					<tr><td>digit</td><td>Digit characters</td></tr>
					<tr><td>graph</td><td>Graphic characters</td></tr>
					<tr><td>lower</td><td>Lowercase alphabetic characters</td></tr>
					<tr><td>print</td><td>Graphic or space characters</td></tr>
					<tr><td>punct</td><td>Punctuation characters</td></tr>
					<tr><td>space</td><td>Space, tab, newline, and carriage return</td></tr>
					<tr><td>upper</td><td>Uppercase alphabetic characters</td></tr>
					<tr><td>xdigit</td><td>Hexadecimal digit characters</td></tr>
				</table>
				<pre>(sql sqlHandle {SELECT 'justalnums' REGEXP '[[:alnum:]]+'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT '!!' REGEXP '[[:alnum:]]+'}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>[[:<:]], [[:>:]]</p>
				<p>These markers stand for word boundaries. They match the beginning and end of words, respectively.
					A word is a sequence of word characters that is not preceded by or followed by word characters.
					A word character is an alphanumeric character in the alnum class or an underscore (_).</p>
				<pre>(sql sqlHandle {SELECT 'a word a' REGEXP '[[:<:]]word[[:>:]]'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 'a xword a' REGEXP '[[:<:]]word[[:>:]]'}) <b>Returns</b> 0</pre>
				<p>To use a literal instance of a special character in a regular expression, precede it by two backslash (\) characters.
					The MySQL parser interprets one of the backslashes, and the regular expression library interprets the other.
					For example, to match the string 1+2 that contains the special + character, only the last of the following regular expressions is the correct one:</p>
				<pre>(sql sqlHandle {SELECT '1+2' REGEXP '1+2'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT '1+2' REGEXP '1\+2'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT '1+2' REGEXP '1\\+2'}) <b>Returns</b> 1</pre>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SNumeric Functions"></A>Numeric Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>ABS()</td><td>Return the absolute value</td></tr>
			<tr><td>ACOS()</td><td>Return the arc cosine</td></tr>
			<tr><td>ASIN()</td><td>Return the arc sine</td></tr>
			<tr><td>ATAN2(), ATAN()</td><td>Return the arc tangent of the two arguments</td></tr>
			<tr><td>ATAN()</td><td>Return the arc tangent</td></tr>
			<tr><td>CEIL()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CEILING()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CONV()</td><td>Convert numbers between different number bases</td></tr>
			<tr><td>COS()</td><td>Return the cosine</td></tr>
			<tr><td>COT()</td><td>Return the cotangent</td></tr>
			<tr><td>CRC32()</td><td>Compute a cyclic redundancy check value</td></tr>
			<tr><td>DEGREES()</td><td>Convert radians to degrees</td></tr>
			<tr><td>DIV</td><td>Integer division</td></tr>
			<tr><td>/</td><td>Division operator</td></tr>
			<tr><td>EXP()</td><td>Raise to the power of</td></tr>
			<tr><td>FLOOR()</td><td>Return the largest integer value not greater than  the argument</td></tr>
			<tr><td>LN()</td><td>Return the natural logarithm of the argument</td></tr>
			<tr><td>LOG10()</td><td>Return the base-10 logarithm of the argument</td></tr>
			<tr><td>LOG2()</td><td>Return the base-2 logarithm of the argument</td></tr>
			<tr><td>LOG()</td><td>  Return the natural logarithm of the first argument  </td></tr>
			<tr><td>-</td><td>Minus operator</td></tr>
			<tr><td>MOD()</td><td>Return the remainder</td></tr>
			<tr><td>%</td><td>Modulo operator</td></tr>
			<tr><td>OCT()</td><td>Return an octal representation of a decimal  number</td></tr>
			<tr><td>PI()</td><td>Return the value of pi</td></tr>
			<tr><td>+</td><td>Addition operator</td></tr>
			<tr><td>POW()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>POWER()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>RADIANS()</td><td>Return argument converted to radians</td></tr>
			<tr><td>RAND()</td><td>Return a random floating-point value</td></tr>
			<tr><td>ROUND()</td><td>Round the argument</td></tr>
			<tr><td>SIGN()</td><td>Return the sign of the argument</td></tr>
			<tr><td>SIN()</td><td>Return the sine of the argument</td></tr>
			<tr><td>SQRT()</td><td>Return the square root of the argument</td></tr>
			<tr><td>TAN()</td><td>Return the tangent of the argument</td></tr>
			<tr><td>*</td><td>Times operator</td></tr>
			<tr><td>TRUNCATE()</td><td>Truncate to specified number of decimal places</td></tr>
			<tr><td>-</td><td>Change the sign of the argument</td></tr>
		</table>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SArithmetic Operators"></A>Arithmetic Operators</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>DIV</td><td>Integer division</td></tr>
			<tr><td>/</td><td>Division operator</td></tr>
			<tr><td>-</td><td>Minus operator</td></tr>
			<tr><td>%</td><td>Modulo operator</td></tr>
			<tr><td>+</td><td>Addition operator</td></tr>
			<tr><td>*</td><td>Times operator</td></tr>
			<tr><td>-</td><td>Change the sign of the argument</td></tr>
		</table>
		<p>The usual arithmetic operators are available. The result is determined according to the following rules:</p>
		<ul>
			<li>
				<p>In the case of -, +, and *, the result is calculated with BIGINT (64-bit) precision if both arguments are integers.</p>
			</li>
			<li>
				<p>If one of the arguments is an unsigned integer, and the other argument is also an integer, the result is an unsigned integer.</p>
			</li>
			<li>
				<p>If any of the operands of a +, -, /, *, % is a real or string value, then the precision of the result is the precision of the argument with the maximum precision.</p>
			</li>
			<li>
				<p>In division performed with /, the scale of the result when using two exact values is the scale of the first argument plus the value of the div_precision_increment system variable (which is 4 by default).
					For example, the result of the expression 5.05 / 0.014 has a scale of six decimal places (360.714286).</p>
			</li>
		</ul>
		<p>These rules are applied for each operation, such that nested calculations imply the precision of each component.
			Hence, (14620 / 9432456) / (24250 / 9432456), would resolve first to (0.0014) / (0.0026), with the final result having 8 decimal places (0.60288653).</p>
		<p>Because of these rules and the way they are applied, care should be taken to ensure that components and sub-components of a calculation use the appropriate level of precision.</p>
		<ul>
			<li>
				<p>+</p>
				<p>Addition:</p>
				<pre>(sql sqlHandle {SELECT 3+5}) <b>Returns</b> 8</pre>
			</li>
			<li>
				<p>-</p>
				<p>Subtraction:</p>
				<pre>(sql sqlHandle {SELECT 3-5}) <b>Returns</b> -2</pre>
			</li>
			<li>
				<p>-</p>
				<p>Unary minus. This operator changes the sign of the argument.</p>
				<pre>(sql sqlHandle {SELECT - 2}) <b>Returns</b> -2</pre>
				<p>Note: If this operator is used with a BIGINT, the return value is also a BIGINT.
					This means that you should avoid using  on integers that may have the value of 263.</p>
			</li>
			<li>
				<p>*</p>
				<p>Multiplication:</p>
				<pre>(sql sqlHandle {SELECT 3*5}) <b>Returns</b> 15</pre>
				<pre>(sql sqlHandle {SELECT 18014398509481984*18014398509481984.0}) <b>Returns</b> 324518553658426726783156020576256.0</pre>
				<pre>(sql sqlHandle {SELECT 18014398509481984*18014398509481984}) <b>Returns</b> 0</pre>
				<p>The result of the last expression is incorrect because the result of the integer multiplication exceeds the 64-bit range of BIGINT calculations.</p>
			</li>
			<li>
				<p>/</p>
				<p>Division:</p>
				<pre>(sql sqlHandle {SELECT 3/5}) <b>Returns</b> 0.60</pre>
				<p>Division by zero produces a NULL result:</p>
				<pre>(sql sqlHandle {SELECT 102/(1-1)}) <b>Returns</b> NULL</pre>
				<p>A division is calculated with BIGINT arithmetic only if performed in a context where its result is converted to an integer.</p>
			</li>
			<li>
				<p>DIV</p>
				<p>Integer division. Similar to FLOOR(), but is safe with BIGINT values.</p>
				<pre>(sql sqlHandle {SELECT 5 DIV 2}) <b>Returns</b> 2</pre>
			</li>
			<li>
				<p>N % M</p>
				<p>Modulo operation. Returns the remainder of N divided by M.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMathematical Functions"></A>Mathematical Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>ABS()</td><td>Return the absolute value</td></tr>
			<tr><td>ACOS()</td><td>Return the arc cosine</td></tr>
			<tr><td>ASIN()</td><td>Return the arc sine</td></tr>
			<tr><td>ATAN2(), ATAN()</td><td>Return the arc tangent of the two arguments</td></tr>
			<tr><td>ATAN()</td><td>Return the arc tangent</td></tr>
			<tr><td>CEIL()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CEILING()</td><td>Return the smallest integer value not less than  the argument</td></tr>
			<tr><td>CONV()</td><td>Convert numbers between different number bases</td></tr>
			<tr><td>COS()</td><td>Return the cosine</td></tr>
			<tr><td>COT()</td><td>Return the cotangent</td></tr>
			<tr><td>CRC32()</td><td>Compute a cyclic redundancy check value</td></tr>
			<tr><td>DEGREES()</td><td>Convert radians to degrees</td></tr>
			<tr><td>EXP()</td><td>Raise to the power of</td></tr>
			<tr><td>FLOOR()</td><td>Return the largest integer value not greater than  the argument</td></tr>
			<tr><td>LN()</td><td>Return the natural logarithm of the argument</td></tr>
			<tr><td>LOG10()</td><td>Return the base-10 logarithm of the argument</td></tr>
			<tr><td>LOG2()</td><td>Return the base-2 logarithm of the argument</td></tr>
			<tr><td>LOG()</td><td>  Return the natural logarithm of the first argument  </td></tr>
			<tr><td>MOD()</td><td>Return the remainder</td></tr>
			<tr><td>OCT()</td><td>Return an octal representation of a decimal  number</td></tr>
			<tr><td>PI()</td><td>Return the value of pi</td></tr>
			<tr><td>POW()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>POWER()</td><td>Return the argument raised to the specified power</td></tr>
			<tr><td>RADIANS()</td><td>Return argument converted to radians</td></tr>
			<tr><td>RAND()</td><td>Return a random floating-point value</td></tr>
			<tr><td>ROUND()</td><td>Round the argument</td></tr>
			<tr><td>SIGN()</td><td>Return the sign of the argument</td></tr>
			<tr><td>SIN()</td><td>Return the sine of the argument</td></tr>
			<tr><td>SQRT()</td><td>Return the square root of the argument</td></tr>
			<tr><td>TAN()</td><td>Return the tangent of the argument</td></tr>
			<tr><td>TRUNCATE()</td><td>Truncate to specified number of decimal places</td></tr>
		</table>
		<p>All mathematical functions return NULL in the event of an error.</p>
		<ul>
			<li>
				<p>ABS(X)</p>
				<p>Returns the absolute value of X.</p>
				<pre>(sql sqlHandle {SELECT ABS(2)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT ABS(-32)}) <b>Returns</b> 32</pre>
				<p>This function is safe to use with BIGINT values.</p>
			</li>
			<li>
				<p>ACOS(X)</p>
				<p>Returns the arc cosine of X, that is, the value whose cosine is X. Returns NULL if X is not in the range -1 to 1.</p>
				<pre>(sql sqlHandle {SELECT ACOS(1)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT ACOS(1.0001)}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT ACOS(0)}) <b>Returns</b> 1.5707963267949</pre>
			</li>
			<li>
				<p>ASIN(X)</p>
				<p>Returns the arc sine of X, that is, the value whose sine is X. Returns NULL if X is not in the range -1 to 1.</p>
				<pre>(sql sqlHandle {SELECT ASIN(0.2)}) <b>Returns</b> 0.20135792079033</pre>
				<pre>(sql sqlHandle {SELECT ASIN('foo')}) <b>Returns</b>
+-------------+
| ASIN('foo') |
+-------------+
|           0 |
+-------------+</pre>
				<pre>(sql sqlHandle {SHOW WARNINGS}) <b>Returns</b>
+---------+------+-----------------------------------------+
| Level   | Code | Message                                 |
+---------+------+-----------------------------------------+
| Warning | 1292 | Truncated incorrect DOUBLE value: 'foo' |
+---------+------+-----------------------------------------+</pre>
			</li>
			<li>
				<p>ATAN(X)</p>
				<p>Returns the arc tangent of X, that is, the value whose tangent is X.</p>
				<pre>(sql sqlHandle {SELECT ATAN(2)}) <b>Returns</b> 1.1071487177941</pre>
				<pre>(sql sqlHandle {SELECT ATAN(-2)}) <b>Returns</b> -1.1071487177941</pre>
			</li>
			<li>
				<p>ATAN(Y,X), ATAN2(Y,X)</p>
				<p>Returns the arc tangent of the two variables X and Y. It is similar to calculating the arc tangent of Y / X,
					except that the signs of both arguments are used to determine the quadrant of the result.</p>
				<pre>(sql sqlHandle {SELECT ATAN(-2,2)}) <b>Returns</b> -0.78539816339745</pre>
				<pre>(sql sqlHandle {SELECT ATAN2(PI(),0)}) <b>Returns</b> 1.5707963267949</pre>
			</li>
			<li>
				<p>CEIL(X)</p>
				<p>CEIL() is a synonym for CEILING().</p>
			</li>
			<li>
				<p>CEILING(X)</p>
				<p>Returns the smallest integer value not less than X.</p>
				<pre>(sql sqlHandle { SELECT CEILING(1.23)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle { SELECT CEILING(-1.23)}) <b>Returns</b> -1</pre>
				<p>For exact-value numeric arguments, the return value has an exact-value numeric type.
					For string or floating-point arguments, the return value has a floating-point type.</p>
			</li>
			<li>
				<p>CONV(N,from_base,to_base)</p>
				<p>Converts numbers between different number bases. Returns a string representation of the number N, converted from base from_base to base to_base.
					Returns NULL if any argument is NULL. The argument N is interpreted as an integer, but may be specified as an integer or a string.
					The minimum base is 2 and the maximum base is 36. If to_base is a negative number, N is regarded as a signed number.
					Otherwise, N is treated as unsigned. CONV() works with 64-bit precision.</p>
				<pre>(sql sqlHandle {SELECT CONV('a',16,2)}) <b>Returns</b> '1010'</pre>
				<pre>(sql sqlHandle {SELECT CONV('6E',18,8)}) <b>Returns</b> '172'</pre>
				<pre>(sql sqlHandle {SELECT CONV(-17,10,-18)}) <b>Returns</b> '-H'</pre>
				<pre>(sql sqlHandle {SELECT CONV(10+'10'+'10'+0xa,10,10)}) <b>Returns</b> '40'</pre>
			</li>
			<li>
				<p>COS(X)</p>
				<p>Returns the cosine of X, where X is given in radians.</p>
				<pre>(sql sqlHandle { SELECT COS(PI())}) <b>Returns</b> -1</pre>
			</li>
			<li>
				<p>COT(X)</p>
				<p>Returns the cotangent of X.</p>
				<pre>(sql sqlHandle {SELECT COT(12)}) <b>Returns</b> -1.5726734063977</pre>
				<pre>(sql sqlHandle {SELECT COT(0)}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>CRC32(expr)</p>
				<p>Computes a cyclic redundancy check value and returns a 32-bit unsigned value. The result is NULL if the argument is NULL.
					The argument is expected to be a string and (if possible) is treated as one if it is not.</p>
				<pre>(sql sqlHandle {SELECT CRC32('MySQL')}) <b>Returns</b> 3259397556</pre>
				<pre>(sql sqlHandle {SELECT CRC32('mysql')}) <b>Returns</b> 2501908538</pre>
			</li>
			<li>
				<p>DEGREES(X)</p>
				<p>Returns the argument X, converted from radians to degrees.</p>
				<pre>(sql sqlHandle {SELECT DEGREES(PI())}) <b>Returns</b> 180</pre>
				<pre>(sql sqlHandle {SELECT DEGREES(PI() / 2)}) <b>Returns</b> 90</pre>
			</li>
			<li>
				<p>EXP(X)</p>
				<p>Returns the value of e (the base of natural logarithms) raised to the power of X.
					The inverse of this function is LOG() (using a single argument only) or LN().</p>
				<pre>(sql sqlHandle {SELECT EXP(2)}) <b>Returns</b> 7.3890560989307</pre>
				<pre>(sql sqlHandle {SELECT EXP(-2)}) <b>Returns</b> 0.13533528323661</pre>
				<pre>(sql sqlHandle {SELECT EXP(0)}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>FLOOR(X)</p>
				<p>Returns the largest integer value not greater than X.</p>
				<pre>(sql sqlHandle {SELECT FLOOR(1.23)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT FLOOR(-1.23)}) <b>Returns</b> -2</pre>
				<p>For exact-value numeric arguments, the return value has an exact-value numeric type.
					For string or floating-point arguments, the return value has a floating-point type.</p>
			</li>
			<li>
				<p>FORMAT(X,D)</p>
				<p>Formats the number X to a format like '#,###,###.##', rounded to D decimal places, and returns the result as a string.</p>
			</li>
			<li>
				<p>HEX(N_or_S)</p>
				<p>This function can be used to obtain a hexadecimal representation of a decimal number or a string;
					the manner in which it does so varies according to the argument's type.</p>
			</li>
			<li>
				<p>LN(X)</p>
				<p>Returns the natural logarithm of X; that is, the base-e logarithm of X. If X is less than or equal to 0, then NULL is returned.</p>
				<pre>(sql sqlHandle {SELECT LN(2)}) <b>Returns</b> 0.69314718055995</pre>
				<pre>(sql sqlHandle {SELECT LN(-2)}) <b>Returns</b> NULL</pre>
				<p>This function is synonymous with LOG(X). The inverse of this function is the EXP() function.</p>
			</li>
			<li>
				<p>LOG(X), LOG(B,X)</p>
				<p>If called with one parameter, this function returns the natural logarithm of X. If X is less than or equal to 0, then NULL is returned.</p>
				<p>The inverse of this function (when called with a single argument) is the EXP() function.</p>
				<pre>(sql sqlHandle {SELECT LOG(2)}) <b>Returns</b> 0.69314718055995</pre>
				<pre>(sql sqlHandle {SELECT LOG(-2)}) <b>Returns</b> NULL</pre>
				<p>If called with two parameters, this function returns the logarithm of X to the base B. If X is less than or equal to 0, or if B is less than or equal to 1, then NULL is returned.</p>
				<pre>(sql sqlHandle {SELECT LOG(2,65536)}) <b>Returns</b> 16</pre>
				<pre>(sql sqlHandle {SELECT LOG(10,100)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT LOG(1,100)}) <b>Returns</b> NULL</pre>
				<p>LOG(B,X) is equivalent to LOG(X) / LOG(B).</p>
			</li>
			<li>
				<p>LOG2(X)</p>
				<p>Returns the base-2 logarithm of X.</p>
				<pre>(sql sqlHandle {SELECT LOG2(65536)}) <b>Returns</b> 16</pre>
				<pre>(sql sqlHandle {SELECT LOG2(-100)}) <b>Returns</b> NULL</pre>
				<p>LOG2() is useful for finding out how many bits a number requires for storage. This function is equivalent to the expression LOG(X) / LOG(2).</p>
			</li>
			<li>
				<p>LOG10(X)</p>
				<p>Returns the base-10 logarithm of X.</p>
				<pre>(sql sqlHandle {SELECT LOG10(2)}) <b>Returns</b> 0.30102999566398</pre>
				<pre>(sql sqlHandle {SELECT LOG10(100)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT LOG10(-100)}) <b>Returns</b> NULL</pre>
				<p>LOG10(X) is equivalent to LOG(10,X).</p>
			</li>
			<li>
				<p>MOD(N,M), N % M, N MOD M</p>
				<p>Modulo operation. Returns the remainder of N divided by M.</p>
				<pre>(sql sqlHandle {SELECT MOD(234, 10)}) <b>Returns</b> 4</pre>
				<pre>(sql sqlHandle {SELECT 253 % 7}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT MOD(29,9)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT 29 MOD 9}) <b>Returns</b> 2</pre>
				<p>This function is safe to use with BIGINT values.</p>
				<p>MOD() also works on values that have a fractional part and returns the exact remainder after division:</p>
				<pre>(sql sqlHandle {SELECT MOD(34.5,3)}) <b>Returns</b> 1.5</pre>
				<p>MOD(N,0) returns NULL.</p>
			</li>
			<li>
				<p>OCT(N)</p>
				<p>Returns a string representation of the octal value of N, where N is a longlong (BIGINT) number. This is equivalent to CONV(N,10,8). Returns NULL if N is NULL.</p>
				<pre>(sql sqlHandle {SELECT OCT(12)}) <b>Returns</b> '14'</pre>
			</li>
			<li>
				<p>PI()</p>
				<p>Returns the value of p (pi). The default number of decimal places displayed is seven, but MySQL uses the full double-precision value internally.</p>
				<pre>(sql sqlHandle {SELECT PI()}) <b>Returns</b> 3.141593</pre>
				<pre>(sql sqlHandle {SELECT PI()+0.000000000000000000}) <b>Returns</b> 3.141592653589793116</pre>
			</li>
			<li>
				<p>POW(X,Y)</p>
				<p>Returns the value of X raised to the power of Y.</p>
				<pre>(sql sqlHandle {SELECT POW(2,2)}) <b>Returns</b> 4</pre>
				<pre>(sql sqlHandle {SELECT POW(2,-2)}) <b>Returns</b> 0.25</pre>
			</li>
			<li>
				<p>POWER(X,Y)</p>
				<p>This is a synonym for POW().</p>
			</li>
			<li>
				<p>RADIANS(X)</p>
				<p>Returns the argument X, converted from degrees to radians. (Note that p radians equals 180 degrees.)</p>
				<pre>(sql sqlHandle {SELECT RADIANS(90)}) <b>Returns</b> 1.5707963267949</pre>
			</li>
			<li>
				<p>RAND(), RAND(N)</p>
				<p>Returns a random floating-point value v in the range 0 <= v < 1.0. If a constant integer argument N is specified,
					it is used as the seed value, which produces a repeatable sequence of column values.
					In the following example, note that the sequences of values produced by RAND(3) is the same both places where it occurs.</p>
				<pre>(sql sqlHandle {CREATE TABLE t (i INT)})</pre>
				<pre>(sql sqlHandle {INSERT INTO t VALUES(1),(2),(3)})</pre>
				<pre>(sql sqlHandle {SELECT i, RAND() FROM t}) <b>Returns</b>
+------+------------------+
| i    | RAND()           |
+------+------------------+
|    1 | 0.61914388706828 | 
|    2 | 0.93845168309142 | 
|    3 | 0.83482678498591 | 
+------+------------------+</pre>

				<pre>(sql sqlHandle {SELECT i, RAND(3) FROM t}) <b>Returns</b>
+------+------------------+
| i    | RAND(3)          |
+------+------------------+
|    1 | 0.90576975597606 | 
|    2 | 0.37307905813035 | 
|    3 | 0.14808605345719 | 
+------+------------------+</pre>

				<pre>(sql sqlHandle {SELECT i, RAND() FROM t}) <b>Returns</b>
+------+------------------+
| i    | RAND()           |
+------+------------------+
|    1 | 0.35877890638893 | 
|    2 | 0.28941420772058 | 
|    3 | 0.37073435016976 | 
+------+------------------+</pre>

				<pre>(sql sqlHandle {SELECT i, RAND(3) FROM t}) <b>Returns</b>
+------+------------------+
| i    | RAND(3)          |
+------+------------------+
|    1 | 0.90576975597606 | 
|    2 | 0.37307905813035 | 
|    3 | 0.14808605345719 | 
+------+------------------+</pre>

				<p>With a constant initializer, the seed is initialized once when the statement is compiled, prior to execution.
					If a non-constant initializer (such as a column name) is used as the argument, the seed is initialized with the value for each invocation of RAND().
					(One implication of this is that for equal argument values, RAND() will return the same value each time.)</p>
				<p>To obtain a random integer R in the range i <= R < j, use the expression FLOOR(i + RAND() * (j  i)).
					For example, to obtain a random integer in the range the range 7 <= R < 12, you could use the following statement:</p>
				<pre>(sql sqlHandle {SELECT FLOOR(7 + (RAND() * 5))})</pre>
				<p>You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. However, you can retrieve rows in random order like this:</p>
				<pre>(sql sqlHandle {SELECT * FROM tbl_name ORDER BY RAND()})</pre>
				<p>ORDER BY RAND() combined with LIMIT is useful for selecting a random sample from a set of rows:</p>
				<pre>(sql sqlHandle {SELECT * FROM table1, table2 WHERE a=b AND c<d -> ORDER BY RAND() LIMIT 1000})</pre>
				<p>Note that RAND() in a WHERE clause is re-evaluated every time the WHERE is executed.</p>
				<p>RAND() is not meant to be a perfect random generator, but instead is a fast way to generate ad hoc random numbers which is portable between platforms for the same MySQL version.</p>
			</li>
			<li>
				<p>ROUND(X), ROUND(X,D)</p>
				<p>Rounds the argument X to D decimal places. The rounding algorithm depends on the data type of X. D defaults to 0 if not specified.
					D can be negative to cause D digits left of the decimal point of the value X to become zero.</p>
				<pre>(sql sqlHandle {SELECT ROUND(-1.23)}) <b>Returns</b> -1</pre>
				<pre>(sql sqlHandle {SELECT ROUND(-1.58)}) <b>Returns</b> -2</pre>
				<pre>(sql sqlHandle {SELECT ROUND(1.58)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT ROUND(1.298, 1)}) <b>Returns</b> 1.3</pre>
				<pre>(sql sqlHandle {SELECT ROUND(1.298, 0)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT ROUND(23.298, -1)}) <b>Returns</b> 20</pre>
				<p>The return type is the same type as that of the first argument (assuming that it is integer, double, or decimal).
					This means that for an integer argument, the result is an integer (no decimal places):</p>
				<pre>(sql sqlHandle {SELECT ROUND(150.000,2), ROUND(150,2)}) <b>Returns</b>
+------------------+--------------+
| ROUND(150.000,2) | ROUND(150,2) |
+------------------+--------------+
|           150.00 |          150 |
+------------------+--------------+</pre>
				<p>ROUND() uses the following rules depending on the type of the first argument:</p>
				<p>For exact-value numbers, ROUND() uses the "round half up" or "round toward nearest" rule:
					A value with a fractional part of .5 or greater is rounded up to the next integer if positive or down to the next integer if negative.
					(In other words, it is rounded away from zero.) A value with a fractional part less than .5 is rounded down to the next integer if positive or up to the next integer if negative.</p>
				<p>For approximate-value numbers, the result depends on the C library. On many systems, this means that ROUND() uses the "round to nearest even" rule:
					A value with any fractional part is rounded to the nearest even integer.</p>
				<p>The following example shows how rounding differs for exact and approximate values:</p>
				<pre>(sql sqlHandle {SELECT ROUND(2.5), ROUND(25E-1)}) <b>Returns</b>
+------------+--------------+
| ROUND(2.5) | ROUND(25E-1) |
+------------+--------------+
| 3          |            2 |
+------------+--------------+</pre>
			</li>
			<li>
				<p>SIGN(X)</p>
				<p>Returns the sign of the argument as -1, 0, or 1, depending on whether X is negative, zero, or positive.</p>
				<pre>(sql sqlHandle {SELECT SIGN(-32)}) <b>Returns</b> -1</pre>
				<pre>(sql sqlHandle {SELECT SIGN(0)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT SIGN(234)}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>SIN(X)</p>
				<p>Returns the sine of X, where X is given in radians.</p>
				<pre>(sql sqlHandle {SELECT SIN(PI())}) <b>Returns</b> 1.2246063538224e-16</pre>
				<pre>(sql sqlHandle {SELECT ROUND(SIN(PI()))}) <b>Returns</b> 0</pre>
			</li>
			<li>
				<p>SQRT(X)</p>
				<p>Returns the square root of a non-negative number X.</p>
				<pre>(sql sqlHandle {SELECT SQRT(4)}) <b>Returns</b> 2</pre>
				<pre>(sql sqlHandle {SELECT SQRT(20)}) <b>Returns</b> 4.4721359549996</pre>
				<pre>(sql sqlHandle {SELECT SQRT(-16)}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>TAN(X)</p>
				<p>Returns the tangent of X, where X is given in radians.</p>
				<pre>(sql sqlHandle {SELECT TAN(PI())}) <b>Returns</b> -1.2246063538224e-16</pre>
				<pre>(sql sqlHandle {SELECT TAN(PI()+1)}) <b>Returns</b> 1.5574077246549</pre>
			</li>
			<li>
				<p>TRUNCATE(X,D)</p>
				<p>Returns the number X, truncated to D decimal places. If D is 0, the result has no decimal point or fractional part.
					D can be negative to cause D digits left of the decimal point of the value X to become zero.</p>
				<pre>(sql sqlHandle {SELECT TRUNCATE(1.223,1)}) <b>Returns</b> 1.2</pre>
				<pre>(sql sqlHandle {SELECT TRUNCATE(1.999,1)}) <b>Returns</b> 1.9</pre>
				<pre>(sql sqlHandle {SELECT TRUNCATE(1.999,0)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT TRUNCATE(-1.999,1)}) <b>Returns</b> -1.9</pre>
				<pre>(sql sqlHandle {SELECT TRUNCATE(122,-2)}) <b>Returns</b> 100</pre>
				<pre>(sql sqlHandle {SELECT TRUNCATE(10.28*100,0)}) <b>Returns</b> 1028</pre>
				<p>All numbers are rounded toward zero.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDate and Time Functions"></A>Date and Time Functions</H2></P>
		<p>This section describes the functions that can be used to manipulate temporal values.</p>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>ADDDATE())</td><td>Add dates</td></tr>
			<tr><td>ADDTIME())</td><td>Add time</td></tr>
			<tr><td>CONVERT_TZ()</td><td>Convert from one timezone to another</td></tr>
			<tr><td>CURDATE()</td><td>Return the current date</td></tr>
			<tr><td>CURRENT_DATE(), CURRENT_DATE</td><td>Synonyms for CURDATE()</td></tr>
			<tr><td>CURRENT_TIME(), CURRENT_TIME</td><td>Synonyms for CURTIME()</td></tr>
			<tr><td>CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP</td><td>Synonyms for NOW()</td></tr>
			<tr><td>CURTIME()</td><td>Return the current time</td></tr>
			<tr><td>DATE_ADD()</td><td>Add two dates</td></tr>
			<tr><td>DATE_FORMAT()</td><td>Format date as specified</td></tr>
			<tr><td>DATE_SUB()</td><td>Subtract two dates</td></tr>
			<tr><td>DATE()</td><td>Extract the date part of a date or datetime expression</td></tr>
			<tr><td>DATEDIFF()</td><td>Subtract two dates</td></tr>
			<tr><td>DAY()</td><td>Synonym for DAYOFMONTH()</td></tr>
			<tr><td>DAYNAME()</td><td>Return the name of the weekday</td></tr>
			<tr><td>DAYOFMONTH()</td><td>Return the day of the month (0-31)</td></tr>
			<tr><td>DAYOFWEEK()</td><td>Return the weekday index of the argument</td></tr>
			<tr><td>DAYOFYEAR()</td><td>Return the day of the year (1-366)</td></tr>
			<tr><td>EXTRACT</td><td>Extract part of a date</td></tr>
			<tr><td>FROM_DAYS()</td><td>Convert a day number to a date</td></tr>
			<tr><td>FROM_UNIXTIME()</td><td>Format UNIX timestamp as a date</td></tr>
			<tr><td>GET_FORMAT()</td><td>Return a date format string</td></tr>
			<tr><td>HOUR()</td><td>Extract the hour</td></tr>
			<tr><td>LAST_DAY</td><td>Return the last day of the month for the argument</td></tr>
			<tr><td>LOCALTIME(), LOCALTIME</td><td>Synonym for NOW()</td></tr>
			<tr><td>LOCALTIMESTAMP, LOCALTIMESTAMP()(v4.0.6)</td><td>Synonym for NOW()</td></tr>
			<tr><td>MAKEDATE()</td><td>Create a date from the year and day of year</td></tr>
			<tr><td>MAKETIME</td><td>MAKETIME()</td></tr>
			<tr><td>MICROSECOND()</td><td>Return the microseconds from argument</td></tr>
			<tr><td>MINUTE()</td><td>Return the minute from the argument</td></tr>
			<tr><td>MONTH()</td><td>Return the month from the date passed</td></tr>
			<tr><td>MONTHNAME()</td><td>Return the name of the month</td></tr>
			<tr><td>NOW()</td><td>Return the current date and time</td></tr>
			<tr><td>PERIOD_ADD()</td><td>Add a period to a year-month</td></tr>
			<tr><td>PERIOD_DIFF()</td><td>Return the number of months between periods</td></tr>
			<tr><td>QUARTER()</td><td>Return the quarter from a date argument</td></tr>
			<tr><td>SEC_TO_TIME()</td><td>Converts seconds to 'HH:MM:SS' format</td></tr>
			<tr><td>SECOND()</td><td>Return the second (0-59)</td></tr>
			<tr><td>STR_TO_DATE()</td><td>Convert a string to a date</td></tr>
			<tr><td>SUBDATE()</td><td>A synonym for DATE_SUB() when invoked with three arguments</td></tr>
			<tr><td>SUBTIME()</td><td>Subtract times</td></tr>
			<tr><td>SYSDATE()</td><td>Return the time at which the function executes</td></tr>
			<tr><td>TIME_FORMAT()</td><td>Format as time</td></tr>
			<tr><td>TIME_TO_SEC()</td><td>Return the argument converted to seconds</td></tr>
			<tr><td>TIME()</td><td>Extract the time portion of the expression passed</td></tr>
			<tr><td>TIMEDIFF()</td><td>Subtract time</td></tr>
			<tr><td>TIMESTAMP()</td><td>With a single argument, this function returns the date or datetime expression; with two arguments, the sum of the arguments</td></tr>
			<tr><td>TIMESTAMPADD()</td><td>Add an interval to a datetime expression</td></tr>
			<tr><td>TIMESTAMPDIFF()</td><td>Subtract an interval from a datetime expression</td></tr>
			<tr><td>TO_DAYS()</td><td>Return the date argument converted to days</td></tr>
			<tr><td>UNIX_TIMESTAMP()</td><td>Return a UNIX timestamp</td></tr>
			<tr><td>UTC_DATE()</td><td>Return the current UTC date</td></tr>
			<tr><td>UTC_TIME()</td><td>Return the current UTC time</td></tr>
			<tr><td>UTC_TIMESTAMP()</td><td>Return the current UTC date and time</td></tr>
			<tr><td>WEEK()</td><td>Return the week number</td></tr>
			<tr><td>WEEKDAY()</td><td>Return the weekday index</td></tr>
			<tr><td>WEEKOFYEAR()</td><td>Return the calendar week of the date (0-53)</td></tr>
			<tr><td>YEAR()</td><td>Return the year</td></tr>
			<tr><td>YEARWEEK()</td><td>Return the year and week</td></tr>
		</table>
		<p>Here is an example that uses date functions. The following query selects all rows with a date_col value from within the last 30 days:</p>
		<pre>(sql sqlHandle {SELECT something FROM tbl_name WHERE DATE_SUB(CURDATE(),INTERVAL 30 DAY) <= date_col})</pre>
		<p>The query also selects rows with dates that lie in the future.</p>
		<p>Functions that expect date values usually accept datetime values and ignore the time part. Functions that expect time values usually accept datetime values and ignore the date part.</p>
		<p>Functions that return the current date or time each are evaluated only once per query at the start of query execution.
			This means that multiple references to a function such as NOW() within a single query always produce the same result.
			(For our purposes, a single query also includes a call to a stored program (stored routine, trigger, or event) and all sub-programs called by that program.)
			This principle also applies to CURDATE(), CURTIME(), UTC_DATE(), UTC_TIME(), UTC_TIMESTAMP(), and to any of their synonyms.</p>
		<p>The CURRENT_TIMESTAMP(), CURRENT_TIME(), CURRENT_DATE(), and FROM_UNIXTIME() functions return values in the connection's current time zone,
			which is available as the value of the time_zone system variable. In addition, UNIX_TIMESTAMP() assumes that its argument is a datetime value in the current time zone.</p>
		<p>Some date functions can be used with "zero" dates or incomplete dates such as '2001-11-00', whereas others cannot.
			Functions that extract parts of dates typically work with incomplete dates and thus can return 0 when you might otherwise expect a non-zero value. For example:</p>
		<pre>(sql sqlHandle {SELECT DAYOFMONTH('2001-11-00'), MONTH('2005-00-00')}) <b>Returns</b> 0, 0</pre>
		<p>Other functions expect complete dates and return NULL for incomplete dates. These include functions that perform date arithmetic or that map parts of dates to names. For example:</p>
		<pre>(sql sqlHandle {SELECT DATE_ADD('2006-05-00',INTERVAL 1 DAY)}) <b>Returns</b> NULL</pre>
		<pre>(sql sqlHandle {SELECT DAYNAME('2006-05-00')}) <b>Returns</b> NULL</pre>
		<ul>
			<li>
				<p>ADDDATE(date,INTERVAL expr unit), ADDDATE(expr,days)</p>
				<p>When invoked with the INTERVAL form of the second argument, ADDDATE() is a synonym for DATE_ADD().
					The related function SUBDATE() is a synonym for DATE_SUB(). For information on the INTERVAL unit argument, see the discussion for DATE_ADD().</p>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2008-01-02', INTERVAL 31 DAY)}) <b>Returns</b> '2008-02-02'</pre>
				<pre>(sql sqlHandle {SELECT ADDDATE('2008-01-02', INTERVAL 31 DAY)}) <b>Returns</b> '2008-02-02'</pre>
				<p>When invoked with the days form of the second argument, MySQL treats it as an integer number of days to be added to expr.</p>
				<pre>(sql sqlHandle {SELECT ADDDATE('2008-01-02', 31)}) <b>Returns</b> '2008-02-02'</pre>
			</li>
			<li>
				<p>ADDTIME(expr1,expr2)</p>
				<p>ADDTIME() adds expr2 to expr1 and returns the result. expr1 is a time or datetime expression, and expr2 is a time expression.</p>
				<pre>(sql sqlHandle {SELECT ADDTIME('2007-12-31 23:59:59.999999', '1 1:1:1.000002')}) <b>Returns</b> '2008-01-02 01:01:01.000001'</pre>
				<pre>(sql sqlHandle {SELECT ADDTIME('01:00:00.999999', '02:00:00.999998')}) <b>Returns</b> '03:00:01.999997'</pre>
			</li>
			<li>
				<p>CONVERT_TZ(dt,from_tz,to_tz)</p>
				<p>CONVERT_TZ() converts a datetime value dt from the time zone given by from_tz to the time zone given by to_tz and returns the resulting value.
					This function returns NULL if the arguments are invalid.</p>
				<p>If the value falls out of the supported range of the TIMESTAMP type when converted from from_tz to UTC, no conversion occurs.</p>
				<pre>(sql sqlHandle {SELECT CONVERT_TZ('2004-01-01 12:00:00','GMT','MET')}) <b>Returns</b> '2004-01-01 13:00:00'</pre>
				<pre>(sql sqlHandle {SELECT CONVERT_TZ('2004-01-01 12:00:00','+00:00','+10:00')}) <b>Returns</b> '2004-01-01 22:00:00'</pre>
				<p>Note: To use named time zones such as 'MET' or 'Europe/Moscow', the time zone tables must be properly set up.</p>
			</li>
			<li>
				<p>CURDATE()</p>
				<p>Returns the current date as a value in 'YYYY-MM-DD' or YYYYMMDD format, depending on whether the function is used in a string or numeric context.</p>
				<pre>(sql sqlHandle {SELECT CURDATE()}) <b>Returns</b> '2008-06-13'</pre>
				<pre>(sql sqlHandle {SELECT CURDATE() + 0}) <b>Returns</b> 20080613</pre>
			</li>
			<li>
				<p>CURRENT_DATE, CURRENT_DATE()</p>
				<p>CURRENT_DATE and CURRENT_DATE() are synonyms for CURDATE().</p>
			</li>
			<li>
				<p>CURTIME()</p>
				<p>Returns the current time as a value in 'HH:MM:SS' or HHMMSS.uuuuuu format, depending on whether the function is used in a string or numeric context.
					The value is expressed in the current time zone.</p>
				<pre>(sql sqlHandle {SELECT CURTIME()}) <b>Returns</b> '23:50:26'</pre>
				<pre>(sql sqlHandle {SELECT CURTIME() + 0}) <b>Returns</b> 235026.000000</pre>
			</li>
			<li>
				<p>CURRENT_TIME, CURRENT_TIME()</p>
				<p>CURRENT_TIME and CURRENT_TIME() are synonyms for CURTIME().</p>
			</li>
			<li>
				<p>CURRENT_TIMESTAMP, CURRENT_TIMESTAMP()</p>
				<p>CURRENT_TIMESTAMP and CURRENT_TIMESTAMP() are synonyms for NOW().</p>
			</li>
			<li>
				<p>DATE(expr)</p>
				<p>Extracts the date part of the date or datetime expression expr.</p>
				<pre>(sql sqlHandle {SELECT DATE('2003-12-31 01:02:03')}) <b>Returns</b> '2003-12-31'</pre>
			</li>
			<li>
				<p>DATEDIFF(expr1,expr2)</p>
				<p>DATEDIFF() returns expr1  expr2 expressed as a value in days from one date to the other.
					expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation.</p>
				<pre>(sql sqlHandle {SELECT DATEDIFF('2007-12-31 23:59:59','2007-12-30')}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT DATEDIFF('2010-11-30 23:59:59','2010-12-31')}) <b>Returns</b> -31</pre>
			</li>
			<li>
				<p>DATE_ADD(date,INTERVAL expr unit), DATE_SUB(date,INTERVAL expr unit)</p>
				<p>These functions perform date arithmetic. The date argument specifies the starting date or datetime value.
					expr is an expression specifying the interval value to be added or subtracted from the starting date.
					expr is a string; it may start with a "-" for negative intervals. unit is a keyword indicating the units in which the expression should be interpreted.</p>
				<p>The INTERVAL keyword and the unit specifier are not case sensitive.</p>
				<p>The following table shows the expected form of the expr argument for each unit value.</p>
				<table border="3">
					<tr><td>unit Value</td><td>Expected expr Format</td></tr>
					<tr><td>MICROSECOND</td><td>MICROSECONDS</td></tr>
					<tr><td>SECOND</td><td>SECONDS</td></tr>
					<tr><td>MINUTE</td><td>MINUTES</td></tr>
					<tr><td>HOUR</td><td>HOURS</td></tr>
					<tr><td>DAY</td><td>DAYS</td></tr>
					<tr><td>WEEK</td><td>WEEKS</td></tr>
					<tr><td>MONTH</td><td>MONTHS</td></tr>
					<tr><td>QUARTER</td><td>QUARTERS</td></tr>
					<tr><td>YEAR</td><td>YEARS</td></tr>
					<tr><td>SECOND_MICROSECOND</td><td>'SECONDS.MICROSECONDS'</td></tr>
					<tr><td>MINUTE_MICROSECOND</td><td>'MINUTES.MICROSECONDS'</td></tr>
					<tr><td>MINUTE_SECOND</td><td>'MINUTES:SECONDS'</td></tr>
					<tr><td>HOUR_MICROSECOND</td><td>'HOURS.MICROSECONDS'</td></tr>
					<tr><td>HOUR_SECOND</td><td>'HOURS:MINUTES:SECONDS'</td></tr>
					<tr><td>HOUR_MINUTE</td><td>'HOURS:MINUTES'</td></tr>
					<tr><td>DAY_MICROSECOND</td><td>'DAYS.MICROSECONDS'</td></tr>
					<tr><td>DAY_SECOND</td><td>'DAYS HOURS:MINUTES:SECONDS'</td></tr>
					<tr><td>DAY_MINUTE</td><td>'DAYS HOURS:MINUTES'</td></tr>
					<tr><td>DAY_HOUR</td><td>'DAYS HOURS'</td></tr>
					<tr><td>YEAR_MONTH</td><td>'YEARS-MONTHS'</td></tr>
				</table>
				<p>The return value depends on the arguments:</p>
				<p>DATETIME if the first argument is a DATETIME (or TIMESTAMP) value, or if the first argument is a DATE and the unit value uses HOURS, MINUTES, or SECONDS.</p>
				<p>String otherwise.</p>
				<p>To ensure that the result is DATETIME, you can use CAST() to convert the first argument to DATETIME.</p>
				<p>MySQL allows any punctuation delimiter in the expr format. Those shown in the table are the suggested delimiters.
					If the date argument is a DATE value and your calculations involve only YEAR, MONTH, and DAY parts (that is, no time parts), the result is a DATE value. Otherwise, the result is a DATETIME value.</p>
				<p>Date arithmetic also can be performed using INTERVAL together with the + or - operator:</p>
				<pre>date + INTERVAL expr unit</pre>
				<pre>date - INTERVAL expr unit</pre>
				<p>INTERVAL expr unit is allowed on either side of the + operator if the expression on the other side is a date or datetime value.
					For the - operator, INTERVAL expr unit is allowed only on the right side, because it makes no sense to subtract a date or datetime value from an interval.</p>
				<pre>(sql sqlHandle {SELECT '2008-12-31 23:59:59' + INTERVAL 1 SECOND}) <b>Returns</b> '2009-01-01 00:00:00'</pre>
				<pre>(sql sqlHandle {SELECT INTERVAL 1 DAY + '2008-12-31'}) <b>Returns</b> '2009-01-01'</pre>
				<pre>(sql sqlHandle {SELECT '2005-01-01' - INTERVAL 1 SECOND}) <b>Returns</b> '2004-12-31 23:59:59'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2000-12-31 23:59:59', INTERVAL 1 SECOND)}) <b>Returns</b> '2001-01-01 00:00:00'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2010-12-31 23:59:59', INTERVAL 1 DAY)}) <b>Returns</b> '2011-01-01 23:59:59'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2100-12-31 23:59:59', INTERVAL '1:1' MINUTE_SECOND)}) <b>Returns</b> '2101-01-01 00:01:00'</pre>
				<pre>(sql sqlHandle {SELECT DATE_SUB('2005-01-01 00:00:00', INTERVAL '1 1:1:1' DAY_SECOND)}) <b>Returns</b> '2004-12-30 22:58:59'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('1900-01-01 00:00:00', INTERVAL '-1 10' DAY_HOUR)}) <b>Returns</b> '1899-12-30 14:00:00'</pre>
				<pre>(sql sqlHandle {SELECT DATE_SUB('1998-01-02', INTERVAL 31 DAY)}) <b>Returns</b> '1997-12-02'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('1992-12-31 23:59:59.000002', INTERVAL '1.999999' SECOND_MICROSECOND)}) <b>Returns</b> '1993-01-01 00:00:01.000001'</pre>
				<p>If you specify an interval value that is too short (does not include all the interval parts that would be expected from the unit keyword),
					MySQL assumes that you have left out the leftmost parts of the interval value.
					For example, if you specify a unit of DAY_SECOND, the value of expr is expected to have days, hours, minutes, and seconds parts.
					If you specify a value like '1:10', MySQL assumes that the days and hours parts are missing and the value represents minutes and seconds.
					In other words, '1:10' DAY_SECOND is interpreted in such a way that it is equivalent to '1:10' MINUTE_SECOND.
					This is analogous to the way that MySQL interprets TIME values as representing elapsed time rather than as a time of day.</p>
				<p>Because expr is treated as a string, be careful if you specify a non-string value with INTERVAL.
					For example, with an interval specifier of HOUR_MINUTE, 6/4 evaluates to 1.5000 and is treated as 1 hour, 5000 minutes:</p>
				<pre>(sql sqlHandle {SELECT 6/4}) <b>Returns</b> 1.5000</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2009-01-01', INTERVAL 6/4 HOUR_MINUTE)}) <b>Returns</b> '2009-01-04 12:20:00'</pre>
				<p>To ensure interpretation of the interval value as you expect, a CAST() operation may be used.
					To treat 6/4 as 1 hour, 5 minutes, cast it to a DECIMAL value with a single fractional digit:</p>
				<pre>(sql sqlHandle {SELECT CAST(6/4 AS DECIMAL(3,1))}) <b>Returns</b> 1.5</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('1970-01-01 12:00:00', INTERVAL CAST(6/4 AS DECIMAL(3,1)) HOUR_MINUTE)}) <b>Returns</b> '1970-01-01 13:05:00'</pre>
				<p>If you add to or subtract from a date value something that contains a time part, the result is automatically converted to a datetime value:</p>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2013-01-01', INTERVAL 1 DAY)}) <b>Returns</b> '2013-01-02'</pre>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2013-01-01', INTERVAL 1 HOUR)}) <b>Returns</b> '2013-01-01 01:00:00'</pre>
				<p>If you add MONTH, YEAR_MONTH, or YEAR and the resulting date has a day that is larger than the maximum day for the new month, the day is adjusted to the maximum days in the new month:</p>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2009-01-30', INTERVAL 1 MONTH)}) <b>Returns</b> '2009-02-28'</pre>
				<p>Date arithmetic operations require complete dates and do not work with incomplete dates such as '2006-07-00' or badly malformed dates:</p>
				<pre>(sql sqlHandle {SELECT DATE_ADD('2006-07-00', INTERVAL 1 DAY)}) <b>Returns</b> NULL</pre>
				<pre>(sql sqlHandle {SELECT '2005-03-32' + INTERVAL 1 MONTH}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>DATE_FORMAT(date,format)</p>
				<p>Formats the date value according to the format string.</p>
				<p>The following specifiers may be used in the format string. The "%" character is required before format specifier characters.</p>
				<table border="3">
					<tr><td>Specifier</td><td>Description</td></tr>
					<tr><td>%a</code></td><td>Abbreviated weekday name (Sun</code>..Sat</code>)</td></tr>
					<tr><td>%b</code></td><td>Abbreviated month name (Jan</code>..Dec</code>)</td></tr>
					<tr><td>%c</code></td><td>Month, numeric (0</code>..12</code>)</td></tr>
					<tr><td>%D</code></td><td>Day of the month with English suffix (0th</code>, 1st</code>, 2nd</code>, 3rd</code>, )</td></tr>
					<tr><td>%d</code></td><td>Day of the month, numeric (00</code>..31</code>)</td></tr>
					<tr><td>%e</code></td><td>Day of the month, numeric (0</code>..31</code>)</td></tr>
					<tr><td>%f</code></td><td>Microseconds (000000</code>..999999</code>)</td></tr>
					<tr><td>%H</code></td><td>Hour (00</code>..23</code>)</td></tr>
					<tr><td>%h</code></td><td>Hour (01</code>..12</code>)</td></tr>
					<tr><td>%I</code></td><td>Hour (01</code>..12</code>)</td></tr>
					<tr><td>%i</code></td><td>Minutes, numeric (00</code>..59</code>)</td></tr>
					<tr><td>%j</code></td><td>Day of year (001</code>..366</code>)</td></tr>
					<tr><td>%k</code></td><td>Hour (0</code>..23</code>)</td></tr>
					<tr><td>%l</code></td><td>Hour (1</code>..12</code>)</td></tr>
					<tr><td>%M</code></td><td>Month name (January</code>..December</code>)</td></tr>
					<tr><td>%m</code></td><td>Month, numeric (00</code>..12</code>)</td></tr>
					<tr><td>%p</code></td><td>AM</code> or PM</code></td></tr>
					<tr><td>%r</code></td><td>Time, 12-hour (hh:mm:ss</code> followed by AM</code> or PM</code>)</td></tr>
					<tr><td>%S</code></td><td>Seconds (00</code>..59</code>)</td></tr>
					<tr><td>%s</code></td><td>Seconds (00</code>..59</code>)</td></tr>
					<tr><td>%T</code></td><td>Time, 24-hour (hh:mm:ss</code>)</td></tr>
					<tr><td>%U</code></td><td>Week (00</code>..53</code>), where Sunday is the first day of the week</td></tr>
					<tr><td>%u</code></td><td>Week (00</code>..53</code>), where Monday is the first day of the week</td></tr>
					<tr><td>%V</code></td><td>Week (01</code>..53</code>), where Sunday is the first day of the week; used with %X</code></td></tr>
					<tr><td>%v</code></td><td>Week (01</code>..53</code>), where Monday is the first day of the week; used with %x</code></td></tr>
					<tr><td>%W</code></td><td>Weekday name (Sunday</code>..Saturday</code>)</td></tr>
					<tr><td>%w</code></td><td>Day of the week (0</code>=Sunday..6</code>=Saturday)</td></tr>
					<tr><td>%X</code></td><td>Year for the week where Sunday is the first day of the week, numeric, four digits; used with %V</code></td></tr>
					<tr><td>%x</code></td><td>Year for the week, where Monday is the first day of the week, numeric, four digits; used with %v</code></td></tr>
					<tr><td>%Y</code></td><td>Year, numeric, four digits</td></tr>
					<tr><td>%y</code></td><td>Year, numeric (two digits)</td></tr>
					<tr><td>%%</code></td><td>A literal "<span class="quote">%</code>" character</td></tr>
					<tr><td>%<i>x</i></td><td><i>x</i>, for any "<i>x</i>" not listed above</td></tr>
				</table>
				<p>Ranges for the month and day specifiers begin with zero due to the fact that MySQL allows the storing of incomplete dates such as '2014-00-00'.</p>
				<p>The language used for day and month names and abbreviations is controlled by the value of the lc_time_names system variable.</p>
				<p>DATE_FORMAT() returns a string with a character set and collation given by character_set_connection and collation_connection so that it can return month and weekday names containing non-ASCII characters.</p>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('2009-10-04 22:23:00', '%W %M %Y')}) <b>Returns</b> 'Sunday October 2009'</pre>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s')}) <b>Returns</b> '22:23:00'</pre>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('1900-10-04 22:23:00', '%D %y %a %d %m %b %j')}) <b>Returns</b> '4th 00 Thu 04 10 Oct 277'</pre>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('1997-10-04 22:23:00', '%H %k %I %r %T %S %w')}) <b>Returns</b> '22 22 10 10:23:00 PM 22:23:00 00 6'</pre>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('1999-01-01', '%X %V')}) <b>Returns</b> '1998 52'</pre>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('2006-06-00', '%d')}) <b>Returns</b> '00'</pre>
			</li>
			<li>
				<p>DATE_SUB(date,INTERVAL expr unit)</p>
				<p>See the description for DATE_ADD().</p>
			</li>
			<li>
				<p>DAY(date)</p>
				<p>DAY() is a synonym for DAYOFMONTH().</p>
			</li>
			<li>
				<p>DAYNAME(date)</p>
				<p>Returns the name of the weekday for date. The language used for the name is controlled by the value of the lc_time_names system variable.</p>
				<pre>(sql sqlHandle {SELECT DAYNAME('2007-02-03')}) <b>Returns</b> 'Saturday'</pre>
			</li>
			<li>
				<p>DAYOFMONTH(date)</p>
				<p>Returns the day of the month for date, in the range 1 to 31, or 0 for dates such as '0000-00-00' or '2008-00-00' that have a zero day part.</p>
				<pre>(sql sqlHandle {SELECT DAYOFMONTH('2007-02-03')}) <b>Returns</b> 3</pre>
			</li>
			<li>
				<p>DAYOFWEEK(date)</p>
				<p>Returns the weekday index for date (1 = Sunday, 2 = Monday, , 7 = Saturday). These index values correspond to the ODBC standard.</p>
				<pre>(sql sqlHandle {SELECT DAYOFWEEK('2007-02-03')}) <b>Returns</b> 7</pre>
			</li>
			<li>
				<p>DAYOFYEAR(date)</p>
				<p>Returns the day of the year for date, in the range 1 to 366.</p>
				<pre>(sql sqlHandle {SELECT DAYOFYEAR('2007-02-03')}) <b>Returns</b> 34</pre>
			</li>
			<li>
				<p>EXTRACT(unit FROM date)</p>
				<p>The EXTRACT() function uses the same kinds of unit specifiers as DATE_ADD() or DATE_SUB(), but extracts parts from the date rather than performing date arithmetic.</p>
				<pre>(sql sqlHandle {SELECT EXTRACT(YEAR FROM '2009-07-02')}) <b>Returns</b> 2009</pre>
				<pre>(sql sqlHandle {SELECT EXTRACT(YEAR_MONTH FROM '2009-07-02 01:02:03')}) <b>Returns</b> 200907</pre>
				<pre>(sql sqlHandle {SELECT EXTRACT(DAY_MINUTE FROM '2009-07-02 01:02:03')}) <b>Returns</b> 20102</pre>
				<pre>(sql sqlHandle {SELECT EXTRACT(MICROSECOND FROM '2003-01-02 10:30:00.000123')}) <b>Returns</b> 123</pre>
			</li>
			<li>
				<p>FROM_DAYS(N)</p>
				<p>Given a day number N, returns a DATE value.</p>
				<pre>(sql sqlHandle {SELECT FROM_DAYS(730669)}) <b>Returns</b> '2007-07-03'</pre>
				<p>Use FROM_DAYS() with caution on old dates. It is not intended for use with values that precede the advent of the Gregorian calendar (1582).</p>
			</li>
			<li>
				<p>FROM_UNIXTIME(unix_timestamp), FROM_UNIXTIME(unix_timestamp,format)</p>
				<p>Returns a representation of the unix_timestamp argument as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS.uuuuuu format,
					depending on whether the function is used in a string or numeric context. The value is expressed in the current time zone.
					unix_timestamp is an internal timestamp value such as is produced by the UNIX_TIMESTAMP() function.</p>
				<p>If format is given, the result is formatted according to the format string, which is used the same way as listed in the entry for the DATE_FORMAT() function.</p>
				<pre>(sql sqlHandle {SELECT FROM_UNIXTIME(1196440219)}) <b>Returns</b> '2007-11-30 10:30:19'</pre>
				<pre>(sql sqlHandle {SELECT FROM_UNIXTIME(1196440219) + 0}) <b>Returns</b> 20071130103019.000000</pre>
				<pre>(sql sqlHandle {SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), %Y %D %M %h:%i:%s %x')}) <b>Returns</b> '2007 30th November 10:30:59 2007'</pre>
				<p>Note: If you use UNIX_TIMESTAMP() and FROM_UNIXTIME() to convert between TIMESTAMP values and Unix timestamp values,
					the conversion is lossy because the mapping is not one-to-one in both directions. For details, see the description of the UNIX_TIMESTAMP() function.</p>
			</li>
			<li>
				<p>GET_FORMAT({DATE|TIME|DATETIME}, {'EUR'|'USA'|'JIS'|'ISO'|'INTERNAL'})</p>
				<p>Returns a format string. This function is useful in combination with the DATE_FORMAT() and the STR_TO_DATE() functions.</p>
				<p>The possible values for the first and second arguments result in several possible format strings (for the specifiers used, see the table in the DATE_FORMAT() function description).
					ISO format refers to ISO 9075, not ISO 8601.</p>
				<table border="3">
					<tr><td>Function Call</td><td>Result</td></tr>
					<tr><td>GET_FORMAT(DATE,'USA')</a></td><td>'%m.%d.%Y'</td></tr>
					<tr><td>GET_FORMAT(DATE,'JIS')</a></td><td>'%Y-%m-%d'</td></tr>
					<tr><td>GET_FORMAT(DATE,'ISO')</a></td><td>'%Y-%m-%d'</td></tr>
					<tr><td>GET_FORMAT(DATE,'EUR')</a></td><td>'%d.%m.%Y'</td></tr>
					<tr><td>GET_FORMAT(DATE,'INTERNAL')</a></td><td>'%Y%m%d'</td></tr>
					<tr><td>GET_FORMAT(DATETIME,'USA')</a></td><td>'%Y-%m-%d %H.%i.%s'</td></tr>
					<tr><td>GET_FORMAT(DATETIME,'JIS')</a></td><td>'%Y-%m-%d %H:%i:%s'</td></tr>
					<tr><td>GET_FORMAT(DATETIME,'ISO')</a></td><td>'%Y-%m-%d %H:%i:%s'</td></tr>
					<tr><td>GET_FORMAT(DATETIME,'EUR')</a></td><td>'%Y-%m-%d %H.%i.%s'</td></tr>
					<tr><td>GET_FORMAT(DATETIME,'INTERNAL')</a></td><td>'%Y%m%d%H%i%s'</td></tr>
					<tr><td>GET_FORMAT(TIME,'USA')</a></td><td>'%h:%i:%s %p'</td></tr>
					<tr><td>GET_FORMAT(TIME,'JIS')</a></td><td>'%H:%i:%s'</td></tr>
					<tr><td>GET_FORMAT(TIME,'ISO')</a></td><td>'%H:%i:%s'</td></tr>
					<tr><td>GET_FORMAT(TIME,'EUR')</a></td><td>'%H.%i.%s'</td></tr>
					<tr><td>GET_FORMAT(TIME,'INTERNAL')</a></td><td>'%H%i%s'</td></tr>
				</table>
				<p>TIMESTAMP can also be used as the first argument to GET_FORMAT(), in which case the function returns the same values as for DATETIME.</p>
				<pre>(sql sqlHandle {SELECT DATE_FORMAT('2003-10-03',GET_FORMAT(DATE,'EUR'))}) <b>Returns</b> '03.10.2003'</pre>
				<pre>(sql sqlHandle {SELECT STR_TO_DATE('10.31.2003',GET_FORMAT(DATE,'USA'))}) <b>Returns</b> '2003-10-31'</pre>
			</li>
			<li>
				<p>HOUR(time)</p>
				<p>Returns the hour for time. The range of the return value is 0 to 23 for time-of-day values.
					However, the range of TIME values actually is much larger, so HOUR can return values greater than 23.</p>
				<pre>(sql sqlHandle {SELECT HOUR('10:05:03')}) <b>Returns</b> 10</pre>
				<pre>(sql sqlHandle {SELECT HOUR('272:59:59')}) <b>Returns</b> 272</pre>
			</li>
			<li>
				<p>LAST_DAY(date)</p>
				<p>Takes a date or datetime value and returns the corresponding value for the last day of the month. Returns NULL if the argument is invalid.</p>
				<pre>(sql sqlHandle {SELECT LAST_DAY('2003-02-05')}) <b>Returns</b> '2003-02-28'</pre>
				<pre>(sql sqlHandle {SELECT LAST_DAY('2004-02-05')}) <b>Returns</b> '2004-02-29'</pre>
				<pre>(sql sqlHandle {SELECT LAST_DAY('2004-01-01 01:01:01')}) <b>Returns</b> '2004-01-31'</pre>
				<pre>(sql sqlHandle {SELECT LAST_DAY('2003-03-32')}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>LOCALTIME, LOCALTIME()</p>
				<p>LOCALTIME and LOCALTIME() are synonyms for NOW().</p>
			</li>
			<li>
				<p>LOCALTIMESTAMP, LOCALTIMESTAMP()</p>
				<p>LOCALTIMESTAMP and LOCALTIMESTAMP() are synonyms for NOW().</p>
			</li>
			<li>
				<p>MAKEDATE(year,dayofyear)</p>
				<p>Returns a date, given year and day-of-year values. dayofyear must be greater than 0 or the result is NULL.</p>
				<pre>(sql sqlHandle {SELECT MAKEDATE(2011,31), MAKEDATE(2011,32)}) <b>Returns</b> '2011-01-31', '2011-02-01'</pre>
				<pre>(sql sqlHandle {SELECT MAKEDATE(2011,365), MAKEDATE(2014,365)}) <b>Returns</b> '2011-12-31', '2014-12-31'</pre>
				<pre>(sql sqlHandle {SELECT MAKEDATE(2011,0)}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>MAKETIME(hour,minute,second)</p>
				<p>Returns a time value calculated from the hour, minute, and second arguments.</p>
				<pre>(sql sqlHandle {SELECT MAKETIME(12,15,30)}) <b>Returns</b> '12:15:30'</pre>
			</li>
			<li>
				<p>MICROSECOND(expr)</p>
				<p>Returns the microseconds from the time or datetime expression expr as a number in the range from 0 to 999999.</p>
				<pre>(sql sqlHandle {SELECT MICROSECOND('12:00:00.123456')}) <b>Returns</b> 123456</pre>
				<pre>(sql sqlHandle {SELECT MICROSECOND('2009-12-31 23:59:59.000010')}) <b>Returns</b> 10</pre>
			</li>
			<li>
				<p>MINUTE(time)</p>
				<p>Returns the minute for time, in the range 0 to 59.</p>
				<pre>(sql sqlHandle {SELECT MINUTE('2008-02-03 10:05:03')}) <b>Returns</b> 5</pre>
			</li>
			<li>
				<p>MONTH(date)</p>
				<p>Returns the month for date, in the range 1 to 12 for January to December, or 0 for dates such as '0000-00-00' or '2008-00-00' that have a zero month part.</p>
				<pre>(sql sqlHandle {SELECT MONTH('2008-02-03')}) <b>Returns</b> 2</pre>
			</li>
			<li>
				<p>MONTHNAME(date)</p>
				<p>Returns the full name of the month for date. The language used for the name is controlled by the value of the lc_time_names system variable.</p>
				<pre>(sql sqlHandle {SELECT MONTHNAME('2008-02-03')}) <b>Returns</b> 'February'</pre>
			</li>
			<li>
				<p>NOW()</p>
				<p>Returns the current date and time as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS.uuuuuu format,
					depending on whether the function is used in a string or numeric context. The value is expressed in the current time zone.</p>
				<pre>(sql sqlHandle {SELECT NOW()}) <b>Returns</b> '2007-12-15 23:50:26'</pre>
				<pre>(sql sqlHandle {SELECT NOW() + 0}) <b>Returns</b> 20071215235026.000000</pre>
				<p>NOW() returns a constant time that indicates the time at which the statement began to execute.
					(Within a stored routine or trigger, NOW() returns the time at which the routine or triggering statement began to execute.)
					This differs from the behavior for SYSDATE(), which returns the exact time at which it executes.</p>
				<pre>(sql sqlHandle {SELECT NOW(), SLEEP(2), NOW()})
+---------------------+----------+---------------------+
| NOW()               | SLEEP(2) | NOW()               |
+---------------------+----------+---------------------+
| 2006-04-12 13:47:36 |        0 | 2006-04-12 13:47:36 |
+---------------------+----------+---------------------+</pre>

				<pre>(sql sqlHandle {SELECT SYSDATE(), SLEEP(2), SYSDATE()})
+---------------------+----------+---------------------+
| SYSDATE()           | SLEEP(2) | SYSDATE()           |
+---------------------+----------+---------------------+
| 2006-04-12 13:47:44 |        0 | 2006-04-12 13:47:46 |
+---------------------+----------+---------------------+</pre>
				<p>In addition, the SET TIMESTAMP statement affects the value returned by NOW() but not by SYSDATE().
					This means that timestamp settings in the binary log have no effect on invocations of SYSDATE().</p>
				<p>See the description for SYSDATE() for additional information about the differences between the two functions.</p>
			</li>
			<li>
				<p>PERIOD_ADD(P,N)</p>
				<p>Adds N months to period P (in the format YYMM or YYYYMM). Returns a value in the format YYYYMM. Note that the period argument P is not a date value.</p>
				<pre>(sql sqlHandle {SELECT PERIOD_ADD(200801,2)}) <b>Returns</b> 200803</pre>
			</li>
			<li>
				<p>PERIOD_DIFF(P1,P2)</p>
				<p>Returns the number of months between periods P1 and P2. P1 and P2 should be in the format YYMM or YYYYMM.
					Note that the period arguments P1 and P2 are not date values.</p>
				<pre>(sql sqlHandle {SELECT PERIOD_DIFF(200802,200703)}) <b>Returns</b> 11</pre>
			</li>
			<li>
				<p>QUARTER(date)</p>
				<p>Returns the quarter of the year for date, in the range 1 to 4.</p>
				<pre>(sql sqlHandle {SELECT QUARTER('2008-04-01')}) <b>Returns</b> 2</pre>
			</li>
			<li>
				<p>SECOND(time)</p>
				<p>Returns the second for time, in the range 0 to 59.</p>
				<pre>(sql sqlHandle {SELECT SECOND('10:05:03')}) <b>Returns</b> 3</pre>
			</li>
			<li>
				<p>SEC_TO_TIME(seconds)</p>
				<p>Returns the seconds argument, converted to hours, minutes, and seconds, as a TIME value.
					The range of the result is constrained to that of the TIME data type.
					A warning occurs if the argument corresponds to a value outside that range.</p>
				<pre>(sql sqlHandle {SELECT SEC_TO_TIME(2378)}) <b>Returns</b> '00:39:38'</pre>
				<pre>(sql sqlHandle {SELECT SEC_TO_TIME(2378) + 0}) <b>Returns</b> 3938</pre>
			</li>
			<li>
				<p>STR_TO_DATE(str,format)</p>
				<p>This is the inverse of the DATE_FORMAT() function. It takes a string str and a format string format.
					STR_TO_DATE() returns a DATETIME value if the format string contains both date and time parts, or a DATE or TIME value if the string contains only date or time parts.</p>
				<p>The date, time, or datetime values contained in str should be given in the format indicated by format.
					For the specifiers that can be used in format, see the DATE_FORMAT() function description.
					If str contains an illegal date, time, or datetime value, STR_TO_DATE() returns NULL. An illegal value also produces a warning.</p>
				<p>This means, for example, that "zero" dates or dates with part values of 0 are allowed unless the SQL mode is set to disallow such values.</p>
				<pre>(sql sqlHandle {SELECT STR_TO_DATE('00/00/0000', '%m/%d/%Y')}) <b>Returns</b> '0000-00-00'</pre>
				<pre>(sql sqlHandle {SELECT STR_TO_DATE('04/31/2004', '%m/%d/%Y')}) <b>Returns</b> '2004-04-31'</pre>
				<p>Note: You cannot use format "%X%V" to convert a year-week string to a date because the combination of a year and week does not uniquely identify a year and month if the week crosses a month boundary.
					To convert a year-week to a date, then you should also specify the weekday:</p>
				<pre>(sql sqlHandle {SELECT STR_TO_DATE('200442 Monday', '%X%V %W')}) <b>Returns</b> '2004-10-18'</pre>
			</li>
			<li>
				<p>SUBDATE(date,INTERVAL expr unit), SUBDATE(expr,days)</p>
				<p>When invoked with the INTERVAL form of the second argument, SUBDATE() is a synonym for DATE_SUB(). For information on the INTERVAL unit argument, see the discussion for DATE_ADD().</p>
				<pre>(sql sqlHandle {SELECT DATE_SUB('2008-01-02', INTERVAL 31 DAY)}) <b>Returns</b> '2007-12-02'</pre>
				<pre>(sql sqlHandle {SELECT SUBDATE('2008-01-02', INTERVAL 31 DAY)}) <b>Returns</b> '2007-12-02'</pre>
				<p>The second form allows the use of an integer value for days. In such cases, it is interpreted as the number of days to be subtracted from the date or datetime expression expr.</p>
				<pre>(sql sqlHandle {SELECT SUBDATE('2008-01-02 12:00:00', 31)}) <b>Returns</b> '2007-12-02 12:00:00'</pre>
			</li>
			<li>
				<p>SUBTIME(expr1,expr2)</p>
				<p>SUBTIME() returns expr1  expr2 expressed as a value in the same format as expr1. expr1 is a time or datetime expression, and expr2 is a time expression.</p>
				<pre>(sql sqlHandle {SELECT SUBTIME('2007-12-31 23:59:59.999999','1 1:1:1.000002')}) <b>Returns</b> '2007-12-30 22:58:58.999997'</pre>
				<pre>(sql sqlHandle {SELECT SUBTIME('01:00:00.999999', '02:00:00.999998')}) <b>Returns</b> '-00:59:59.999999'</pre>
			</li>
			<li>
				<p>SYSDATE()</p>
				<p>Returns the current date and time as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS.uuuuuu format, depending on whether the function is used in a string or numeric context.</p>
				<p>SYSDATE() returns the time at which it executes. This differs from the behavior for NOW(), which returns a constant time that indicates the time at which the statement began to execute.
					(Within a stored routine or trigger, NOW() returns the time at which the routine or triggering statement began to execute.)</p>
				<pre>(sql sqlHandle {SELECT NOW(), SLEEP(2), NOW()}) <b>Returns</b>
+---------------------+----------+---------------------+
| NOW()               | SLEEP(2) | NOW()               |
+---------------------+----------+---------------------+
| 2006-04-12 13:47:36 |        0 | 2006-04-12 13:47:36 |
+---------------------+----------+---------------------+</pre>
				<pre>(sql sqlHandle {SELECT SYSDATE(), SLEEP(2), SYSDATE()}) <b>Returns</b>
+---------------------+----------+---------------------+
| SYSDATE()           | SLEEP(2) | SYSDATE()           |
+---------------------+----------+---------------------+
| 2006-04-12 13:47:44 |        0 | 2006-04-12 13:47:46 |
+---------------------+----------+---------------------+</pre>
				<p>In addition, the SET TIMESTAMP statement affects the value returned by NOW() but not by SYSDATE().
					This means that timestamp settings in the binary log have no effect on invocations of SYSDATE().</p>
				<p>Because SYSDATE() can return different values even within the same statement, and is not affected by SET TIMESTAMP,
					it is non-deterministic and therefore unsafe for replication if statement-based binary logging is used.
					If that is a problem, you can use row-based logging, or start the server with the --sysdate-is-now option to cause SYSDATE() to be an alias for NOW().
					The non-deterministic nature of SYSDATE() also means that indexes cannot be used for evaluating expressions that refer to it.</p>
			</li>
			<li>
				<p>TIME(expr)</p>
				<p>Extracts the time part of the time or datetime expression expr and returns it as a string.</p>
				<pre>(sql sqlHandle {SELECT TIME('2003-12-31 01:02:03')}) <b>Returns</b> '01:02:03'</pre>
				<pre>(sql sqlHandle {SELECT TIME('2003-12-31 01:02:03.000123')}) <b>Returns</b> '01:02:03.000123'</pre>
			</li>
			<li>
				<p>TIMEDIFF(expr1,expr2)</p>
				<p>TIMEDIFF() returns expr1  expr2 expressed as a time value. expr1 and expr2 are time or date-and-time expressions, but both must be of the same type.</p>
				<pre>(sql sqlHandle {SELECT TIMEDIFF('2000:01:01 00:00:00', '2000:01:01 00:00:00.000001')}) <b>Returns</b> '-00:00:00.000001'</pre>
				<pre>(sql sqlHandle {SELECT TIMEDIFF('2008-12-31 23:59:59.000001', '2008-12-30 01:01:01.000002')}) <b>Returns</b> '46:58:57.999999'</pre>
			</li>
			<li>
				<p>TIMESTAMP(expr), TIMESTAMP(expr1,expr2)</p>
				<p>With a single argument, this function returns the date or datetime expression expr as a datetime value.
					With two arguments, it adds the time expression expr2 to the date or datetime expression expr1 and returns the result as a datetime value.</p>
				<pre>(sql sqlHandle {SELECT TIMESTAMP('2003-12-31')}) <b>Returns</b> '2003-12-31 00:00:00'</pre>
				<pre>(sql sqlHandle {SELECT TIMESTAMP('2003-12-31 12:00:00','12:00:00')}) <b>Returns</b> '2004-01-01 00:00:00'</pre>
			</li>
			<li>
				<p>TIMESTAMPADD(unit,interval,datetime_expr)</p>
				<p>Adds the integer expression interval to the date or datetime expression datetime_expr.
					The unit for interval is given by the unit argument, which should be one of the following values: FRAC_SECOND (microseconds), SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.</p>
				<p>It is possible to use MICROSECOND in place of FRAC_SECOND with this function, and FRAC_SECOND is deprecated.</p>
				<p>The unit value may be specified using one of keywords as shown, or with a prefix of SQL_TSI_. For example, DAY and SQL_TSI_DAY both are legal.</p>
				<pre>(sql sqlHandle {SELECT TIMESTAMPADD(MINUTE,1,'2003-01-02')}) <b>Returns</b> '2003-01-02 00:01:00'</pre>
				<pre>(sql sqlHandle {SELECT TIMESTAMPADD(WEEK,1,'2003-01-02')}) <b>Returns</b> '2003-01-09'</pre>
			</li>
			<li>
				<p>TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)</p>
				<p>Returns the integer difference between the date or datetime expressions datetime_expr1 and datetime_expr2.
					The unit for the result is given by the unit argument. The legal values for unit are the same as those listed in the description of the TIMESTAMPADD() function.</p>
				<pre>(sql sqlHandle {SELECT TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01')}) <b>Returns</b> 3</pre>
				<pre>(sql sqlHandle {SELECT TIMESTAMPDIFF(YEAR,'2002-05-01','2001-01-01')}) <b>Returns</b> -1</pre>
			</li>
			<li>
				<p>TIME_FORMAT(time,format)</p>
				<p>This is used like the DATE_FORMAT() function, but the format string may contain format specifiers only for hours, minutes, and seconds. Other specifiers produce a NULL value or 0.</p>
				<p>If the time value contains an hour part that is greater than 23, the %H and %k hour format specifiers produce a value larger than the usual range of 0..23.
					The other hour format specifiers produce the hour value modulo 12.</p>
				<pre>(sql sqlHandle {SELECT TIME_FORMAT('100:00:00', '%H %k %h %I %l')}) <b>Returns</b> '100 100 04 04 4'</pre>
			</li>
			<li>
				<p>TIME_TO_SEC(time)</p>
				<p>Returns the time argument, converted to seconds.</p>
				<pre>(sql sqlHandle {SELECT TIME_TO_SEC('22:23:00')}) <b>Returns</b> 80580</pre>
				<pre>(sql sqlHandle {SELECT TIME_TO_SEC('00:39:38')}) <b>Returns</b> 2378</pre>
			</li>
			<li>
				<p>TO_DAYS(date)</p>
				<p>Given a date date, returns a day number (the number of days since year 0).</p>
				<pre>(sql sqlHandle {SELECT TO_DAYS(950501)}) <b>Returns</b> 728779</pre>
				<pre>(sql sqlHandle {SELECT TO_DAYS('2007-10-07')}) <b>Returns</b> 733321</pre>
				<p>TO_DAYS() is not intended for use with values that precede the advent of the Gregorian calendar (1582),
					because it does not take into account the days that were lost when the calendar was changed.
					For dates before 1582 (and possibly a later year in other locales), results from this function are not reliable.</p>
				<p>Remember that MySQL converts two-digit year values in dates to four-digit form  For example, '2008-10-07' and '08-10-07' are seen as identical dates:</p>
				<pre>(sql sqlHandle {SELECT TO_DAYS('2008-10-07'), TO_DAYS('08-10-07')}) <b>Returns</b> 733687, 733687</pre>
			</li>
			<li>
				<p>UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)</p>
				<p>If called with no argument, returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) as an unsigned integer.
					If UNIX_TIMESTAMP() is called with a date argument, it returns the value of the argument as seconds since '1970-01-01 00:00:00' UTC.
					date may be a DATE string, a DATETIME string, a TIMESTAMP, or a number in the format YYMMDD or YYYYMMDD.
					The server interprets date as a value in the current time zone and converts it to an internal value in UTC. Clients can set their time zone.</p>
				<pre>(sql sqlHandle {SELECT UNIX_TIMESTAMP()}) <b>Returns</b> 1196440210</pre>
				<pre>(sql sqlHandle {SELECT UNIX_TIMESTAMP('2007-11-30 10:30:19')}) <b>Returns</b> 1196440219</pre>
				<p>When UNIX_TIMESTAMP() is used on a TIMESTAMP column, the function returns the internal timestamp value directly, with no implicit "string-to-Unix-timestamp" conversion.
					If you pass an out-of-range date to UNIX_TIMESTAMP(), it returns 0.</p>
				<p>Note: If you use UNIX_TIMESTAMP() and FROM_UNIXTIME() to convert between TIMESTAMP values and Unix timestamp values,
					the conversion is lossy because the mapping is not one-to-one in both directions. For example, due to conventions for local time zone changes,
					it is possible for two UNIX_TIMESTAMP() to map two TIMESTAMP values to the same Unix timestamp value. FROM_UNIXTIME() will map that value back to only one of the original TIMESTAMP values.
					Here is an example, using TIMESTAMP values in the CET time zone:</p>
				<pre>(sql sqlHandle {SELECT UNIX_TIMESTAMP('2005-03-27 03:00:00')}) <b>Returns</b>
+---------------------------------------+
| UNIX_TIMESTAMP('2005-03-27 03:00:00') |
+---------------------------------------+
|                            1111885200 |
+---------------------------------------+</pre>
				<pre>(sql sqlHandle {SELECT UNIX_TIMESTAMP('2005-03-27 02:00:00')}) <b>Returns</b>
+---------------------------------------+
| UNIX_TIMESTAMP('2005-03-27 02:00:00') |
+---------------------------------------+
|                            1111885200 |
+---------------------------------------+</pre>
				<pre>(sql sqlHandle {SELECT FROM_UNIXTIME(1111885200)}) <b>Returns</b>
+---------------------------+
| FROM_UNIXTIME(1111885200) |
+---------------------------+
| 2005-03-27 03:00:00       |
+---------------------------+</pre>
				<p>If you want to subtract UNIX_TIMESTAMP() columns, you might want to cast the result to signed integers.</p>
			</li>
			<li>
				<p>UTC_DATE, UTC_DATE()</p>
				<p>Returns the current UTC date as a value in 'YYYY-MM-DD' or YYYYMMDD format, depending on whether the function is used in a string or numeric context.</p>
				<pre>(sql sqlHandle {SELECT UTC_DATE(), UTC_DATE() + 0}) <b>Returns</b> '2003-08-14', 20030814</pre>
			</li>
			<li>
				<p>UTC_TIME, UTC_TIME()</p>
				<p>Returns the current UTC time as a value in 'HH:MM:SS' or HHMMSS.uuuuuu format, depending on whether the function is used in a string or numeric context.</p>
				<pre>(sql sqlHandle {SELECT UTC_TIME(), UTC_TIME() + 0}) <b>Returns</b> '18:07:53', 180753.000000</pre>
			</li>
			<li>
				<p>UTC_TIMESTAMP, UTC_TIMESTAMP()</p>
				<p>Returns the current UTC date and time as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS.uuuuuu format, depending on whether the function is used in a string or numeric context.</p>
				<pre>(sql sqlHandle {SELECT UTC_TIMESTAMP(), UTC_TIMESTAMP() + 0}) <b>Returns</b> '2003-08-14 18:08:04', 20030814180804.000000</pre>
			</li>
			<li>
				<p>WEEK(date[,mode])</p>
				<p>This function returns the week number for date. The two-argument form of WEEK() allows you to specify whether the week starts on Sunday or Monday and whether the return value should be in the range from 0 to 53 or from 1 to 53.
					If the mode argument is omitted, the value of the default_week_format system variable is used.</p>
				<p>The following table describes how the mode argument works.</p>
				
				<table border="3">
					<tr><td>Mode</td><td>First day of week</td><td>Range</td><td>Week 1 is the first week ...</td></tr>
					<tr><td>0</td><td>Sunday</td><td>0-53</td><td>with a Sunday in this year</td></tr>
					<tr><td>1</td><td>Monday</td><td>0-53</td><td>with more than 3 days this year</td></tr>
					<tr><td>2</td><td>Sunday</td><td>1-53</td><td>with a Sunday in this year</td></tr>
					<tr><td>3</td><td>Monday</td><td>1-53</td><td>with more than 3 days this year</td></tr>
					<tr><td>4</td><td>Sunday</td><td>0-53</td><td>with more than 3 days this year</td></tr>
					<tr><td>5</td><td>Monday</td><td>0-53</td><td>with a Monday in this year</td></tr>
					<tr><td>6</td><td>Sunday</td><td>1-53</td><td>with more than 3 days this year</td></tr>
					<tr><td>7</td><td>Monday</td><td>1-53</td><td>with a Monday in this year</td></tr>
				</table>
				<pre>(sql sqlHandle {SELECT WEEK('2008-02-20')}) <b>Returns</b> 7</pre>
				<pre>(sql sqlHandle {SELECT WEEK('2008-02-20',0)}) <b>Returns</b> 7</pre>
				<pre>(sql sqlHandle {SELECT WEEK('2008-02-20',1)}) <b>Returns</b> 8</pre>
				<pre>(sql sqlHandle {SELECT WEEK('2008-12-31',1)}) <b>Returns</b> 53</pre>
				<p>Note that if a date falls in the last week of the previous year, MySQL returns 0 if you do not use 2, 3, 6, or 7 as the optional mode argument:</p>
				<pre>(sql sqlHandle {SELECT YEAR('2000-01-01'), WEEK('2000-01-01',0)}) <b>Returns</b> 2000, 0</pre>
				<p>One might argue that MySQL should return 52 for the WEEK() function, because the given date actually occurs in the 52nd week of 1999.
					We decided to return 0 instead because we want the function to return "the week number in the given year."
					This makes use of the WEEK() function reliable when combined with other functions that extract a date part from a date.</p>
				<p>If you would prefer the result to be evaluated with respect to the year that contains the first day of the week for the given date, use 0, 2, 5, or 7 as the optional mode argument.</p>
				<pre>(sql sqlHandle {SELECT WEEK('2000-01-01',2)}) <b>Returns</b> 52</pre>
				<p>Alternatively, use the YEARWEEK() function:</p>
				<pre>(sql sqlHandle {SELECT YEARWEEK('2000-01-01')}) <b>Returns</b> 199952</pre>
				<pre>(sql sqlHandle {SELECT MID(YEARWEEK('2000-01-01'),5,2)}) <b>Returns</b> '52'</pre>
			</li>
			<li>
				<p>WEEKDAY(date)</p>
				<p>Returns the weekday index for date (0 = Monday, 1 = Tuesday,  6 = Sunday).</p>
				<pre>(sql sqlHandle {SELECT WEEKDAY('2008-02-03 22:23:00')}) <b>Returns</b> 6</pre>
				<pre>(sql sqlHandle {SELECT WEEKDAY('2007-11-06')}) <b>Returns</b> 1</pre>
			</li>
			<li>
				<p>WEEKOFYEAR(date)</p>
				<p>Returns the calendar week of the date as a number in the range from 1 to 53. WEEKOFYEAR() is a compatibility function that is equivalent to WEEK(date,3).</p>
				<pre>(sql sqlHandle {SELECT WEEKOFYEAR('2008-02-20')}) <b>Returns</b> 8</pre>
			</li>
			<li>
				<p>YEAR(date)</p>
				<p>Returns the year for date, in the range 1000 to 9999, or 0 for the "zero" date.</p>
				<pre>(sql sqlHandle {SELECT YEAR('1987-01-01')}) <b>Returns</b> 1987</pre>
			</li>
			<li>
				<p>YEARWEEK(date), YEARWEEK(date,mode)</p>
				<p>Returns year and week for a date. The mode argument works exactly like the mode argument to WEEK().
					The year in the result may be different from the year in the date argument for the first and the last week of the year.</p>
				<pre>(sql sqlHandle {SELECT YEARWEEK('1987-01-01')}) <b>Returns</b> 198653</pre>
				<p>Note that the week number is different from what the WEEK() function would return (0) for optional arguments 0 or 1, as WEEK() then returns the week in the context of the given year.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCast Functions and Operators"></A>Cast Functions and Operators</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>BINARY</td><td>Cast a string to a binary string</td></tr>
			<tr><td>CAST()</td><td>Cast a value as a certain type</td></tr>
			<tr><td>Convert()</td><td>Cast a value as a certain type</td></tr>
		</table>
		<ul>
			<li>
				<p>BINARY</p>
				<p>The BINARY operator casts the string following it to a binary string.
					This is an easy way to force a column comparison to be done byte by byte rather than character by character.
					This causes the comparison to be case sensitive even if the column isn't defined as BINARY or BLOB. BINARY also causes trailing spaces to be significant.</p>
				<pre>(sql sqlHandle {SELECT 'a' = 'A'}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT BINARY 'a' = 'A'}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 'a' = 'a '}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT BINARY 'a' = 'a '}) <b>Returns</b> 0</pre>
				<p>In a comparison, BINARY affects the entire operation; it can be given before either operand with the same result.</p>
				<p>BINARY str is shorthand for CAST(str AS BINARY).</p>
				<p>Note that in some contexts, if you cast an indexed column to BINARY, MySQL is not able to use the index efficiently.</p>
			</li>
			<li>
				<p>CAST(expr AS type)</p>
				<p>The CAST() function takes a value of one type and produce a value of another type, similar to CONVERT(). See the description of CONVERT() for more information.</p>
			</li>
			<li>
				<p>CONVERT(expr,type), CONVERT(expr USING transcoding_name)</p>
				<p>The CONVERT() and CAST() functions take a value of one type and produce a value of another type.</p>
				<p>The type can be one of the following values:</p>
				<ul>
					<li><p>BINARY[(N)]</p></li>
					<li><p>CHAR[(N)]</p></li>
					<li><p>DATE</p></li>
					<li><p>DATETIME</p></li>
					<li><p>DECIMAL[(M[,D])]</p></li>
					<li><p>SIGNED [INTEGER]</p></li>
					<li><p>TIME</p></li>
					<li><p>UNSIGNED [INTEGER]</p></li>
				</ul>
				<p>BINARY produces a string with the BINARY data type.
					If the optional length N is given, BINARY(N) causes the cast to use no more than N bytes of the argument. Values shorter than N bytes are padded with 0x00 bytes to a length of N.</p>
				<p>CHAR(N) causes the cast to use no more than N characters of the argument.</p>
				<p>CAST() and CONVERT(... USING ...) are standard SQL syntax. The non-USING form of CONVERT() is ODBC syntax.</p>
				<p>CONVERT() with USING is used to convert data between different character sets. In MySQL, transcoding names are the same as the corresponding character set names.
					For example, this statement converts the string 'abc' in the default character set to the corresponding string in the utf8 character set:</p>
				<pre>(sql sqlHandle {SELECT CONVERT('abc' USING utf8)})</pre>
			</li>
		</ul>
		<p>Normally, you cannot compare a BLOB value or other binary string in case-insensitive fashion because binary strings have no character set, and thus no concept of lettercase.
			To perform a case-insensitive comparison, use the CONVERT() function to convert the value to a non-binary string.
			If the character set of the result has a case-insensitive collation, the LIKE operation is not case sensitive:</p>
		<pre>(sql sqlHandle {SELECT 'A' LIKE CONVERT(blob_col USING latin1) FROM tbl_name})</pre>
		<p>To use a different character set, substitute its name for latin1 in the preceding statement.
			To ensure that a case-insensitive collation is used, specify a COLLATE clause following the CONVERT() call.</p>
		<p>CONVERT() can be used more generally for comparing strings that are represented in different character sets.</p>
		<p>The cast functions are useful when you want to create a column with a specific type in a CREATE ... SELECT statement:</p>
		<pre>(sql sqlHandle {CREATE TABLE new_table SELECT CAST('2000-01-01' AS DATE)})</pre>
		<p>The functions also can be useful for sorting ENUM columns in lexical order.
			Normally, sorting of ENUM columns occurs using the internal numeric values. Casting the values to CHAR results in a lexical sort:</p>
		<pre>(sql sqlHandle {SELECT enum_col FROM tbl_name ORDER BY CAST(enum_col AS CHAR)})</pre>
		<p>CAST(str AS BINARY) is the same thing as BINARY str. CAST(expr AS CHAR) treats the expression as a string with the default character set.</p>
		<p>CAST() also changes the result if you use it as part of a more complex expression such as CONCAT('Date: ',CAST(NOW() AS DATE)).</p>
		<p>You should not use CAST() to extract data in different formats but instead use string functions like LEFT() or EXTRACT().</p>
		<p>To cast a string to a numeric value in numeric context, you normally do not have to do anything other than to use the string value as though it were a number:</p>
		<pre>(sql sqlHandle {SELECT 1+'1'}) <b>Returns</b> 2</pre>
		<p>If you use a number in string context, the number automatically is converted to a BINARY string.</p>
		<pre>(sql sqlHandle {SELECT CONCAT('hello you ',2)}) <b>Returns</b> 'hello you 2'</pre>
		<p>MySQL supports arithmetic with both signed and unsigned 64-bit values.
			If you are using numeric operators (such as + or -) and one of the operands is an unsigned integer, the result is unsigned.
			You can override this by using the SIGNED and UNSIGNED cast operators to cast the operation to a signed or unsigned 64-bit integer, respectively.</p>
		<pre>(sql sqlHandle {SELECT CAST(1-2 AS UNSIGNED)}) <b>Returns</b> 18446744073709551615</pre>
		<pre>(sql sqlHandle {SELECT CAST(CAST(1-2 AS UNSIGNED) AS SIGNED)}) <b>Returns</b> -1</pre>
		<p>Note that if either operand is a floating-point value, the result is a floating-point value and is not affected by the preceding rule.
			(In this context, DECIMAL column values are regarded as floating-point values.)</p>
		<pre>(sql sqlHandle {SELECT CAST(1 AS UNSIGNED) - 2.0}) <b>Returns</b> -1.0</pre>
		<p>If you are using a string in an arithmetic operation, this is converted to a floating-point number.</p>
		<p>If you convert a "zero" date string to a date, CONVERT() and CAST() return NULL and produce a warning when the NO_ZERO_DATE SQL mode is enabled.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SOther Functions"></A>Other Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>AES_DECRYPT()</td><td>Decrypt using AES</td></tr>
			<tr><td>AES_ENCRYPT()</td><td>Encrypt using AES</td></tr>
			<tr><td>BENCHMARK()</td><td>Repeatedly execute an expression</td></tr>
			<tr><td>BIT_COUNT()</td><td>Return the number of bits that are set</td></tr>
			<tr><td>&amp;</td><td>Bitwise AND</td></tr>
			<tr><td>~</td><td>Invert bits</td></tr>
			<tr><td>|</td><td>Bitwise OR</td></tr>
			<tr><td>^</td><td>Bitwise XOR</td></tr>
			<tr><td>CHARSET()</td><td>Return the character set of the argument</td></tr>
			<tr><td>COERCIBILITY()</td><td>Return the collation coercibility value of the string argument</td></tr>
			<tr><td>COLLATION()</td><td>Return the collation of the string argument</td></tr>
			<tr><td>COMPRESS()</td><td>Return result as a binary string</td></tr>
			<tr><td>CONNECTION_ID()</td><td>Return the connection ID (thread ID) for the connection</td></tr>
			<tr><td>CURRENT_USER(), CURRENT_USER</td><td>Return the username and hostname combination</td></tr>
			<tr><td>DATABASE()</td><td>Return the default (current) database name</td></tr>
			<tr><td>DECODE()</td><td>Decodes a string encrypted using ENCODE()</td></tr>
			<tr><td>DEFAULT()</td><td>Return the default value for a table column</td></tr>
			<tr><td>DES_DECRYPT()</td><td>Decrypt a string</td></tr>
			<tr><td>DES_ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>ENCODE()</td><td>Encode a string</td></tr>
			<tr><td>ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>FOUND_ROWS()</td><td>For a SELECT with a LIMIT clause, the number of rows that would be returned were there no LIMIT clause</td></tr>
			<tr><td>GET_LOCK()</td><td>Get a named lock</td></tr>
			<tr><td>INET_ATON()</td><td>Return the numeric value of an IP address</td></tr>
			<tr><td>INET_NTOA()</td><td>Return the IP address from a numeric value</td></tr>
			<tr><td>IS_FREE_LOCK()</td><td>Checks whether the named lock  is free</td></tr>
			<tr><td>IS_USED_LOCK()</td><td>Checks whether the named lock is in use. Return connection identifier if true.</td></tr>
			<tr><td>LAST_INSERT_ID()</td><td>Value of the AUTOINCREMENT column for the last INSERT</td></tr>
			<tr><td>&lt;&lt;</td><td>Left shift</td></tr>
			<tr><td>MASTER_POS_WAIT()</td><td>Block until the slave has read and  applied all updates up to the specified position</td></tr>
			<tr><td>MD5()</td><td>Calculate MD5 checksum</td></tr>
			<tr><td>NAME_CONST()</td><td>Causes the column to have the given name</td></tr>
			<tr><td>OLD_PASSWORD()</td><td>Return the value of the old implementation of PASSWORD</td></tr>
			<tr><td>PASSWORD()</td><td>Calculate and return a password string</td></tr>
			<tr><td>RAND()</td><td>Return a random floating-point value</td></tr>
			<tr><td>RELEASE_LOCK()</td><td>Releases the named lock</td></tr>
			<tr><td>&gt;&gt;</td><td>Right shift</td></tr>
			<tr><td>ROW_COUNT()</td><td>The number of rows  updated</td></tr>
			<tr><td>SCHEMA()</td><td>A synonym for DATABASE()</td></tr>
			<tr><td>SESSION_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>SHA1(), SHA()</td><td>Calculate an SHA-1 160-bit checksum</td></tr>
			<tr><td>SLEEP()</td><td>Sleep for a number of seconds</td></tr>
			<tr><td>SYSTEM_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>UNCOMPRESS()</td><td>Uncompress a string compressed</td></tr>
			<tr><td>UNCOMPRESSED_LENGTH()</td><td>Return the length of a string before compression</td></tr>
			<tr><td>USER()</td><td>Return the current username and hostname</td></tr>
			<tr><td>UUID_SHORT()</td><td>Return an integer-valued universal identifier</td></tr>
			<tr><td>UUID()</td><td>Return a Universal Unique Identifier (UUID)</td></tr>
			<tr><td>VALUES()</td><td>Defines the values to be used during an INSERT</td></tr>
			<tr><td>VERSION()</td><td>Returns a string that indicates the MySQL server version</td></tr>
		</table>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SBit Functions"></A>Bit Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>BIT_COUNT()</td><td>Return the number of bits that are set</td></tr>
			<tr><td>&amp;</td><td>Bitwise AND</td></tr>
			<tr><td>~</td><td>Invert bits</td></tr>
			<tr><td>|</td><td>Bitwise OR</td></tr>
			<tr><td>^</td><td>Bitwise XOR</td></tr>
			<tr><td>&lt;&lt;</td><td>Left shift</td></tr>
			<tr><td>&gt;&gt;</td><td>Right shift</td></tr>
		</table>
		<p>MySQL uses BIGINT (64-bit) arithmetic for bit operations, so these operators have a maximum range of 64 bits.</p>
		<ul>
			<li>
				<p>|</p>
				<p>Bitwise OR:</p>
				<pre>(sql sqlHandle {SELECT 29 | 15}) <b>Returns</b> 31</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p>&</p>
				<p>Bitwise AND:</p>
				<pre>(sql sqlHandle {SELECT 29 & 15}) <b>Returns</b> 13</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p>^</p>
				<p>Bitwise XOR:</p>
				<pre>(sql sqlHandle {SELECT 1 ^ 1}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT 1 ^ 0}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT 11 ^ 3}) <b>Returns</b> 8</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p><<</p>
				<p>Shifts a longlong (BIGINT) number to the left.</p>
				<pre>(sql sqlHandle {SELECT 1 << 2}) <b>Returns</b> 4</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p>>></p>
				<p>Shifts a longlong (BIGINT) number to the right.</p>
				<pre>(sql sqlHandle {SELECT 4 >> 2}) <b>Returns</b> 1</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p>~</p>
				<p>Invert all bits.</p>
				<pre>(sql sqlHandle {SELECT 5 & ~1}) <b>Returns</b> 4</pre>
				<p>The result is an unsigned 64-bit integer.</p>
			</li>
			<li>
				<p>BIT_COUNT(N)</p>
				<p>Returns the number of bits that are set in the argument N.</p>
				<pre>(sql sqlHandle {SELECT BIT_COUNT(29), BIT_COUNT(b'101010')}) <b>Returns</b> 4, 3</pre>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SEncryption and Compression Functions"></A>Encryption and Compression Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>AES_DECRYPT()</td><td>Decrypt using AES</td></tr>
			<tr><td>AES_ENCRYPT()</td><td>Encrypt using AES</td></tr>
			<tr><td>COMPRESS()</td><td>Return result as a binary string</td></tr>
			<tr><td>DECODE()</td><td>Decodes a string encrypted using ENCODE()</td></tr>
			<tr><td>DES_DECRYPT()</td><td>Decrypt a string</td></tr>
			<tr><td>DES_ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>ENCODE()</td><td>Encode a string</td></tr>
			<tr><td>ENCRYPT()</td><td>Encrypt a string</td></tr>
			<tr><td>MD5()</td><td>Calculate MD5 checksum</td></tr>
			<tr><td>OLD_PASSWORD()</td><td>Return the value of the old implementation of PASSWORD</td></tr>
			<tr><td>PASSWORD()</td><td>Calculate and return a password string</td></tr>
			<tr><td>SHA1()</code>, SHA()</td><td>Calculate an SHA-1 160-bit checksum</td></tr>
			<tr><td>UNCOMPRESS()</td><td>Uncompress a string compressed</td></tr>
			<tr><td>UNCOMPRESSED_LENGTH()</td><td>Return the length of a string before compression</td></tr>
		</table>
		<p>Note: The encryption and compression functions return binary strings. For many of these functions, the result might contain arbitrary byte values.
			If you want to store these results, use a column with a VARBINARY or BLOB binary string data type.
			This will avoid potential problems with trailing space removal or character set conversion that would change data values,
			such as may occur if you use a non-binary string data type (CHAR, VARCHAR, TEXT).</p>
		<p>Note: Exploits for the MD5 and SHA-1 algorithms have become known. You may wish to consider using one of the other encryption functions described in this section instead.</p>
		<ul>
			<li>
				<p>AES_DECRYPT(crypt_str,key_str)</p>
				<p>This function allows decryption of data using the official AES (Advanced Encryption Standard) algorithm. For more information, see the description of AES_ENCRYPT().</p>
			</li>
			<li>
				<p>AES_ENCRYPT(str,key_str)</p>
				<p>AES_ENCRYPT() and AES_DECRYPT() allow encryption and decryption of data using the official AES (Advanced Encryption Standard) algorithm, previously known as "Rijndael."
					Encoding with a 128-bit key length is used, but you can extend it up to 256 bits by modifying the source. We chose 128 bits because it is much faster and it is secure enough for most purposes.</p>
				<p>AES_ENCRYPT() encrypts a string and returns a binary string. AES_DECRYPT() decrypts the encrypted string and returns the original string.
					The input arguments may be any length. If either argument is NULL, the result of this function is also NULL.</p>
				<p>Because AES is a block-level algorithm, padding is used to encode uneven length strings and so the result string length may be calculated using this formula:</p>
				<pre>16  (trunc(string_length / 16) + 1)</pre>
				<p>If AES_DECRYPT() detects invalid data or incorrect padding, it returns NULL.
					However, it is possible for AES_DECRYPT() to return a non-NULL value (possibly garbage) if the input data or the key is invalid.</p>
				<p>You can use the AES functions to store data in an encrypted form by modifying your queries:</p>
				<pre>INSERT INTO t VALUES (1,AES_ENCRYPT('text','password'));</pre>
				<p>AES_ENCRYPT() and AES_DECRYPT() can be considered the most cryptographically secure encryption functions currently available in MySQL.</p>
			</li>
			<li>
				<p>COMPRESS(string_to_compress)</p>
				<p>Compresses a string and returns the result as a binary string. This function requires MySQL to have been compiled with a compression library such as zlib.
					Otherwise, the return value is always NULL. The compressed string can be uncompressed with UNCOMPRESS().</p>
				<pre>(sql sqlHandle {SELECT LENGTH(COMPRESS(REPEAT('a',1000)))}) <b>Returns</b> 21</pre>
				<pre>(sql sqlHandle {SELECT LENGTH(COMPRESS(''))}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT LENGTH(COMPRESS('a'))}) <b>Returns</b> 13</pre>
				<pre>(sql sqlHandle {SELECT LENGTH(COMPRESS(REPEAT('a',16)))}) <b>Returns</b> 15</pre>
				<p>The compressed string contents are stored the following way:</p>
				<p>Empty strings are stored as empty strings.</p>
				<p>Non-empty strings are stored as a four-byte length of the uncompressed string (low byte first), followed by the compressed string.
					If the string ends with space, an extra "." character is added to avoid problems with endspace trimming should the result be stored in a CHAR or VARCHAR column.
					(However, use of non-binary string data types such as CHAR or VARCHAR to store compressed strings is not recommended anyway because character set conversion may occur.
					Use a VARBINARY or BLOB binary string column instead.)</p>
			</li>
			<li>
				<p>DECODE(crypt_str,pass_str)</p>
				<p>Decrypts the encrypted string crypt_str using pass_str as the password. crypt_str should be a string returned from ENCODE().</p>
			</li>
			<li>
				<p>ENCODE(str,pass_str)</p>
				<p>Encrypt str using pass_str as the password. To decrypt the result, use DECODE().</p>
				<p>The result is a binary string of the same length as str.</p>
				<p>The strength of the encryption is based on how good the random generator is. It should suffice for short strings.</p>
			</li>
			<li>
				<p>DES_DECRYPT(crypt_str[,key_str])</p>
				<p>Decrypts a string encrypted with DES_ENCRYPT(). If an error occurs, this function returns NULL.</p>
				<p>This function works only if MySQL has been configured with SSL support.</p>
				<p>If no key_str argument is given, DES_DECRYPT() examines the first byte of the encrypted string to determine the DES key number that was used to encrypt the original string,
					and then reads the key from the DES key file to decrypt the message. For this to work, the user must have the SUPER privilege. The key file can be specified with the --des-key-file server option.</p>
				<p>If you pass this function a key_str argument, that string is used as the key for decrypting the message.</p>
				<p>If the crypt_str argument does not appear to be an encrypted string, MySQL returns the given crypt_str.</p>
			</li>
			<li>
				<p>DES_ENCRYPT(str[,{key_num|key_str}])</p>
				<p>Encrypts the string with the given key using the Triple-DES algorithm.</p>
				<p>This function works only if MySQL has been configured with SSL support.</p>
				<p>The encryption key to use is chosen based on the second argument to DES_ENCRYPT(), if one was given.
					With no argument, the first key from the DES key file is used. With a key_num argument,
					the given key number (0-9) from the DES key file is used. With a key_str argument, the given key string is used to encrypt str.</p>
				<p>The key file can be specified with the --des-key-file server option.</p>
				<p>The return string is a binary string where the first character is CHAR(128 | key_num). If an error occurs, DES_ENCRYPT() returns NULL.</p>
				<p>The 128 is added to make it easier to recognize an encrypted key. If you use a string key, key_num is 127.</p>
				<p>The string length for the result is given by this formula:</p>
				<pre>new_len = orig_len + (8 - (orig_len % 8)) + 1</pre>
				<p>Each line in the DES key file has the following format:</p>
				<pre>key_num des_key_str</pre>
				<p>Each key_num value must be a number in the range from 0 to 9. Lines in the file may be in any order.
					des_key_str is the string that is used to encrypt the message. There should be at least one space between the number and the key.
					The first key is the default key that is used if you do not specify any key argument to DES_ENCRYPT().</p>
				<p>You can tell MySQL to read new key values from the key file with the FLUSH DES_KEY_FILE statement. This requires the RELOAD privilege.</p>
				<p>One benefit of having a set of default keys is that it gives applications a way to check for the existence of encrypted column values,
					without giving the end user the right to decrypt those values.</p>
				<pre>(sql sqlHandle {SELECT customer_address FROM customer_table > WHERE crypted_credit_card = DES_ENCRYPT('credit_card_number')}) </pre>
			</li>
			<li>
				<p>ENCRYPT(str[,salt])</p>
				<p>Encrypts str using the Unix crypt() system call and returns a binary string. The salt argument should be a string with at least two characters.
					If no salt argument is given, a random value is used.</p>
				<p><pre>(sql sqlHandle {SELECT ENCRYPT('hello')}) <b>Returns</b> 'VxuFAJXVARROc'</pre>
				<p>ENCRYPT() ignores all but the first eight characters of str, at least on some systems. This behavior is determined by the implementation of the underlying crypt() system call.</p>
				<p>The use of ENCRYPT() with multi-byte character sets other than utf8 is not recommended because the system call expects a string terminated by a zero byte.</p>
				<p>If crypt() is not available on your system (as is the case with Windows), ENCRYPT() always returns NULL.</p>
			</li>
			<li>
				<p>MD5(str)</p>
				<p>Calculates an MD5 128-bit checksum for the string. The value is returned as a binary string of 32 hex digits,
					or NULL if the argument was NULL. The return value can, for example, be used as a hash key.</p>
				<pre>(sql sqlHandle {SELECT MD5('testing')}) <b>Returns</b> 'ae2b1fca515949e5d54fb22b8ed95575'</pre>
				<p>This is the "RSA Data Security, Inc. MD5 Message-Digest Algorithm."</p>
				<p>See the note regarding the MD5 algorithm at the beginning this section.</p>
			</li>
			<li>
				<p>OLD_PASSWORD(str)</p>
				<p>OLD_PASSWORD() was added to MySQL when the implementation of PASSWORD() was changed to improve security.
					OLD_PASSWORD() returns the value of the old (pre-4.1) implementation of PASSWORD() as a binary string,
					and is intended to permit you to reset passwords for any pre-4.1 clients that need to connect to your version 5.1 MySQL server without locking them out.</p>
			</li>
			<li>
				<p>PASSWORD(str)</p>
				<p>Calculates and returns a password string from the plaintext password str and returns a binary string, or NULL if the argument was NULL.
					This is the function that is used for encrypting MySQL passwords for storage in the Password column of the user grant table.</p>
				<pre>(sql sqlHandle {SELECT PASSWORD('badpwd')}) <b>Returns</b> '*AAB3E285149C0135D51A520E1940DD3263DC008C'</pre>
				<p>PASSWORD() encryption is one-way (not reversible).</p>
				<p>PASSWORD() does not perform password encryption in the same way that Unix passwords are encrypted. See ENCRYPT().</p>
				<p>Note: The PASSWORD() function is used by the authentication system in MySQL Server; you should not use it in your own applications.
					For that purpose, consider MD5() or SHA1() instead. Also see RFC 2195, section 2 (Challenge-Response Authentication Mechanism (CRAM)),
					for more information about handling passwords and authentication securely in your applications.</p>
			</li>
			<li>
				<p>SHA1(str), SHA(str)</p>
				<p>Calculates an SHA-1 160-bit checksum for the string, as described in RFC 3174 (Secure Hash Algorithm).
					The value is returned as a binary string of 40 hex digits, or NULL if the argument was NULL.
					One of the possible uses for this function is as a hash key. You can also use it as a cryptographic function for storing passwords. SHA() is synonymous with SHA1().</p>
				<pre>(sql sqlHandle {SELECT SHA1('abc')}) <b>Returns</b> 'a9993e364706816aba3e25717850c26c9cd0d89d'</pre>
				<p>SHA1() can be considered a cryptographically more secure equivalent of MD5(). However, see the note regarding the MD5 and SHA-1 algorithms at the beginning this section.</p>
			</li>
			<li>
				<p>UNCOMPRESS(string_to_uncompress)</p>
				<p>Uncompresses a string compressed by the COMPRESS() function. If the argument is not a compressed value, the result is NULL.
					This function requires MySQL to have been compiled with a compression library such as zlib. Otherwise, the return value is always NULL.</p>
				<pre>(sql sqlHandle {SELECT UNCOMPRESS(COMPRESS('any string'))}) <b>Returns</b> 'any string'</pre>
				<pre>(sql sqlHandle {SELECT UNCOMPRESS('any string')}) <b>Returns</b> NULL</pre>
			</li>
			<li>
				<p>UNCOMPRESSED_LENGTH(compressed_string)</p>
				<p>Returns the length that the compressed string had before being compressed.</p>
				<pre>(sql sqlHandle {SELECT UNCOMPRESSED_LENGTH(COMPRESS(REPEAT('a',30)))}) <b>Returns</b> 30</pre>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SInformation Functions"></A>Information Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>BENCHMARK()</td><td>Repeatedly execute an expression</td></tr>
			<tr><td>CHARSET()</td><td>Return the character set of the argument</td></tr>
			<tr><td>COERCIBILITY()</td><td>Return the collation coercibility value of the string  argument</td></tr>
			<tr><td>COLLATION()</td><td>Return the collation of the string argument</td></tr>
			<tr><td>CONNECTION_ID()</td><td>Return the connection ID (thread ID) for the connection</td></tr>
			<tr><td>CURRENT_USER(), CURRENT_USER</td><td>Return the username and hostname combination</td></tr>
			<tr><td>DATABASE()</td><td>Return the default (current) database name</td></tr>
			<tr><td>FOUND_ROWS()</td><td>For a SELECT with a LIMIT clause, the number of rows that would be returned were there no LIMIT clause</td></tr>
			<tr><td>LAST_INSERT_ID()</td><td>Value of the AUTOINCREMENT column for the last INSERT</td></tr>
			<tr><td>ROW_COUNT()</td><td>The number of rows  updated</td></tr>
			<tr><td>SCHEMA()</td><td>A synonym for DATABASE()</td></tr>
			<tr><td>SESSION_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>SYSTEM_USER()</td><td>Synonym for USER()</td></tr>
			<tr><td>USER()</td><td>Return the current username and hostname</td></tr>
			<tr><td>VERSION()</td><td>Returns a string that indicates the MySQL server version</td></tr>
		</table>
		<ul>
			<li>
				<p>BENCHMARK(count,expr)</p>
				<p>The BENCHMARK() function executes the expression expr repeatedly count times. It may be used to time how quickly MySQL processes the expression.
					The result value is always 0. The intended use is from within the mysql client, which reports query execution times:</p>
				<pre>(sql sqlHandle {SELECT BENCHMARK(1000000,ENCODE('hello','goodbye'))}) <b>Returns</b>
+----------------------------------------------+
| BENCHMARK(1000000,ENCODE('hello','goodbye')) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+</pre>
				<p>The time reported is elapsed time on the client end, not CPU time on the server end.
					It is advisable to execute BENCHMARK() several times, and to interpret the result with regard to how heavily loaded the server machine is.</p>
				<p>BENCHMARK() is intended for measuring the runtime performance of scalar expressions,
					which has some significant implications for the way that you use it and interpret the results:</p>
				<p>Only scalar expressions can be used. Although the expression can be a subquery, it must return a single column and at most a single row.
					For example, BENCHMARK(10, (SELECT * FROM t)) will fail if the table t has more than one column or more than one row.</p>
				<p>Executing a SELECT expr statement N times differs from executing SELECT BENCHMARK(N, expr) in terms of the amount of overhead involved.
					The two have very different execution profiles and you should not expect them to take the same amount of time.
					The former involves the parser, optimizer, table locking, and runtime evaluation N times each.
					The latter involves only runtime evaluation N times, and all the other components just once.
					Memory structures already allocated are reused, and runtime optimizations such as local caching of results already evaluated for aggregate functions can alter the results.
					Use of BENCHMARK() thus measures performance of the runtime component by giving more weight to that component and removing the "noise" introduced by the network, parser, optimizer, and so forth.</p>
			</li>
			<li>
				<p>CHARSET(str)</p>
				<p>Returns the character set of the string argument.</p>
				<pre>(sql sqlHandle {SELECT CHARSET('abc')}) <b>Returns</b> 'latin1'</pre>
				<pre>(sql sqlHandle {SELECT CHARSET(CONVERT('abc' USING utf8))}) <b>Returns</b> 'utf8'</pre>
				<pre>(sql sqlHandle {SELECT CHARSET(USER())}) <b>Returns</b> 'utf8'</pre>
			</li>
			<li>
				<p>COERCIBILITY(str)</p>
				<p>Returns the collation coercibility value of the string argument.</p>
				<pre>(sql sqlHandle {SELECT COERCIBILITY('abc' COLLATE latin1_swedish_ci)}) <b>Returns</b> 0</pre>
				<pre>(sql sqlHandle {SELECT COERCIBILITY(USER())}) <b>Returns</b> 3</pre>
				<pre>(sql sqlHandle {SELECT COERCIBILITY('abc')}) <b>Returns</b> 4</pre>
				<p>The return values have the meanings shown in the following table. Lower values have higher precedence.</p>
				<table border="3">
					<tr><td>Coercibility</td><td>Meaning</td><td>Example</td></tr>
					<tr><td>0</td><td>Explicit collation</td><td>Value with COLLATE clause</td></tr>
					<tr><td>1</td><td>No collation</td><td>Concatenation of strings with different collations</td></tr>
					<tr><td>2</td><td>Implicit collation</td><td>Column value, stored routine parameter or local variable</td></tr>
					<tr><td>3</td><td>System constant</td><td><a href="functions.html#function_user">USER()</a> return value</td></tr>
					<tr><td>4</td><td>Coercible</td><td>Literal string</td></tr>
					<tr><td>5</td><td>Ignorable</td><td>NULL or an expression derived from NULL</td></tr>
				</table>
			</li>
			<li>
				<p>COLLATION(str)</p>
				<p>Returns the collation of the string argument.</p>
				<pre>(sql sqlHandle {SELECT COLLATION('abc')}) <b>Returns</b> 'latin1_swedish_ci'</pre>
				<pre>(sql sqlHandle {SELECT COLLATION(_utf8'abc')}) <b>Returns</b> 'utf8_general_ci'</pre>
			</li>
			<li>
				<p>CONNECTION_ID()</p>
				<p>Returns the connection ID (thread ID) for the connection. Every connection has an ID that is unique among the set of currently connected clients.</p>
				<pre>(sql sqlHandle {SELECT CONNECTION_ID()}) <b>Returns</b> 23786</pre>
			</li>
			<li>
				<p>CURRENT_USER, CURRENT_USER()</p>
				<p>Returns the username and hostname combination for the MySQL account that the server used to authenticate the current client.
					This account determines your access privileges. Within a stored routine that is defined with the SQL SECURITY DEFINER characteristic,
					CURRENT_USER() returns the creator of the routine. The return value is a string in the utf8 character set.</p>
				<p>The value of CURRENT_USER() can differ from the value of USER().</p>
				<pre>(sql sqlHandle {SELECT USER()}) <b>Returns</b> 'davida@localhost'</pre>
				<pre>(sql sqlHandle {SELECT * FROM mysql.user}) <b>Returns</b> ERROR 1044: Access denied for user ''@'localhost' to database 'mysql'</pre>
				<pre>(sql sqlHandle {SELECT CURRENT_USER()}) <b>Returns</b> '@localhost'</pre>
				<p>The example illustrates that although the client specified a username of davida (as indicated by the value of the USER() function),
					the server authenticated the client using an anonymous user account (as seen by the empty username part of the CURRENT_USER() value).
					One way this might occur is that there is no account listed in the grant tables for davida.</p>
			</li>
			<li>
				<p>DATABASE()</p>
				<p>Returns the default (current) database name as a string in the utf8 character set.
					If there is no default database, DATABASE() returns NULL. Within a stored routine,
					the default database is the database that the routine is associated with, which is not necessarily the same as the database that is the default in the calling context.</p>
				<pre>(sql sqlHandle {SELECT DATABASE()}) <b>Returns</b> 'test'</pre>
				<p>If there is no default database, DATABASE() returns NULL.</p>
			</li>
			<li>
				<p>FOUND_ROWS()</p>
				<p>A SELECT statement may include a LIMIT clause to restrict the number of rows the server returns to the client.
					In some cases, it is desirable to know how many rows the statement would have returned without the LIMIT, but without running the statement again.
					To obtain this row count, include a SQL_CALC_FOUND_ROWS option in the SELECT statement, and then invoke FOUND_ROWS() afterward:</p>
				<pre>(sql sqlHandle {SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name WHERE id > 100 LIMIT 10})</pre>
				<pre>(sql sqlHandle {SELECT FOUND_ROWS()})</pre>
				<p>The second SELECT returns a number indicating how many rows the first SELECT would have returned had it been written without the LIMIT clause.</p>
				<p>In the absence of the SQL_CALC_FOUND_ROWS option in the most recent successful SELECT statement, FOUND_ROWS() returns the number of rows in the result set returned by that statement.</p>
				<p>The row count available through FOUND_ROWS() is transient and not intended to be available past the statement following the SELECT SQL_CALC_FOUND_ROWS statement.
					If you need to refer to the value later, save it:</p>
				<pre>(sql sqlHandle {SELECT SQL_CALC_FOUND_ROWS * FROM ... })</pre>
				<pre>(sql sqlHandle {SET @rows = FOUND_ROWS()})</pre>
				<p>If you are using SELECT SQL_CALC_FOUND_ROWS, MySQL must calculate how many rows are in the full result set.
					However, this is faster than running the query again without LIMIT, because the result set need not be sent to the client.</p>
				<p>SQL_CALC_FOUND_ROWS and FOUND_ROWS() can be useful in situations when you want to restrict the number of rows that a query returns,
					but also determine the number of rows in the full result set without running the query again.
					An example is a Web script that presents a paged display containing links to the pages that show other sections of a search result.
					Using FOUND_ROWS() allows you to determine how many other pages are needed for the rest of the result.</p>
				<p>The use of SQL_CALC_FOUND_ROWS and FOUND_ROWS() is more complex for UNION statements than for simple SELECT statements,
					because LIMIT may occur at multiple places in a UNION. It may be applied to individual SELECT statements in the UNION, or global to the UNION result as a whole.</p>
				<p>The intent of SQL_CALC_FOUND_ROWS for UNION is that it should return the row count that would be returned without a global LIMIT.
					The conditions for use of SQL_CALC_FOUND_ROWS with UNION are:</p>
				<p>The SQL_CALC_FOUND_ROWS keyword must appear in the first SELECT of the UNION.</p>
				<p>The value of FOUND_ROWS() is exact only if UNION ALL is used. If UNION without ALL is used, duplicate removal occurs and the value of FOUND_ROWS() is only approximate.</p>
				<p>If no LIMIT is present in the UNION, SQL_CALC_FOUND_ROWS is ignored and returns the number of rows in the temporary table that is created to process the UNION.</p>
				<p>Beyond the cases described here, the behavior of FOUND_ROWS() is undefined (for example, its value following a SELECT statement that fails with an error).</p>
				<p>Important: FOUND_ROWS() is not replicated reliably using statement-based replication.
					Starting with MySQL 5.1.23, this function is automatically replicated using row-based replication.</p>
			</li>
			<li>
				<p>LAST_INSERT_ID(), LAST_INSERT_ID(expr)</p>
				<p>For MySQL 5.1.12 and later, LAST_INSERT_ID() (no arguments) returns the first automatically generated value successfully inserted for an AUTO_INCREMENT column as a result of the most recently executed INSERT statement.
					The value of LAST_INSERT_ID() remains unchanged if no rows are successfully inserted.</p>
				<p>For example, after inserting a row that generates an AUTO_INCREMENT value, you can get the value like this:</p>
				<pre>(sql sqlHandle {SELECT LAST_INSERT_ID()}) <b>Returns</b> 195</pre>
				<p>In MySQL 5.1.11 and earlier, LAST_INSERT_ID() (no arguments) returns the first automatically generated value if any rows were successfully inserted or updated.
					This means that the returned value could be a value that was not successfully inserted into the table. If no rows were successfully inserted, LAST_INSERT_ID() returns 0.</p>
				<p>The value of LAST_INSERT_ID() will be consistent across all versions if all rows in the INSERT or UPDATE statement were successful.</p>
				<p>if a table contains an AUTO_INCREMENT column and INSERT ... ON DUPLICATE KEY UPDATE updates (rather than inserts) a row,
					the value of LAST_INSERT_ID() is not meaningful prior to MySQL 5.1.12.</p>
				<p>The currently executing statement does not affect the value of LAST_INSERT_ID(). Suppose that you generate an AUTO_INCREMENT value with one statement,
					and then refer to LAST_INSERT_ID() in a multiple-row INSERT statement that inserts rows into a table with its own AUTO_INCREMENT column.
					The value of LAST_INSERT_ID() will remain stable in the second statement; its value for the second and later rows is not affected by the earlier row insertions.
					(However, if you mix references to LAST_INSERT_ID() and LAST_INSERT_ID(expr), the effect is undefined.)</p>
				<p>If the previous statement returned an error, the value of LAST_INSERT_ID() is undefined. For transactional tables,
					if the statement is rolled back due to an error, the value of LAST_INSERT_ID() is left undefined.
					For manual ROLLBACK, the value of LAST_INSERT_ID() is not restored to that before the transaction; it remains as it was at the point of the ROLLBACK.</p>
				<p>Within the body of a stored routine (procedure or function) or a trigger, the value of LAST_INSERT_ID() changes the same way as for statements executed outside the body of these kinds of objects.
					The effect of a stored routine or trigger upon the value of LAST_INSERT_ID() that is seen by following statements depends on the kind of routine:</p>
				<p>If a stored procedure executes statements that change the value of LAST_INSERT_ID(), the changed value will be seen by statements that follow the procedure call.</p>
				<p>For stored functions and triggers that change the value, the value is restored when the function or trigger ends, so following statements will not see a changed value.</p>
				<p>The ID that was generated is maintained in the server on a per-connection basis.
					This means that the value returned by the function to a given client is the first AUTO_INCREMENT value generated for most recent statement affecting an AUTO_INCREMENT column by that client.
					This value cannot be affected by other clients, even if they generate AUTO_INCREMENT values of their own.
					This behavior ensures that each client can retrieve its own ID without concern for the activity of other clients, and without the need for locks or transactions.</p>
				<p>The value of LAST_INSERT_ID() is not changed if you set the AUTO_INCREMENT column of a row to a non-"magic" value (that is, a value that is not NULL and not 0).</p>
				<p>Important: If you insert multiple rows using a single INSERT statement, LAST_INSERT_ID() returns the value generated for the first inserted row only.
					The reason for this is to make it possible to reproduce easily the same INSERT statement against some other server.</p>
				<p>For example:</p>
				<pre>(sql sqlHandle {USE test})</pre>
				<pre>(sql sqlHandle {CREATE TABLE t (id INT AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(10) NOT NULL)})</pre>
				<pre>(sql sqlHandle {INSERT INTO t VALUES (NULL, 'Bob')})</pre>
				<pre>(sql sqlHandle {SELECT * FROM t}) <b>Returns</b>
+----+------+
| id | name |
+----+------+
|  1 | Bob  |
+----+------+</pre>
				<pre>(sql sqlHandle {SELECT LAST_INSERT_ID()}) <b>Returns</b>
+------------------+
| LAST_INSERT_ID() |
+------------------+
|                1 |
+------------------+</pre>
				<pre>(sql sqlHandle {INSERT INTO t VALUES (NULL, 'Mary'), (NULL, 'Jane'), (NULL, 'Lisa')})</pre>
				<pre>(sql sqlHandle {SELECT * FROM t}) <b>Returns</b>
+----+------+
| id | name |
+----+------+
|  1 | Bob  |
|  2 | Mary |
|  3 | Jane |
|  4 | Lisa |
+----+------+</pre>
				<pre>(sql sqlHandle {SELECT LAST_INSERT_ID()}) <b>Returns</b>
+------------------+
| LAST_INSERT_ID() |
+------------------+
|                2 |
+------------------+</pre>
				<p>Although the second INSERT statement inserted three new rows into t, the ID generated for the first of these rows was 2,
					and it is this value that is returned by LAST_INSERT_ID() for the following SELECT statement.</p>
				<p>If you use INSERT IGNORE and the row is ignored, the AUTO_INCREMENT counter is not incremented and LAST_INSERT_ID() returns 0, which reflects that no row was inserted.</p>
				<p>If expr is given as an argument to LAST_INSERT_ID(), the value of the argument is returned by the function and is remembered as the next value to be returned by LAST_INSERT_ID().
					This can be used to simulate sequences:</p>
				<p>Create a table to hold the sequence counter and initialize it:</p>
				<pre>(sql sqlHandle {CREATE TABLE sequence (id INT NOT NULL)})</pre>
				<pre>(sql sqlHandle {INSERT INTO sequence VALUES (0)})</pre>
				<p>Use the table to generate sequence numbers like this:</p>
				<pre>(sql sqlHandle {UPDATE sequence SET id=LAST_INSERT_ID(id+1)})</pre>
				<pre>(sql sqlHandle {SELECT LAST_INSERT_ID()})</pre>
				<p>The UPDATE statement increments the sequence counter and causes the next call to LAST_INSERT_ID() to return the updated value.
					The SELECT statement retrieves that value. The mysql_insert_id() C API function can also be used to get the value.</p>
				<p>You can generate sequences without calling LAST_INSERT_ID(), but the utility of using the function this way is that the ID value is maintained in the server as the last automatically generated value.
					It is multi-user safe because multiple clients can issue the UPDATE statement and get their own sequence value with the SELECT statement (or mysql_insert_id()),
					without affecting or being affected by other clients that generate their own sequence values.</p>
				<p>Note that mysql_insert_id() is only updated after INSERT and UPDATE statements, so you cannot use the C API function
					to retrieve the value for LAST_INSERT_ID(expr) after executing other SQL statements like SELECT or SET.</p>
			</li>
			<li>
				<p>ROW_COUNT()</p>
				<p>ROW_COUNT() returns the number of rows updated, inserted, or deleted by the preceding statement.
					This is the same as the row count that the mysql client displays and the value from the mysql_affected_rows() C API function.</p>
				<pre>(sql sqlHandle {INSERT INTO t VALUES(1),(2),(3)})</pre>
				<pre>(sql sqlHandle {SELECT ROW_COUNT()}) <b>Returns</b>
+-------------+
| ROW_COUNT() |
+-------------+
|           3 |
+-------------+</pre>
				<pre>(sql sqlHandle {DELETE FROM t WHERE i IN(1,2)})</pre>
				<pre>(sql sqlHandle {SELECT ROW_COUNT()}) <b>Returns</b>
+-------------+
| ROW_COUNT() |
+-------------+
|           2 |
+-------------+</pre>
				<p>Important: ROW_COUNT() is not replicated reliably using statement-based replication. Beginning with MySQL 5.1.23, this function is automatically replicated using row-based replication.</p>
			</li>
			<li>
				<p>SCHEMA()</p>
				<p>This function is a synonym for DATABASE().</p>
			</li>
			<li>
				<p>SESSION_USER()</p>
				<p>SESSION_USER() is a synonym for USER().</p>
			</li>
			<li>
				<p>SYSTEM_USER()</p>
				<p>SYSTEM_USER() is a synonym for USER().</p>
			</li>
			<li>
				<p>USER()</p>
				<p>Returns the current MySQL username and hostname as a string in the utf8 character set.</p>
				<pre>(sql sqlHandle {SELECT USER()}) <b>Returns</b> 'davida@localhost'</pre>
				<p>The value indicates the username you specified when connecting to the server, and the client host from which you connected.
					The value can be different from that of CURRENT_USER().</p>
				<p>You can extract only the username part like this:</p>
				<pre>(sql sqlHandle {SELECT SUBSTRING_INDEX(USER(),'@',1)}) <b>Returns</b> 'davida'</pre>
			</li>
			<li>
				<p>VERSION()</p>
				<p>Returns a string that indicates the MySQL server version. The string uses the utf8 character set.</p>
				<pre>(sql sqlHandle {SELECT VERSION()}) <b>Returns</b> '5.1.30-standard'</pre>
				<p>Note that if your version string ends with -log this means that logging is enabled.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMiscellaneous Functions"></A>Miscellaneous Functions</H2></P>
		<table border="3"><tr><th>Name</th><th></th></tr>
			<tr><td>DEFAULT()</td><td>Return the default value for a table column</td></tr>
			<tr><td>GET_LOCK()</td><td>Get a named lock</td></tr>
			<tr><td>INET_ATON()</td><td>Return the numeric value of an IP address</td></tr>
			<tr><td>INET_NTOA()</td><td>Return the IP address from a numeric value</td></tr>
			<tr><td>IS_FREE_LOCK()</td><td>Checks whether the named lock  is free</td></tr>
			<tr><td>IS_USED_LOCK()</td><td>Checks whether the named lock is in use.  Return connection identifier if true.</td></tr>
			<tr><td>MASTER_POS_WAIT()</td><td>Block until the slave has read and  applied all updates up to the specified position</td></tr>
			<tr><td>NAME_CONST()</td><td>Causes the column to have the given name</td></tr>
			<tr><td>RAND()</td><td>Return a random floating-point value</td></tr>
			<tr><td>RELEASE_LOCK()</td><td>Releases the named lock</td></tr>
			<tr><td>SLEEP()</td><td>Sleep for a number of seconds</td></tr>
			<tr><td>UUID_SHORT()</td><td>Return an integer-valued universal identifier</td></tr>
			<tr><td>UUID()</td><td>Return a Universal Unique Identifier (UUID)</td></tr>
			<tr><td>VALUES()</td><td>Defines the values to be used during an INSERT</td></tr>
		</table>
		<ul>
			<li>
				<p>DEFAULT(col_name)</p>
				<p>Returns the default value for a table column. An error results if the column has no default value.</p>
				<pre>(sql sqlHandle {UPDATE t SET i = DEFAULT(i)+1 WHERE id < 100})</pre>
			</li>
			<li>
				<p>FORMAT(X,D)</p>
				<p>Formats the number X to a format like '#,###,###.##', rounded to D decimal places, and returns the result as a string.</p>
			</li>
			<li>
				<p>GET_LOCK(str,timeout)</p>
				<p>Tries to obtain a lock with a name given by the string str, using a timeout of timeout seconds.
					Returns 1 if the lock was obtained successfully, 0 if the attempt timed out (for example, because another client has previously locked the name),
					or NULL if an error occurred (such as running out of memory or the thread was killed with mysqladmin kill).
					If you have a lock obtained with GET_LOCK(), it is released when you execute RELEASE_LOCK(), execute a new GET_LOCK(),
					or your connection terminates (either normally or abnormally). Locks obtained with GET_LOCK() do not interact with transactions.
					That is, committing a transaction does not release any such locks obtained during the transaction.</p>
				<p>This function can be used to implement application locks or to simulate record locks. Names are locked on a server-wide basis.
					If a name has been locked by one client, GET_LOCK() blocks any request by another client for a lock with the same name.
					This allows clients that agree on a given lock name to use the name to perform cooperative advisory locking.
					But be aware that it also allows a client that is not among the set of cooperating clients to lock a name,
					either inadvertently or deliberately, and thus prevent any of the cooperating clients from locking that name.
					One way to reduce the likelihood of this is to use lock names that are database-specific or application-specific.
					For example, use lock names of the form db_name.str or app_name.str.</p>
				<pre>(sql sqlHandle {SELECT GET_LOCK('lock1',10)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT IS_FREE_LOCK('lock2')}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT GET_LOCK('lock2',10)}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT RELEASE_LOCK('lock2')}) <b>Returns</b> 1</pre>
				<pre>(sql sqlHandle {SELECT RELEASE_LOCK('lock1')}) <b>Returns</b> NULL</pre>
				<p>The second RELEASE_LOCK() call returns NULL because the lock 'lock1' was automatically released by the second GET_LOCK() call.</p>
				<p>Note: If a client attempts to acquire a lock that is already held by another client, it blocks according to the timeout argument.
					If the blocked client terminates, its thread does not die until the lock request times out. This is a known bug (fixed in MySQL 6.0).</p>
			</li>
			<li>
				<p>INET_ATON(expr)</p>
				<p>Given the dotted-quad representation of a network address as a string, returns an integer that represents the numeric value of the address.
					Addresses may be 4- or 8-byte addresses.</p>
				<pre>(sql sqlHandle {SELECT INET_ATON('209.207.224.40')}) <b>Returns</b> 3520061480</pre>
				<p>The generated number is always in network byte order. For the example just shown, the number is calculated as 2092563 + 2072562 + 224256 + 40.</p>
				<p>INET_ATON() also understands short-form IP addresses:</p>
				<pre>(sql sqlHandle {SELECT INET_ATON('127.0.0.1'), INET_ATON('127.1')}) <b>Returns</b> 2130706433, 2130706433</pre>
				<p>Note: When storing values generated by INET_ATON(), it is recommended that you use an INT UNSIGNED column.
					If you use a (signed) INT column, values corresponding to IP addresses for which the first octet is greater than 127 cannot be stored correctly.</p>
			</li>
			<li>
				<p>INET_NTOA(expr)</p>
				<p>Given a numeric network address (4 or 8 byte), returns the dotted-quad representation of the address as a string.</p>
				<pre>(sql sqlHandle {SELECT INET_NTOA(3520061480)}) <b>Returns</b> '209.207.224.40'</pre>
			</li>
			<li>
				<p>IS_FREE_LOCK(str)</p>
				<p>Checks whether the lock named str is free to use (that is, not locked). Returns 1 if the lock is free (no one is using the lock),
					0 if the lock is in use, and NULL if an error occurs (such as an incorrect argument).</p>
			</li>
			<li>
				<p>IS_USED_LOCK(str)</p>
				<p>Checks whether the lock named str is in use (that is, locked). If so, it returns the connection identifier of the client that holds the lock. Otherwise, it returns NULL.</p>
			</li>
			<li>
				<p>MASTER_POS_WAIT(log_name,log_pos[,timeout])</p>
				<p>This function is useful for control of master/slave synchronization. It blocks until the slave has read and applied all updates up to the specified position in the master log.
					The return value is the number of log events the slave had to wait for to advance to the specified position.
					The function returns NULL if the slave SQL thread is not started, the slave's master information is not initialized, the arguments are incorrect, or an error occurs.
					It returns -1 if the timeout has been exceeded. If the slave SQL thread stops while MASTER_POS_WAIT() is waiting, the function returns NULL.
					If the slave is past the specified position, the function returns immediately.</p>
				<p>If a timeout value is specified, MASTER_POS_WAIT() stops waiting when timeout seconds have elapsed. timeout must be greater than 0; a zero or negative timeout means no timeout.</p>
			</li>
			<li>
				<p>NAME_CONST(name,value)</p>
				<p>Returns the given value. When used to produce a result set column, NAME_CONST() causes the column to have the given name. The arguments should be constants.</p>
				<pre>(sql sqlHandle {SELECT NAME_CONST('myname', 14)}) <b>Returns</b>
+--------+
| myname |
+--------+
|     14 |
+--------+</pre>
				<p>This function was added in MySQL 5.0.12. It is for internal use only.
					The server uses it when writing statements from stored routines that contain references to local routine variables, You might see this function in the output from mysqlbinlog.</p>
			</li>
			<li>
				<p>RELEASE_LOCK(str)</p>
				<p>Releases the lock named by the string str that was obtained with GET_LOCK(). Returns 1 if the lock was released, 0 if the lock was not established by this thread (in which case the lock is not released),
					and NULL if the named lock did not exist. The lock does not exist if it was never obtained by a call to GET_LOCK() or if it has previously been released.</p>
				<p>The DO statement is convenient to use with RELEASE_LOCK().</p>
			</li>
			<li>
				<p>SLEEP(duration)</p>
				<p>Sleeps (pauses) for the number of seconds given by the duration argument, then returns 0.
					If SLEEP() is interrupted, it returns 1. The duration may have a fractional part given in microseconds.</p>
			</li>
			<li>
				<p>UUID()</p>
				<p>Returns a Universal Unique Identifier (UUID) generated according to "DCE 1.1: Remote Procedure Call" (Appendix A) CAE (Common Applications Environment)
					Specifications published by The Open Group in October 1997 (Document Number C706, http://www.opengroup.org/public/pubs/catalog/c706.htm).</p>
				<p>A UUID is designed as a number that is globally unique in space and time.
					Two calls to UUID() are expected to generate two different values, even if these calls are performed on two separate computers that are not connected to each other.</p>
				<p>A UUID is a 128-bit number represented by a utf8 string of five hexadecimal numbers in aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee format:</p>
				<p>The first three numbers are generated from a timestamp.</p>
				<p>The fourth number preserves temporal uniqueness in case the timestamp value loses monotonicity (for example, due to daylight saving time).</p>
				<p>The fifth number is an IEEE 802 node number that provides spatial uniqueness.
					A random number is substituted if the latter is not available (for example, because the host computer has no Ethernet card,
					or we do not know how to find the hardware address of an interface on your operating system).
					In this case, spatial uniqueness cannot be guaranteed. Nevertheless, a collision should have very low probability.</p>
				<p>Currently, the MAC address of an interface is taken into account only on FreeBSD and Linux. On other operating systems, MySQL uses a randomly generated 48-bit number.</p>
				<pre>(sql sqlHandle {SELECT UUID()}) <b>Returns</b> '6ccd780c-baba-1026-9564-0040f4311e29'</pre>
				<p>Warning: The UUID() function returns a string using the character set defined by the character_set_server parameter.
					If you are using UUID values in your tables and these columns are indexed the character set of your column or table should match the character set used when the UUID() was called.
					If you do not use the same character set for the column and the UUID value, then the indexes on those columns will not be used,
					which may lead to a reduction in performance and locked tables during operations as the table is searched sequentially for the value.</p>
				<p>You can convert between different character sets when using UUID-based strings using the CONVERT() function.</p>
				<p>Note: UUID() does not work with statement-based replication.</p>
			</li>
			<li>
				<p>UUID_SHORT()</p>
				<p>Returns a "short" universal identifier as a 64-bit unsigned integer (rather than a string-form 128-bit identifier as returned by the UUID() function).</p>
				<p>The value of UUID_SHORT() is guaranteed to be unique if the following conditions hold:</p>
				<p>The server_id of the current host is unique among your set of master and slave servers</p>
				<p>server_id is between 0 and 255</p>
				<p>You don't set back your system time for your server between mysqld restarts</p>
				<p>You do not invoke UUID_SHORT() on average more than 16 million times per second between mysqld restarts</p>
				<p>The UUID_SHORT() return value is constructed this way:</p>
				<pre>(server_id & 255) << 56 + (server_startup_time_in_seconds << 24) + incremented_variable++;</pre>
				<pre>(sql sqlHandle {SELECT UUID_SHORT()}) <b>Returns</b> 92395783831158784</pre>
				<p>Note that UUID_SHORT() does not work with statement-based replication.</p>
				<p>This function was added in MySQL 5.1.20.</p>
			</li>
			<li>
				<p>VALUES(col_name)</p>
				<p>In an INSERT ... ON DUPLICATE KEY UPDATE statement, you can use the VALUES(col_name) function in the UPDATE clause to refer to column values from the INSERT portion of the statement.
					In other words, VALUES(col_name) in the UPDATE clause refers to the value of col_name that would be inserted, had no duplicate-key conflict occurred.
					This function is especially useful in multiple-row inserts. The VALUES() function is meaningful only in INSERT ... ON DUPLICATE KEY UPDATE statements and returns NULL otherwise.</p>
				<pre>(sql sqlHandle {INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b)})</pre>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SGROUP BY (Aggregate) Functions"></A>GROUP BY (Aggregate) Functions</H2></P>
		<table border="3">
			<tr><th>Name</th><th>Description</th></tr>
			<tr><td>AVG()</td><td>Return the average value of the argument</td></tr>
			<tr><td>BIT_AND()</td><td>Return bitwise and</td></tr>
			<tr><td>BIT_OR()</td><td>Return bitwise or</td></tr>
			<tr><td>BIT_XOR()</td><td>Return bitwise xor</td></tr>
			<tr><td>COUNT(DISTINCT)</td><td>Return the count of a number of different values</td></tr>
			<tr><td>COUNT()</td><td>Return a count of the number of rows returned</td></tr>
			<tr><td>GROUP_CONCAT()</td><td>Return a concatenated string</td></tr>
			<tr><td>MAX()</td><td>Return the maximum value</td></tr>
			<tr><td>MIN()</td><td>Return the minimum value</td></tr>
			<tr><td>STD()</td><td>Return the population standard deviation</td></tr>
			<tr><td>STDDEV_POP()</td><td>Return the population standard deviation</td></tr>
			<tr><td>STDDEV_SAMP()</td><td>Return the sample standard deviation</td></tr>
			<tr><td>STDDEV()</td><td>Return the population standard deviation</td></tr>
			<tr><td>SUM()</td><td>Return the sum</td></tr>
			<tr><td>VAR_POP()</td><td>Return the population standard variance</td></tr>
			<tr><td>VAR_SAMP()</td><td>Return the sample variance</td></tr>
			<tr><td>VARIANCE()</td><td>Return the population standard variance</td></tr>
		</table>
		<p>This section describes group (aggregate) functions that operate on sets of values. Unless otherwise stated, group functions ignore NULL values.</p>
		<p>If you use a group function in a statement containing no GROUP BY clause, it is equivalent to grouping on all rows.</p>
		<p>For numeric arguments, the variance and standard deviation functions return a DOUBLE value.
			The SUM() and AVG() functions return a DECIMAL value for exact-value arguments (integer or DECIMAL), and a DOUBLE value for approximate-value arguments (FLOAT or DOUBLE).</p>
		<p>The SUM() and AVG() aggregate functions do not work with temporal values. (They convert the values to numbers, losing everything after the first non-numeric character.)
			To work around this problem, you can convert to numeric units, perform the aggregate operation, and convert back to a temporal value. Examples:</p>
		<pre>SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(time_col))) FROM tbl_name</pre>
		<pre>SELECT FROM_DAYS(SUM(TO_DAYS(date_col))) FROM tbl_name</pre>
		<p>Functions such as SUM() or AVG() that expect a numeric argument cast the argument to a number if necessary.
			For SET or ENUM values, the cast operation causes the underlying numeric value to be used.</p>
		<ul>
			<li>
				<p>AVG([DISTINCT] expr)</p>
				<p>Returns the average value of expr. The DISTINCT option can be used to return the average of the distinct values of expr.</p>
				<p>AVG() returns NULL if there were no matching rows.</p>
				<pre>(sql sqlHandle {SELECT student_name, AVG(test_score) FROM student GROUP BY student_name})</pre>
			</li>
			<li>
				<p>BIT_AND(expr)</p>
				<p>Returns the bitwise AND of all bits in expr. The calculation is performed with 64-bit (BIGINT) precision.</p>
				<p>This function returns 18446744073709551615 if there were no matching rows. (This is the value of an unsigned BIGINT value with all bits set to 1.)</p>
			</li>
			<li>
				<p>BIT_OR(expr)</p>
				<p>Returns the bitwise OR of all bits in expr. The calculation is performed with 64-bit (BIGINT) precision.</p>
				<p>This function returns 0 if there were no matching rows.</p>
			</li>
			<li>
				<p>BIT_XOR(expr)</p>
				<p>Returns the bitwise XOR of all bits in expr. The calculation is performed with 64-bit (BIGINT) precision.</p>
				<p>This function returns 0 if there were no matching rows.</p>
			</li>
			<li>
				<p>COUNT(expr)</p>
				<p>Returns a count of the number of non-NULL values of expr in the rows retrieved by a SELECT statement. The result is a BIGINT value.</p>
				<p>COUNT() returns 0 if there were no matching rows.</p>
				<pre>(sql sqlHandle {SELECT student.student_name,COUNT(*)}) FROM student,course WHERE student.student_id=course.student_id GROUP BY student_name})</pre>
				<p>COUNT(*) is somewhat different in that it returns a count of the number of rows retrieved, whether or not they contain NULL values.</p>
				<p>COUNT(*) is optimized to return very quickly if the SELECT retrieves from one table, no other columns are retrieved, and there is no WHERE clause. For example:</p>
				<pre>(sql sqlHandle {SELECT COUNT(*) FROM student})</pre>
				<p>This optimization applies only to MyISAM tables only, because an exact row count is stored for this storage engine and can be accessed very quickly.
					For transactional storage engines such as InnoDB, storing an exact row count is more problematic because multiple transactions may be occurring, each of which may affect the count.</p>
			</li>
			<li>
				<p>COUNT(DISTINCT expr,[expr...])</p>
				<p>Returns a count of the number of different non-NULL values.</p>
				<p>COUNT(DISTINCT) returns 0 if there were no matching rows.</p>
				<pre>(sql sqlHandle {SELECT COUNT(DISTINCT results) FROM student})</pre>
				<p>In MySQL, you can obtain the number of distinct expression combinations that do not contain NULL by giving a list of expressions.
					In standard SQL, you would have to do a concatenation of all expressions inside COUNT(DISTINCT ...).</p>
			</li>
			<li>
				<p>GROUP_CONCAT(expr)</p>
				<p>This function returns a string result with the concatenated non-NULL values from a group.
					It returns NULL if there are no non-NULL values. The full syntax is as follows:</p>
				<pre>GROUP_CONCAT([DISTINCT] expr [,expr ...]
	[ORDER BY {unsigned_integer | col_name | expr}
	 [ASC | DESC] [,col_name ...]]
	[SEPARATOR str_val])</pre>
				<pre>(sql sqlHandle {SELECT student_name, GROUP_CONCAT(test_score) FROM student GROUP BY student_name})</pre>
				<p>Or:</p>
				<pre>(sql sqlHandle {SELECT student_name, GROUP_CONCAT(DISTINCT test_score ORDER BY test_score DESC SEPARATOR ' ') FROM student GROUP BY student_name})</pre>
				<p>In MySQL, you can get the concatenated values of expression combinations. You can eliminate duplicate values by using DISTINCT.
					If you want to sort values in the result, you should use ORDER BY clause. To sort in reverse order,
					add the DESC (descending) keyword to the name of the column you are sorting by in the ORDER BY clause.
					The default is ascending order; this may be specified explicitly using the ASC keyword.
					SEPARATOR is followed by the string value that should be inserted between values of result.
					The default is a comma (","). You can eliminate the separator altogether by specifying SEPARATOR ''.</p>
				<p>The result is truncated to the maximum length that is given by the group_concat_max_len system variable, which has a default value of 1024.
					The value can be set higher, although the effective maximum length of the return value is constrained by the value of max_allowed_packet.
					The syntax to change the value of group_concat_max_len at runtime is as follows, where val is an unsigned integer:</p>
				<pre>SET [SESSION | GLOBAL] group_concat_max_len = val;</pre>
				<p>The type returned by GROUP_CONCAT() is always VARCHAR unless group_concat_max_len is greater than 512, in which case, it returns a BLOB.</p>
			</li>
			<li>
				<p>MAX([DISTINCT] expr)</p>
				<p>Returns the maximum value of expr. MAX() may take a string argument; in such cases, it returns the maximum string value.
					The DISTINCT keyword can be used to find the maximum of the distinct values of expr, however, this produces the same result as omitting DISTINCT.</p>
				<p>MAX() returns NULL if there were no matching rows.</p>
				<pre>(sql sqlHandle {SELECT student_name, MIN(test_score), MAX(test_score) FROM student GROUP BY student_name})</pre>
				<p>For MAX(), MySQL currently compares ENUM and SET columns by their string value rather than by the string's relative position in the set.
					This differs from how ORDER BY compares them. This is expected to be rectified in a future MySQL release.</p>
			</li>
			<li>
				<p>MIN([DISTINCT] expr)</p>
				<p>Returns the minimum value of expr. MIN() may take a string argument; in such cases, it returns the minimum string value. 
					The DISTINCT keyword can be used to find the minimum of the distinct values of expr, however, this produces the same result as omitting DISTINCT.</p>
				<p>MIN() returns NULL if there were no matching rows.</p>
				<pre>(sql sqlHandle {SELECT student_name, MIN(test_score), MAX(test_score) FROM student GROUP BY student_name})</pre>
				<p>For MIN(), MySQL currently compares ENUM and SET columns by their string value rather than by the string's relative position in the set.
					This differs from how ORDER BY compares them. This is expected to be rectified in a future MySQL release.</p>
			</li>
			<li>
				<p>STD(expr)</p>
				<p>Returns the population standard deviation of expr. This is an extension to standard SQL. The standard SQL function STDDEV_POP() can be used instead.</p>
				<p>This function returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>STDDEV(expr)</p>
				<p>Returns the population standard deviation of expr. This function is provided for compatibility with Oracle. The standard SQL function STDDEV_POP() can be used instead.</p>
				<p>This function returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>STDDEV_POP(expr)</p>
				<p>Returns the population standard deviation of expr (the square root of VAR_POP()). You can also use STD() or STDDEV(), which are equivalent but not standard SQL.</p>
				<p>STDDEV_POP() returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>STDDEV_SAMP(expr)</p>
				<p>Returns the sample standard deviation of expr (the square root of VAR_SAMP().</p>
				<p>STDDEV_SAMP() returns NULL if there were no matching rows.</p>
			<li>
			<li>
				<p>SUM([DISTINCT] expr)</p>
				<p>Returns the sum of expr. If the return set has no rows, SUM() returns NULL. The DISTINCT keyword can be used in MySQL 5.1 to sum only the distinct values of expr.</p>
				<p>SUM() returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>VAR_POP(expr)</p>
				<p>Returns the population standard variance of expr. It considers rows as the whole population, not as a sample, so it has the number of rows as the denominator.
					You can also use VARIANCE(), which is equivalent but is not standard SQL.</p>
				<p>VAR_POP() returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>VAR_SAMP(expr)</p>
				<p>Returns the sample variance of expr. That is, the denominator is the number of rows minus one.</p>
				<p>VAR_SAMP() returns NULL if there were no matching rows.</p>
			</li>
			<li>
				<p>VARIANCE(expr)</p>
				<p>Returns the population standard variance of expr. This is an extension to standard SQL. The standard SQL function VAR_POP() can be used instead.</p>
				<p>VARIANCE() returns NULL if there were no matching rows.</p>
			</li>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SGROUP BY Modifiers"></A>GROUP BY Modifiers</H2></P>
		<p>The GROUP BY clause allows a WITH ROLLUP modifier that causes extra rows to be added to the summary output.
			These rows represent higher-level (or super-aggregate) summary operations.
			ROLLUP thus allows you to answer questions at multiple levels of analysis with a single query.
			It can be used, for example, to provide support for OLAP (Online Analytical Processing) operations.</p>
		<p>Suppose that a table named sales has year, country, product, and profit columns for recording sales profitability:</p>
		<pre>(sql sqlHandle {
CREATE TABLE sales
(
    year    INT NOT NULL,
    country VARCHAR(20) NOT NULL,
    product VARCHAR(32) NOT NULL,
    profit  INT
)})</pre>
		<p>The table's contents can be summarized per year with a simple GROUP BY like this:</p>
		<pre>(sql sqlHandle {SELECT year, SUM(profit) FROM sales GROUP BY year}) <b>Returns</b>
+------+-------------+
| year | SUM(profit) |
+------+-------------+
| 2000 |        4525 |
| 2001 |        3010 |
+------+-------------+</pre>
		<p>This output shows the total profit for each year, but if you also want to determine the total profit summed over all years,
			you must add up the individual values yourself or run an additional query.</p>
		<p>Or you can use ROLLUP, which provides both levels of analysis with a single query.
			Adding a WITH ROLLUP modifier to the GROUP BY clause causes the query to produce another row that shows the grand total over all year values:</p>
		<pre>(sql sqlHandle {SELECT year, SUM(profit) FROM sales GROUP BY year WITH ROLLUP}) <b>Returns</b>
+------+-------------+
| year | SUM(profit) |
+------+-------------+
| 2000 |        4525 |
| 2001 |        3010 |
| NULL |        7535 |
+------+-------------+</pre>
		<p>The grand total super-aggregate line is identified by the value NULL in the year column.</p>
		<p>ROLLUP has a more complex effect when there are multiple GROUP BY columns.
			In this case, each time there is a "break" (change in value) in any but the last grouping column, the query produces an extra super-aggregate summary row.</p>
		<p>For example, without ROLLUP, a summary on the sales table based on year, country, and product might look like this:</p>
		<pre>(sql sqlHandle {SELECT year, country, product, SUM(profit) FROM sales GROUP BY year, country, product}) <b>Returns</b>
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
| 2000 | USA     | Calculator |          75 |
| 2000 | USA     | Computer   |        1500 |
| 2001 | Finland | Phone      |          10 |
| 2001 | USA     | Calculator |          50 |
| 2001 | USA     | Computer   |        2700 |
| 2001 | USA     | TV         |         250 |
+------+---------+------------+-------------+</pre>
		<p>The output indicates summary values only at the year/country/product level of analysis. When ROLLUP is added, the query produces several extra rows:</p>
		<pre>(sql sqlHandle {SELECT year, country, product, SUM(profit) FROM sales GROUP BY year, country, product WITH ROLLUP}) <b>Returns</b>
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | Finland | NULL       |        1600 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
| 2000 | India   | NULL       |        1350 |
| 2000 | USA     | Calculator |          75 |
| 2000 | USA     | Computer   |        1500 |
| 2000 | USA     | NULL       |        1575 |
| 2000 | NULL    | NULL       |        4525 |
| 2001 | Finland | Phone      |          10 |
| 2001 | Finland | NULL       |          10 |
| 2001 | USA     | Calculator |          50 |
| 2001 | USA     | Computer   |        2700 |
| 2001 | USA     | TV         |         250 |
| 2001 | USA     | NULL       |        3000 |
| 2001 | NULL    | NULL       |        3010 |
| NULL | NULL    | NULL       |        7535 |
+------+---------+------------+-------------+</pre>
		<p>For this query, adding ROLLUP causes the output to include summary information at four levels of analysis, not just one. Here's how to interpret the ROLLUP output:</p>
		<ul>
			<li>
				<p>Following each set of product rows for a given year and country, an extra summary row is produced showing the total for all products. These rows have the product column set to NULL.</p>
			</li>
			<li>
				<p>Following each set of rows for a given year, an extra summary row is produced showing the total for all countries and products. These rows have the country and products columns set to NULL.</p>
			</li>
			<li>
				<p>Finally, following all other rows, an extra summary row is produced showing the grand total for all years, countries, and products. This row has the year, country, and products columns set to NULL.</p>
			</li>
		</ul>
		<p><b>Other Considerations When using ROLLUP</b></p>
		<p>The following items list some behaviors specific to the MySQL implementation of ROLLUP:</p>
		<p>When you use ROLLUP, you cannot also use an ORDER BY clause to sort the results. In other words, ROLLUP and ORDER BY are mutually exclusive.
			However, you still have some control over sort order. GROUP BY in MySQL sorts results, and you can use explicit ASC and DESC keywords with
			columns named in the GROUP BY list to specify sort order for individual columns. (The higher-level summary rows added by ROLLUP still appear
			after the rows from which they are calculated, regardless of the sort order.)</p>
		<p>LIMIT can be used to restrict the number of rows returned to the client. LIMIT is applied after ROLLUP, so the limit applies against the extra rows added by ROLLUP. For example:</p>
		<pre>(sql sqlHandle {SELECT year, country, product, SUM(profit) FROM sales GROUP BY year, country, product WITH ROLLUP LIMIT 5}) <b>Returns</b>
+------+---------+------------+-------------+
| year | country | product    | SUM(profit) |
+------+---------+------------+-------------+
| 2000 | Finland | Computer   |        1500 |
| 2000 | Finland | Phone      |         100 |
| 2000 | Finland | NULL       |        1600 |
| 2000 | India   | Calculator |         150 |
| 2000 | India   | Computer   |        1200 |
+------+---------+------------+-------------+</pre>
		<p>Using LIMIT with ROLLUP may produce results that are more difficult to interpret, because you have less context for understanding the super-aggregate rows.</p>
		<p>The NULL indicators in each super-aggregate row are produced when the row is sent to the client.
			The server looks at the columns named in the GROUP BY clause following the leftmost one that has changed value.
			For any column in the result set with a name that is a lexical match to any of those names, its value is set to NULL.
			(If you specify grouping columns by column number, the server identifies which columns to set to NULL by number.)</p>
		<p>Because the NULL values in the super-aggregate rows are placed into the result set at such a late stage in query processing, you cannot test them as NULL values within the query itself.
			For example, you cannot add HAVING product IS NULL to the query to eliminate from the output all but the super-aggregate rows.</p>
		<p>On the other hand, the NULL values do appear as NULL on the client side and can be tested as such using any MySQL client programming interface.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SGROUP BY and HAVING with Hidden Fields"></A>GROUP BY and HAVING with Hidden Fields</H2></P>
		<p>MySQL extends the use of GROUP BY so that you can use non-aggregated columns or calculations in the SELECT list that do not appear in the GROUP BY clause.
			You can use this feature to get better performance by avoiding unnecessary column sorting and grouping.
			For example, you do not need to group on customer.name in the following query:</p>
		<pre>(sql sqlHandle {
SELECT order.custid, customer.name, MAX(payments)
  FROM order,customer
  WHERE order.custid = customer.custid
  GROUP BY order.custid})</pre>
		<p>In standard SQL, you would have to add customer.name to the GROUP BY clause. In MySQL, the name is redundant.</p>
		<p>Do not use this feature if the columns you omit from the GROUP BY part are not constant in the group.
			The server is free to return any value from the group, so the results are indeterminate unless all values are the same.</p>
		<p>A similar MySQL extension applies to the HAVING clause.
			The SQL standard does not allow the HAVING clause to name any column that is not found in the GROUP BY clause if it is not enclosed in an aggregate function.
			MySQL allows the use of such columns to simplify calculations. This extension assumes that the non-grouped columns will have the same group-wise values. Otherwise, the result is indeterminate.</p>
		<p>If the ONLY_FULL_GROUP_BY SQL mode is enabled, the MySQL extension to GROUP BY does not apply.
			That is, columns not named in the GROUP BY clause cannot be used in the SELECT list or HAVING clause if not used in an aggregate function.</p>
		<p>The select list extension also applies to ORDER BY. That is, you can use non-aggregated columns or calculations in the ORDER BY clause that do not appear in the GROUP BY clause.
			This extension does not apply if the ONLY_FULL_GROUP_BY SQL mode is enabled.</p>
		<p>In some cases, you can use MIN() and MAX() to obtain a specific column value even if it isn't unique.
			The following gives the value of column from the row containing the smallest value in the sort column:</p>
		<pre>(sql sqlHandle {SUBSTR(MIN(CONCAT(RPAD(sort,6,' '),column)),7)})</pre>
		<p>Note that if you are trying to follow standard SQL, you can't use expressions in GROUP BY clauses. You can work around this limitation by using an alias for the expression:</p>
		<pre>(sql sqlHandle {
SELECT id,FLOOR(value/100) AS val
  FROM tbl_name
  GROUP BY id, val})</pre>
		<p>MySQL does allow expressions in GROUP BY clauses. For example:</p>
		<pre>(sql sqlHandle {
SELECT id,FLOOR(value/100)
  FROM tbl_name
  GROUP BY id, FLOOR(value/100)})</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P>

 

</BODY>
</HTML>