/**********************************************************************************
    Copyright (C) 2008 Investment Science Corp.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

***********************************************************************************/
/*	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
aisdev/aforms/adebugpage.cpp
														 Debug Page

CHANGE HISTORY
Version	Date		Who		Change
3.2009	05/08/2007	fchua	Added setParameters().
2.0002	 1/25/2007	mfk		debugCodeLines. Fix to avoid an unwanted scroll to (0,0) generated by a mouse click on a row.
1.0113	11/7/2006	tlw		Omit unused destructor.
1.0107	9/19/2006	tlw		debugCodeLines. Add scrollTo to current line to show current line.
1.0070	10/3/2005	tlw		Add for Qt4
												--------------- --------------
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

//	------------------------------------------------------ IMPORTS ------------------------------------------------------------
#include <QtGui/QStandardItemModel>
#include <QtGui/QMessageBox>
#include <QtGui/QCursor>
#include <QtGui/QToolTip>
#include <QtGui/QTextBlock>
#include <QtCore/QUrl>
#include "appclient.h"
#include "adebugpage.h"
#include "asessionform.h"

//	------------------------------------------------------ METHODS -------------------------------------------------------------
ADebugPage::ADebugPage(AAppClient* ipAppClient, ASessionForm* ipParentForm, AReturnRcvr* ipReturnRcvr, const char* ipName)
: QWidget(qobject_cast<QWidget*>(ipParentForm)), cpAppClient(ipAppClient), cBlankIcon(":images/checkoff.png"),
  cCodeLinesCount( -1 ), cCurrentIcon(":images/debugcurrent.png"), cCurrentLine(-1), cpParentForm(ipParentForm), cpReturnRcvr(ipReturnRcvr),
  cShowSource(false), cSourceOff(QIcon(":/images/debugsourceoff.png")), cSourceOn(QIcon(":/images/debugsourceon.png")), cTabWidth(4)
{
    Q_UNUSED(ipName);
    QStringList headerLabels;

	// Setup. Establish the widgets for all types of log pages.
	cUi.setupUi(this);

	// Toolbar. Initialize the toolbar buttons
	cUi.upGoToolButton->setIcon(QIcon(":/images/debuggo.png"));
	cUi.upGoToolButton->setShortcut(Qt::Key_F5);
	cUi.upGoToolButton->setStatusTip("Continue execution until next breakpoint.");
	cUi.upGoToolButton->setToolTip("Continue execution F5");
	connect(cUi.upGoToolButton, SIGNAL(clicked()), this, SLOT(onGoClicked()));

	cUi.upStepOverToolButton->setIcon(QIcon(":/images/debugstepover.png"));
	cUi.upStepOverToolButton->setShortcut(Qt::Key_F10);
	cUi.upStepOverToolButton->setStatusTip("Step over call to agent");
	cUi.upStepOverToolButton->setToolTip("Step Over F10");
	connect(cUi.upStepOverToolButton, SIGNAL(clicked()), this, SLOT(onStepOverClicked()));

	cUi.upStepIntoToolButton->setIcon(QIcon(":/images/debugstepinto.png"));
	cUi.upStepIntoToolButton->setShortcut(Qt::Key_F11);
	cUi.upStepIntoToolButton->setStatusTip("Step into call to agent");
	cUi.upStepIntoToolButton->setToolTip("Step Into F11");
	connect(cUi.upStepIntoToolButton, SIGNAL(clicked()), this, SLOT(onStepIntoClicked()));

	cUi.upRunToToolButton->setIcon(QIcon(":/images/debugrunto.png"));
	cUi.upRunToToolButton->setShortcut(Qt::Key_F4);
	cUi.upRunToToolButton->setStatusTip("Continue execution to selected line");
	cUi.upRunToToolButton->setToolTip("Run To F4");
	connect(cUi.upRunToToolButton, SIGNAL(clicked()), this, SLOT(onRunToClicked()));

	cUi.upStepOutToolButton->setIcon(QIcon(":/images/debugstepout.png"));
	cUi.upStepOutToolButton->setShortcut(Qt::SHIFT + Qt::Key_F11);
	cUi.upStepOutToolButton->setStatusTip(tr("Return to calling agent"));
	cUi.upStepOutToolButton->setToolTip("Step Out Shift-F11");
	connect(cUi.upStepOutToolButton, SIGNAL(clicked()), this, SLOT(onStepOutClicked()));

	cUi.upQuitToolButton->setIcon(QIcon(":/images/debugquit.png"));
	cUi.upQuitToolButton->setStatusTip("Stop debugger. Return to console tab.");
	cUi.upQuitToolButton->setToolTip(tr("Stop"));
	connect(cUi.upQuitToolButton, SIGNAL(clicked()), this, SLOT(onQuitClicked()));

	cUi.upSourceToolButton->setIcon(cSourceOff);
	cUi.upSourceToolButton->setStatusTip("Toggle Source on/off ");
	cUi.upSourceToolButton->setToolTip("Show Source/VmCode");
	connect(cUi.upSourceToolButton, SIGNAL(clicked()), this, SLOT(onSourceClicked()));

	cUi.upHelpToolButton->setIcon(QIcon(":/images/debughelp.png"));
	cUi.upHelpToolButton->setShortcut(Qt::Key_F1);
	cUi.upHelpToolButton->setStatusTip("Show debug commands");
	cUi.upHelpToolButton->setToolTip("Show Commands F1");
	connect(cUi.upHelpToolButton, SIGNAL(clicked()), this, SLOT(onHelpClicked()));

	// Code View. Configure the code list view
	//connect(cUi.upCodeListView, SIGNAL(doubleClicked(const QModelIndex&)), this, SLOT(onCodeListDoubleClicked(const QModelIndex&)));

	// Code Model. Configure the code list model to feed the list view
	cpCodeListModel = new QStandardItemModel(0/*Rows*/, 1/*Cols*/, this);
	cpCodeListModel->setObjectName("CodeListModel");
	//cUi.upCodeListView->setModel(cpCodeListModel);

	//Code Text Edit. Configure the code text editor.
	cUi.upCodeTextEdit->setWordWrapMode(QTextOption::NoWrap);
	cUi.upCodeTextEdit->setReadOnly( true );
	cUi.upCodeTextEdit->installEventFilter(this);
	cUi.upCodeTextEdit->viewport()->installEventFilter(this);

	cpLineNumberArea = new QWidget( cUi.upCodeTextEdit );

	// Var View. Configure the var list view
	cUi.upVarListTree->setSelectionBehavior(QAbstractItemView::SelectRows);
	cUi.upVarListTree->setSelectionMode(QAbstractItemView::SingleSelection);
	connect(cUi.upVarListTree, SIGNAL(doubleClicked(const QModelIndex&)), this, SLOT(onVarListDoubleClicked(const QModelIndex&)));

	// Var Model. Configure the var list model to feed the list view
	cpRegisterTree = new QStandardItem( "Register Vars" );
	cpArgumentTree = new QStandardItem( "Argument Vars" );
	cpPersistentTree = new QStandardItem( "Persistent Vars" );
	cpConstantTree = new QStandardItem( "Constant Vars" );
	cpTemporaryTree = new QStandardItem( "Temporary Vars" );
	cpClassTree = new QStandardItem( "Class Vars" );
	cpInterfaceTree = new QStandardItem( "Interface Vars" );
	cUi.upVarListTree->setEditTriggers(QAbstractItemView::NoEditTriggers);
	cpVarListModel = new QStandardItemModel(0/*Rows*/, 2/*Cols*/, this);
	cpVarListModel->setObjectName("VarListModel");
	cpVarListModel->setItem(0, cpRegisterTree);
	cpVarListModel->setItem(1, cpArgumentTree);
	cpVarListModel->setItem(2, cpPersistentTree);
	cpVarListModel->setItem(3, cpConstantTree);
	cpVarListModel->setItem(4, cpTemporaryTree);
	cpVarListModel->setItem(5, cpClassTree);
	cpVarListModel->setItem(6, cpInterfaceTree);

	cUi.upVarListTree->setModel(cpVarListModel);

	//  Connections. Connect up the widget signals to local slots.
	connect(cUi.upCmdLineEdit, SIGNAL(returnPressed()), this, SLOT(onCmdReturnPressed()));
	connect(cUi.upWatchButton, SIGNAL(clicked()), this, SLOT(onWatchPressed()));

	headerLabels << "Name" << "Value";
	cpVarListModel->setHorizontalHeaderLabels(headerLabels);

	// Create Menu for the Variable List
	// The menu should add a selected variable to the watch list
	cpWatchVariableAct = new QAction(tr("Watch variable..."), this);
	connect(cpWatchVariableAct, SIGNAL(triggered()), this, SLOT(onWatchVariable()));
	cpVarListTreeMenu = new QMenu(QString(""), this);
	cpVarListTreeMenu->addAction(cpWatchVariableAct);

	cUi.upVarListTree->setContextMenuPolicy(Qt::CustomContextMenu);
	connect(cUi.upVarListTree, SIGNAL(customContextMenuRequested(const QPoint&)), this, SLOT(showTreeContextMenu(const QPoint&)));
	connect(cUi.upVarListTree, SIGNAL(expanded(const QModelIndex&)), this, SLOT(onVarListExpanded()));
	connect(cUi.upVarListTree, SIGNAL(collapsed(const QModelIndex&)), this, SLOT(onVarListCollapsed()));

	cpWatchList = new AWatchDialog(this, cpAppClient, cpReturnRcvr, "Watch List");

	setParameters(ipParentForm->getDebugParameters());
}

/*!
\brief debugLineEdit - Set the response lineedit's text

\param irText - Response to be displayed
\return void
*/
void ADebugPage::debugLineEdit(const QString& irText)
{
	// Do nothing if irText is ""
	if(irText != "")
		cUi.upResponseLineEdit->setText(irText);
}

/*!
\brief debugCodeLines - Display code in the code pane

\param irCode - Source or VM code to be debugged
\param iCurrentLine - The line number of the next line to be executed.
\return void
*/
void ADebugPage::debugCodeLines(const QString& irCode, long iCurrentLine)
{
    QModelIndex aIdx;
    QTextCursor aMarkedCursor;
    QString aSrcCode = irCode;
    QStringList aCodeLines = aSrcCode.split('\177', QString::KeepEmptyParts);
    long aCount = aCodeLines.size();

	cCurrentLine = iCurrentLine;
	// Check if returned source code listing is the same as the older code listing
	// Note:  The string returned by the smtbase engine(fmvscpt2.c) is "000000: ..same source.."
	if( irCode.indexOf( "000000: ..same source.." ) == 0 )
	{
		// Highlight the current line
        cUi.upCodeTextEdit->highlightLine(iCurrentLine);
		// Set the cursor to focus on the current line
		aMarkedCursor = cUi.upCodeTextEdit->textCursor();
		aMarkedCursor.movePosition(QTextCursor::Start);
		aMarkedCursor.movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, iCurrentLine );
		cUi.upCodeTextEdit->setTextCursor(aMarkedCursor);
        cUi.upCodeTextEdit->centerCursor();
		return;
	}

    cUi.upCodeTextEdit->clear();
	cpCodeListModel->removeRows(0,cpCodeListModel->rowCount());
    if( aCount> 0 )
    {
		cpCodeListModel->insertRows(0,aCount);
        QStringList aCodeLines = aSrcCode.split('\177', QString::KeepEmptyParts);
		cCodeLinesCount = aCount;
        for (long aLine = 0; aLine < aCount; ++aLine)
        {
			// Add each line to the source list model
			aIdx = cpCodeListModel->index( aLine, 0 );
			cpCodeListModel->setData(aIdx, QVariant( aCodeLines[aLine] ), Qt::EditRole);
			// Display the source with tab width changed to user's preference
            //cUi.upCodeTextEdit->insertPlainText(aCodeLines[aLine].replace(QString('\t'), QString(cTabWidth, ' ' )));
            cUi.upCodeTextEdit->insertPlainText(aCodeLines[aLine]);
            cUi.upCodeTextEdit->insertPlainText("\n");
        }
		// Highlight the current line
        cUi.upCodeTextEdit->highlightLine(iCurrentLine);
		// Set the cursor to focus on the current line
		aMarkedCursor = cUi.upCodeTextEdit->textCursor();
		aMarkedCursor.movePosition(QTextCursor::Start);
		aMarkedCursor.movePosition(QTextCursor::Down, QTextCursor::MoveAnchor, iCurrentLine );
		cUi.upCodeTextEdit->setTextCursor(aMarkedCursor);
        cUi.upCodeTextEdit->centerCursor();
    }
}

/*!
\brief debugInfoLines - Display variables or help info in the variable list view.

\param irVariables - Variables or help info to be displayed.
\return void
*/
void ADebugPage::debugInfoLines(const QString& irVariables)
{
	QStringList aWatchList = cpWatchList->getWatchList();
	long ctr = 0;
	cpWatchList->clearValues();

	// " ? " Display the Help information as a Message box
	if( irVariables.startsWith( " ? " ))
	{
		QString aVarLines = irVariables;
		aVarLines = aVarLines.mid(3);
		aVarLines = aVarLines.replace(QChar('\177'), QChar('\n'));
		aVarLines = aVarLines.replace("***", "\n        ");
		QMessageBox::information( this, "Help Information", aVarLines );
	}
	else
	// "***" marks that the values returned by the debugger is meant to be handled source code viewer,
	// and display it as a tooltip
	if( irVariables.startsWith( "***" ))
	{
		QToolTip::showText( QCursor::pos(), irVariables.mid(3));
	}
	else
	// "###" marks that the values returned by the debugger is meant to be handled by the watch list window.
	if( irVariables.startsWith( "##" ))
	{
		cpWatchList->updateValue( irVariables );
	}
	else
	if( irVariables.startsWith( "===" ))
	{
		QString data = cIdx.data().toString();
		QModelIndex aIdx = cIdx.sibling( cIdx.row(), 0 );
		QStandardItem* aParent = cpVarListModel->itemFromIndex( aIdx );
		aParent->removeRows( 0, aParent->rowCount() );
		QStringList aVarLines = irVariables.split('\177', QString::KeepEmptyParts);
		for( ctr = 3; ctr < aVarLines.count(); ctr++ )
		{
			QList<QStandardItem*> aItem;
			QString name = aVarLines[ctr].left( aVarLines[ctr].indexOf( " " ));
			QString value = aVarLines[ctr].mid( aVarLines[ctr].indexOf( " " ) + 1);

			if( value.startsWith( "= " ) )
				value = value.mid( 2 );

			if( name.length() > 0 )
			{
				// Special case for source code value of a lambda
				if( (irVariables.indexOf( "#<Lambda" ) > 0 ) && name.startsWith( "Instructions:" ) )
				{
					QStandardItem* aInstructionTree = new QStandardItem();
					ctr++;
					aInstructionTree->setText(name);
					for( int aCtr = ctr; aCtr < aVarLines.count(); aCtr++, ctr++ )
					{
						QString aDisplacement = aVarLines[aCtr].left( aVarLines[aCtr].indexOf( " " ));
						QString aSource = aVarLines[aCtr].mid( aVarLines[aCtr].indexOf( " " ) + 1);
						QList<QStandardItem*> aItemList;
						aItemList.append(new QStandardItem( aDisplacement ));
						aItemList.append(new QStandardItem( aSource ));
						aInstructionTree->insertRow( aInstructionTree->rowCount(), aItemList );
					}
					// Add the instruction tree to the parent row
					aParent->appendRow( aInstructionTree );
				}
				else
				// Default values, insert a row into the tree
				{
					aItem.append(new QStandardItem( name ));
					aItem.append(new QStandardItem( value ));
					aParent->insertRow( aParent->rowCount(), aItem );
				}
			}
		}
		cUi.upVarListTree->setExpanded( aParent->index(), true );
	}
	else
	if( ( irVariables.startsWith( "rv." )) ||
		( irVariables.startsWith( "av." )) ||
		( irVariables.startsWith( "pv." )) ||
		( irVariables.startsWith( "cv." )) ||
		( irVariables.startsWith( "tv." )) ||
		( irVariables.startsWith( "Sv." )) ||
		( irVariables.startsWith( "In." )))
	{
		QStringList aVarLines = irVariables.split('\177', QString::KeepEmptyParts);
		QStringList aCurrentVarList;
		QStandardItem* cpMatchedTree = NULL;
		long aCount = aVarLines.size();
		QList<QString> aIndexList;

		if( aCount > 0 )
		{
			// Create a regular expression that starts with "av."
			QRegExp aArgExp("^av.");
			// Remove it from the current list so that it will not be sorted.
			QStringList aArgumentList = aVarLines.filter( aArgExp );
			// Sorting Variable List
			aVarLines.sort();
			// Remove all argument variables from list first and add the unsorted variables
			for(int aCtr = 0; aCtr < aArgumentList.size(); aCtr++)
			{
				aVarLines.removeFirst();
			}
			// Add back the unsorted argument variable list.
			aVarLines = aVarLines + aArgumentList;

			for (long aLine = 0; aLine < aCount; ++aLine)
			{
				bool aMatchFound = false;
				QString data = aVarLines[aLine];
				QString name = data.mid( 3, data.indexOf( " = " ) - 3);
				QString value = data.mid( data.indexOf( " = " ) + 3);
				if( data.startsWith( "rv." ))
					cpMatchedTree = cpRegisterTree;
				else
				if( data.startsWith( "cv." ))
					cpMatchedTree = cpConstantTree;
				else
				if( data.startsWith( "pv." ))
					cpMatchedTree = cpPersistentTree;
				else
				if( data.startsWith( "tv." ))
					cpMatchedTree = cpTemporaryTree;
				else
				if( data.startsWith( "av." ))
					cpMatchedTree = cpArgumentTree;
				else
				if( data.startsWith( "Sv." ))
					cpMatchedTree = cpClassTree;
				else
				if( data.startsWith( "In." ))
					cpMatchedTree = cpInterfaceTree;

				if( cpMatchedTree != NULL )
				{
					int rowCount = cpMatchedTree->rowCount();
					for( ctr = 0; ctr < rowCount; ++ctr )
					{
						QStandardItem* aItem = cpMatchedTree->child( ctr );
						if( aItem->text() == name )
						{
							QString aValueText = cpMatchedTree->child( ctr, 1 )->text();
							if( aValueText.indexOf( "#<" ) == 0 )
							if( cpMatchedTree->child( ctr )->hasChildren() )
								cpMatchedTree->child( ctr )->removeRows( 0, cpMatchedTree->child( ctr )->rowCount() );
							cpMatchedTree->setChild( ctr, 1, new QStandardItem( value ));
							aMatchFound = true;
						}
					}

					if( aMatchFound == false )
					{
						QList<QStandardItem*> aItemList;
						aItemList.append(new QStandardItem( name ));
						aItemList.append(new QStandardItem( value ));
						cpMatchedTree->appendRow( aItemList );
					}
				}

				// Check if the variable is in the watch list, update the value in the watch dialog
				if( aWatchList.contains( name ) )
				{	
					cpWatchList->updateValue( data );
				}
				aCurrentVarList.append( data.left( data.indexOf( " = " )));
			}
			cleanVarTree(aCurrentVarList);
			QList<QStandardItem*> aItem;
			QString name = "No variables...";
			QString value = "";
			if(cpRegisterTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpRegisterTree->insertRow( cpRegisterTree->rowCount(), aItem );
			}
			if(cpArgumentTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpArgumentTree->insertRow( cpArgumentTree->rowCount(), aItem );
			}
			if(cpPersistentTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpPersistentTree->insertRow( cpPersistentTree->rowCount(), aItem );
			}
			if(cpConstantTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpConstantTree->insertRow( cpConstantTree->rowCount(), aItem );
			}
			if(cpTemporaryTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpTemporaryTree->insertRow( cpTemporaryTree->rowCount(), aItem );
			}
			if(cpClassTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpClassTree->insertRow( cpClassTree->rowCount(), aItem );
			}
			if(cpInterfaceTree->rowCount() == 0 )
			{
				aItem.clear();
				aItem.append(new QStandardItem( name ));
				aItem.append(new QStandardItem( value ));
				cpInterfaceTree->insertRow( cpInterfaceTree->rowCount(), aItem );
			}
		}
	}
	else
		debugLineEdit(irVariables);
}

/*!
\brief getFocusWidget - Returns the widget that currently has focus.

\return apFocus - The widget that currently has focus
\par Notes:
-# Inherited from the APage base class.
-# The widget that has focus receives keyboard and mouse input.
*/
QWidget* ADebugPage::getFocusWidget()
{
	QWidget* apFocus = focusWidget();
	return (apFocus == NULL) ? cUi.upCodeTextEdit : apFocus;
}

/*!
\brief getTabMenus - Returns the menus and the toolbar actions for the console page

\param orTabMenus - Reference to place to put the console page menu list.
\param orTabTools - Reference to place to put the console page tool list.
\param iSelected - True iff this tab is currently selected (not currently used).
\return void
\par Notes:
-# Inherited from the APage base class.
-# Used to update the Session Form menus and toolbar list.
*/
void ADebugPage::getTabMenus(AMenuList &orTabMenus, AToolList &orTabTools, bool iSelected)
{
    Q_UNUSED(iSelected);

	// Menus. No menus.
	orTabMenus.clear();
	orTabTools.clear();
}

void ADebugPage::onCmdReturnPressed()
{
	if (cpParentForm->debuggerActive())
		submit(cUi.upCmdLineEdit->text());
}
void ADebugPage::onWatchPressed()
{
	cpWatchList->show();
}

void ADebugPage::onCodeListDoubleClicked(const QModelIndex&)
{
	onRunToClicked();
}

void ADebugPage::onGoClicked()
{
	if (cpParentForm->debuggerActive())
	{	submit("g");
		cpParentForm->setCurrentTab(0/*Console*/, "");	// Switch focus to console tab.
	}
}

void ADebugPage::onHelpClicked()
{
	submit("?");
}

void ADebugPage::onQuitClicked()
{
	if (cpParentForm->debuggerActive())
	{	cCurrentLine = -1;
		submit("q");
	}
}

void ADebugPage::onRunToClicked()
{
	if (cpParentForm->debuggerActive())
	{
		QTextCursor aCursor = cUi.upCodeTextEdit->textCursor();
		QTextBlock aIndex;
		QTextBlock aCurrentBlock;
		QString aCurItem;
		QString aLastItem;
		long aLine = 0;
		aCurrentBlock = aCursor.block();
		for(aIndex = cUi.upCodeTextEdit->document()->begin(); aIndex!=cUi.upCodeTextEdit->document()->end(); aIndex = aIndex.next())
		{
			if(aIndex == aCurrentBlock) break;
			aLine++;
		}

		QModelIndex aIdx = cpCodeListModel->index(aLine, 0/*Column*/);
		if (aIdx.isValid())
		{
			aCurItem = cpCodeListModel->data(aIdx, Qt::DisplayRole).toString();
			if (!aCurItem.isEmpty())
			{
				aCurItem = aCurItem.left(6);
				aCurItem.prepend("t,");
				submit(aCurItem);
			}
		}
	}
}

void ADebugPage::onSourceClicked()
{
	cShowSource = !cShowSource;
	cUi.upSourceToolButton->setIcon(cShowSource ? cSourceOn : cSourceOff);
	if (cpParentForm->debuggerActive())
	{
		submit(cShowSource ? "d,s" : "d,a");
	}
}

void ADebugPage::onStepIntoClicked()
{
	if (cpParentForm->debuggerActive())
	{
		submit("t");
	}
}

void ADebugPage::onStepOutClicked()
{
	if (cpParentForm->debuggerActive())
	{	long aLastIx = cpCodeListModel->rowCount() - 1;
		QModelIndex aIdx = cpCodeListModel->index(aLastIx, 0/*Column*/);
		if (aIdx.isValid())
		{	QString aLastItem = cpCodeListModel->data(aIdx, Qt::DisplayRole).toString();
			// Check if the current line being stepped over is the last line of a lambda
			if(cCurrentLine + 1 == cCodeLinesCount)
				submit("t");
			else
			if (!aLastItem.isEmpty())
			{	aLastItem = aLastItem.left(6);
				aLastItem.prepend("t,");
				submit(aLastItem);
			}
		}
	}
}

void ADebugPage::onStepOverClicked()
{
	if (cpParentForm->debuggerActive() && cCurrentLine >= 0)
	{	// Return. Force step into if a return
		QModelIndex aIdx = cpCodeListModel->index(cCurrentLine, 0/*Column*/);
		QString aCurItem = cpCodeListModel->data(aIdx, Qt::DisplayRole).toString();
		if (!aCurItem.isEmpty())
		{
			// Check if the current line being stepped over is the last line of a lambda
			// Or if the current line is a "return" statement
			if(cCurrentLine + 1 == cCodeLinesCount || aCurItem.indexOf("return") >= 0)
				submit( "t" );
			else
				submit( "x" );
		}
	}
}

// Item. An item may have one of the following formats where * represents zero or more chars:
//	*#<StructureName>
//	Av.ArgumentName=*
//	Cv.ConstantName=*
//	Tv.TemporaryName=*
//	Pv.PersistentName=*
//	Rules.
//	 1.	If a structure (#<), show previous descent information in Vars display and descend one level.
//	 2.	If a variable, show value.
void ADebugPage::onVarListDoubleClicked(const QModelIndex& irIdx)
{
	if (!cpParentForm->debuggerActive()) return;
	long aCharPos = 0;
	QString aCmd;
	QString aVar = cpVarListModel->data(irIdx, Qt::DisplayRole).toString().simplified();
	long aBeg, aEnd;

	// VarName. Compose command for Xv.Name format.
	if ((aBeg = aVar.indexOf("#<")) < 0)
	{	if (aVar.mid(1, 2) == "v." && (aCharPos = aVar.indexOf('=', 0)) > 0)
		{	aCmd = "=(string " + aVar.left(aCharPos - 1) + " true)";
			submit (aCmd);
		}
	}
	// Structure. Else, extract history before structure., if any.
	else if ((aEnd = aVar.indexOf('>')) > 0)
	{	// History. History is a list of lines beginning and ending with  "===" that precedes the structure.
		QString aHistory;
		long aIy = 0;
		long aCurIy = irIdx.row();
		QModelIndex aIdy = cpVarListModel->index(0/*Row*/, 0/*Column*/);
		QString aLine = cpVarListModel->data(aIdy, Qt::DisplayRole).toString();
		if (aLine == "===")
		{	for (;;)
			{	aIdy = cpVarListModel->index(++aIy, 0/*column*/);
				aLine = cpVarListModel->data(aIdy, Qt::DisplayRole).toString();
				if (aIy < aCurIy && aLine != "===")
					aHistory += '\t' + aLine.simplified();
				else
					break;
			}
			aHistory += '\t';
		}
		else
			aHistory = "===\t";
		aHistory += aVar + "\t===\t";

		// Target. Extract target to be expanded.
		QString aTarget(aVar.mid(aBeg));

		cIdx = irIdx;
		// Cmd. Format and submit command.
		aCmd = "=(append {" + aHistory + "} (browseLib.Pv.delimitedString " + aTarget + " { = } #\\tab true))";
		submit(aCmd);
	}
}

/*!
 * \brief Update widget properties.
 *
 * \param[in] ipDebugPrams New widget properties.
 */
void ADebugPage::setParameters(AParameters* ipDebugParams)
{
	if (ipDebugParams != NULL)
	{
		QFont aNewFont(ipDebugParams->mFont, ipDebugParams->mFontSize);
		QWidget* aViewPort = cUi.upCodeTextEdit->viewport();
		QFontMetrics aFontMetrics = aViewPort->fontMetrics();
		// Retrieve the pixel width of a space to convert the tab into spaces
		long aPixelWidth = aFontMetrics.width( "W" );
		// If the font's pixel size is not set, set a default value
		if(aPixelWidth <= 0)
			aPixelWidth = 8;
		cTabWidth = (long)ipDebugParams->mTabWidth;

		cUi.upCodeTextEdit->setFont(aNewFont);
		cUi.upVarListTree->setFont(aNewFont);
		cUi.upCmdLineEdit->setFont(aNewFont);
		cUi.upResponseLineEdit->setFont(aNewFont);
		aPixelWidth = cTabWidth * aFontMetrics.width( "W" );
		cUi.upCodeTextEdit->setTabStopWidth( aPixelWidth );
		cUi.upCodeTextEdit->update();
		//aViewPort->update();
	}
}

/*!
\brief show - Enables this page

\return void
\par Notes:
-# Inherited from the APage base class.
-# Enables this page when this tab is selected.
*/
void ADebugPage::show()
{
	cUi.upCmdLineEdit->setEnabled(true);
	cUi.upGoToolButton->setEnabled(true);
	cUi.upHelpToolButton->setEnabled(true);
	cUi.upQuitToolButton->setEnabled(true);
	cUi.upRunToToolButton->setEnabled(true);
	cUi.upSourceToolButton->setEnabled(true);
	cUi.upStepIntoToolButton->setEnabled(true);
	cUi.upStepOutToolButton->setEnabled(true);
	cUi.upStepOverToolButton->setEnabled(true);
	cUi.upVarListTree->setEnabled(true);
}

void ADebugPage::submit(const QString& irCmd)
{
	if (cpParentForm->debuggerActive() && !irCmd.isEmpty())
	{	
		QString aShowVars = "";
		cpParentForm->enable(false/*IsEnabled*/);
		cpParentForm->setDebuggerActive(false);
		cpParentForm->setEngineState(1/*Enable*/);
		cpAppClient->debug(cpReturnRcvr, irCmd);
		// Disable GUI.
		cUi.upCmdLineEdit->setEnabled(false);
		cUi.upGoToolButton->setEnabled(false);
		cUi.upHelpToolButton->setEnabled(false);
		cUi.upQuitToolButton->setEnabled(false);
		cUi.upRunToToolButton->setEnabled(false);
		cUi.upSourceToolButton->setEnabled(false);
		cUi.upStepIntoToolButton->setEnabled(false);
		cUi.upStepOutToolButton->setEnabled(false);
		cUi.upStepOverToolButton->setEnabled(false);
		cUi.upVarListTree->setEnabled(false);
	}
	else
		cpParentForm->statusAlert("Debugger is not active");
}

void ADebugPage::cleanVarTree(const QStringList iList)
{
	QStringList aIndexList;
	long ctr = 0;
	long ctr2 = 0;
	long rowCount = 0;
	//Mark and store index for removal first for each classified tree
	//Removal happens after marking, it crashes if you remove it on the first loop
	if( cpRegisterTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpRegisterTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpRegisterTree->child( ctr );
			QString aItemName = QString("rv." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpRegisterTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpRegisterTree->child( ctr2 );
				QString aItemName = QString("rv." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpRegisterTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpArgumentTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpArgumentTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpArgumentTree->child( ctr );
			QString aItemName = QString("av." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpArgumentTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpArgumentTree->child( ctr2 );
				QString aItemName = QString("av." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpArgumentTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpPersistentTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpPersistentTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpPersistentTree->child( ctr );
			QString aItemName = QString("pv." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpPersistentTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpPersistentTree->child( ctr2 );
				QString aItemName = QString("pv." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpPersistentTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpConstantTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpConstantTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpConstantTree->child( ctr );
			QString aItemName = QString("cv." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpConstantTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpConstantTree->child( ctr2 );
				QString aItemName = QString("cv." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpConstantTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpTemporaryTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpTemporaryTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpTemporaryTree->child( ctr );
			QString aItemName = QString("tv." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpTemporaryTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpTemporaryTree->child( ctr2 );
				QString aItemName = QString("tv." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpTemporaryTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpClassTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpClassTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpClassTree->child( ctr );
			QString aItemName = QString("Sv." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpClassTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpClassTree->child( ctr2 );
				QString aItemName = QString("Sv." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpClassTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
	if( cpInterfaceTree->hasChildren() )
	{
		aIndexList.clear();
		rowCount = cpInterfaceTree->rowCount();
		for( ctr = 0; ctr < rowCount; ++ctr )
		{
			QStandardItem* aItem = cpInterfaceTree->child( ctr );
			QString aItemName = QString("In." + aItem->text());
			if( iList.contains(aItemName) == false)
				aIndexList.append(aItemName);
		}
		// Remove the non-existing variables from the tree
		for( ctr = aIndexList.count() - 1; ctr >= 0; --ctr )
		{
			rowCount = cpInterfaceTree->rowCount();
			for( ctr2 = 0; ctr2 < rowCount; ++ctr2 )
			{
				QStandardItem* aItem = cpInterfaceTree->child( ctr2 );
				QString aItemName = QString("In." + aItem->text());
				if( aItemName == aIndexList[ctr] )
				{
					cpInterfaceTree->removeRow( ctr2 );
					break;
				}
			}
		}
	}
}

bool ADebugPage::eventFilter(QObject* o, QEvent* e)
{
Q_UNUSED(o);
QString aCmd;
QString aSelectedText;
QPoint aPoint;
switch( e->type() )
{
	case QEvent::MouseButtonDblClick:
		{
			QWidget* aViewPort = cUi.upCodeTextEdit->viewport();
			QFontMetrics aFontMetrics = aViewPort->fontMetrics();
			// Retrieve the pixel width of a space to convert the tab into spaces
			long aPixelWidth = aFontMetrics.width( "000000:" ) + cUi.upCodeTextEdit->lineNumberAreaWidth();

			aPoint = cUi.upCodeTextEdit->mapFromGlobal( QCursor::pos() );
			if(aPoint.x() > cUi.upCodeTextEdit->lineNumberAreaWidth() && aPoint.x() <= aPixelWidth)
			{
				onRunToClicked();
				return true;
			}
		}
	break;
	case QEvent::MouseButtonRelease:
	aSelectedText = cUi.upCodeTextEdit->textCursor().selectedText().trimmed();
	if( aSelectedText.length() > 0 && (aSelectedText == aSelectedText.simplified() ))
	{
		aCmd = "=(string (cond ((<> #void rv." + aSelectedText + ")(append {***" + aSelectedText + ": }rv." + aSelectedText +  "))";
		aCmd += "((<> #void cv." + aSelectedText + ")(append {***" + aSelectedText + ": } cv." + aSelectedText +  "))";
		aCmd += "((<> #void pv." + aSelectedText + ")(append {***" + aSelectedText + ": } pv." + aSelectedText +  "))";
		aCmd += "((<> #void tv." + aSelectedText + ")(append {***" + aSelectedText + ": } tv." + aSelectedText +  "))";
		aCmd += "((<> #void av." + aSelectedText + ")(append {***" + aSelectedText + ": } av." + aSelectedText +  "))";
		aCmd += "((<> #void Sv." + aSelectedText + ")(append {***" + aSelectedText + ": } Sv." + aSelectedText +  "))";
		aCmd += "((<> #void In." + aSelectedText + ")(append {***" + aSelectedText + ": } In." + aSelectedText +  "))";
		aCmd += "(else (append {*** " + aSelectedText + ": } " + aSelectedText + "))))";
		submit(aCmd);
		return true;
	}
	break;
	case QEvent::MouseButtonPress:
		return false;
	break;
	default:
		return false;
	break;
}

return false;
}

void ADebugPage::onVarListExpanded()
{
	sendShowVarList(true);
}

void ADebugPage::onVarListCollapsed()
{
	sendShowVarList(false);
}

void ADebugPage::sendShowVarList(bool aRetrieveVarsFlag)
{
	QString aVarList = "";
	QModelIndex aIdx;

	aIdx = cpVarListModel->indexFromItem( cpTemporaryTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",t";
	aIdx = cpVarListModel->indexFromItem( cpClassTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",s";
	aIdx = cpVarListModel->indexFromItem( cpInterfaceTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",i";
	aIdx = cpVarListModel->indexFromItem( cpRegisterTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",r";
	aIdx = cpVarListModel->indexFromItem( cpArgumentTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",a";
	aIdx = cpVarListModel->indexFromItem( cpPersistentTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",p";
	aIdx = cpVarListModel->indexFromItem( cpConstantTree );
	if( cUi.upVarListTree->isExpanded( aIdx ) )
		aVarList += ",c";

	// Append a 'v' character so that the engine will return a new list of variables
	if(aRetrieveVarsFlag == true)
	{
		aVarList += ",v";
	}
	// Format the command to be sent to the server
	if(aVarList != "" && aVarList.startsWith(","))
		aVarList = "s=" + aVarList.mid(1);

	if(aVarList != "" && cVarList != aVarList)
	{
		// Store the new VarList to being sent to the server
		cVarList = aVarList;
		submit(aVarList);
	}
}

void ADebugPage::onWatchVariable()
{
	QModelIndex aIdx = cUi.upVarListTree->currentIndex();
	QStandardItem* aParent = cpVarListModel->itemFromIndex( aIdx.parent() );
	// Add the variable to the watch list iff it is a first level variable
	if( cpRegisterTree == aParent ||
		cpArgumentTree == aParent ||
		cpPersistentTree == aParent ||
		cpConstantTree == aParent ||
		cpTemporaryTree == aParent ||
		cpClassTree == aParent ||
		cpInterfaceTree == aParent ) 
	{
		QStandardItem* aItem = cpVarListModel->itemFromIndex(aIdx.sibling(aIdx.row(),0));
		cpWatchList->watchVariable( aItem->text() );
	}
}

void ADebugPage::showTreeContextMenu(const QPoint& point)
{
   cpVarListTreeMenu->exec(cUi.upVarListTree->viewport()->mapToGlobal(point));
}
// end
