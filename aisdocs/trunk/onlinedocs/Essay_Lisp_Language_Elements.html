
<HTML>
<HEAD>
<link rel="stylesheet" type="text/css" href="../CoreContent/help.css">
<TITLE>AIS Essay Template</TITLE></HEAD>
<!--Page Parameters -->
<BODY BGCOLOR="#FFFFF0" TEXT="#000000" LINK="#0000ff">

<A NAME="topage"></A>
<A HREF="TOP"></A>



<P>&nbsp;</P>

<FONT COLOR="#000080"><H1>Lisp Language Elements</H1></FONT>
<P>&nbsp;</P>

<UL>
<li><a href="#SOverview"><FONT SIZE=2>Overview</font></a></li><li><a href="#SLambda Declaration"><FONT SIZE=2>Lambda Declaration</font></a></li><li><a href="#SBuilt-in AIS Functions and Objects"><FONT SIZE=2>Built-in AIS Functions and Objects</font></a></li><li><a href="#SAccessing with ref"><FONT SIZE=2>Accessing with ref</font></a></li><li><a href="#SAssigning with setq"><FONT SIZE=2>Assigning with setq</font></a></li><li><a href="#SBracket Operator []"><FONT SIZE=2>Bracket Operator []</font></a></li><li><a href="#SDot Operator ."><FONT SIZE=2>Dot Operator .</font></a></li><li><a href="#SOffset Addressing"><FONT SIZE=2>Offset Addressing</font></a></li><li><a href="#SCircumflex Operator ^"><FONT SIZE=2>Circumflex Operator ^</font></a></li><li><a href="#SQuote Operator '"><FONT SIZE=2>Quote Operator '</font></a></li><li><a href="#SColon Operator :"><FONT SIZE=2>Colon Operator :</font></a></li><li><a href="#SAt Operator @"><FONT SIZE=2>At Operator @</font></a></li><li><a href="#SMath Operators + - * /"><FONT SIZE=2>Math Operators + - * /</font></a></li><li><a href="#SMath Operators + - * /"><FONT SIZE=2>Math Operators + - * /</font></a></li><li><a href="#SMath Assignors += -= *= /="><FONT SIZE=2>Math Assignors += -= *= /=</font></a></li><li><a href="#SMath Incrementors ++ --"><FONT SIZE=2>Math Incrementors ++ --</font></a></li><li><a href="#SRelational Operators &lt; &lt;= = == &lt;&gt; &gt;= &gt;"><FONT SIZE=2>Relational Operators &lt; &lt;= = == &lt;&gt; &gt;= &gt;</font></a></li><li><a href="#SComparison Operators LT LE EQ NE GE GT"><FONT SIZE=2>Comparison Operators LT LE EQ NE GE GT</font></a></li><li><a href="#Slambda"><FONT SIZE=2>lambda</font></a></li><li><a href="#Sdefclass"><FONT SIZE=2>defclass</font></a></li><li><a href="#Sdefclone"><FONT SIZE=2>defclone</font></a></li><li><a href="#Sdefun"><FONT SIZE=2>defun</font></a></li><li><a href="#Sdefchild"><FONT SIZE=2>defchild</font></a></li><li><a href="#Sdefine"><FONT SIZE=2>define</font></a></li><li><a href="#Sdefmacro"><FONT SIZE=2>defmacro</font></a></li><li><a href="#Sdefmethod"><FONT SIZE=2>defmethod</font></a></li><li><a href="#Sdefriend"><FONT SIZE=2>defriend</font></a></li><li><a href="#Sdeforphan"><FONT SIZE=2>deforphan</font></a></li><li><a href="#Sdefstruct"><FONT SIZE=2>defstruct</font></a></li><li><a href="#Sdefvm"><FONT SIZE=2>defvm</font></a></li><li><a href="#Sand"><FONT SIZE=2>and</font></a></li><li><a href="#SargCount"><FONT SIZE=2>argCount</font></a></li><li><a href="#SargFetch"><FONT SIZE=2>argFetch</font></a></li><li><a href="#Sbegin"><FONT SIZE=2>begin</font></a></li><li><a href="#Scase"><FONT SIZE=2>case</font></a></li><li><a href="#Scompile"><FONT SIZE=2>compile</font></a></li><li><a href="#Scond"><FONT SIZE=2>cond</font></a></li><li><a href="#Seval"><FONT SIZE=2>eval</font></a></li><li><a href="#Sgoto"><FONT SIZE=2>goto</font></a></li><li><a href="#SConditional goto"><FONT SIZE=2>Conditional goto</font></a></li><li><a href="#Sif"><FONT SIZE=2>if</font></a></li><li><a href="#Slet"><FONT SIZE=2>let</font></a></li><li><a href="#Slisp"><FONT SIZE=2>lisp</font></a></li><li><a href="#Sloop"><FONT SIZE=2>loop</font></a></li><li><a href="#Smorph"><FONT SIZE=2>morph</font></a></li><li><a href="#Smyself"><FONT SIZE=2>myself</font></a></li><li><a href="#Snot"><FONT SIZE=2>not</font></a></li><li><a href="#SonError"><FONT SIZE=2>onError</font></a></li><li><a href="#Sor"><FONT SIZE=2>or</font></a></li><li><a href="#Sparse"><FONT SIZE=2>parse</font></a></li><li><a href="#Squote"><FONT SIZE=2>quote</font></a></li><li><a href="#Srefmacro"><FONT SIZE=2>refmacro</font></a></li><li><a href="#Sreturn"><FONT SIZE=2>return</font></a></li><li><a href="#Ssend"><FONT SIZE=2>send</font></a></li><li><a href="#Ssetq"><FONT SIZE=2>setq</font></a></li><li><a href="#Ssuper"><FONT SIZE=2>super</font></a></li><li><a href="#Swhile"><FONT SIZE=2>while</font></a></li>
</UL>

<P><H2><A NAME="SOverview"></A>Overview</H2></P>
		<div class="h2section" id="Overview">
		<p>The Lisp language is characterized by functions, macros, special forms, and
		  lexical forms. These functions, macros, special forms, and lexical forms
		  contain everything from basic control flow operators to language keywords. All
		  of the basic language elements of AIS Lisp are contained in this chapter.</p>
		  <p>All Lisp macros, special forms, and lexical forms are understood only by
		  the Lisp compiler.</p>
		  <p>Lisp, heavily influenced by the <i>functional programming</i> paradigm, is
		  a language composed entirely of function calls. Each function call is inclosed
		  in parentheses <b>(function ...agruments...)</b>. It is this focus on the
		  parenthetically enclosed function call which gives Lisp its multiplicity of
		  parens.</p>
		  <p>The best pocket introduction to the essential elements of AIS Lisp is the
		  following table of Lisp essential flow of control language elements.</p>
		    <!-- Arguments Table Template -->
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>(ref ... )</th>
		      <td>Access statement</td>
		    </tr>
		    <tr>
		      <th>(setq ... )</th>
		      <td>Assignment statement</td>
		    </tr>
		    <tr>
		      <th>(if ... then ... else ... )</th>
		      <td>Conditional statement</td>
		    </tr>
		    <tr>
		      <th>(loop ... )</th>
		      <td>Iteration statement</td>
		    </tr>
		    <tr>
		      <th>(while ... )</th>
		      <td>Iteration statement</td>
		    </tr>
		    <tr>
		      <th>(cond ... case ... case ... )</th>
		      <td>Conditional case statement</td>
		    </tr>
		    <tr>
		      <th>(goto ... )</th>
		      <td>Transfer of control statement</td>
		    </tr>
		    <tr>
		      <th>(defclass ... )</th>
		      <td>Class (user defined) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(defclone ... )</th>
		      <td>Clone (user defined) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(lambda ... )</th>
		      <td>Lambda(<i>function</i>) building statement</td>
		    </tr>
		    <tr>
		      <th>(defun ... )</th>
		      <td>Lambda(<i>function</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(defchild ... )</th>
		      <td>Lambda(<i>function</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(defriend ... )</th>
		      <td>Lambda(<i>function</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(deforphan ... )</th>
		      <td>Lambda(<i>function</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(defmethod ... )</th>
		      <td>Lambda(<i>method</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>(defvm ... )</th>
		      <td>Lambda(<i>virtual machine</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>regs:(...)</th>
		      <td>Lambda(<i>register</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>vars:(...)</th>
		      <td>Lambda(<i>variable</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>svars:(...)</th>
		      <td>Object(<i>variable</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>pvars:(...)</th>
		      <td>Lambda(<i>variable</i>) declaration statement</td>
		    </tr>
		    <tr>
		      <th>cvars:(...)</th>
		      <td>Lambda(<i>variable</i>) declaration statement</td>
		    </tr>
		  </table> 
		  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SLambda Declaration"></A>Lambda Declaration</H2></P>   
		    <div class="h2section" id="Lambda Declaration">
			<p>The <b>lambda</b> special form creates and returns an instance of an <a href="Lambda.htm">Lambda</a> object. 
			  Each Lambda is an executable software object which is storable as a fundamental unit of data in an AIS
			  repository and can be mobile between copies of Analytic Information Server across the Internet.
			  AIS Lisp provides several ways to declare an <a href="Lambda.htm">Lambda</a>. The <b>lambda</b> function
			  supports the creation of unbound-unnamed Lambdas. There are multiple ways of declaring bound-named Lambdas
			  as follows.</p> 
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>defun</th>
			      <td>Declaration of globally bound and named Lambda. May be declared <u>inside</u> the body of another
			      Lambda declaration. If declared <u>inside</u> another <i>parent</i> Lambda declaration, this Lambda automatically 
			      becomes the <i>child</i> of its parent Lambda. The child Lambda will be bound to its name in the <b>Pv</b>
			      persistent storage Structure of the parent Lambda. The child's <b>Pv</b> and <b>Cv</b> persistent storage
			      Structures will be identical (<i>the exact same objects</i>) as its parent Lambda. 
			      </td>
			    </tr>
			    <tr>
			      <th>defchild</th>
			      <td>Declaration of a child Lambda to a globally bound and named parent Lambda. Must be declared <u>outside</u> 
			      the body of the parent Lambda declaration. The parent Lambda must already have declared a <b>pvars</b>
			      variable of the same name as declared in this child Lambda. The child Lambda will be bound to its name in the <b>Pv</b>
			      persistent storage Structure of the parent Lambda. The child's <b>Pv</b> and <b>Cv</b> persistent storage
			      Structures will be identical (<i>the exact same objects</i>) as its parent Lambda. 
			      </td>
			    </tr>
			    <tr>
			      <th>defriend</th>
			      <td>Declaration of a friend Lambda to a globally bound and named parent Lambda. Must be declared <u>outside</u> 
			      the body of the parent Lambda declaration. The parent Lambda must already have declared a <b>pvars</b>
			      variable of the same name as declared in this friend Lambda. The friend Lambda will be bound to its name in the <b>Pv</b>
			      persistent storage Structure of the parent Lambda. The parent's <b>Pv</b> persistent storage Structure will be
			      unknown to the friend Lambda. The friend's <b>Pv</b> persistent storage Structure will be identical to the <b>Cv</b> 
			      persistent storage Structure of its parent Lambda. The friend's <b>Cv</b> persistent storage Structure will be
			      unknown to the parent Lambda.
			      </td>
			    </tr>
			    <tr>
			      <th>deforphan</th>
			      <td>Declaration of an orphan Lambda to a globally bound and named parent Lambda. Must be declared <u>outside</u> 
			      the body of the parent Lambda declaration. The parent Lambda must already have declared a <b>pvars</b>
			      variable of the same name as declared in this orphan Lambda. The orphan Lambda will be bound to its name in the <b>Pv</b>
			      persistent storage Structure of the parent Lambda. The parent's <b>Pv</b> and <b>Cv</b> persistent storage Structures will be
			      unknown to the orphan Lambda. The orphan's <b>Pv</b> and <b>Cv</b> persistent storage Structures will be separate
			      and distinct from those of its parent Lambda.
			      </td>
			    </tr>
			    <tr>
			      <th>defmethod</th>
			      <td>Declaration of a bound and named method Lambda to an owner data type (Object Oriented Programming Paradigm). 
			      The owner data type must already have been declared. The method Lambda will be bound to its name in the methods
			      Dictionary associated with its owner data type.
			      </td>
			    </tr>
			    <tr>
			      <th>defmacro</th>
			      <td>Declaration of globally bound and named Lisp macro Lambda. Will automatically be recognized by the <b>morph</b>
			      and <b>compile</b> functions during compilation. 
			      </td>
			    </tr>
			    <tr>
			      <th>defvm</th>
			      <td>Declaration of a globally bound and named Lambda virtual machine. Can be assigned as the virtual machine of any
			      Lambda, and will be responsible for controling the Lambda's behavior. 
			      </td>
			    </tr>
			  </table>
			  <p>Each Lambda declaration contains the declaration of variables (including argument variables), the declaration of
			  Lambda interfaces, and any Lambda event keywords.</p>
			  <h3>Variable Declarations</h3>
			  <p>AIS Lisp supports the declaration of local variables. There are five categories of local variables for each Lambda.</p>
			  <ul>
			    <li>Argument variables passed (<i>on the stack</i>) to the Lambda upon
			      invocation (<b>args</b>)</li>
			    <li>Temporary variables allocated (<i>on the stack</i>) by the Lambda upon
			      invocation (<b>vars</b>)</li>
			    <li>Persistent variables allocated (<i>in the Pv Structure</i>) for the life
			      of the Lambda (<b>pvars</b>)</li>
			    <li>Persistent variables allocated (<i>in the Cv Structure</i>) for the life
			      of the Lambda (<b>cvars</b>)</li>
			    <li>Register variables allocated (<i>in the microchip</i>) by the Lambda upon
			      invocation (<b>regs</b>)</li>
			  </ul>
			  <p>The <b>vars</b>, <b>pvars</b>, and <b>cvars</b> local variable allocations
			  may include initialization specifications along with their declarations. The <b>regs</b>
			  local variable allocations may include data type specifications along with
			  their declarations.</p>
			  <!-- Code Eaxmples Template -->
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun foo(<b>n</b>) ;; Variable <b>n</b> is an argument variable.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  vars:(<b>x</b> Number:<b>y</b>) ;; <b>y</b> and <b>y</b> are temporary variables.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  pvars:((<b>a</b> 20)) ;; Variable <b>a</b> is a persistent variable initialized to type Word with a value of 20.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  cvars:(<b>b</b>) ;; Variable <b>b</b> is a persistent variable uninitialized defaulted to Word type.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  regs:(Integer:<b>myReg</b>) ;; Variable <b>myReg</b> is a microchip register variable typed as Integer.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  true)</p>
			  <p>An Analytic Information Server Lambda may be defined, with a definite list (fixed) or an indefinite list of arguments. 
			  Ellipses (<b>...</b>) at the end of the argument list indicate the function has indefinite arguments. 
			  At run time, the Lambda's actual arguments are bound to the specified formal definite arguments respectively. 
			  An error is generated if there are too few arguments in the definite argument list.  If the number of actual arguments exceeds 
			  the number of definite arguments, and the function has been defined as having indefinite arguments, 
			  the excess arguments can only be accessed via the argCount and argFetch functions at run time.  
			  When called, the Lambda receives its arguments on the <i>stack</i>. The arguments are received and bound to the proper arguments.</p>
			  <p>&nbsp;</p>
			  <h3>Interface Declarations</h3>
			  <p>AIS Lisp supports the declaration of Lambda interfacesas well as the declaration of event keywords.
			  The keyword <b>faces:</b> declares the interfaces feature Structure of the Lambda. The features are specified 
			  as list constants, <b>faces:((name Alice))</b>, the listed feature is initialized to the value specified.</p>
			  <p>The keyword <b>doomed:</b>  declares that the Lambda is to be evaluated, by the garbage collector, when the Lambda is doomed. 
			  The Lambda?s EvalWhenDoomed element is set to true. The Lambda is always evaluated, by the garbage collector, with no arguments.</p>
			  <!-- Code Eaxmples Template -->
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun foo() ;; Lambda is declared with no argument variables.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  faces:((English  true) (French  false)) ;; Declaration of English and French interface protocols.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  Doomed: ;; This Lambda will be executed just before it is destroyed.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  true)</p>
			  <!-- Type and Syntax Template -->
			  <p>&nbsp;</p>
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defchild parent:name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defriend parent:name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (deforphan parent:name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defmethod typeSymbol:name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defmacro name(arguments) variables interfaces body)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defvm name(arguments) variables interfaces body)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>name</th>
			      <td>The name to which the Lambda is to be bound.</td>
			    </tr>
			    <tr>
			      <th>arguments</th>
			      <td>The list of argument variable declarations.</td>
			    </tr>
			    <tr>
			      <th>variable declarations</th>
			      <td>The list of local variable declarations.</td>
			    </tr>
			    <tr>
			      <th>body</th>
			      <td>The Lisp expressions which make up the execution instructions for the Lambda.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>An executable Lambda object.</td>
			    </tr>
			  </table>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>parent</th>
			      <td>The name of the parent Lambda into which the Lambda is to be bound.</td>
			    </tr>
			    <tr>
			      <th>name</th>
			      <td>The name to which the Lambda is to be bound.</td>
			    </tr>
			    <tr>
			      <th>arguments</th>
			      <td>The list of argument variable declarations.</td>
			    </tr>
			    <tr>
			      <th>variable declarations</th>
			      <td>The list of local variable declarations.</td>
			    </tr>
			    <tr>
			      <th>body</th>
			      <td>The Lisp expressions which make up the execution instructions for the Lambda.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>An executable Lambda object.</td>
			    </tr>
			  </table>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>typeSymbol</th>
			      <td>The name of the owner data type into whose method list the Lambda is to be bound.</td>
			    </tr>
			    <tr>
			      <th>name</th>
			      <td>The name to which the Lambda is to be bound.</td>
			    </tr>
			    <tr>
			      <th>arguments</th>
			      <td>The list of argument variable declarations.</td>
			    </tr>
			    <tr>
			      <th>variable declarations</th>
			      <td>The list of local variable declarations.</td>
			    </tr>
			    <tr>
			      <th>body</th>
			      <td>The Lisp expressions which make up the execution instructions for the Lambda.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>An executable Lambda object.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the lambda special form and other Lambda declaration forms when an Lambda is to be created for use 
			  in your application program.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>These examples demonstrate some simple properties of the <b>lambda</b> special form. 
			  Here the lambda returns a simple Lambda.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (lambda(X)  (+  X  X))<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 392&gt;</p>
			  <p>Here a simple Lambda is declared bound to a global variable.</p> 
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun  foo(X)  (+  X  X))<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 312&gt;</p>
			  <p>Here the Lambda is invoked with the argument 4.</p> 
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo  4)<i>Returns</i>&nbsp;&nbsp;&nbsp;8</p>
			  <p>Here the Lambda is immediately invoked with the argument 4.</p> 
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  ((lambda(X)  (+  X  X))  4)<i>Returns</i>&nbsp;&nbsp;&nbsp;8</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 2</u></b></p>
			  <p>Here a slightly more complex Lambda which is declared bound to a global variable.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun sumNums(X ...)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  vars:(Z)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq  Z  X)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (loop for i from 1 to (1+ (argCount)) do</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq Z (+  Z  (argFetch i)))))</p>
			  <p>Here the Lambda is invoked with the arguments 4 5 and 71.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (sumNums  4  5  71)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;80</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 3</u></b></p>
			  <p>This example defines an Lambda named <b>foo</b> with a child Lambda named <b>sum</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun foo(x)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  pvars:(y)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (defun sum(x) (+ x y))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq y x))</p>
			  <p>Here we invoke the parent Lambda <b>foo</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo  9)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;9</p>
			  <p>Here we invoke the child Lambda <b>sum</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo.sum 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;11</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The scope of variables in nested Lambdas depends upon the following Lisp compilation rules: 
			  Nested Lambdas do not share either their argument or their temporary variables. The argument and the temporary 
			  variables are always limited in scope to the immediate Lambda object. A nested Lambda both shares and extends 
			  the persistent variables (pvars) of its parents. When a variable reference is encountered, the Lisp compiler 
			  first searches the local Lambda's arguments for a match, then the searches the local Lambda's temporary variables (vars) 
			  for a match, finally searches the Lambda's extended persistent variables (pvars) and then the (cvars) for a match.  
			  A referenced variable, without a match, always refers to the global value of the variable.</p> 
			  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SBuilt-in AIS Functions and Objects"></A>Built-in AIS Functions and Objects</H2></P>   
		     <div class="h2section" id="Built-in AIS Functions and Objects">
			 <p>All of the built-in AIS functions and objects are available to Lisp programs.
			  Functions such as <b>append</b>, <b>left</b>, <b>avg</b>, <b>sqrt</b>, etc.
			  are all available to Lisp programs. Objects such as <b>Vector</b>, <b>String</b>, 
			  <b>Structure</b>, <b>Repository</b>, etc. are all available to Lisp programs. 
			  Also available to all Lisp programs is a rich library of native data types. 
			  In order to benefit from the full power of the AIS environment, the Lisp programmer 
			  should become familiar with the many libraries of functions, macros, and object types
			  available.</p>
			  <p>&nbsp;</p>
			  <p>The following reference guides may be of some help.</p>
			  <ul>
			    <li><a href="Axfunc.htm">Math Functions</a></li>
			    <li><a href="Axfunc.htm">Trig Functions</a></li>
			    <li><a href="Axfunc.htm">BitWise Functions</a></li>
			    <li><a href="Axfunc.htm">File IO Functions</a></li>
			    <li><a href="Axfunc.htm">Built-in Macros</a></li>
			    <li><a href="MatrixFunctions.htm">NAG Matrix Functions</a></li>
			    <li><a href="StatFunctions.htm">NAG Statistical Functions</a></li>
			    <li><a href="Lambda.htm">Lambda Objects</a></li>
			    <li><a href="Axnative.htm">Native Types</a></li>
			    <li><a href="Axstring.htm">String Types</a></li>
			    <li><a href="Axlist.htm">Pair (and List) Types</a></li>
			    <li><a href="Axvector.htm">Vector Types</a></li>
			    <li><a href="Axmatrix.htm">Matrix Types</a></li>
			    <li><a href="Axstruct.htm">Structure Types</a></li>
			    <li><a href="Axdictionary.htm">Dictionary Types</a></li>
			    <li><a href="Axdirectory.htm">Directory Types</a></li>
			    <li><a href="Axcomplex.htm">Complex Types</a></li>
			    <li><a href="NeuralNet.htm">Neural Nets</a></li>
			    <li><a href="VectorMachines.htm">Vector Machines</a></li>
			    <li><a href="Axrepo.htm">Lambda Repositories</a></li>
			    <li><a href="Axcontext.htm">Lambda Contexts</a></li>
			    <li><a href="LambdaCompiler.htm">LambdaCompiler</a></li>
			    <li><a href="Axxml.htm">XML</a></li>
			    <li><a href="Alice.htm">AIML</a></li>
			    <li><a href="Xquery.htm">XQuery</a></li>
			    <li><a href="parseLib.htm">parseLib</a></li>
			    <li><a href="browseLib.htm">browseLib</a></li>
			    <li><a href="dataMineLib.htm">dataMineLib</a></li>
			    <li><a href="indexLambda.htm">index Lambda</a></li>
			    <li><a href="xmlBase.htm">xmlBase Lambda</a></li>
			    <li><a href="Alice.htm">Alice Chat Robot</a></li>
			    <li><a href="math.htm">math Lambda</a></li>
			    <li><a href="rulesLib.htm">rulesLib</a></li>
			  </ul>     
			  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SAccessing with ref"></A>Accessing with ref</H2></P>  
		<div class="h2section" id="Accessing with ref">
			<p>The <b>ref</b> function is the fundamental access statement of Lisp. The <b>ref</b>
			  function supports both direct referencing and indexed referencing of elements
			  within an object. The <b>ref</b> function must always be passed one variable
			  argument; and, can be passed one, two, or three, index arguments. In each case
			  The <b>ref</b> function returns the result of referencing the variable with
			  one, two, or three index arguments.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ref variable)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ref variable index1)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ref variable index1
			  index2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ref variable index1
			  index2 index3)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>variable</th>
			      <td>The target of the reference attempt (the ultimate behavior of <b>ref</b>
			        is dependent upon the data type of the target).</td>
			    </tr>
			    <tr>
			      <th>index1</th>
			      <td>(Optional) First index argument.</td>
			    </tr>
			    <tr>
			      <th>index2</th>
			      <td>(Optional) Second index argument.</td>
			    </tr>
			    <tr>
			      <th>index3</th>
			      <td>(Optional) Third index argument.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>ref</b> function when indexed referencing of an AIS object is
			  essential to the correct operation of your program.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample object retrievals using the <b>ref</b> function.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Vector:3 45 -6 78)) ;; Set the
			  newly created vector object into the variable x.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;78</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x 0)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;45</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Structure: A: 45 B: -6 C: 78))
			  ;; Set the Structure object into the variable x.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x C:)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;78</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x A:)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;45</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x 2 1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;78</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x &quot;Hello World&quot;) ;; Set the
			  string &quot;Hello World&quot; into the variable x.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x 1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#\e</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ref x 6)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#\W</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Refer to the appropriate object data type reference guide to determine the
			  effect of the <b>ref</b> function on that specific type or even what types of
			  indices the <b>ref</b> function can take. For String objects refer to the <a href="axstring.htm">String
			  Object Reference Guide</a>, For Vector objects refer to the <a href="axvector.htm">Vector
			  Object Reference Guide</a>, For Dictionary objects refer to the <a href="axdictionary.htm">Dictionary
			  Object Reference Guide</a>, etc.</p>    
			  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SAssigning with setq"></A>Assigning with setq</H2></P>  
		<div class="h2section" id="Assigning with Setq">
		  <!-- Overview Template -->
		  <p class="overview">Overview</p>
		  <p>The <b>setq</b> special form is the fundamental assignment statement of
		  Lisp. The <b>setq</b> special form supports both direct assignment and indexed
		  assignment of elements within an object. The <b>setq</b> special form must
		  always be passed one receiver argument, and one new value argument; and, can
		  be passed one, two, or three, index arguments. In each case The <b>setq</b>
		  special form returns the result of assigning the new value argument to the
		  receiver argument with one, two, or three index arguments.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">special
		  form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq receiver newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq (ref receiver
		  index1) newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq (ref receiver
		  index1 index2) newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq (ref receiver
		  index1 index2 index3) newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set receiver index1
		  newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set receiver index1
		  index2 newValue)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (set receiver index1
		  index2 index3 newValue)</p>
		  <p>&nbsp;</p>
		    <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>receiver</th>
		      <td>The target of the assignment attempt (the ultimate behavior of <b>setq</b>
		        is dependent upon the data type of the receiver).</td>
		    </tr>
		    <tr>
		      <th>index1</th>
		      <td>(Optional) First index argument.</td>
		    </tr>
		    <tr>
		      <th>index2</th>
		      <td>(Optional) Second index argument.</td>
		    </tr>
		    <tr>
		      <th>index3</th>
		      <td>(Optional) Third index argument.</td>
		    </tr>
		    <tr>
		      <th>newValue</th>
		      <td>The new value to be assigned to the receiver.</td>
		    </tr>
		  </table>
		  <hr>
		    <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the <b>setq</b> special form when indexed assignment of an AIS object
		  is essential to the correct operation of your program.</p>
		    <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here are just a few sample object assignments using the <b>setq</b> special
		  form.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Vector:3 45 -6 78)) ;; Set the
		  newly created vector object into the variable x.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (set x 2 20)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(45
		  -6 20)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq (ref x 0) -65)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(-65
		  -6 20)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Structure: A: 45 B: -6 C: 78))
		  ;; Set the Structure object into the variable x.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq (ref x C:) 22)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A
		  45 B -6 C 22}</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (set x A: 16)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A
		  16 B -6 C 22}</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (set x 1 0 X:)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A
		  16 X -6 C 22}</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq x &quot;Hello World&quot;) ;; Set the
		  string &quot;Hello World&quot; into the variable x.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (set x 1 #\E)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;&quot;HEllo
		  World&quot;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; (setq (ref x 6) #\w)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;&quot;HEllo
		  world&quot;</p>
		  <p>&nbsp;</p>
		    <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>Refer to the appropriate object data type reference guide to determine the
		  effect of the <b>setq</b> special form on that specific type or even what
		  types of indices the <b>setq</b> special form can take. For String objects
		  refer to the <a href="axstring.htm">String Object Reference Guide</a>, For
		  Vector objects refer to the <a href="axvector.htm">Vector Object Reference
		  Guide</a>, For Dictionary objects refer to the <a href="axdictionary.htm">Dictionary
		  Object Reference Guide</a>, etc.</p>
		</div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SBracket Operator []"></A>Bracket Operator []</H2></P>
            <div class="h2section" id="Bracket Operator []">
			<p>The Bracket Operator <b>[ ]</b> supports both setting and referencing
			  indexed elements within an object in AIS Lisp. The bracket operator, used for
			  reference, is the equivalent of the <b>ref</b> built-in function. The bracket
			  operator, used for assignment, is the equivalent of the <b>setq</b> special
			  form.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable[index]</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq variable[index]
			  newValue)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>x[5]</th>
			      <td>is identical to</td>
			      <td>(ref x 5)</td>
			    </tr>
			    <tr>
			      <th>(setq x[2] &quot;Hello&quot;)</th>
			      <td>is identical to</td>
			      <td>(setq (ref x 0) &quot;Hello&quot;)</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the bracket operator when writing out the full equivalent <b>setq</b>
			  or <b>ref</b> expressions would be too cumbersome or would make the Lisp
			  program less readable.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample object retrievals and settings using the bracket
			  operator.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Vector:3 45 -6 78)) ;; Set the
			  newly created vector object into the variable <b>x</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>[</b>2<b>]</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;78</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>[</b>0<b>]</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;45</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x<b>[</b>0<b>]</b>
			  26)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(26 -6 78)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x &quot;Hello World&quot;) ;; Set the
			  string &quot;Hello World&quot; into the variable <b>x</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>[</b>1<b>]</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#\e</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>[</b>6<b>]</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#\W</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x<b>[</b>0<b>]</b>
			  #\h)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;&quot;hello World&quot;</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Refer to the appropriate object data type reference guide to determine the
			  effect of the bracket operator on that specific type or even what types of
			  indices the bracket operator can take. For String objects refer to the <a href="axstring.htm">String
			  Object Reference Guide</a>, For Vector objects refer to the <a href="axvector.htm">Vector
			  Object Reference Guide</a>, For Dictionary objects refer to the <a href="axdictionary.htm">Dictionary
			  Object Reference Guide</a>, etc.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDot Operator ."></A>Dot Operator .</H2></P>
             <div class="h2section" id="Dot Operator .">
			  <p>The Dot Operator <b>.</b> supports both setting and referencing indexed
			  elements within an object in AIS Lisp. The dot operator, used for reference,
			  is the equivalent of the <b>ref</b> built-in function. The dot operator, used
			  for assignment, is the equivalent of the <b>setq</b> special form.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable.indexSymbol</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq
			  variable.indexSymbol newValue)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>x.A</th>
			      <td>is identical to</td>
			      <td>(ref x A:)</td>
			    </tr>
			    <tr>
			      <th>(setq x.C &quot;Hello&quot;)</th>
			      <td>is identical to</td>
			      <td>(setq (ref x C:) &quot;Hello&quot;)</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the dot operator when writing out the full equivalent <b>setq</b> or <b>ref</b>
			  expressions would be too cumbersome or would make the Lisp program less
			  readable.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample object retrievals and settings using the dot
			  operator.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (new Structure: A: 45 B: -6 C: 78))
			  ;; Set the newly created Structure object into the variable <b>x</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>.</b>C&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;78</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; x<b>.</b>A&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;45</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x<b>.</b>A 26)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A
			  26 B -6 C 78}</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x<b>.</b>B 0)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A
			  26 B 0 C 78}</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Refer to the appropriate object data type reference guide to determine the
			  effect of the dot operator on that specific type or even what types of indices
			  the bracket operator can take. For String objects refer to the <a href="axstring.htm">String
			  Object Reference Guide</a>, For Vector objects refer to the <a href="axvector.htm">Vector
			  Object Reference Guide</a>, For Dictionary objects refer to the <a href="axdictionary.htm">Dictionary
			  Object Reference Guide</a>, etc.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SOffset Addressing"></A>Offset Addressing</H2></P>
            
			  <p>The <b>offset</b> function returns the byte offset, from the start of the specified basis object <b>basis</b>,  
			  when computed using the specified constant indices <b>index1</b>, <b>index2</b>, <b>index3</b>.
			  The offset function operates on a number of object types and can accept from one to three indices depending upon the type of basis object.
			  The offset function is an important tool in supporting direct offset addressing using AIS Lisp registers addressing.</p>
			  <p>The offset function is called automatically, by the compiler, when an AIS Lisp register variable is indexed by
			  a <i>constant offset expression</i>, using the <b>bracket</b> operator such as: <b>register[:integer:]</b>,
			  <b>register[basis(name)]</b>, <b>register[basis(index1)]</b>, <b>register[basis(index1,index2)]</b>, or <b>register[basis(index1,index2,index3)]</b>.
			  AIS Lisp treats each register offset expression as a single <i>compound variable name</i>. Therefore, there can be absolutely
			  NO whitespace between any of the parts of the register offset expression. It should also be noted that
			  AIS Lisp only supports register offsets of up to 32,767 bytes.
			  </p>
			  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>vars:((employee #{decl| (Name "John Doe") (Number:Salary 23450.00)}))</b><br>
			  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>regs:(NumPointer:ptr)</b><br>
			  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(setq ptr employee)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Loads register <i>ptr</i> with the address of the employee Structure.<br>
			  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(+= ptr[employee(Salary)] 200.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Adds 200 to Salary, using direct offset addressing from the <i>ptr</i> register.</p>
			  <p>&nbsp;</p>
			<!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (offset basis index1)</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (offset basis index1 index2)</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (offset basis index1 index2 index3)</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  register[:integer:]</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  register[basis(name)]</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  register[basis(index1)]</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  register[basis(index1,index2)]</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  register[basis(index1,index2,index3)]</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>basis</th>
			      <td>The specified basis object to be referenced via direct offset addressing.</td>
			    </tr>
			    <tr>
			      <th>name</th>
			      <td>(Mandatory) The field name from which to compute the direct offset address.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The direct offset address, from the start of the basis object, for the indices specified.</td>
			    </tr>
			  </table>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>basis</th>
			      <td>The specified basis object to be referenced via direct offset addressing.</td>
			    </tr>
			    <tr>
			      <th>index1</th>
			      <td>(Mandatory) The first numeric index from which to compute the direct offset address.</td>
			    </tr>
			    <tr>
			      <th>index2</th>
			      <td>(Optional) The second numeric index from which to compute the direct offset address.</td>
			    </tr>
			    <tr>
			      <th>index3</th>
			      <td>(Optional) The third numeric index from which to compute the direct offset address.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The direct offset address, from the start of the basis object, for the indices specified.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The offset function is an important tool in supporting direct offset addressing using AIS Lisp registers addressing.</p>
			  <p>The offset function operates on a number of object types and can accept a number of different constant indices, as follows:</p>
			  <ul>
			  	<li>ByteVector (accepts a single integer index)</li>
			  	<li>Brick (accepts a single integer or symbol index)</li>
			  	<li>CpxVector (accepts a single integer index)</li>
			  	<li>Dictionary (accepts a single integer or symbol index, or accepts a pair of integer indices)</li>
			  	<li>Directory (accepts a single word index, or accepts a pair of integer indices)</li>
			  	<li>FltVector (accepts a single integer index)</li>
			  	<li>IntVector (accepts a single integer index)</li>
			  	<li>LongVector (accepts a single integer index)</li>
			  	<li>Matrix (accepts from one to three integer indices)</li>
			  	<li>NumMatrix (accepts from one to three integer indices)</li>
			  	<li>NumVector (accepts a single integer index)</li>
			  	<li>ObjVector (accepts a single integer index)</li>
			  	<li>PcodeVector (accepts a single integer index)</li>
			  	<li>ShortVector (accepts a single integer index)</li>
			  	<li>String (accepts a single integer index)</li>
			  	<li>Structure (accepts a single integer or symbol index, or accepts a pair of integer indices)</li>
			  	<li>Symbol (accepts a single integer index)</li>
			  	<li>Vector (accepts a single integer or symbol index)</li>
			  </ul>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here follows a simple example of AIS Lisp offset addressing in action.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>vars:((complex #{Real 2134.2 Imagine 23450.00}))</b><br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>regs:(NumPointer:ptr)</b><br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(setq ptr complex)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Loads register <i>ptr</i> with the address of the complex Structure.<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(+= ptr[complex(Real)] 200.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Adds 200 to the real part of complex.</br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(+= ptr[complex(Imagine)] 1540.0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Adds 200 to the imaginary part of complex.</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 2</u></b></p>
			  <p>Here follows a simple example of AIS Lisp offset addressing for Number Matrices.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>vars:((gauss #(NumMat[2 2 2]| 1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0)))</b><br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>regs:(NumPointer:ptr)</b><br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(setq ptr gauss)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Loads register <i>ptr</i> with the address of the gauss Matrix.<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  <b>(setq ptr[gauss(1 0 1)] .45)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>;; Moves .45 into the [1 0 1]th element of the matrix.</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The offset function is an important tool for supporting direct register offset addressing in AIS Lisp.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCircumflex Operator ^"></A>Circumflex Operator ^</H2></P>
			  <p>The Circumflex Operator <b>^</b> preceding a symbol references a global
			  variable value even in contexts where there are local variable naming
			  conflicts. The AIS Lisp <b>^</b> operator uses the <b>getGlobalValue</b>
			  function to return the global value of the specified symbol argument. 
              The circumflex operator <b>^name</b> is the equivalent of the <b>(getGlobalValue name:)</b> function.
              Also the circumflex operator <b>^name</b> has a similar effect as the <b>|Gv:name|</b> symbolic form.
              </p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^variable</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |Gv:variable|</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>^name</th>
			      <td>is identical to</td>
			      <td>(getGlobalValue name:)</td>
			    </tr>
			    <tr>
			      <th>^name</th>
			      <td>has a similar effect as</td>
			      <td>|Gv:name|</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the circumflex operator when writing out the full equivalent <b>(getGlobalValue name:)</b>
			  expression would be too cumbersome or would make the Lisp program less readable, or
			  use the |Gv:name| symbolic form to achieve the same effect without a function call.
			  </p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example</u></b></p>
			  <p>Here are just a few sample globals retrievals using the circumflex operator.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
              (setq x (new Structure: A: 45 B: -6 C: 78))
			  ;; Set the Structure object into the global variable <b>x</b>.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
              ((lambda(x) ^x) 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A 45 B -6 C 78}</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
              ((lambda(x) |Gv:x|) 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#{A 45 B -6 C 78}</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
              ((lambda(x) x) 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;2</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the circumflex operator only as shorthand notation for the <b>(getGlobalValue name)</b> function,
                 or use the |Gv:name| symbolic form to achieve the same effect without a function call. 
			     </p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SQuote Operator '"></A>Quote Operator '</H2></P>
             <div class="h2section" id="Quote Operator '">
			  <p>The Quote Operator <b>'</b> preceding a list or symbol converts the list or symbol into
			  a list or symbol constant. The AIS Lisp <b>'</b> is the short hand equivalent of the <b>quote</b>
			  special form.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  'symbol</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  '(...list...)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>'thing</th>
			      <td>is identical to</td>
			      <td>(quote thing)</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the quote operator when writing out the full equivalent <b>quote</b>
			  expression would be too cumbersome or would make the Lisp program less
			  readable.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the quote operator in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defun foo(x) (length x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 291&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq x (new Vector: 3 1 2 3))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(1 2 3)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  x&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(1 2 3)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  <b>'</b>x&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;x</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (foo x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (foo <b>'</b>x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  '(foo x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;(foo x)</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the quote operator only as shorthand notation for the <b>quote</b>
			  special form.</p>
             </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SColon Operator :"></A>Colon Operator :</H2></P>
			 <p>The Colon Operator <b>:</b> suffixing a symbol always converts the symbol into a symbolic constant.
              Also symbols enclosed in vertical bars <b>|I am a compound symbol|:</b> can be converted into symbolic constants using the colon operator. 
			  The AIS Lisp <b>name:</b> is the short hand equivalent of the <b>(quote name)</b> special form.
              </p>
              
			  <p>Using the colon operator on a symbol at the head of a list can be used as short hand to send a message to a class instance.
			     The AIS Lisp <b>(msg: self)</b> is the short hand equivalent of the <b>(send msg: self)</b> method invocation.
                 </p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  name:</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  |I am a compound symbol|:</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (msg: self)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>name:</th>
			      <td>is identical to</td>
			      <td>(quote name)</td>
			    </tr>
			    <tr>
			      <th>(msg: self)</th>
			      <td>is identical to</td>
			      <td>(send msg: self)</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the colon operator when writing out the full equivalent <b>(quote name)</b> or <b>(send msg: self)</b>
			  expressions would be too cumbersome or would make the Lisp program less readable.
			  </p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example</u></b></p>
			  <p>Here are some examples of the colon operator in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defclass foo() svars:(Number:x Vector:y) (defun new(self) (setq y (new Vector: 3 1 2 3))) true)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defmethod foo:len(self) (length y))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq x (new foo))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (len: x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  x<b>:</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;x</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (length x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;2</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (length x:)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the colon operator as shorthand notation for the <b>(quote name)</b> special form, or
                 use the colon operator as shorthand notation sending a message to a class instance.
                 </p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SAt Operator @"></A>At Operator @</H2></P>
			 <p>The At Operator <b>@</b> infixing a compound name, converts the compound name into a member macro invocation. 
			  The AIS Lisp <b>parent@name</b> is the short hand equivalent of the <b>(refmacro parent name)</b> special form.
			  Using the @ Operator on a symbol at the head of a list can be used to invoke a member macro during compilation.
              </p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Lexical</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (parent@name)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (parent.child@name)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (parent.child[2]@name)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Equivalence</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			      <col>
			    </colgroup>
			    <tr>
			      <th>parent@name</th>
			      <td>is identical to</td>
			      <td>(refmacro parent name)</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the @ operator when writing out the full equivalent <b>(refmacro parent name)</b>
			  expression would be too cumbersome or would make the Lisp program less readable.
			  </p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example</u></b></p>
			  <p>Here is an example of the colon operator in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defun foo(x) pvars:(v len) (setq v x))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defmacro foo:len(self) (macroReplace self '(length %1)))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq x (new Vector: 3 1 2 3))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  <b>(foo@len x)</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
			  <p>&nbsp;</p>	    
         <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMath Operators + - * /"></A>Math Operators + - * /</H2></P>
			<div class="h2section" id="Math Operators + - * /">			 
              <p>The Math Operators <b>+ - * /</b> support the basic arithmetic operations
			  of add (+), subtract (-), multiply (*), and divide (/). Each operator is
			  treated as a function call (as is everything else in Lisp). Each math operator
			  must have one argument, and may have up to nineteen (19) optional additional
			  arguments.</p>
			  <p>The add (+) operator returns to total of all its numeric arguments. The
			  subtract (-) operator returns the negative of the first argument (if only one
			  argument was passed), and the difference between the first argument and the
			  total of all remaining arguments (if more than one argument was passed). The
			  multiply (*) operator returns the product of all its numeric arguments. The
			  divide (/) operator returns the inverse of the first argument (if only one
			  argument was passed), and the quotient of the first argument and the product
			  of all remaining arguments (if more than one argument was passed).</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (+ number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (- number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (/ number ... )</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>number</th>
			      <td>(Mandatory) the first number to be operated upon</td>
			    </tr>
			    <tr>
			      <th>number</th>
			      <td>(Optional) up to nineteen (19) additional numbers to be operated upon</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the math operators when artithmetic computations are essential to the
			  success of your program.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample arithmetic computations using the math
			  operators.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (/ x 15))<i>Returns</i>&nbsp;&nbsp;&nbsp;2</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (- (* 15 x) 5 4 3 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;0</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (* 5 4 3 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;120</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the math operators to return the results of arithmetic calculations.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMath Operators + - * /"></A>Math Operators + - * /</H2></P>
			 <p>The Math Operators <b>+ - * /</b> support the basic arithmetic operations
			  of add (+), subtract (-), multiply (*), and divide (/). Each operator is
			  treated as a function call (as is everything else in Lisp). Each math operator
			  must have one argument, and may have up to nineteen (19) optional additional
			  arguments.</p>
			  <p>The add (+) operator returns to total of all its numeric arguments. The
			  subtract (-) operator returns the negative of the first argument (if only one
			  argument was passed), and the difference between the first argument and the
			  total of all remaining arguments (if more than one argument was passed). The
			  multiply (*) operator returns the product of all its numeric arguments. The
			  divide (/) operator returns the inverse of the first argument (if only one
			  argument was passed), and the quotient of the first argument and the product
			  of all remaining arguments (if more than one argument was passed).</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (+ number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (- number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* number ... )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (/ number ... )</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>number</th>
			      <td>(Mandatory) the first number to be operated upon</td>
			    </tr>
			    <tr>
			      <th>number</th>
			      <td>(Optional) up to nineteen (19) additional numbers to be operated upon</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the math operators when artithmetic computations are essential to the
			  success of your program.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample arithmetic computations using the math
			  operators.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (/ x 15))<i>Returns</i>&nbsp;&nbsp;&nbsp;2</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (- (* 15 x) 5 4 3 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;0</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (* 5 4 3 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;120</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the math operators to return the results of arithmetic calculations.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMath Assignors += -= *= /="></A>Math Assignors += -= *= /=</H2></P>
             <div class="h2section" id="Math Assignors += -= *= /=">
			<p>The Math Assignors <b>+= -= *= /=</b> support the basic arithmetic
			  operations of add (+), subtract (-), multiply (*), and divide (/). Each
			  operator is treated as a function call (as is everything else in Lisp). Each
			  math assignor must have exactly two arguments. The first argument must be a
			  variable which is the target assignor of the operation, and the second
			  argument must be a numeric value which is the assignee.</p>
			  <p>The add (+=) assignor assigns the total of the target and the argument back
			  into the target. The subtract (-=) assignor assigns the difference of the
			  target and the argument back into the target. The multiply (*=) assignor
			  assigns the product of the target and the argument back into the target. The
			  divide (/=) assignor assigns the quotient of the target and the argument back
			  into the target.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Macro</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (+= variable number)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-= variable number)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*= variable number)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (/= variable number)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>variable</th>
			      <td>The target to be assigned with the final result.</td>
			    </tr>
			    <tr>
			      <th>number</th>
			      <td>The numeric argument to be added to, subtracted from, multiplied by,
			        or divided into the target.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the math assignors when artithmetic computations are essential to the
			  success of your program, and the long hand equivalent setq special forms would
			  be to cumbersome or would make your program difficult to read.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample arithmetic computations using the math
			  assignors.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (+= x 15)<i>Returns</i>&nbsp;&nbsp;&nbsp;45</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (-= x (+ 5 4 3 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (*= x 2)<i>Returns</i>&nbsp;&nbsp;&nbsp;60</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (/= x 2)<i>Returns</i>&nbsp;&nbsp;&nbsp;60</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The math assignors are all equivalent to standard (setq ...) special forms.
			  For instance, (+= n 20) is equivalent to (setq n (+ n 20))</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMath Incrementors ++ --"></A>Math Incrementors ++ --</H2></P>
             <div class="h2section" id="Math Incrementors ++ --"> 
			  <p>The Math Incrementors <b>++ --</b> support the basic arithmetic operations
			  of increment (++), and decrement (--). Each operator is treated as a function
			  call (as is everything else in Lisp). Each math incrementor must have exactly
			  one argument, a variable which is the target assignor of the moperation. The
			  increment (++) incrementor assigns the total of the target and the number 1
			  back into the target. The decrement (--) incrementor assigns the difference of
			  the target and the number 1 back into the target.
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Macro</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (++ variable)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (-- variable)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>variable</th>
			      <td>The target to be incremented or decremented.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the math incrementors when artithmetic computations are essential to
			  the success of your program, and the long hand equivalent setq special forms
			  would be to cumbersome or would make your program difficult to read.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample arithmetic computations using the math
			  incrementors.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (++ x)<i>Returns</i>&nbsp;&nbsp;&nbsp;31</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (-- x)<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The math incrementors are all equivalent to standard (setq ...) special
			  forms. For instance, (++ n) is equivalent to (setq n (+ n 1))</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRelational Operators &lt; &lt;= = == &lt;&gt; &gt;= &gt;"></A>Relational Operators &lt; &lt;= = == &lt;&gt; &gt;= &gt;</H2></P>
			  <p>The Relational Operators <b>&lt; &lt;= = == &lt;&gt; &gt;= &gt;</b> support the
			  basic comparison operations of less than (&lt;), less than or equal (&lt;=),
			  equal (=), isIdentical (==), not equal (&lt;&gt;), greater than or equal (&gt;=), and greater
			  than (&gt;). Each comparison operator is treated as a function call (as is
			  everything else in Lisp). Each comparison operator must have two arguments.</p>
			  <p>The less than (&lt;) operator returns true if arg1 is less than arg2. 
              The less than or equal (&lt;=) operator returns true if arg1 is less than or equal to arg2. 
              The equal (=) operator returns true if arg1 is equal to arg2. 
              The isIdentical (==) operator returns true if arg1 is identical to arg2. 
              The not equal (&lt;&gt;) operator returns true if arg1 is not equal to arg2. 
			  The greater than or equal (&gt;=) operator returns true if arg1 is greater than or equal to arg2. 
			  The greater than (&gt;) operator returns true if arg1 is greater than arg2.
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&lt; value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&lt;= value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (= value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (== value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&lt;&gt; value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&gt;= value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (&gt; value1 value2)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>value1</th>
			      <td>The first value to be compared</td>
			    </tr>
			    <tr>
			      <th>value2</th>
			      <td>The second value to be compared.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the relational operators when comparisons are essential to the success
			  of your program.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample relational operations using the a range of
			  values.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (&lt; x 15)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (&lt;= x -1)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (= x 30.0)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (= x &quot;30&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x &quot;Hello World&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;&quot;Hello World&quot;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (&lt;&gt; x &quot;Hello World&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (= x[6] #\W)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq y #(#\H #\W #\O)<i>Returns</i>&nbsp;&nbsp;&nbsp;#(#\H #\W #\O)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (= x[6] y[1])<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the relational operators to return the results of value comparisons.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SComparison Operators LT LE EQ NE GE GT"></A>Comparison Operators LT LE EQ NE GE GT</H2></P>
             <div class="h2section" id="Comparison Operators LT LE EQ NE GE GT">
			 <p>The Comparison Operators <b>LT LE EQ NE GE GT</b> support the
			  basic comparison operation (compare), as well as the
			  basic comparison operations of less than (compareGT), less than or equal (compareGE),
			  not equal (compareNE), equal (compareEQ), greater than or equal (compareGE), and greater
			  than (compareGT). Each comparison operator is treated as a function call (as is
			  everything else in Lisp). Each comparison operator must have two arguments.</p>
			  <p>The comparison operator (compare) returns -1 if arg1 is less then arg2, returns 0 if arg1 is equal to arg2,
			  and returns 1 if arg1 is greater then arg2. The less than (compareLT) operator returns true if arg1 is less than arg2. The
			  less than or equal (compareLE) operator returns true if arg1 is less than or equal
			  to arg2. The not equal (compareNE) operator returns true if arg1 is not equal
			  to arg2. The equal (compareEQ) operator returns true if arg1 is equal to arg2. The
			  greater than or equal (compareGE) operator returns true if arg1 is greater than or
			  equal to arg2. The greater than (compareGT) operator returns true if arg1 is
			  greater than arg2.
			  
			  <p>The comparison operators may optionally be prefixed with a strong typing indicator, which causes the appropriate
			  memory to memory strongly typed comparison operators to be invoked. The values of the optional strong typing indicators 
			  <i>t</i> are as follows.</p>
			  <ul>
			  	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(generic compare)</li>
			  	<li>b&nbsp;&nbsp;&nbsp;&nbsp;(bit compare)</li>
			  	<li>c&nbsp;&nbsp;&nbsp;&nbsp;(character compare)</li>
			  	<li>i&nbsp;&nbsp;&nbsp;&nbsp;(integer compare)</li>
			  	<li>n&nbsp;&nbsp;&nbsp;&nbsp;(number compare)</li>
			  </ul>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (compare value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (compareCC value1 value2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (tcompareCC value1 value2)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>value1</th>
			      <td>The first value to be compared</td>
			    </tr>
			    <tr>
			      <th>value2</th>
			      <td>The second value to be compared.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the comparison operators when comparisons are essential to the success
			  of your program.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few sample comparison operations using the a range of
			  values.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x (+ 10 20))<i>Returns</i>&nbsp;&nbsp;&nbsp;30</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (icompareLT x 15)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (compareLE x -1)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ncompareEQ x 30.0)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (compareEQ x &quot;30&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq x &quot;Hello World&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;&quot;Hello
			  World&quot;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (compareNE x &quot;Hello World&quot;)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (ccompareEQ x[6] #\W)<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (setq y #(#\H #\W #\O)<i>Returns</i>&nbsp;&nbsp;&nbsp;#(#\H
			  #\W #\O)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (compareEQ x[6] y[1])<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>Use the comparison operators to return the results of value comparisons.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Slambda"></A>lambda</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>lambda</b> special form creates a new Lambda object and returns it to the caller.</p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (lambda(args...) faces:(var...) svars:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>lambda</b> special form creates a new executable Lambda object. 
             When called, the Lambda extends its environment to include the specified argument variables {arg}, 
             the arguments are received and bound to the proper variables {arg}, 
             the expressions {exp} are evaluated from left to right, and the value of the final expression is returned.
             The new Lambda object may be either a root Lambda or it will be a child Lambda of any Lambda within which it is declared.
             Child <b>lambda</b> Lambdas are always registered in the pvars:() of their parent Lambda.
             The new Lambda may be called directly when the arguments specified in its argument list.
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, macros, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

          <p>An AIS Lambda may be defined, with a definite list (fixed) or an indefinite list of arguments (variable). 
             The ellipses at the end of the argument list indicate the function has indefinite arguments. 
             At run time, the Lambda's actual arguments are bound to the specified formal definite arguments respectively. 
             An error is generated if there are too few arguments in the definite argument list.  
             If the number of actual arguments exceed the number of definite arguments, and the function has been defined as having indefinite arguments, 
             the excess arguments can only be accessed during via the argCount and argFetch functions at run time. 
             </p>

          <p>The keyword <b>faces:(var...)</b>  declares the interfaces feature Structure of the Lambda.  
             The features are specified as lists,  faces:((english  true) (french  false)),  the listed feature is initialized to the value specified.
             </p>


          <p>The keyword <b>svars:(var...)</b>  declares the class variables of the Lambda.  
             The variables are specified as follows  svars:(X  Y...).  
             If any one of the variables is specified as a list,  vars:((X  0)  Y),  the listed variable is initialized to the constant value specified (The variable X is initialized to the constant 0). 
             Unlike the setq or define special forms, the svars special form always evaluates the initialization value as a constant.
             A variable may be strongly typed if a type preceeds the variable,  svars:((Number:X  0.0) String:Y).
             If no type is specified, the variable defaults to type Word.
             </p>

          <p>The keyword <b>vars:(var...)</b>  declares the temporary variables of the Lambda.  
             The variables are specified as follows  vars:(X  Y...).  
             If any one of the variables is specified as a list,  vars:((X  0)  Y...),  the listed variable is initialized to the constant value specified (The variable X is initialized to the constant 0). 
             Unlike the setq or define special forms, the vars special form always evaluates the initialization value as a constant.
             A variable may be strongly typed if a type preceeds the variable,  vars:((Number:X  0.0) String:Y).
             If no type is specified, the variable defaults to type Word.
             </p>


          <p>The keyword <b>pvars:(var...)</b>  declares the persistent variables of the Lambda.  
             The variables are specified as a list  pvars:(X  Y...).  
             If any one of the variables is specified as a list,  pvars:((X  0)  Y...),  the listed variable is initialized to the constant value specified (The variable X is initialized to the constant 0). 
             Unlike the setq or define special forms, the pvars special form always evaluates the initialization value as a constant.
             A variable may be strongly typed if a type preceeds the variable,  pvars:((Integer:X  0) Vector:Y).
             If no type is specified, the variable defaults to type Word.
             </p>


          <p>The keyword <b>cvars:(var...)</b>  declares the constant variables of the Lambda.  
             The variables are specified as a list  cvars:(X  Y...).  
             If any one of the variables is specified as a list,  pvars:((X  0)  Y...),  the listed variable is initialized to the constant value specified (The variable X is initialized to the constant 0). 
             Unlike the setq or define special forms, the cvars special form always evaluates the initialization value as a constant.
             A variable may be strongly typed if a type preceeds the variable,  cvars:((Boolean:X  0) Number:Y).
             If no type is specified, the variable defaults to type Word.
             </p>


          <p>The keyword <b>regs:(var...)</b>  declares the register variables of the Lambda.  
             The variables are specified as a list regs:  (X  Y...).   
             If any one of the variables is specified as a list, regs:((X  0)  Y...),  the listed variable is initialized to the constant value specified (The variable X is initialized to the constant 0).  
             Up to fifty register variables are allowed. 
             Unlike the setq or define special forms, the regs special form always evaluates the initialization value as a constant.
             A variable may be strongly typed if a type preceeds the variable,  regs:((Integer:X  0) CharPointer:Y).
             If no type is specified, the variable defaults to type Integer.
             </p>


          <p>The body of the Lambda is a sequence of Lisp expressions {exp}. 
             At run time, each of the expressions is evaluated, in the extended environment, from left to right.  
             The Lambda returns the value of the final expression in the sequence. 
             </p>


		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>svars:(var...)</th>
		      <td>(Optional)The Lambda class variable declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>Here the Lambda expressed as a lambda expressed is immediately invoked with the argument 4. 
          </p>

		  <p>((lambda(X)  (+  X  X))  4) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 8</p>
		  <p><b>Note:</b> The <b>lambda</b> special form returns a new Lambda object, which is immediately executed.
             This newly minted Lambda is passed a numeric argument and a numeric result is returned. 
             </p>

		  <p><b><font color="blue"><u>Example 2</u></font></b></p>
		  <p>Here a slightly more complex Lambda is assigned to a global variable.
          </p>

	      <p><b>(define sumNums (lambda(X ...)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      vars:(Z)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (setq  Z  X)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (loop for i from 1 to (-1+ (argCount)) do (setq Z (+  Z  (argFetch i))))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          Z ))</b></p>

		  <p>(sumNums  4  5  71) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 80</p>
		  <p><b>Note:</b> The <b>lambda</b> special form returns a new Lambda object, which assigned to the specified global variable name.
             This newly minted Lambda is passed a series of numeric arguments and a numeric result is returned. 
             </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefclass"></A>defclass</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defclass</b> special form creates a new Class Lambda and assigns it to the specified global variable name.</p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defclass libarary:parent:name(args...) svars:(var...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The new class Lambda creates a new class of object and may be either a root class or it may inherit from an existing class or class library.
             The class Lambda may be called directly when the class itself is to be initialized.
             The class Lambda may be specified as the argument to the new function when an object of the specified class is to be created.
             An object of the specified class contains the variables as declared in the svars:() plus any variables which may have been inherited
             from the parent and/or library classes.
             The keyword <b>self</b> is used in the class argument lists to denote the current instance of the class object. 
             Whenever the keyword <b>self</b> is declared as the first argument to any method of the class, the Sv register is automatically used for addressing.
             Whenever the variables declared in the svars:() are referenced on their own, it is assumed that the intended reference is <b>self</b>. 
             </p>

		  <p>The class Lambda may contain a <b>new</b> method which will be invoked whenever the class Lambda is specified as the argument to the new function.
             The new function is invoked when an object of the specified class is to be created. 
             The <b>new</b> method must declare the <b>self</b> variable as its first argument and should always return <b>self</b> as its result.
             </p>

		  <p>After compilation, the class Lambda will contain a methods list in its Interfaces section named <b>classMethods</b>. 
             Also, the class Lambda will contain a class names list in its Interfaces section named <b>classNames</b>. 
             Plus the <b>parent</b> and <b>library</b> properties in the Interfaces section will be set appropriately, 
             and <b>class</b> property in the Interfaces section will be set <b>true</b>.
             When the new function is invoked to create an object of the specified class, the new object is linked to the class methods list. 
             Through this manner, the methods list of each class can be separate and distinct while still benefiting from inheritance.
             </p>

		  <p>Child classes, which inherit from other classes, will always be <b>friend</b> Lambdas of their parent class Lambda.
             After compilation, child class Lambdas are linked to their parent classes and to their library classes via the 
             <b>classNames</b>, <b>parent</b>, and <b>library</b> properties of the class Lambda Interfaces sections. 
             Normally, friend Lambdas of a class Lambda are NOT added to the class names list. 
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All class names, within a single class library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new class Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>library</th>
		      <td>(Optional)The symbolic name of the class library from which the new class is to inherit (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>parent</th>
		      <td>(Optional)The symbolic name of the immediate parent class from which the new class is to inherit (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new class (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>svars:(var...)</th>
		      <td>(Mandatory)The class variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The class interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The class persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The class constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The class temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The class register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the class Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Class Lambda.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>Creating and initializing a new class of object.</p>

		  <p><b>(defclass employee()</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          svars:(String:Name (Number:Salary 0.0))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (defun new(self String:name Number:salary)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (setq Name name)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (setq Salary salary)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          self) ;; end of new method</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          true)  ;; end of employee class</b></p>

		  <p><b>(setq x (new employee "John Doe" 24000.0))</b></p>
		  <p>x.Name &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; "John Doe"</p>
		  <p>x.Salary &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 24000.0</p>
		  <p><b>Note:</b> The <b>new</b> function creates a new copy of the class object, containing all of the variables as declared in the svars:().
             This newly minted copy of the class object is passed to the new method as the argument <b>self</b>. 
             The Sv register is automatically set to address the <b>self</b> argument so any reference to the svars:() variables will effect the self object.
             </p>

	      <p>One of the most important events occurs at the end of an class's life
	      span, just before the class Lambda is destroyed. 
          When an class Lambda object is no longer referenced, the garbage collector may choose to destroy the Lambda. 
          Before final destruction takes place, the class Lambda will be sent a <b>doomed</b> message.</p>

	      <p>Each Lambda's <b>EvalWhenDoomed</b> property is initially set to false.
	      Normally, garbage collecting an Lambda, causes nothing to happen (<i>other than the destruction of the Lambda</i>); 
          however, if the class Lambda's <b>EvalWhenDoomed</b> property is set to true, then the doomed Lambda is evaluated by the garbage
	      collector BEFORE final destruction.</p>

	      <p>For instance, the following class opens a log file and performs
	      operations on the open log file during the life span of the class. 
          When the class Lambda is destroyed, we do not wish the log file to be left open. 
          The class Lambda has the task of responding to the <b>doomed</b> event and
	      closing the file before final destruction.</p>

		  <p><b><font color="blue"><u>Example 2</u></font></b></p>
	      <p>This example shows how the class Lambda can open a log file at class
	      initialization time, keep it open during the life of the class, and close the
	      log file before the class is destroyed.</p>

	      <p><b>(defclass myClass(fileName)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      svars:(String:WidgetName Integer:Widget)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      pvars:(logFileHandle)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (defun closeLog() (setq logFileHandle (fileClose logFileHandle)))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (defun writeLog(record) (fileWrite logFileHandle record))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      ClassInitialization::</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (setq logFileHandle (fileOpen fileName))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (setq closeLog.EvalWhenDoomed true)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      logFileHandle)</b></p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefclone"></A>defclone</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defclone</b> special form creates a new clone Lambda and assigns it to the specified global variable name. 
                                 The clone Lambda is a partial copy of the parent Lambda</p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defclone libarary:parent:name(args...) svars:(var...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The new clone Lambda creates a partial copy of the parent Lambda and assigns it to the specified global variable name.
             The clone Lambda contains a copy of the variables as declared in the parent's svars:(), 
             the variables as declared in the parent's pvars:(), and the variables as declared in the parent's cvars:().
             The new clone Lambda does NOT share the variables as declared in the parent's faces:().
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All class names, within a single class library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new class Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>library</th>
		      <td>(Optional)The symbolic name of the class library from which the new class is to inherit (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>parent</th>
		      <td>(Optional)The symbolic name of the immediate parent class from which the new class is to inherit (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new class (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>svars:(var...)</th>
		      <td>(Mandatory)The class variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The class interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The class persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The class constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The class temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The class register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the class Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Class Lambda.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example</u></font></b></p>
		  <p>Creating and initializing a new class of object.</p>

		  <p><b>(defun foo(x)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          pvars:((Number:Salary 1.0))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (+ Salary x) ;; end of foo</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  <p><b>(defclone foo:moo(x)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          pvars:((Number:Salary 10.0))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (+ Salary x) ;; end of moo</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

		  <p><b>(foo 24000.0)) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; "24001.0"</p>
		  <p><b>(moo 24000.0)) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; "24010.0"</p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefun"></A>defun</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defun</b> special form creates a new Lambda and assigns it to the specified global variable name.</p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defun name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>defun</b> special form creates a new executable object which is assigned to the specified global name.
             The new Lambda object may be either a root Lambda or it will be a child Lambda of any Lambda within which it is declared.
             Child <b>defun</b> Lambdas are always registered in the pvars:() of their parent Lambda.
             The new Lambda may be called directly when the arguments specified in its argument list.
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All child Lambda names, within a single Lambda library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>This example shows that the defun special form is equivalent to a version of the define special form. 
          This first form:
          </p>

		  <p><b>(defun  times(X)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          vars:((Z  5))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          pvars:((Y  10))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (*  X  Y  Z))</b></p>
		  <p>is equivalent to this second form:</p>
		  <p><b>(define  times</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (lambda(X)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          vars:((Z  5))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          pvars:((Y  10))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (*  X  Y  Z)))</b></p>

		  <p>(times 2) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 100</p>
		  <p><b>Note:</b> The <b>defun</b> special form creates a new Lambda object, containing all of the variables as declared in the pvars:() and vars:().
             This newly minted Lambda is passed a numeric argument and a numeric result is returned. 
             </p>

	      <p>One of the most important events occurs at the end of an Lambda's life span, just before the Lambda is destroyed. 
          When an Lambda object is no longer referenced, the garbage collector may choose to destroy the Lambda. 
          Before final destruction takes place, the Lambda will be sent a <b>doomed</b> message.</p>

	      <p>Each Lambda's <b>EvalWhenDoomed</b> property is initially set to false.
	      Normally, garbage collecting an Lambda, causes nothing to happen (<i>other than the destruction of the Lambda</i>); 
          however, if the Lambda's <b>EvalWhenDoomed</b> property is set to true, then the doomed Lambda is evaluated by the garbage
	      collector BEFORE final destruction.</p>

	      <p>For instance, the following Lambda library opens a log file and performs
	      operations on the open log file during the life span of the library. 
          When the Lambda is destroyed, we do not wish the log file to be left open. 
          The Lambda has the task of responding to the <b>doomed</b> event and
	      closing the file before final destruction.</p>

		  <p><b><font color="blue"><u>Example 2</u></font></b></p>
	      <p>This example shows how an Lambda library can open a log file at
	      initialization time, keep it open during the life of the Lambda library, and close the
	      log file before the library is destroyed.</p>

	      <p><b>(defun myLambda(fileName)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      pvars:(String:WidgetName Integer:Widget)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      pvars:(logFileHandle)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (defun closeLog() (setq logFileHandle (fileClose logFileHandle)))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (defun writeLog(record) (fileWrite logFileHandle record))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      Initialization::</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (setq logFileHandle (fileOpen fileName))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (setq closeLog.EvalWhenDoomed true)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      logFileHandle)</b></p>

		  <p><b><font color="blue"><u>Example 3</u></font></b></p>
	      <p>This example shows how an Lambda library can create and share a user-defined Structure template
          containing strongly-typed variable declarations.
	      </p>

	      <p><b>(defun myLambda(fileName)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      pvars:((Structure:Thing #{decl| String:Name Number:Salary Integer:ID}))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      vars:(Structure:{Thing}x)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (defun raise(Structure:{Thing}y Number:amount) (+= y.Salary amount))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      Initialization::</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          (setq x (new Thing))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      (raise x 20000.00)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	      x)</b></p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefchild"></A>defchild</H2></P>
		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defchild</b> special form creates a new child Lambda and assigns it to the specified parent Lambda.
             The new child Lambda object is always assigned to the pvars:() of the specified parent Lambda. 
             The defchild special form always returns the newly created child Lambda object. 
          </p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defchild parent:name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defchild parent name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defchild parent.member name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>defchild</b> special form creates a new executable object which is assigned to the specified parent name.
             The new Lambda object will be a child Lambda of the parent Lambda to which it is declared.
             Child Lambdas are always registered in the pvars:() of their parent Lambda, and
             child Lambdas always have their pvars:() as the pvars:() of their parent.
             Child Lambdas always have their cvars:() as the cvars:() of their parent.
             The new Lambda may be called directly with the arguments specified in its argument list.
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All child Lambda names, within a single Lambda library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new child Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>parent</th>
		      <td>The parent Lambda of the new child Lambda (must be a Symbol or an Lambda).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>This example shows how child Lambdas can be defined in separate source files from their parent. 
          For instance, the following two separate forms 
          </p>

		  <p><b>(defun  foo(x) pvars:(y)  (setq y x))</b></p>
          <p><b>(defchild foo:sum(x) (+ x y))</b></p>
		  <p>are equivalent to the following single form</p>
		  <p><b>(defun foo(x)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          pvars:(y)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (defun sum(x) (+ x y))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (setq y x))</b></p>

		  <p>(foo 10) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p>(foo.sum 3) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 13</p>
		  <p><b>Note:</b> Note: A child Lambda DOES share the same pvars:() and cvars:() variables as its parent Lambda. 
          A friend Lambda has a different pvars:() structure from its parent Lambda, 
          but the cvars:() structure of a friend Lambda is the pvars:() structure of its parent Lambda.
          </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefine"></A>define</H2></P>
		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defined</b> special form assigns a value to the specified variable name <i>at compile time</i>.
             The specified name will either be bound to a global symbol or to the pvars:() of the parent Lambda 
             depending on whether the <b>define</b> special form is invoked outside of or inside another Lambda. 
             The major difference between the <b>define</b> nd the <b>setq</b> special forms is that the form makes its assignment once at compile time. 
          </p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (define name expression)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (define (name args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (define  macro: (name  arg...)  faces:(var?) vars:(var...)  pvars:(var...)  cvars:(var...)  regs:(var...)  exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (define  vm: (name  arg...)  faces:(var?) vars:(var...)  pvars:(var...)  cvars:(var...)  regs:(var...)  exp...)</b></p>

		  <p>The <b>(define (name args...)</b> special form provides support for a <i>Scheme-like</i> version of <b>defun</b>.
             Review the <b>defun</b> special form in this document.
             We will provide further documentation there.
             </p>

		  <p>The <b>(define macro: (name args...)</b> special form provides support for a <i>Scheme-like</i> version of <b>defmacro</b>.
             Review the <b>defmacro</b> special form in this document.
             We will provide further documentation there.
             </p>

		  <p>The <b>(define vm: (name args...)</b> special form provides support for a <i>Scheme-like</i> version of <b>defvm</b>.
             Review the <b>defvm</b> special form in this document.
             We will provide further documentation there.
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a variable must be initialized in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the variable to be initialized at compile time (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>expression</th>
		      <td>(Mandatory)One Lisp expression to be assigned to the specified variable name at compile time.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The value of the assigned expression.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>This example shows how variables may be initialized in Lisp. 
          </p>

          <p><b>(define y 33)</b></p>
		  <p><b>(defun  foo(x) (define y 22) (+= y x))</b></p>

		  <p>y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 33</p>
		  <p>foo.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 22</p>
		  <p>(foo 10) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 32</p>
		  <p>foo.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 32</p>
		  <p>(foo 10) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 42</p>
		  <p>foo.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 42</p>
		  <p><b>Note:</b> Note: The define special form assigns to global variables when it is invoked with global scope. 
          However, if defined within an Lambda, the define special form assigns to the pvars:() of the parent Lambda.
          Note that the define special form assigns only once a compile time not every time the Lambda is executed.
          </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefmacro"></A>defmacro</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defmacro</b> special form creates a new Macro Lambda object, assigns it to the specified variable name and returns the newly created Macro Lambda object.  
             The new Macro Lambda will be invoked by the compile function during the macro substitution phase of compilation (see the compile, and morph functions).
             </p> 

		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmacro name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmacro parent:name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmacro parent name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmacro parent.member name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>defmacro</b> special form creates a new executable object which is assigned to the specified global name.
             The new macro Lambda object will always be registered in the global name space, and may be invoked directly in any Lisp expression.
             Macro Lambdas can be used to enhance any class or Lambda library. 
             It is an AIS Lisp traditional to name all macros, in a library, after the global name of the class or Lambda library with an extending dash "_" symbol.
             For instance, if our class library has the name <i>ourClassLibrary</i>, 
             then traditionally the enhancing macros for our class library would be named <i>ourClassLibrary_Macro1</i>, <i>ourClassLibrary_Macro2</i>, etc. 
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, macros, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All macro Lambda names must be unique within the global name space! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when creating a new in-line macro, which expands its arguments, rather than invoking a function call.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>parent</th>
		      <td>The parent Lambda of the new macro Lambda (must be a Symbol or an Lambda).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new Macro Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new list for additional compilation.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>In this example, we demonstrate how macros can be used to reduce complex expressions to simpler forms at compile time. The plus macro is defined as follows: 
          </p>

		  <p><b>(defmacro  plus(x  y)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (if  (or  (isSymbol  x)  (isSymbol  y))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (list  |+|:  x  y)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (+  x  y)))</b></p>
		  <p>The following form:</p>
		  <p><b>(plus  10  20)</b></p>
		  <p>is replaced, in-line, with the number</p>
		  <p><b>30</b></p>
		  <p>but this more complex form:</p>
		  <p><b>(plus  x  34)</b></p>
		  <p>is replaced, in-line, with this form</p>
		  <p><b>(+  x  34)</b></p>
		  <p><b>Note:</b> Note: In the language of compilers, the plus macro performs constant folding. 
             </p>

		  <p><b><font color="blue"><u>Example 2</u></font></b></p>
		  <p>This square macro expands its arguments in-line rather than calling a function. 
          </p>

		  <p><b>(defmacro square(x) (list  |*|:  x  x))</b></p>
		  <p>By invoking the macro below</p>
		  <p><b>(square  23)</b></p>
		  <p>we generate in-line code as follows:</p>
		  <p><b>(* 23 23)</b></p>
		  <p><b>Note:</b> Note: The <b>defmacro</b> special form allows complete control of the macro substitution process during compilation.
             The macro Lambda may be as complex as required, including macro Lambdas which are complex Lambda libraries. 
             </p>

	      <p>One of the most important features of AIS Lisp macros is the complete control offered over the macro substitution process. 
          In cases where very simple manipulation of the macro substitution process is required, 
          the <b>defmacro</b> special form can be used with the <b>macroReplace</b> function to provide simple argument substitution similar to the macros in the C language.
             </p>

		  <p><b><font color="blue"><u>Example 3</u></font></b></p>
		  <p>In this example, we demonstrate how Lisp macros can be used, together with the macroReplace function, 
             to provide simple argument substitution similar to the macros in the C language. 
             The plus macro can also be defined as follows: 
          </p>

		  <p><b>(defmacro plus(%1 %2) (macroReplace %1 %2 '(+ %1 %2)))</b></p>
		  <p>The following form:</p>
		  <p><b>(plus (mod 2 3) 4)</b></p>
		  <p>is replaced, in-line, with this form:</p>
		  <p><b>(+ (mod 2 3) 4)</b></p>
		  <p><b>Note:</b> Note: The <b>macroReplace</b> function may take any number of arguments.
             Each argument must be named %nn (where nn is a sequential argument number).
             The last argument must be a source string of any size (either enclosed in braces or double quotes).
             Each instance of an argument notation <i>%nn</i> in the source string will be replaced, in the source string, by the appropriate argument.
             The final argument will be converted into a List and returned as the final form for compilation.
             </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefmethod"></A>defmethod</H2></P>

		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defmethod</b> macro creates a new method Lambda for the specified Class Lambda and adds it to the classMethods in the Interfaces section of the specified class Lambda.</p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmethod library:class:msgName(self args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defmethod typeName:msgName(self args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

          <p>If a <i>typeName</i> is specified, the defmethod special form constructs an Lambda with at least one argument (which by convention is named self). 
             The first argument, declared for the new method Lambda, must be of the specified type typeName. 
             The new method Lambda is added to the Methods Structure of the specified type typeName. 
             After adding the Lambda to the Methods Structure of the specified type, the type will respond to the message named msgName by invoking the new methods Lambda. 
             The defmethod and defstruct special forms support the development of user defined types in AIS Lisp 
             (for those applications where an object oriented type-paradigm is warranted).
             </P>

		  <p>If a <i>class</i> is specified, the new method Lambda adds a new function or capability to the specified Lambda class library 
             and may be a root method or may override an existing method of the class library.
             The method Lambda may be called directly or it may be invoked by sending a message to any object instance of the specified class.
             The method Lambda must declare <b>self</b> as its first argument followed by any number of additional arguments.
             Any object of the specified class contains the variables as declared in the class svars:() 
             which always includes all additional svars:() variables inherited from the parent and library classes.
             The keyword <b>self</b> is used in the method argument lists to denote the current instance of the class object. 
             Whenever the keyword <b>self</b> is declared as the first argument to any method of the class, the Sv register is automatically used for addressing.
             Whenever the variables declared in the svars:() are referenced on their own, it is assumed that the intended reference is <b>self</b>. 
             </p>

		  <p>The specified class Lambda will contain a methods list in its Interfaces section named <b>classMethods</b> 
		     After compilation, the new method Lambda will be added to the methods list in the specified class Lambda.
             When the <b>new</b> function is invoked to create an object of the specified class, the new object is linked to the class methods list. 
             Through this manner, a message sent to the object will invoke the corresponding method Lambda.
             </p>

		  <p>The method Lambda always shares the svars:() pvars:() and cvars:() variables of the specified class Lambda.
             The new method Lambda is always a child Lambda of the class Lambda. 
             The only difference between a simple child Lambda and a method Lambda is the method Lambda is added to the classMethods Structure in the Interfaces section of the class Lambda.
             Normally child, friend, and orphan Lambdas are NOT added to the methods list of the class Lambda.
             Declare as methods only those functions which are to be publicly available via messages to objects of the specified class. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All method Lambda names, within a single class Lambda, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this macro when a class Lambda must be extended with new functionality.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>library</th>
		      <td>(Optional)The symbolic name of the class library to which the new method is to belong (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>class or typeName</th>
		      <td>The symbolic name of the <i>Lambda class</i> or <i>type</i> to which the new method is to belong (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>msgName</th>
		      <td>The symbolic name of the new method (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(self arg...)</th>
		      <td>The mandatory self argument plus zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The method Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The class Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The class Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The method Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The method Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the method Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The programmer defined results of the method invocation.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>Creating and enhancing a new class of object with a new method function.</p>

		  <p><b>(defclass employee()</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          svars:((String:Name "John Doe") (Number:Salary 0.0))</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          true)  ;; end of employee class</b></p>
          <p><b>(defmethod employee:raise(self Number:amount)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          (+= Salary amount)</b></p>
	      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          Salary) ;; end of raise method</b></p>
		  <p><b>(setq x (new employee))</b></p>
		  <p>(raise:x 22000) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 22000</p>
		  <p><b>Note:</b> The <b>new</b> function creates a new object of the class, containing all of the variables as declared in the svars:().
             In other words, <b>self</b> is an object containing members <b>self.Name</b> and <b>self.Salary</b> (see the svars:() declarations in the class Lambda).
             This newly minted copy of the class object is sent the "raise" message which invokes the <b>raise</b> method Lambda.
             In the <b>raise</b> method, the reference to <i>Salary</i> is assumed to be equivalent to a reference to <b>self.Salary</b>. 
             The Sv register is automatically set to address the <b>self</b> argument. 
             Therefore all references to the svars:() variables effect the self object.
             </p>

	      <p>One of the most important properties of class library construction is inheritance between class Lambdas.
	      Through <i>inheritance</i> a newly declared class may automatically obtain many of the properties of its parent and library class Lambdas.
          For instance, the following class declarations show how properties of a parent class can be <i>inherited</i> by a child class.
          </p>

		  <p><b><font color="blue"><u>Example 2</u></font></b></p>
	      <p>This example shows how the <b>manager</b> class Lambda inherits the properties of its parent class.
	      </p>

		  <p><b>(defclass employee() svars:((String:Name "John Doe") (Number:Salary 0.0)) true)</b></p>
          <p><b>(defmethod employee:raise(self Number:amount) (+= Salary amount) Salary)</b></p>
		  <p><b>(defclass employee:manager() svars:((String:Dept "Sales Division")) true)</b></p>
		  <p><b>(setq x (new employee.manager))</b></p>
		  <p>(raise:x 22000) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 22000</p>
		  <p><b>Note:</b> The <b>new</b> function creates a new object of the class "manager" (from the <i>employee</i> class library), 
             containing all of the variables as declared in the svars:() of the <b>manager</b> class 
             and all those variables svars:() variables declared in the parent class <b>employee</b>.
             In other words, <b>self</b> is an object containing members <b>self.Name</b>, <b>self.Salary</b>, and <b>self.Dept</b> 
             (see the svars:() declarations in both <i>employee</i> and <i>manager</i> class Lambdas).
             This newly minted copy of the <b>manager</b> object is sent the "raise" message which invokes the <b>raise</b> method Lambda.
             The <b>raise</b> method does not have to be defined again because the <b>manager</b> class <i>inherits</i> it from the <b>employee</b> class. 
             In the <b>raise</b> method, the reference to <i>Salary</i> is assumed to be equivalent to a reference to <b>self.Salary</b>. 
             The Sv register is automatically set to address the <b>self</b> argument. 
             Therefore all references to the svars:() variables effect the self object.
             </p>

		  <p><b><font color="blue"><u>Example 3</u></font></b></p>
	      <p>This example shows how the <b>manager</b> class Lambda may override an inherited properties of its parent class.
	      </p>

		  <p><b>(defclass employee() svars:((String:Name "John Doe") (Number:Salary 0.0)) true)</b></p>
          <p><b>(defmethod employee:raise(self Number:amount) (+= Salary amount) Salary)</b></p>
		  <p><b>(defclass employee:manager() svars:((String:Dept "Sales Division")) true)</b></p>
          <p><b>(defmethod employee:manager:raise(self Number:amount) (+= Salary (* 1.2 amount)) Salary)</b></p>
		  <p><b>(setq x (new employee.manager))</b></p>
		  <p>(raise:x 20000) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 24000</p>
		  <p><b>Note:</b> The <b>new</b> function creates a new object of the class "manager" (from the <i>employee</i> class library), 
             containing all of the variables as declared in the svars:() of the <b>manager</b> class 
             and all those variables svars:() variables declared in the parent class <b>employee</b>.
             In other words, <b>self</b> is an object containing members <b>self.Name</b>, <b>self.Salary</b>, and <b>self.Dept</b> 
             (see the svars:() declarations in both <i>employee</i> and <i>manager</i> class Lambdas).
             This newly minted copy of the <b>manager</b> object is sent the "raise" message which invokes the manager's <b>raise</b> method Lambda.
             The <b>raise</b> method declared for the <b>manager</b> class overrides the <b>raise</b> method inherited from the parent <b>employee</b> class.
             The <b>raise</b> method does not have to be defined again because the <b>manager</b> class <i>inherits</i> it from the <b>employee</b> class. 
             In the <b>raise</b> method, the reference to <i>Salary</i> is assumed to be equivalent to a reference to <b>self.Salary</b>. 
             The Sv register is automatically set to address the <b>self</b> argument. 
             Therefore all references to the svars:() variables effect the self object.
             </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefriend"></A>defriend</H2></P>
		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>defriend</b> special form creates a new friend Lambda and assigns it to the specified parent Lambda.
             The new friend Lambda object is always assigned to the pvars:() of the specified parent Lambda. 
             The defriend special form always returns the newly created friend Lambda object. 
          </p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defriend parent:name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defriend parent name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (defriend parent.member name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>defriend</b> special form creates a new executable object which is assigned to the specified parent name.
             The new Lambda object will be a friend Lambda of the parent Lambda to which it is declared.
             Friend Lambdas are always registered in the pvars:() of their parent Lambda, and
             friend Lambdas always have their pvars:() new an separate from the pvars:() of their parent.
             Friend Lambdas always have their cvars:() shared as the pvars:() of their parent.
             Friend Lambdas cannot see the cvars:() of their parent, and parents cannot see the pvars:() of their friend Lambdas.
             The new Lambda may be called directly with the arguments specified in its argument list.
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All friend Lambda names, within a single Lambda library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new friend Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>parent</th>
		      <td>The parent Lambda of the new friend Lambda (must be a Symbol or an Lambda).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>This example shows how friend Lambdas can be defined in separate source files from their parent. 
          For instance, the following two separate forms 
          </p>

		  <p><b>(defun  foo(x) pvars:(y)  (setq y x))</b></p>
          <p><b>(defriend foo:sum(x) (+ x y))</b></p>

		  <p>(foo 10) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p>(foo.sum 3) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 13</p>
		  <p>foo.Pv.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p>foo.sum.Cv.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p><b>Note:</b> Note: A friend Lambda does not share the same pvars:() variables with its parent; 
          however, the cvars:() structure of a friend Lambda is the pvars:() structure of its parent Lambda.
          </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdeforphan"></A>deforphan</H2></P>
		  <p><b><font color="blue"><u>Overview</u></font></b></p>
          <p>The <b>deforphan</b> special form creates a new orphan Lambda and assigns it to the specified parent Lambda.
             The new orphan Lambda object is always assigned to the pvars:() of the specified parent Lambda. 
             The deforphan special form always returns the newly created orphan Lambda object. 
          </p>
		  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		  <p><b><font color="blue">Syntax:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (deforphan parent:name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (deforphan parent name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>
		  <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		  (deforphan parent.member name(args...) faces:(var...) vars:(var...) pvars:(var...) cvars:(var...) regs:(var...) exp...)</b></p>

		  <p>The <b>deforphan</b> special form creates a new executable object which is assigned to the specified parent name.
             The new Lambda object will be an orphan Lambda of the parent Lambda to which it is declared.
             Orphan Lambdas are always registered in the pvars:() of their parent Lambda, and
             Orphan Lambdas always have their pvars:() new an separate from the pvars:() of their parent.
             Orphan Lambdas always have their cvars:() new an separate from the cvars:() of their parent.
             Orphan Lambdas cannot see the pvars:() of their parent, and orphan Lambdas cannot see the cvars:() of their parent.
             Orphan Lambdas cannot see their parent.
             The new Lambda may be called directly with the arguments specified in its argument list.
             </p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All orphan Lambda names, within a single Lambda library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new orphan Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>parent</th>
		      <td>The parent Lambda of the new orphan Lambda (must be a Symbol or an Lambda).</td>
		    </tr>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
		  <p><b><font color="blue"><u>Example 1</u></font></b></p>
		  <p>This example shows how orphan Lambdas can be defined in separate source files from their parent. 
          For instance, the following two separate forms 
          </p>

		  <p><b>(defun  foo(x) pvars:(y)  (setq y x))</b></p>
          <p><b>(deforphan foo:sum(x) pvars:((y 20)) (+ x y))</b></p>

		  <p>(foo 10) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p>(foo.sum 3) &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 23</p>
		  <p>foo.Pv.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 10</p>
		  <p>foo.sum.Pv.y &nbsp;&nbsp;&nbsp; ==> &nbsp;&nbsp;&nbsp; 20</p>
		  <p><b>Note:</b> Note: An orphan Lambda does not share the same pvars:() variables with its parent; 
          and, an orphan Lambda does not share the same cvars:() variables with its parent;
          </p>

	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefstruct"></A>defstruct</H2></P>

                  <p><b><font color="blue"><u>Overview</u></font></b></p>
                  <p>The <b>defstruct</b> special form creates and initializes a new Structure type <b>{newType}</b> with the specified field names <b>{fieldnames}</b>.  
                    There may be one or more field names.  
                    The new Structure type created by <b>defstruct</b> can inherit from another Structure 
                    by specifying the <b>include:</b> keyword and the name of the parent object <b>{parentName}</b>.  
                    </p>

                  <p>The defstruct special form results in the following substitution:</p>
                  <p><b> (defineStructure  newType:  include:  parentName  fieldnames....)</b></p>
                  
                  <p>The <b>defstruct</b> special form is a mechanism for adding user-defined Structure types to the Analytic Information Server context.  
                     The <b>defstruct</b> special form brings the conventional object-oriented paradigm to the Analytic Information Server tool set. 
                     The special form describes a template for the new Structure type. 
                     The object is not  instantiated until the constructor function is invoked.  
                     The new Structure type can inherit field names (analogous to OOP properties or members) and methods by using the <b>include:</b> syntax.
                     </p>
                  <p>&nbsp;</p>
                  <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

                  <p><b><font color="blue">Syntax:</font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  <b>(defstruct newType: fieldnames....)</b></p>
                  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  <b>(defstruct newType: include:  parentName  fieldnames....)</b></p>
                  <p>&nbsp;</p>


		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>newType</th>
		      <td>The symbolic name for the new Structure type.</td>
		    </tr>
		    <tr>
		      <th>include:</th>
		      <td>An optional keyword.  If present, it must be followed by an existing Structure type.</td>
		    </tr>
		    <tr>
		      <th>parentName</th>
		      <td>If the include: keyword is present, it must be followed by an existing Structure type name.</td>
		    </tr>
		    <tr>
		      <th>fieldName...</th>
		      <td>One or more symbolic field name declarations.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Structure type.</td>
		    </tr>
		  </table>
		  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the defstruct special form whenever the creation of additional Structure types is appropriate. 
                 </p>

			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here we create a new Structure type to represent employees.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defstruct Employee: Name: Address: Salary:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defmethod Employee:raise(self amount) (+= self.Salary amount))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq self (new Employee: Name: "John Doe" Address: "Las Vegas, Nevada" Salary: $20000.00))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (raise: self $3000.00)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;$23000.00</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sdefvm"></A>defvm</H2></P>
		  		  <p><b><font color="blue"><u>Overview</u></font></b></p>
			      <p>The <b>defvm</b> macro creates an Lambda Virtual Machine object, assigns it to the specified global variable <b>name</b>
			      in the global environment, and returns the newly created Lambda Virtual Machine object.
			      The new Virtual Machine Lambda object is assigned to the specified global variable
			      <b>name</b>, and can be used to control the behavior of any other Lambda to which it is assigned.</p>
			      <p>Every AIS Lambda object must be assigned a virtual machine, which controls the behavior of the Lambda object when it is invoked.
			      Normally, the compile function assigns the <b>drmVirtualMachine</b> to each Lambda object which it compiles. 
			      The <b>drmVirtualMachine</b> controls Lambda object behavior using a Dynamically typed word Register Machine model,
			      and contains both an emulation mode and a Just-In-Time compiler.
			      The <b>defvm</b> macro allows the creation of additional Lambda Virtual Machines. 
			      These additional virtual machines can be used to implement alternative machine models or to provide profiling and debugging information.</p>
			      
                  <p>&nbsp;</p>
		          <p><b><font color="blue">Type:</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Special From</b></p>

		          <p><b><font color="blue">Syntax:</font></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			      <b>(defvm name(arg...) faces:(vars?)  regs:(var...) vars:(var...) pvars:(var...) cvars:(var...) exp...)</b></p>
			      <p>&nbsp;</p>

		  <p>Operating alone, Lambdas are of limited capability and value.
             Operating in communities, Lambdas have immense value and capabilities.
             AIS Lisp allows individual Lambdas to be formed together into large Lambda communities of complex architecture.
             Lambdas can work together as classes, methods, children, friends, orphans, all in increasing layers of complexity.
             A community of Lambdas brought together to accomplish a specific set of tasks AND which can be used as a mobile TOOL is called an Lambda <b>library</b>.
             The precise qualities which cause an Lambda community to evolve from a simple hodpodge into a useful <b>library</b> are qualitative.
             However useful Lambda libraries come in two distinctive flavors: Lambda oriented Libraries (AOP), and Object Oriented Libraries (OOP).
             Lambda oriented library tools present their users with a functional interface wherein data is passed to functional Lambda-objects which causes work to be performed.
             Object oriented library tools present their users with a data interface wherein messages are passed to data-objects which causes work to be performed.
             AIS Lisp allows Lambda libraries of either flavor to be created and mixed together in arbitrary layers of complexity. 
             </p>

		  <p><b><font color="red">WARNING:</font></b> All orphan Lambda names, within a single Lambda library, must be unique! 
             </p>

		  <p><b>Note:</b> See also the <b>lambda</b> special form for additional information on creating Lambdas objects. 
             </p>

		  <p><b><font color="blue"><u>When To Use</u></font></b></p>
		  <p>Use this special form when a new virtual machine Lambda must be declared in Lisp.</p>

		  <!-- Arguments Table Template -->
		  <p><b><font color="blue"><u>Arguments</u></font></b></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>name</th>
		      <td>The symbolic name for the new virtual machine Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>(arg...)</th>
		      <td>Zero or more argument variable declarations.</td>
		    </tr>
		    <tr>
		      <th>faces:(var...)</th>
		      <td>(Optional)The Lambda interfaces declarations.</td>
		    </tr>
		    <tr>
		      <th>pvars:(var...)</th>
		      <td>(Optional)The Lambda persistant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>cvars:(var...)</th>
		      <td>(Optional)The Lambda constant variable declarations.</td>
		    </tr>
		    <tr>
		      <th>vars:(var...)</th>
		      <td>(Optional)The Lambda temporary variable declarations.</td>
		    </tr>
		    <tr>
		      <th>regs:(var...)</th>
		      <td>(Optional)The Lambda register variable declarations.</td>
		    </tr>
		    <tr>
		      <th>expression...</th>
		      <td>(Mandatory)One or more Lisp expressions defining the body of the Lambda.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The new Lambda object.</td>
		    </tr>
		  </table>
		  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the defvm special form whenever the creation of additional Lambda Virtual Machines is appropriate. 
			     Additional Lambda Virtual Machines can be used to implement alternative machine models 
			     or to provide profiling and debugging information.
                 </p>

			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here we create an Lambda Virtual Machine whose job is to keep a count of the number of times
			     each of its client Lambdas is invoked.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defvm countVM(...)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  regs:(n)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  vars:(client x result)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  pvars:(clientList)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  ;; Retrieve my client (who will always be the last argument)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq client (argFetch (sub1 (argCount))))<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  ;; Initialize my client list (if necessary)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (if (= clientList #void) (setq new clientList (new Dictionary:)))<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  ;; Initialize this client count history (only on the first invocation)<br>
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (if (= clientList[client] #void)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (begin<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq n 0)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq x (copy client))  ;; Make a copy of my client<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq x.Vm drmVirtualMachine:)  ;; The copy will run on the standard DRM<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (vmregSaveTail n x)  ;; Use the tail of the client to keep its count<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq clientList[client] x)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  )) ; end if<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq x clientList[client])<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (vmregLoadTail x n)  ;; Use the tail of the client to keep its count<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (++ n)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (vmregSaveTail n x)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq clientList[client] x)<br> 
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (vmapply -1 x result))  ;; Invoke the client passing the original arguments<br>
			  </p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The defvm macro must define an Lambda Virtual Machine whose <u>last</u> argument is always 
			     the Lambda whose behavior is to be controlled.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sand"></A>and</H2></P>
            <div class="h2section" id="and">
			<p>The <b>and</b> special form evaluates each expression from left to right.
			  As soon as any expression evaluates to False, the and special form will return
			  False. If all expressions evaluate to True, the value True is returned. If no
			  expressions are specified, the value True is returned.</p>
			  <p>&nbsp;</p>
			  <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special
			  Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (and exp ...)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>exp ?</th>
			      <td>Any number of expressions to be evaluated</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>If All expressions evaluate to True, True is returned. If one
			        expression evaluate to False, False is returned. If no expressions are
			        specified, True is returned.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p><font color="red">[...under construction...]</font></p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are but a few examples of the <b>and</b> special form.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (and (= 12 12) (&gt; 2 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (and (= 24 24) (&lt; 1 1))<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (and 1 2 3 4 5)<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (and) <i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p><font color="red">[...under construction...]</font></p>
             </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SargCount"></A>argCount</H2></P>
            <div class="h2section" id="argCount">
			<p>The <b>argCount</b> special form is the only method to return the number of
			  arguments that was passed to the current Lambda. The current Lambda has been
			  defined with an indefinite number of arguments using the ellipsis syntax form.
			  The number of arguments is only known at runtime.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special
			  Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (argCount)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>Returns</th>
			      <td>The number of arguments for the current Lambda.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The <b>argCount</b> special form is the only method to return the number of
			  arguments that was passed to the current Lambda. The current Lambda has been
			  defined with an indefinite number of arguments using the ellipsis syntax form.
			  The number of arguments is only known at runtime.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here is an example of the <b>argCount</b> special form in use.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (define SumNums</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda (X ...) vars:(Z)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq Z
			  X)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (loop
			  for i from 1 until (argCount) do</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq Z (+ Z (argFetch i))))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (SumNums 4 5 71)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;80</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>An Analytic Information Server Lambda may be defined, with a definite list
			  (fixed) or an indefinite list of arguments (variable) The ellipses at the end
			  of the argument list indicates the function has indefinite arguments. At run
			  time, the Lambda's arguments are bound to the specified definite arguments
			  respectively. The Lisp compiler can detect and generate an error message when
			  there are too few arguments in the definite argument list. If the number of
			  arguments exceed the number of definite arguments, the excess arguments can
			  only be accessed during runtime via the argCount and argFetch functions. (see
			  the lambda special form).</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SargFetch"></A>argFetch</H2></P>
             <div class="h2section" id="argFetch">
			 <p>The <b>argFetch</b> special form is used to access arguments in Lambdas
			  which have been sent an indefinite number of arguments using the ellipses
			  syntax form. The number of arguments are only known at runtime.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special
			  Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (argFetch index)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>index</th>
			      <td>The index of the argument to be fetched.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The value of the indexed argument.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The <b>argFetch</b> special form is used to access arguments in Lambdas
			  which have been sent an indefinite number of arguments using the ellipses
			  syntax form. The number of arguments are only known at runtime.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here is an example of the <b>argCount</b> special form in use.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (define SumNums</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (lambda (X ...) vars:(Z)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq Z
			  X)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (loop
			  for i from 1 until (argCount) do</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			  (setq Z (+ Z (argFetch i))))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; (SumNums 4 5 71)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;80</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>An Analytic Information Server Lambda may be defined, with a definite list
			  (fixed) or an indefinite list of arguments (variable) The ellipses at the end
			  of the argument list indicates the function has indefinite arguments. At run
			  time, the Lambda's arguments are bound to the specified definite arguments
			  respectively. The Lisp compiler can detect and generate an error message when
			  there are too few arguments in the definite argument list. If the number of
			  arguments exceed the number of definite arguments, the excess arguments can
			  only be accessed during runtime via the argCount and argFetch functions. (see
			  the lambda special form).</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sbegin"></A>begin</H2></P>
           <div class="h2section" id="begin">
			<p>The <b>begin</b> Special Form
			  evaluates a sequence of expressions, and returns the value of the last
			  expression. If no expressions are
			  specified, the empty list () is returned.</p>
			  <p></p>
			    <!-- Type and Syntax Template -->
			  <p>&nbsp;</p>
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special
			  Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (begin expression ...)</p>
			  <p>&nbsp;</p>
			    <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>expression ...</th>
			      <td>Any number of expressions to be evaluated.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The value of the last expression evaluated is returned.</td>
			    </tr>
			  </table>
			  <hr>
			    <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The <b>begin</b> Special Form marks the beginning of a group of expressions that logically form a compound expression.</p>
			    <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here is an example of the <b>begin</b> special form in action.</font></p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (define  Y  (begin  (+  1  2)  (+  3  4)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;7</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p><font color=red>[...under construction...]</font></p>
             </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Scase"></A>case</H2></P>
             <div class="h2section" id="case">
			 <p>The <b>case</b> Special Form selects one of a series of clauses to evaluate based upon the value of a selector expression.  
			  (<i>similar to the <b>switch</b> statement in the C programming language</i>). Each clause is a list (<b>matchexp resultexp</b>) 
			  which contains a match expression followed by a result expression.  Each match expression is an atom, a list of atoms, 
			  or the keyword <b>else</b>.</p>
			  <p>First the selector clause (<b>selectorClause</b>) expression is evaluated, and the result value is compared with the 
			  match expression from each match clause (<b>matchClause</b>) until the comparison returns true or until a match with 
			  the keyword <b>else</b> is encountered.  The selector value is compared to each match expression using the <b>isMember</b>
			  function, if the (<b>matchClause</b>) is a list, and the <b>isEqual</b> function, if (<b>matchClause</b>) is not a list.  
			  If no selector matches, the case special form returns the value False.  If a clause is selected, the expression in the 
			  clause is evaluated.  If no match occurred, and the else keyword is present, 
			  the expression following the else keyword will be evaluated.</p>
			  <!-- Type and Syntax Template -->
			  <p>&nbsp;</p>
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case  selectorClause  (matchClause) ? )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(case  selectorClause  (matchClause) ? (elseClause))</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>selectorClause</th>
			      <td>An expression to be evaluated.</td>
			    </tr>
			    <tr>
			      <th>(matchClause)'s</th>
			      <td>Any number of <b>matchClauses</b> can be present. Each match clause is a list (<b>matchexp resultexp</b>) 
			      which contains a match expression followed by a result expression. Each match expression is an atom, a list of atoms.</td>
			    </tr>
			    <tr>
			      <th>(elseClause)</th>
			      <td>(Optional) If present there can only be one else clause.  Each else clause is a list (<b>else resultexp</b>). 
			      The head of the list is the keyword <b>else</b> followed by a result expression.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The <b>selectorClause</b> is compared to each <b>matchClause</b>. If the match clause is a list the comparison implements <b>isMember</b> 
			      function to determine if the selector matches an element in the list.   If the match clause is not a list, the <b>isEqual</b> 
			      function will be used to determine if the selector clause matches the match clause. If no selector matches, 
			      the <b>case</b> special form returns the value False.  If a clause is selected, the expression in the clause is evaluated.  
			      If no match occurred, and the <b>else</b> keyword is present, the expression following the <b>else</b> keyword will be evaluated.
			      </td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p><font color="red">[...under construction...]</font></p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (case  (*  2  3)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((2  3  5  7)  'PRIME)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((1  4  6  8  9)  'COMPOSITE))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'COMPOSITE</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 2</u></b></p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (case (+ 4 -2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (1 '(DO-THIS))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (2 '(DO-THAT))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (else '(DO-THE-OTHER)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'(DO-THAT)</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 3</u></b></p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (case  2</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (1  (+ 8 9))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (2 (begin (+ 1 2) (* 4 5)))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (else (/ 5 6)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;20</p>
			  <p>&nbsp;</p>
			    <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p><font color=red>[...under construction...]</font></p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Scompile"></A>compile</H2></P>
             <div class="h2section" id="compile">
			 <p>The <b>compile</b> function compiles the Analytic Information Server generic parse tree (<b>parseTree</b>) argument 
			  (normally the output from lisp) and returns an Lambda object. If the optional (<b>anLambda</b>) argument is passed, 
			  it becomes the target of the compilation and is returned; otherwise, a new Lambda object is returned. 
			  If the optional true argument is passed, the compilation always inherits the persistent variables of the 
			  optional (<b>anLambda</b>) argument.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (compile  parseTree)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (compile parseTree anLambda)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (compile parseTree anLambda true)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>parseTree</th>
			      <td>An Analytic Information Server generic parse tree (normally output from lisp)</td>
			    </tr>
			    <tr>
			      <th>anLambda</th>
			      <td>Optional Argument. If present, it specifies the target (Lambda) of the compilation. 
			      If not present,  a new Lambda object is returned.</td>
			    </tr>
			    <tr>
			      <th>true</th>
			      <td>Optional Argument. If present, the compilation will inherit the persistent variables 
			      of the {anLambda} argument.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>An executable Lambda object.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the compile function when producing an Lambda from a parse tree is required. 
			  Normally, a two step process will compile Lisp source: lisp, followed by compile.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>We can create Lambdas from Lisp source by using the compile function.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (compile (lisp "(lambda(x) (+ x x))")))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 291&gt;</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>We can create Lambda objects by using the <b>makeLambda</b> function (without resorting to using compile). 
			  For instance, an Lambda to execute the following Lisp code.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (lambda (n) #void)</p>
			  <p>Can be created from the following Lisp code.</p> 
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (makeLambda</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  Av: #{n: 0}</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  Pv: #{__C0 10}</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  Pc: #(pcd| 0))</p>
			  <p>The same result can be obtained from the following Lisp expression.</p> 
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (compile '(lambda (n) #void))</p>
               </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Scond"></A>cond</H2></P>
             <div class="h2section" id="cond">
			 <p>The <b>cond</b> Special Form selects one of a series of clauses to evaluate based upon the value of their guard expressions.  
			  Each guard expression is a list (<b>guardexp  resultexp</b>). The head of the list is a  guardexp which is a test expression that 
			  results in a Boolean value and the resultexp is any Lisp expression. From left to right each guard expression, is evaluated. 
			  If the result is True, the result expression is evaluated and the cond Special Form terminates.  If the result is False, 
			  the following guard expressions are evaluated until a true is encountered or until the keyword else is encountered.  
			  If no guard expression is True or no else is present, the cond Special Form returns the Boolean value False.</p>
			    <!-- Type and Syntax Template -->
			  <p>&nbsp;</p>
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond ((guardexp) resultexp) ?)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cond ((guardexp) resultexp) ? (else resultexp))</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>guardexp</th>
			      <td>An expression to be evaluated.</td>
			    </tr>
			    <tr>
			      <th width=20%>((guardexp) resultexp)'s</th>
			      <td>Any number of <b>((guardexp) resultexp)</b> clauses can be present. Each <b>guardexp</b> is a Lisp expression 
			      which, if it returns true, will cause its (<b>resultexp</b>) to be evaluated. Only the resultexp, paired with the
			      first <b>true</b> guardexp, is evaluated. All remaining <b>((guardexp) resultexp)</b> clauses are skipped. If no
			      guardexp ever returns true, then the optional <b>else</b> clause is evaluated (if present).</td>
			    </tr>
			    <tr>
			      <th>(else resultExp)</th>
			      <td>(Optional) If present there can only be one else clause.  Each else clause is a list (<b>else resultexp</b>). 
			      The head of the list is the keyword <b>else</b> followed by a result expression.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>Each <b>guardexp</b> is evaluated. If no guardexp returns true, 
			      the <b>cond</b> special form returns the value False.  If a guardexp return true, the resultexp in the clause is evaluated 
			      and the value of that resultexp is returned.  If no guardexp returns true, and the <b>else</b> keyword is present, the expression 
			      following the <b>else</b> keyword will be evaluated.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The <b>cond</b> Special Form behaves like a series of Lisp if - else special forms. Use the cond special form when the
			  use of multiple if - else forms would make the program less readable.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (cond ((&gt; 3 2) 'GREATER)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((&lt; 3 2) 'LESS-THAN))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'GREATER</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 2</u></b></p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (cond ((&gt; 3 3) 'GREATER)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((&lt; 3 1) 'LESS-THAN)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (else 'EQUAL))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'EQUAL</p>
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 3</u></b></p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (cond ((&gt; 3 3) 'GREATER)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((&lt; 3 1) 'LESS-THAN)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p><font color=red>[...under construction...]</font></p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Seval"></A>eval</H2></P>
          <div class="h2section" id="eval">
		   <p>The <b>eval</b> Function evaluates the argument {exp} and returns the resulting value. 
		  When the input to eval is a List, invoking eval is equivalent to invoking compile, and eval.   
		  If the eval Function is passed a string as an argument, invoking eval is equivalent to invoking lisp, compile, and eval.
		  If the eval Function is passed an Lambda as an argument, invoking eval is equivalent to invoking the Lambda with no arguments.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (eval string)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (eval list)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (eval Lambda)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>string</th>
		      <td>A string containing a Lisp language expression to be compiled and evaluated.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>Always returns the result of (eval (compile (lisp string))).</td>
		    </tr>
		  </table>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>list</th>
		      <td>A list containing a parse tree expression to be compiled and evaluated.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>Always returns the result of (eval (compile list)).</td>
		    </tr>
		  </table>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>Lambda</th>
		      <td>An Lambda to be invoked with no arguments.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>Always returns the result of (Lambda).</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the eval function whenever a lisp expression or an Lambda needs to be evaluated.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here follows an example of the eval function in action.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (eval {(lambda() "Hello world")})&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"Hello World"</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>The eval Function should only be passed Lambdas of zero arguments.</p>
          </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sgoto"></A>goto</H2></P>
         <div class="h2section" id="goto">
		<p>The <b>goto</b> special form allows Lisp Lambdas to transfer control to goto labels within an <a href="Lambda.htm">Lambda</a>.  
		  The goto label is a symbol that is suffixed with the <b>::</b> character pair when it is defined, and with the <b>:</b> 
		  character when it is referenced in the goto expression.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (goto label:)</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (goto register)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>label</th>
		      <td>The label of the location where execution control is to be transferred.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The program will start executing at the position specified by the <b>label::</b> and the goto special form returns True.</td>
		    </tr>
		  </table>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>register</th>
		      <td>The name of a register containing the location where execution control is to be transferred.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The program will start executing at the position specified by the <b>label::</b> and the goto special form returns True.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>The <b>goto</b> special form is used to handle unconditional branches within an <a href="Lambda.htm">Lambda</a>.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here follow just a few examples of goto forms in action.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defun  foo(X)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (goto TWO:)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  ONE::</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (writeln "ONE " X)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (goto EXIT:)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  TWO::</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (writeln "TWO" )</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (goto ONE:)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  EXIT::</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (writeln "foo EXIT" ))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 2195&gt;</p>
		  <p>The invocation of foo produces the following console output.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (foo 1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;TWO</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;ONE 1</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;foo EXIT</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p><font color=red>[...under construction...]</font></p>
           </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SConditional goto"></A>Conditional goto</H2></P>
            <div class="h2section" id="Conditional goto">
			 <p>The conditional goto <b>gotoCCt</b> special form allows Lisp Lambdas to conditionally branch to goto labels within an <a href="Lambda.htm">Lambda</a>.  
			  The expressions {exp1} and {exp2} are evaluated and {exp2} is compared with {exp1}. If the specified condition <i>CC</i> of the <b>goto<i>CC</i></b> 
			  conditional goto is true, then the program will start executing at the location specified by the (<b>LabelName:</b>).  
			  The conditional goto label is a symbol that is suffixed with the <b>::</b> character pair when it is defined, and with the <b>:</b>
			  character when it is referenced in the conditional goto expression. The values of the goto contitionals <i>CC</i> are as follows.</p> 
			  <ul>
			  	<li>LT&nbsp;&nbsp;&nbsp;&nbsp;(less than)</li>
			  	<li>LE&nbsp;&nbsp;&nbsp;&nbsp;(less than or equal)</li>
			  	<li>EQ&nbsp;&nbsp;&nbsp;&nbsp;(equal)</li>
			  	<li>NE&nbsp;&nbsp;&nbsp;&nbsp;(not equal)</li>
			  	<li>GE&nbsp;&nbsp;&nbsp;&nbsp;(greater than or equal)</li>
			  	<li>GT&nbsp;&nbsp;&nbsp;&nbsp;(greater than)</li>
			  </ul>
			  <p>An optional strong typing indicator <b>gotoCC<i>t</i></b> may be appended, which causes the generation of the appropriate
			  memory to memory strongly typed comparison. The values of the optional strong typing indicators <i>t</i> are as follows.</p>
			  <ul>
			  	<li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(generic compare)</li>
			  	<li>b&nbsp;&nbsp;&nbsp;&nbsp;(bit compare)</li>
			  	<li>c&nbsp;&nbsp;&nbsp;&nbsp;(character compare)</li>
			  	<li>i&nbsp;&nbsp;&nbsp;&nbsp;(integer compare)</li>
			  	<li>n&nbsp;&nbsp;&nbsp;&nbsp;(number compare)</li>
			  </ul>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (goto<i>CC</i> exp1 exp2 LabelName:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (goto<i>CCt</i> exp1 exp2 LabelName:)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>exp1</th>
			      <td>The first expression to be compared.</td>
			    </tr>
			    <tr>
			      <th>exp2</th>
			      <td>The second expression to be compared.</td>
			    </tr>
			    <tr>
			      <th>LabelName</th>
			      <td>The label of the location where execution control is to conditionally be transferred.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The program will conditionally start executing at the position specified by the <b>label::</b> 
			      and the conditional goto special form returns True.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>The conditional goto Special Form is used whenever it is necessary to test for a condition before branching to a 
			  location (label) in an <a href="Lambda.htm">Lambda</a>.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here follow just a few examples of conditional goto forms in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun  foo(X)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (gotoGTi (* X 2) 0 TWO:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ONE::</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (writeln "ONE " X)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (gotoEQ X 1 EXIT:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  TWO::</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (writeln "TWO" )</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (goto ONE:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  EXIT::</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (writeln "foo EXIT" ))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 2195&gt;</p>
			  <p>The invocation of foo produces the following console output.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo 1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;TWO</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;ONE 1</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  <b>console</b>&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;foo EXIT</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p><font color=red>[...under construction...]</font></p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sif"></A>if</H2></P>
        <div class="h2section" id="if">
		<p>The <b>if</b> special form selects one of two expressions to evaluate based upon the value of a (<b>testClause</b>) expression.  
		  If the (<b>testClause</b>) evaluates to true, then the (<b>thenClause</b>) expression is evaluated; otherwise, the (<b>elseClause</b>) 
		  expression is evaluated.  The (<b>testClause</b>) and (<b>thenClause</b>) expressions are mandatory. 
		  The (<b>elseClause</b>) expression is optional.  The (<b>thenClause</b>) and (<b>elseClause</b>) expressions may be preceded 
		  by optional <i>then</i> and <i>else</i> keywords for readability.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (if  (testClause) then (thenClause) else (elseClause))&nbsp;&nbsp;&nbsp;; Generates efficient code</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (if  (testClause) (thenClause) (elseClause))&nbsp;&nbsp;&nbsp;; Generates efficient code</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (if  (testClause) then (thenClause))&nbsp;&nbsp;&nbsp;; Generates efficient code</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (if  (testClause) (thenClause)); Returns <i>false</i> when <i>testClause</i> fails</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th width=20%>(testClause)</th>
		      <td>An expression that returns a Boolean value.</td>
		    </tr>
		    <tr>
		      <th width=20%>then</th>
		      <td>Optional Keyword.</td>
		    </tr>
		    <tr>
		      <th width=20%>(thenClause)</th>
		      <td>The expression to be executed if the test clause returns true.</td>
		    </tr>
		    <tr>
		      <th width=20%>else</th>
		      <td>Optional Keyword.</td>
		    </tr>
		    <tr>
		      <th width=20%>(elseClause)</th>
		      <td>The expression to  be executed if the test clause does NOT returns true.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>Returns the value of the expression evaluated.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the <b>if</b> special form when conditional execution of expressions is essential for your application program.</p>
		  <p>Use the <b>if</b> special form with the <i>then</i> keyword to generate efficient code without returning <i>false</i> when the test clause fails.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here are just a few examples of the <b>if</b> special form in action.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (&gt; 3 2) then 'YES else 'NO)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'YES</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (&gt; 2 2) then 'YES else (+ 1 2))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (&gt; 2  3) 'YES)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (&gt; 2 3) then 'YES)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;...undefined...</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (and (icompareLT 2  3) (icompareGT  3  2)) 'YES 'NO)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'YES</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (if (compareGT 2  3) 'YES (+ 3 4))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;7</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>The <b>if</b> special form is similar to the <b>cond</b> special form, except the cond special form
		  supports more than two choices of clauses.</p>		
          </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Slet"></A>let</H2></P>
        <div class="h2section" id="let">
		<p>The <b>let</b> special form extends the current environment and evaluates the expressions (<b>exp...</b>) 
		  in the extended environment.  The let special form evaluates the initial expressions (<b>init</b>).  
		  The current environment is then extended to include the specified variables (<b>var</b>).  
		  The initial expressions (<b>init</b>) are then bound to the proper variables (<b>var</b>). 
		  The expressions (<b>exp</b>) are evaluated from left to right, and the value of the final expression is returned.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (let ((var init)...  ) exp...)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>var</th>
		      <td>Variable name</td>
		    </tr>
		    <tr>
		      <th>init</th>
		      <td>Constant expression with which to initialize the variable.</td>
		    </tr>
		    <tr>
		      <th>exp</th>
		      <td>One or more Lisp expressions.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The expressions are evaluated from left to right and the value of the final expression is returned.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the <b>let</b> form when a series of expressions need to be extended with additional local variables.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here are just a few examples of the let special form in action.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (let ((X 2) (Y 3)) (* X Y))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;6</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  X&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;6</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (let ((X 2) (Y 3))</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (let ((foo(lambda(Z) (+ X Y Z))) (X 7))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 281&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (foo 4)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;9</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  X&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;6</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>The <b>let</b> special form always extends either the global environment or the persistent environment
		  of the enclosed lambda expression. For instance:</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (let ((X 2)) (lambda() true))</p>
		  <p>Is the equivalent of the following.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (lambda() pvars:((X 2)) true)</p>
		  <p>&nbsp;</p>
           </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Slisp"></A>lisp</H2></P>
             <div class="h2section" id="lisp">
			<p>The <b>lisp</b> function performs normal Analytic Information Server lexical analysis on the (<b>inputString</b>) argument. 
			  The input argument must be a string containing a valid simple or compound Lisp expression. The output of the lisp function 
			  is an Analytic Information Server parse tree List containing Lisp lexical and semantic tokens. Normal Lisp strings are passed 
			  to the lisp function, whose output is passed to the compile function. The final result, which is produced by compile, 
			  is an executable Lambda Object ready to perform its assigned tasks.</p>
			  <p>This two-step process allows the use of plug-n-play parsers, thus permitting Analytic Information Server to operate with 
			  alternate programming languages. The <b>lisp</b> function looks for any directive such as <b>#name#</b> in the very first
			  character positions of the input string. The presence of such a directive will cause the lisp parser to pass control to
			  the global variable <b>name</b> on the assumption that this is an alternate parser. Alternate AIS parser must produce an
			  AIS parse tree list like the <b>lisp</b> function does</p>
			  <p>If the optional Lambda argument (<b>anLambda</b>), is present, the input source string is converted into a Token Vector 
			  and stored in the Sc property of the Lambda (see the <b>disassemble</b> Function). This allows the original source to be stored 
			  with the Lambda after compilation.</p>
			  <p>Normal Lisp lexical analyzers recognize tokens separated by white space.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?1  +  2?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;three tokens: '(1 + 2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?1+2?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;one token: '1+2</p>
			  <p>If the optional <b>arithmetic:</b> argument is passed, it causes the normal Lisp names to be separated 
			  by the arithmetic operators  + - * &#47 &#60 &#62 =.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?1  +  2?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;three tokens: '(1 + 2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?1+2?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;three tokens: '(1 + 2)</p>
			  <p>If the optional extended: argument is passed, the normal Lisp lexical analysis is altered as follows:</p>
			  <ul>
			  	<li>The lexical symbol ' is no longer a lexical quote operator, and becomes a stand-alone operator symbol.</li>
			  	<li>The lexical symbols  '  ,  [  ]  {  }  (  )  ;  .  Become singleton (ungrouped) stand-alone operator symbols.</li>
			  	<li>The lexical symbols !  @  #  $  %  ^  &  *  -  =  +  |  &#92  : &#60 &#62  ?  /  Become clustered (grouped) operator symbols.</li>
			  	<li>The lexical constants for Money, Integer, Number, and String are still recognized as in normal AIS Lisp.</li>
			  	<li>The lexical Lisp names are now terminated when a grouped or ungrouped operator symbol is encountered.</li>
			  	<li>The arithmetic operators become separators.</li>
			  </ul>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?(1  +  2)? extended:) &nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;five tokens: '(|(| 1 + 2 |)|)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?1+2?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;three tokens: '(1 + 2)</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString anLambda)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString extended:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString anLambda extended:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString arithmetic:)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp inputString anLambda arithmetic:)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>inputString</th>
			      <td>Must be a valid Lisp string. If the string begins with #LambdaName# where LambdaName is predefined Lambda, 
			      the entire input string will be passed to the Lambda which will perform the lexical analysis.</td>
			    </tr>
			    <tr>
			      <th>anLambda</th>
			      <td>(Optional) The name of the Lambda that will be associated with the result of the lexical analysis.</td>
			    </tr>
			    <tr>
			      <th>extended:</th>
			      <td>(Optional) Converts the lisp function into a lexical analyzer for simple expressions.</td>
			    </tr>
			    <tr>
			      <th>arithmetic:</th>
			      <td>(Optional) Causes the normal Lisp names to be separated by the arithmetic operators  + - * &#47 &#60 &#62 = .</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>An executable Lambda object.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the lisp function when parsing a Lisp string is required. This function will perform full Lisp parsing 
			  or even elementary lexical parsing</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here is an example of the lisp function in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((compile (lisp ?(lambda(x) (+ x 2))?) 10)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;12</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (lisp ?(1 + 2)?)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;three tokens: '(1 + 2)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  ((compile (lisp ?#javaScript#function(x) {return(x + 2);}?) 10)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;12</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The <b>lisp</b> function can be used as an AIS Lisp parser or as a redirector to any number of other user 
			  defined languages.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sloop"></A>loop</H2></P>
           <div class="h2section" id="loop">
			<p>The <b>loop</b> Special Form performs fast numeric iteration.  The specified variable (<b>var</b>) is the index of the iteration. 
			  The (<b>init</b>) expression forms the initial value for (<b>var</b>) at the start of the iteration.  The (<b>step</b>) expression 
			  forms the value that is added to the (<b>var</b>) at the start of the next iteration</p>
			  <p>The (<b>final</b>) expression is compared to the (<b>var</b>) at the start of each iteration.  
			  If the to keyword is used, then the iterations will continue as long as (<b>var</b>) is less than or equal to (<b>final</b>).  
			  If the until keyword is used, then the iterations will continue as long as  (<b>var</b>) is less than (<b>final</b>). 
			  During each iteration, each (<b>stmt</b>) is evaluated in order. Next, the (<b>step</b>) value is added to the (<b>var</b>)</p>
			  <p>If the (<b>step</b>) value is positive, iteration stops when the var is greater than (<b>final</b>).  
			  If the (<b>step</b>) is negative, iteration stops when the (<b>var</b>) is less than (<b>final</b>).  
			  If the (<b>step</b>) is omitted, the step value is assumed to be 1, and iteration stops when 
			  the (<b>var</b>) is greater than (<b>final</b>).</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (loop for var from init to final by step do stmt...)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (loop for var from init until final by step do stmt...)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (loop for var from init to final do stmt...)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (loop for var from init until final do stmt...)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>var</th>
			      <td>Index Variable.</td>
			    </tr>
			    <tr>
			      <th>from</th>
			      <td>Mandatory keyword.</td>
			    </tr>
			    <tr>
			      <th>init</th>
			      <td>Initial value of the index variable (must be an Integer).</td>
			    </tr>
			    <tr>
			      <th>to/until</th>
			      <td>Mandatory keyword (must be either <b>to</b> or <b>until</b>.</td>
			    </tr>
			    <tr>
			      <th>final</th>
			      <td>Max value of the index variable. Must be an Integer.</td>
			    </tr>
			    <tr>
			      <th>by</th>
			      <td>Optional keyword.</td>
			    </tr>
			    <tr>
			      <th>step</th>
			      <td>The step value added to the index variable after an iteration (must be an Integer).</td>
			    </tr>
			    <tr>
			      <th>do</th>
			      <td>Optional keyword.</td>
			    </tr>
			    <tr>
			      <th>stmt</th>
			      <td>Multiple Lisp expressions (must be at least one statement).</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The final value of the (<b>var</b>) variable after exiting from the loop.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the loop special form when sequential integer iteration is advisable for your application program.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are two examples of the loop form in action.</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (loop for n from 1 to 10 by 1 do (display  " "  n))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;11</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  Console&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;1 2 3 4 5 6 7 8 9 10</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (loop for n from 1 until 10 by 1 do (display  " "  n))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;10</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  Console&nbsp;&nbsp;&nbsp;<i>==></i>&nbsp;&nbsp;&nbsp;1 2 3 4 5 6 7 8 9</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>For correct operation, the loop special form's control variables: var, init, final, and step must be integer variables.  
			  The loop special form uses fast integer virtual machine instructions to update its control operations: 
			  initializing the var (loop index variable), incrementing the var, (adding step to var), and comparing the 
			  values of var and final (the termination value).</p>	
             </div>		
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Smorph"></A>morph</H2></P>
         <div class="h2section" id="morph">
		<p>The <b>morph</b> Function performs normal Analytic Information Server macro substitution on the input argument, (<b>input</b>). 
		  The input argument (<b>input</b>) may be any Lisp form or forms enclosed in a list.  Often the morph function receives the 
		  output of the lisp function. The output of the morph function is a list, which has been transformed by macro substitution.  
		  Often the output of morph is input to the compile function; however, the morph function is also used to perform rule-based
		  transformations on list objects.</p>
		  <p>The second argument (<b>altRule</b>), called the alternative rule function, is optional. If the (<b>altRule</b>) function 
		  is specified, this function will perform the macro substitution in place of normal AIS macro substitution rules. 
		  The (<b>altRule</b>) function must be a function of one argument. The morph function will repeatedly send the (<b>altRule</b>)
		  function every sub-list within the original input. If the (<b>altRule</b>) function wishes to pass a sub-list without macro 
		  substitution, it should return the Boolean value false. If the (<b>altRule</b>) function wishes to perform macro substitution 
		  on a sub-list, it should return the transformation to be substituted in place of the original sub-list.</p>
		  <p>If the optional third argument (<b>altFailure</b>), is present, it may be any legal AIS value. 
		  If not present, it defaults to a Boolean value of False.</p>
		  <p>&nbsp;</p>
		  <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (morph input)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (morph input altRule)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (morph input altRule altFailure)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>input</th>
		      <td>A list within a list to be transformed with macro or rule-based substitution.</td>
		    </tr>
		    <tr>
		      <th>altRule</th>
		      <td>(Optional) must be a function expecting a single argument, and it will replace the normal AIS macro substitution rules.</td>
		    </tr>
		    <tr>
		      <th>altFailure</th>
		      <td>(Optional) The value to be recognized by morph that the substitution will not take place.  
		      If the altRule function returns the altFailure value, the morph function will not substitute.  
		      If the altRule function returns a value other than the altFailure value, morph will perform the substitution.  
		      If the alfFailure argument is not present, morph will assume that the failure value is the Boolean value False</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>A list which has been transformed by macro substitutions.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the morph function when macro transformation of a list is essential to your application program.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Simple Macro substitution using morph.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (morph '((++ x)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'(setq x (+ x 1)) ;; Note that the ++ is a built-in macro</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (morph 1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (morph '(1))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (morph '((*= x y)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;'(setq x (* x y)) ;; Note that the *= is a built-in macro</p>
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 2</u></b></p>
		  <p>Macro substitution using an alternative rule function (<b>altRule</b>) and alternative failure (<b>altFailure</b>) options.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defun foo(x)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (cond</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  ((and  (=  (length  x)  2)  (=  x[0]  add1:)  (isNumber  x[1])) (+  x[1]  1))</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  ((and  (=  (length  x)  3)  (=  x[0]  +:)  (isNumber  x[1]) (isNumber  x[2])) (+  x[1]  x[2]))</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (else _failure:)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 729&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (morph '(divi (+ (add1 34) 5) n) foo _failure:)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;(divi  40  n)</p>
		  <p>&nbsp;</p>
		  <p><u>What happens</u></p>
		  <p>&nbsp;&nbsp;&nbsp;First morph sends the innermost proper sublist to foo = > (foo '(add1  34)).</p>
		  <p>&nbsp;&nbsp;&nbsp;The result of (foo ?(add1  34)) => 35, is not the altFailure value _failure, so morph substitutes.</p>
		  <p>&nbsp;&nbsp;&nbsp;After substitution, the list appears as follows:   '(divi  (+  35  5) n).</p>
		  <p>&nbsp;&nbsp;&nbsp;Next morph sends the next innermost proper sublist to foo = > (foo ?(+  35  5)).</p>
		  <p>&nbsp;&nbsp;&nbsp;The result of (foo ?(+  35  5) => 40, is not the altFailure value _failure, so morph substitutes.</p>
		  <p>&nbsp;&nbsp;&nbsp;After substitution, the list appears as follows:  '(divi  40  n).</p>
		  <p>&nbsp;&nbsp;&nbsp;Next morph sends the next innermost proper sublist to foo = > (foo '(divi  40  n)).</p>
		  <p>&nbsp;&nbsp;&nbsp;The result of (foo '(divi  40  n) => _failure:, is the altFailure value _failure.</p>
		  <p>&nbsp;&nbsp;&nbsp;There are no more proper sublists, so the final morphed list appears as follows: '(divi  40  n).</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>The morph function can be used to built a rule-based list transforming forward production engine 
		  (see <a href="rulesLib.htm">rulesLib</a>).</p>
            </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Smyself"></A>myself</H2></P>
            <div class="h2section" id="myself">
			<p>The <b>myself</b> Special Form returns the currently evaluating Lambda object.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (myself)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>Returns</th>
			      <td>The evaluating executable Lambda object itself.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>myself</b> special form when the identity of the current Lambda object is required.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here is an example of the myself special form in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun foo() (myself))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 888&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 888&gt;</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The <b>myself</b> special form is necessary for an executing Lambda to gain access to its own object identity.</p>
			 </div>		 
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Snot"></A>not</H2></P>
           <div class="h2section" id="not">
			<p>The <b>not</b> function returns the Boolean complement of the argument. For all arguments, the <b>not</b> function
			  returns false if and only if the argument (<b>arg</b>) is true. If the argument (<b>arg</b>) is false, the <b>not</b> function 
			  returns true.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (not arg)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>arg</th>
			      <td>A boolean expression to be complemented.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>not</b> function when complementing a boolean expression is required for your application program.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the not function in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (not false)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (not (= 2 2))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (not (+ 2 2))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The not function is very useful in the succint implementation of many <b>if</b> special form conditions.</p>	
              </div>				
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SonError"></A>onError</H2></P>
            <div class="h2section" id="onError">
			<p>The <b>onError</b> Special Form assigns an error event handler function (<b>anLambda</b>).  The scope of the <b>onError</b> 
			  special form is limited to the scope of the current executing Lambda. Any error events, occurring during the scope of the current 
			  executing Lambda, will result in the specified error event handler Lambda being invoked.</p>
			  <p>The specified error event handler Lambda (<b>anLambda</b>), must be a function of one argument. The error event is converted 
			  into a text object and passed to the error event handler function.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (onError anLambda)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>anLambda</th>
			      <td>The specified error event handler Lambda (anLambda) must be a function of one argument.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>true</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the onError Special Form to define an error handler function for your program.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here follows a simple example of the onError special form in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (defun foo()</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (defun errHandler(err) (append "foo got the following error: " err))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (onError errHandler)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (error "badFoo"))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 194&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (foo)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"foo got the following error: badFoo"</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The onError special form is an important tool for error recovery in executable Lambda objects.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sor"></A>or</H2></P>
            <div class="h2section" id="or">
			<p>The <b>or</b> Special Form evaluates each expression from left to right, returning the value true at the first expression that is true.  
			  Any remaining expressions are not evaluated.  If no expression returns true, the value false is returned.  
			  If no expressions are specified, the value false is returned.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (or exp...)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>exp...</th>
			      <td>Any Number of boolean expressions.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>Returns the value true at the first expression that is true.  Any remaining expressions are not evaluated.  
			      If no expression returns true, the value false is returned.  If no expressions are specified, the value false is returned.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>or</b> Special Form to evaluate a group of expressions, and determine if any one expression in the aggregate is true.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the or special form in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (or (= 12 12) (&#62 2 1))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (or (= 24 24) (&#61 1 1))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;true</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (or 1 2 3 4 5)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (or)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The or special form is an important tool in succinctly expression <b>if</b> conditionals.</p>
	          </div>
       <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sparse"></A>parse</H2></P>
            <div class="h2section" id="parse">
			<p>The <b>parse</b> function converts a string value into a numeric, date, vector, or other value. 
			  The parse function converts the string according to the built-in Lisp parsing rules. If the string cannot be recognized, 
			  by one of the built-in Lisp parsing rules, the original string, without change, is returned.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (parse  string)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>string</th>
			      <td>The converted value of the string. If the string cannot be correctly parsed, the original string argument is returned.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>Returns the converted value of the string . If the string cannot be correctly parsed, the original string argument is returned.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the parse function when a Lisp constant is to be recognized from an input string.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>These examples show how a string may be parsed, using the built-in Lisp parsing rules. Each of the examples is parsed 
			  and converted, except the last example. It cannot be recognized, and the original string is returned.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (parse "3.141592")&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3.141592</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (parse "#Jan,19,1993")&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#Jan,19,1993</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (parse "#(1 2 3)")&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Vector 2194&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (parse  "23Hello")&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"23Hello"</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The parse function allows Lisp constants to be quickly recognized from strings.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Squote"></A>quote</H2></P>
              <div class="h2section" id="quote">
			  <p>The <b>quote</b> Special Form expands its arguments without evaluation of symbols, numbers, constants, or lists.  
			  The <b>quote</b> special form returns a list constructed from the specified argument expressions.  The newly constructed 
			  list is always returned.  The <b>quote</b> special form returns its argument expressions unevaluated as constants.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (quote expression...)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>expressions...</th>
			      <td>One or more Lisp expressions.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The unevaluated expressions returned as constants.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>quote</b> special form whenever a list is to be interpreted as constant.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the quote special form in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defun foo(x) (length x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 291&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq x (new Vector: 3 1 2 3))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(1 2 3)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  x&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#(1 2 3)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (<b>quote</b> x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;x</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (foo x)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (foo (<b>quote</b> x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (<b>quote</b> (foo x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;(foo x)</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The quote special form has an equivalent short hand form in the ' operator.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Srefmacro"></A>refmacro</H2></P>
         <div class="h2section" id="refmacro">
		 <p>The <b>refmacro</b> special form invokes a member macro (<b>macroName</b>) from its parent Lambda.  
		  The macro invocation may include 0 or more arguments. The <b>refmacro</b> special form can only be used on a macro that has been installed 
		  in the parent Lambda and is only invoked during compile time.
          </p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  ((refmacro name macroName) args...)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (name@macroName args...)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>name</th>
		      <td>The name of the parent Lambda (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>macroName</th>
		      <td>The name of the child macro to be invoked (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>arg1...</th>
		      <td>(Optional) Up to twenty arguments to be sent along with the message.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The result of invoking the child macro Lambda on the specified arguments.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the refmaco special form when a child macro Lambda is to be invoked during compilation.</p>
		  
              <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the colon operator in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defun foo(x) pvars:(v len) (setq v x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 291&gt;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (defmacro foo:len(self) pvars:(v len) (macroReplace self '(length (ref |Gv:foo| v))))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (setq x (new Vector: 3 1 2 3))</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  (foo x)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;
			  x<b>(foo@len foo)</b>&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;3</p>
			  <p>&nbsp;</p>	    
          </div>	
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Sreturn"></A>return</H2></P>
            <div class="h2section" id="return">
			<p>The <b>return</b> Special Form immediately returns the specified argument (<b>exp</b>) to the caller.  
			  The current Lambda gives up control and returns to its caller.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="black">Function</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (return exp)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>exp</th>
			      <td>Any Lisp expression.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>Immediately evaluates the expression, returns the value and resumes execution of the caller function.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</b></u></p>
			  <p>Use the <b<return</b> special form</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</b></u></p>
			  <p><font color="red">[...under construction...]</font></p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (begin (return 1) 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;1</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (begin (return (+ 2 3)) 2)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;5</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</b></u></p>
			  <p>The return special form allows premature return from an Lambda.</p>
             </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Ssend"></A>send</H2></P>
         <div class="h2section" id="send">
		 <p>The <b>send</b> special form sends a message (<b>msgName</b>) to an object and causes the corresponding message Lambda to be invoked.  
		  The Lambda invocation may include 0 or more arguments. The <b>send</b> special form can only be used on a method that has been installed 
		  in the Methods Dictionary for an object via the defmethod macro or the addMethod function.  The Methods Dictionary for any 
		  Analytic Information Server native type or object contains an arbitrary number of method bindings, i.e. message name and Lambda name pairs. 
		  The <b>send</b> special form causes a lookup of the message name argument in the Methods Dictionary specific object argument.  
		  If the message name is found, the corresponding message Lambda attached to the message name will be invoked.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (send msgName object)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (send msgName object arg1 arg2 ?)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (msgName:object)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (msgName:object arg1  arg2 ?)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>msgName</th>
		      <td>The message to be sent (must be a Symbol).</td>
		    </tr>
		    <tr>
		      <th>object</th>
		      <td>The target object (the object that responds to the message).</td>
		    </tr>
		    <tr>
		      <th>arg1...</th>
		      <td>(Optional) Up to twenty arguments to be sent along with the message.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The result of invoking the message Lambda on the specified object.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>Use the send special form when a message is to be sent to an object.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>Here are several examples of the send special form in action.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defmethod Lambda: square: (self x) (* x x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Dictionary 1234&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defun foo(x) pvars:(p1) (setq p1 x))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 634&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (foo 10)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;10</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (send square: foo foo.p1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;100</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (square:foo foo.p1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;100</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>Dissecting the send special form involves understanding the Methods Dictionary of any Analytic Information Server type. 
		  The send special form is translated as a reference into the Methods Dictionary. The translation is as follows.</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (msgName:object args...)&nbsp;&nbsp;&nbsp;<i>is Identical to</i>&nbsp;&nbsp;&nbsp;((ref (methodsOf (type object)) msgName) args?)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (square:aNumLambda 10)&nbsp;&nbsp;&nbsp;<i>is Identical to</i>&nbsp;&nbsp;&nbsp;((ref (methodsOf (type aNumLambda )) square: ) aNumLambda 10)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (square:aNumLambda aNumLambda.p1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;100</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (type aNumLambda)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;Lambda:</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (methodsOf (type aNumLambda))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Dictionary 194&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (ref (methodsOf (type aNumLambda)) square: )&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;#&lt;Lambda 164&gt;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  ((ref (methodsOf (type aNumLambda )) square: ) aNumLambda aNumLambda.p1)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;100</p>
		  <p>&nbsp;</p>	
          </div>	
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Ssetq"></A>setq</H2></P>
            <div class="h2section" id="setq">
			<p>The <b>setq</b> special form is a short hand form for the (<b>set</b>) function which assigns new values to variables.
			  A simple <b>set</b> function results in a simple assignment and is completely uncomplicated.
			  However, the <b>set</b> function can also be used to set a new value into a target object with indexing.
			  When indexing is used, the results of the <b>set</b> function depend upon the type of target object being indexed.
			  The result of a <b>set</b> function, with indexing, are complicated because we need to know the type of target object and the types of the indices.  
			  In all cases the <b>setq</b> special form converts easily into a longer <b>set</b> function call.
			  </p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq target newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1) newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1 index2) newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1 index2 index3) newValue)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>target</th>
			      <td>The target variable to be assigned.</td>
			    </tr>
			    <tr>
			      <th>index1</th>
			      <td>(Optional) A target variable index.</td>
			    </tr>
			    <tr>
			      <th>index2</th>
			      <td>(Optional) A target variable index.</td>
			    </tr>
			    <tr>
			      <th>index3</th>
			      <td>(Optional) A target variable index.</td>
			    </tr>
			    <tr>
			      <th>newValue</th>
			      <td>The new value to be assigned to the target variable.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>The result of setq depends upon the type of object in the target variable.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the <b>setq</b> special form when a longer <b>set</b> function is too cumbersome.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Equivalence Examples</u></b></p>
			  <p>Here are several examples of the setq special form and set function equivalences.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set 'target newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target: newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(vmmove newValue target)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1) newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target[index1] newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target.index1 newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1 index2) newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 index2 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target[index1 index2] newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 index2 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq (ref target index1 index2 index3) newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 index2 index3 newValue)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq target[index1 index2 index3] newValue)&nbsp;&nbsp;&nbsp;<i>Same As</i>&nbsp;&nbsp;&nbsp;(set target index1 index2 index3 newValue)</p>
			  <p>&nbsp;</p>	
              </div>		    
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Ssuper"></A>super</H2></P>
          <div class="h2section" id="super">
		  <p>The <b>super</b> Special Form supports symbolic messaging with any number of arguments. 
		  The message argument must be an element of type Symbol, and there must be at least one argument.
		  The action taken by the symbolic message is dependent upon the type of the first argument.  
		  The message symbol is looked up in the Methods Dictionary attached to the type's Parent type (see the defmethod Macro).  
		  If the message symbol is found, the associated Lambda is invoked against the whole argument list.  
		  If the message symbol is not found, an error condition results.</p>
		  <p>&nbsp;</p>
		    <!-- Type and Syntax Template -->
		  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
		  <p>&nbsp;</p>
		  <p class="syntax">Syntax examples</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
		  (super message object args...)</p>
		  <p>&nbsp;</p>
		  <!-- Arguments Table Template -->
		  <p class="arguments"><u>Arguments</u></p>
		  <hr>
		  <table border="3" cellpadding="2" class="members_table">
		    <colgroup>
		      <col>
		      <col style="font-style:italic">
		    </colgroup>
		    <tr>
		      <th>message</th>
		      <td>The symbolic name of the message to be sent.</td>
		    </tr>
		    <tr>
		      <th>object</th>
		      <td>The object whose parent message Lambda is to be invoked.</td>
		    </tr>
		    <tr>
		      <th>args...</th>
		      <td>(Optional) Up to twenty arguments.</td>
		    </tr>
		    <tr>
		      <th>Returns</th>
		      <td>The result of invoking the parent message Lambda with the specified arguments.</td>
		    </tr>
		  </table>
		  <hr>
		  <!-- When To Use Template -->
		  <p>&nbsp;</p>
		  <p class="whentouse"><u><b>When To Use</u></b></p>
		  <p>The super Special Form can only be used on a type that has been defined that is a child of a parent type. 
		  The message {message} in the argument list must that have been installed in the Methods Dictionary for the parent 
		  type via the defmethod macro or the addMethod function.  The Methods Dictionary for any Analytic Information Server 
		  native type or object contains an arbitrary number of method bindings, i.e. message name and Lambda name pairs.  
		  The super command causes a lookup of the message name argument in the Methods Dictionary for the parent type.  
		  If the message name is found, the Lambda attached to the name will be invoked.</p>
		  <!-- Code Eaxmples Template -->
		  <p>&nbsp;</p>
		  <p class="example"><u><b>Example 1</u></b></p>
		  <p>This example demonstrates normal object oriented messaging in Analytic Information Server. First, we define two types of objects: 
		  employees and managers. Managers inherit from employees. Each type is taught how to talk.</p>
		  <p>&nbsp;</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defclass employee: 'name 'job 'salary)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defmethod  employee:talk(me) "I am an employee.")</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (talk:(new  employee:))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"I am an employee."</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defclass manager: include: employee: 'department)</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (defmethod manager:talk(me) "I am a manager.")</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (talk:(new manager:))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"I am a manager."</p>
		  <p class="code">&nbsp;&nbsp;&nbsp; 
		  (super talk:(new manager:))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;"I am an employee."</p>
		  <p>&nbsp;</p>
		  <!-- Notes & Hints Template -->
		  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
		  <p>The super special form can be used to send messages to the parent class of an object.</p>
          </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="Swhile"></A>while</H2></P>
             <div class="h2section" id="while">
			<p>The <b>while</b> Special Form repeatedly evaluates the expression {exp...} while the test clause {test} evaluates to True.  
			  When the test clause evaluates to something other than True execution halts and this value is returned.  
			  An optional do keyword may precede the {exp...}.</p>
			  <p>&nbsp;</p>
			    <!-- Type and Syntax Template -->
			  <p class="type">Type:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="black">Special Form</font></p>
			  <p>&nbsp;</p>
			  <p class="syntax">Syntax examples</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (while test exp...)</p>
			  <p class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
			  (while test do exp...)</p>
			  <p>&nbsp;</p>
			  <!-- Arguments Table Template -->
			  <p class="arguments"><u>Arguments</u></p>
			  <hr>
			  <table border="3" cellpadding="2" class="members_table">
			    <colgroup>
			      <col>
			      <col style="font-style:italic">
			    </colgroup>
			    <tr>
			      <th>test</th>
			      <td>An expression returning a Boolean: true or false.</td>
			    </tr>
			    <tr>
			      <th>exp...</th>
			      <td>One or more Lisp expressions to be executed while the test expression is true.</td>
			    </tr>
			    <tr>
			      <th>Returns</th>
			      <td>Always returns the final result of the test expression.</td>
			    </tr>
			  </table>
			  <hr>
			  <!-- When To Use Template -->
			  <p>&nbsp;</p>
			  <p class="whentouse"><u><b>When To Use</u></b></p>
			  <p>Use the while special form to iterate an expression or set of expressions while a test condition is True. 
			  The test clause is always evaluated first.</p>
			  <!-- Code Eaxmples Template -->
			  <p>&nbsp;</p>
			  <p class="example"><u><b>Example 1</u></b></p>
			  <p>Here are just a few examples of the while special form in action.</p>
			  <p>&nbsp;</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (setq Y 10)&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;10</p>
			  <p class="code">&nbsp;&nbsp;&nbsp; 
			  (while (> Y 0) do (setq Y (- Y 1)))&nbsp;&nbsp;&nbsp;<i>Returns</i>&nbsp;&nbsp;&nbsp;false</p>
			  <p>&nbsp;</p>
			  <!-- Notes & Hints Template -->
			  <p class="notes"><u><b>Notes &amp; Hints</u></b></p>
			  <p>The while special form is used to iterate an expression or set of expressions while a test condition is True. 
			  The test clause is always evaluated first.</p>
              </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P>

 

</BODY>
</HTML>