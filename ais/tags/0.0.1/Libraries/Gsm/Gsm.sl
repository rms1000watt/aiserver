;;*************************************
;;*************************************
;; Exported Lambda File Cabinet Document
;;*************************************
;;*************************************
;;version=5.0011-64bit
;;location=AgentAppCabinets/Gsm.sl
;;storageScope=file
;;importSync=none
;;exportSync=none
;;autoCompile=true
;;objRepoName=AgentAppBinary/Gsm.db
;;lastImport=#Sep,23,2009:23:09:44
;;END __DATA

;;**EXPORTKEY**:gsm
(defun gsm(ObjVector:X NumVector:Y Integer:G Number:S ...)
;; *******************************************************************
;;
;; summary: The Grammatical Swarm Symbolic Regression Machine Lambda (GSM) is a learning machine which learns to
;;          select and score the best individuals from a universe of individuals over time. Over  
;;          a series of discrete time steps, a universe of individuals is collected for each time
;;          step. The individuals are things such as Stocks, People, Cities, etc. The discrete time
;;          steps are weeks, days, seconds, years, microseconds, etc.
;;       
;;          Each individual followed by the system is given a unique identifier which remains
;;          unique across all time periods studied (no two individuals ever have the same identifier).
;;          Furthermore, each time period studied is given a unique ascending integer index (i.e. week 1,
;;          week 2, etc.). So, for a series of time periods, historical information about groups of
;;          individuals is collected for each time period. The historical information collected for each
;;          individual for each time period is stored in a Number Vector and includes: the time period index;
;;          the unique identifier of the individual; and other numeric information about the individual
;;          pertinent to the current investigation. Finally, each individual in each time period is given
;;          a numeric "score" which determines the value of the individual in that time period. The "best"
;;          individuals have the highest "score" values.
;;
;;          During training, the GSM is given historical information for time periods 0 through T for
;;          all individuals. The GSM is also given the "score" values for each individual in each training
;;          time period from 0 through T. During training the GSM attempts to "learn" any patterns in 
;;          the available historical data. The machine (GSM) is free to discover static as well as time
;;          varying patterns.
;;
;;          During forward prediction, the GSM is given new information for time period T+1 for
;;          all individuals. The GSM is NOT given the "score" values for each individual in the new
;;          time period T+1. During prediction the GSM attempts to use any patterns it has learned to 
;;          select and score the best individuals from the universe of individuals seen in time period T+1. The 
;;          machine (GSM) is free to select no individuals in time period T+1 (an "I am uncertain" response). 
;;          Once the machine selects and scores a set of individuals, the accuracy of the machine is determined by
;;          least squares error on the selected individuals, averaging the actual "score" values for the selected
;;          individuals (which the machine has never seen) with the average "score" for all individuals 
;;          in time period T+1, or by other appropriate methods.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;; SelfTest Scripts:
;;           (gsm.setOptions Symbol:Option Number:RandomError Boolean:VerboseSW)(gsm.selfTest Symbol:Test Integer:Ns Integer:Ms Integer:Gs Number:Ss)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest crossCorrelation: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest cubicRegression: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest hyperTangent: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest elipsoid: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest hiddenModel: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest linearRegression: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest mixedModels: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest ratioRegression: 10000 20 10 .01)
;;           (gsm.setOptions regressGSOALPS: 40% true)(gsm.selfTest cyclicSeries: 10000 20 10 .01)
;;
;; SelfTest Scripts (with user defined WFFs):
;;           (gsm.setOptions regressGSOALPS: 00% true)(gsm.setUserGrammarWFFs #("(ruleReg #((ruleSin x2)))"))(gsm.selfTest hiddenModel: 10000 5 20 .05)
;;           (gsm.setOptions regressSWARM: 00% true)(gsm.setUserGrammarWFFs #("(ruleReg #((ruleSin (ruleMul c0 v0))))"))(gsm.selfTest hiddenModel: 10000 5 20 .05)
;;           (gsm.setOptions regressSWARM: 40% true)(gsm.setUserGrammarWFFs #("(ruleReg #((ruleSin (ruleAdd (ruleMul c0 v0) e0))))"))(gsm.selfTest hiddenModel: 10000 5 20 .05)
;;           (gsm.setOptions regressSWARM: 00% true)(gsm.setUserGrammarWFFs #("(ruleMvl #((ruleTanh (ruleCube v0)) (ruleTanh (ruleCube v1))))"))(gsm.selfTest hiddenModel: 10000 2 20 .05)
;;           (gsm.setOptions regressSWARM: 00% true)(gsm.setUserGrammarWFFs #("(ruleMvl #((ruleMul v0 (ruleMul v1 v2)) (ruleMul v3 (ruleMul v4 v5)) (ruleMul v6 (ruleMul v7 v8))))"))(gsm.selfTest crossCorrelation: 10000 3 5 .05)
;;           (gsm.setOptions regressSWARM: 40% true)(gsm.setUserGrammarWFFs #("(ruleMvl #((ruleMul v0 (ruleMul v1 v2)) (ruleMul v3 (ruleMul v4 v5)) (ruleMul v6 (ruleMul v7 v8)) (ruleMul v9 (ruleMul v10 v11))))"))(gsm.selfTest crossCorrelation: 10000 4 100 .05)
;;           (gsm.setOptions regressSWARM: 00% true)(gsm.setUserGrammarWFFs #("(ruleMvl #((ruleMul v0 (ruleMul v1 v2))))"))(gsm.selfTest userModel:10000 5 10 5% false gsm.mySeedDefault "regress(x2*x3*x4);")
;;
;; Depends:  browseLib 
;;           math 
;;           ParseLib 
;;           rulesLib 
;;
;; *******************************************************************
  pvars:(;; Public Variables

        (Number:myVersion 2.40)         ;; The current version number for this edition of the software.
		
        ;; Begin User Defined cross over Options
        (myCrossOverStrategy normal)  	;; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).
        (Number:myCrossAbsPct 0.00) 	;; The probability of cross over, using abstract expressions, during each generation step.
        (Number:myCrossColPct 0.00)  	;; The probability of cross over in each column island during each generation step.
        (Number:myCrossRegPct 0.00)  	;; The probability of cross over in the best-regressor island during each generation step.
        (Number:myCrossSelPct 1.00)  	;; The probability of cross over in the best-of-breed island during each generation step.
        (Number:myContextColPct 0.00)  	;; The probability of context aware cross over in each column island during each generation step.
        (Number:myContextRegPct 0.00)  	;; The probability of context aware cross over in the best-regressor island during each generation step.
        (Number:myContextSelPct 0.00)  	;; The probability of context aware cross over in the best-of-breed island during each generation step.
        ;; End User Defined cross over Options

        ;; Begin User Defined mutation Options
        (myMutateStrategy normal)  		;; The strategy used in the mutation operation (normal, constrained).
        (Number:myMutateAbsPct 0.00) 	;; The probability of mutation, using abstract expressions, during each generation step.
        (Number:myMutateColPct 0.00) 	;; The probability of mutation in each column island during each generation step.
        (Number:myMutateRegPct 0.00) 	;; The probability mutation in the best-regressor island during each generation step.
        (Number:myMutateSelPct 1.00) 	;; The probability mutation in the best-of-breed island during each generation step.
        ;; End User Defined mutation Options

        ;; Begin User Defined Learning Options
		(Number:myAbstractConsPct .25)  ;; The percent chance that an abstract constant will be generated during numeric constant generation.
		(Number:myAbstractNoisePct .10) ;; The percent chance that an abstract random noise term will be generated during variable generation.
		(Number:myAbstractVarsPct .10)  ;; The percent chance that an abstract variable will be generated during variable generation.
		(myAbstractOperators full)  	;; The valid abstract operators (math trig full noop).
        (Number:myAcceptMaxErr 9999.00) ;; The maximum acceptable fitness score, higher than this will result in a void candidate being returned. 
		(Integer:myBaggingCnt 10)       ;; The number of champion Lambdas to use when bagging creates a composite champion.
		(Number:myBaggingPct .50)       ;; The percent error score above which bagging is to start.
        (myBestAverage 1)  	            ;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	    (myBestAsConcreteWFF false)     ;; The switch to return the myBest WFF, grown in the best-of-breed island, as a concrete WFF. 
        (Integer:myBestOfBest 10)       ;; The maximum number of best of the best estimator champions to save.
        (Integer:myChromosomeGEN 0000)  ;; The maximum random root-chromosome genomes from different columns to grow during each generation step.
        (Integer:myChromosomeINIT 0000) ;; The maximum random root-chromosome genomes from different columns to grow during the initialization step.
	    (myChromosomeRule MVL:)         ;; The rule used for root-chromosome search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
		(Number:myCovarianceLimit .25)  ;; The maximum absolute value of the covariance between champions for entry into the alternate champion pool (only scriptGSOALPS).
		Number:myEvolutionMaxTickCount  ;; The maximum clock tick count before all evolutionary processes must halt (only scriptGSOALPS and scriptGABALPS).
        (Integer:myFRMMaximum 1000)     ;; The maximum number of chromosomes to allowed in any one FRM regression.
		(Number:myGetSeriousErr	2.0)    ;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
		(Integer:myGetSeriousGens 1000)	;; The count of generations after which we turn sampling off and set the training factor to 4.
        (Integer:myGreedyDepth 00)    	;; The depth of greedy search exploration of each chosen column island  during each generation step. 
        (Integer:myGreedyGEN  000)    	;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
        (Integer:myGreedyINIT 0000)    	;; The number of greedy search WFFs the system will grow in the best-of-breed island  during the initialization step. 
        (myGreedyWidth narrow)    	    ;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
        (myGreedyRule MVL:)          	;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
        (Integer:myGrowColINIT 00)   	;; The number of random WFFs the system will grow in each column island during the initialization step.
        (Integer:myGrowColGEN 00)    	;; The number of random WFFs the system will grow in each column island during each generation step. 
        (myGrowColRule REG:)         	;; The rule used for random WFFs grown in each column island (FRM, MVL, REG, or SVM). 
        (myGrowRootRule REG:)         	;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
        (Integer:myGrowSelINIT 0000)   	;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
        (Integer:myGrowSelGEN 00)    	;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
        (myGrowSelRule MVL:)         	;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
        (myGrowWFFStyle term:)       	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
        (Integer:myNoiseMaxGen 10)      ;; The maximum number of training generations in any one random noise swarm training regression.
		(Number:myNumberPct .25)     	;; The percent chance that a numeric constant will be generated during term generation.
        (Integer:myREGMaximum 1000)     ;; The maximum number of chromosomes to allowed in any one REG regression.
        (Integer:mySWMMaxGap 25)        ;; The maximum number of training generations without improvement before the swarm is reinitialized.
        (Integer:mySWMMaxGen 10)        ;; The maximum number of training generations in any one swarm training regression.
        (Integer:mySWMPool 500)         ;; The maximum size of the particle population pool allowed in any one swarm training regression.
        (Integer:myMaxColWFFLen 05)  	;; The maximum length of a single WFF for each column.
        (Number:myMigratePct 0.00)   	;; The probability of Column island mutation during each generation step.
		 myOptionSetting			    ;; The last option setting for this Lambda (see setOption).
        (Integer:myMVLMaximum 1000)     ;; The maximum number of chromosomes to allowed in any one MVL regression.
		myRandomFunction				;; The pseudo random number function currently selected for use.
        (myRandomError .00)          	;; The amount of random error to add to each selfTest test case (0.00 thru .50).
        (myREGMultiple true)            ;; Support multiple columns when growing REG regression expressions.
        (Integer:myREGMaximum 1000)     ;; The maximum number of chromosomes to allowed in any one REG regression.
        (Integer:myRestartEpoch 00010) 	;; The count of generations to allow before initializing a new age layered population.
        (Integer:myRestartGap 00010) 	;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
        (Integer:myRootINIT 00)  	 	;; The number of root WFFs the system will grow in each column island during the initialization step.
        (Integer:myRootGEN 00)       	;; The number of root WFFs the system will grow in each column island during each generation step. 
        (myRootRule REG:)            	;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
        (mySamplingON  true)   	     	;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
        (myScoreFocus full:)  	        ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
        (mySeedDefault 2407987.0)    	;; The default seed number used to initialize the random number genenerator at the start of each training run.
        (Integer:mySurvivors  25)     	;; The count of surviving estimator WFFs in each generation.
        (mySurvivorStyle equalOFF:)  	;; The option allowing surviving estimator WFFs to have equal scores (equalON, or equalOFF).
        (mySvmKernelID composite:)      ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
        (Integer:mySVMMaximum 1000)     ;; The maximum number of chromosomes to allowed in any one SVM regression.
        (mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
        (mySvmMaxLayers 1)             	;; The maximum number of training layers to use for all SVM learning (see svmRegress).
        (mySvmModelCount 1)             ;; The maximum number of training models to use for all SVM learning (see svmRegress).
        (Integer:myTournamentSize 05)	;; The size of the myBestEstimatorChampions queue which initiates a tournament-of-champions when the next evolutionary process begins.
		(Integer:myTrainingFactor 10)   ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
		myTrainingScript			    ;; The currently selected training script used for training this symbolic regression machine.
        (myUseFRM false)             	;; Grow FRM estimator candidates during the initialization step and during each generation step.
        (myUseMVL  true)             	;; Grow MVL estimator candidates during the initialization step and during each generation step.
        (myUseREG false)             	;; Grow REG estimator candidates during the initialization step and during each generation step.
        (myUseSVM false)             	;; Grow SVM estimator candidates during the initialization step and during each generation step.
        (myUseREGRatio 1.0)             ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
        (myVerboseSW false)		     	;; The switch controlling verbose mode during testing, maintennance, and development.
		(myWFFLengthLimit 5000)       	;; The maximum length, after which, any Estimator WFF will be rejected on the basis of size alone.
	    (myWFFSaveLimit 5000)           ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        (myWFFReinitSW true)            ;; The switch controlling the reinitialization of WFF cache at the start of every new run.
        ;; End User Defined Learning Options

     	;; System wide data and champion variables
		myBest            		     	;; The "best" estimator found during the training process.
		myBestModel     		     	;; The "best" estimator model formula found during the training process.
		myBestBoosted    		     	;; The "best" estimator found during the boosted training process.
		myBestEstimator    		     	;; The "best" estimator found during the current training process.
		myBestEstimatorChampions      	;; The "best" estimator found during any evolutionary training process.
		myBestEstimatorBestOfBest	    ;; The "best of the best" estimators found across all evolutionary training runs.
		myBestLinear     		     	;; The "best" linear multivariate estimator found during the training process (if available).
		myBestLinearAxis		     	;; The "best" linear multivariate estimator axis found during the training process (if available).
		myBestLinearCoefficients    	;; The "best" linear multivariate estimator coefficients found during the training process (if available).
		myBestLinearModel     		    ;; The "best" linear estimator model formula found during the training process.
		myBestRegressor    		     	;; The "best" regressor found during the current training process.
		myBestRegressorChampions	 	;; The "best" regressor found during any evolutionary training process.
		myBestRegressorIsland 	     	;; The index, into myPopulationIslands, of the best-overall regressor island.
		myBestSampler    		     	;; The "best" regressor used to create the last "difficult" sample vertical slice training process.
		myBestUncorrelatedIsland 	   	;; The index, into myPopulationIslands, of the best uncorrelated regressor island. 
        myColumnGenome               	;; The default genome containing references to all columns. 
		myHVESW							;; The flag if HVES Algorithm is used
		Integer:myG			         	;; The maximum number of evolutionary generations to run.
		Integer:myGc			     	;; The current number of evolutionary generations which have run.
		(Integer:tagDepth 0)			;; The current tag depth during recursion when HVES is true
		(Boolean:mergeFlag #void)		;; The label the combines the resutling data partitions from HVES
		(Boolean:recurseFlag #void)		;; The label that signifies the data partitioning
	    IntVector:myIslands          	;; The vector of root terms tried in each distinct island population of estimator Lambdas.
		(Integer:myM 10)      	    	;; The number of columns in the training data (including xtime).
		Integer:myMaxRootWFFs        	;; The maximum number of root WFFs for each column.
		myModelLambda				    ;; The current model Estimator WFF for building the training data in selfTest.
		Integer:myN				     	;; The number of rows in the training data.
		Integer:myNextID		     	;; The next unique Estimator Lambda identifier to be issued (uniquely identifies one and only one Estimator Lambda).
		myParent				    	;; The top parent Lambda for this Lambda complex.
		myPopulation			    	;; The current population of estimator Lambdas.
		myPopulationIslands	         	;; The vector of current distinct populations of estimator Lambdas.
		myMergedPopulation
		Number:myS				     	;; The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
		Number:mySeed                	;; The seed number used to initialize the random number genenerator at the start of each training run.
        (mySvmModelCount 1)             ;; The maximum number of training models to use for all SVM learning (see svmRegress).    
		Integer:myTrainingSize       	;; The size of the training data for quick scoring.
		myUserGrammarWFFs			    ;; The Vector of user defined grammar WFFs the system will use at the start of each training run.
        myUserJavaScriptWFFs			;; The Vector of user defined JavaScript WFFs the system will use at the start of each training run.
		myWFFs			            	;; The Dictionary of all WFFs the system has ever seen and their scored Estimator Lambda.
		myX					         	;; The N by M vector array representing the training data.
		myXtrain				     	;; The myTrainingSize by M vector array representing the smaller training data for quick scoring.
		myY		              	     	;; The N Vector of score variables for the entire training example.
		myYAvg              	     	;; The mean of the N Vector of score variables for the entire training example.
		myYStdev		              	;; The standard deviation of the N Vector of score variables for the entire training example.
		myYtrain              	     	;; The myTrainingSize Vector of score variables for each of the smaller training data for quick scoring.
     	;; System wide run statistics
        myTotalCompileTime				;; The count of total clock ticks devoted to WFF compilation during this run.
 		myTotalEvaluations	    		;; The count of total single fittness case row & column expression evaluations during this run.
        myTotalParseTime				;; The count of total clock ticks devoted to WFF parsing during this run.
		myTotalRegressions	    		;; The count of total fittness case row & column expressions undergoing multivariate regression trainings during this run.
     	;; Public Child Lambdas
		bestRegressor       	     	;; Return the "fittest" regressor WFF from all of the distinct island populations.
		clear    			         	;; Clear all persistent memory.
        compileEstimator                ;; Compile a estimator wff and return a Estimator Lambda.
        compileModelSource              ;; Compile a model source statement (i.e. "y = avg(x0,x1,x2);" and return a Estimator Lambda.
		copyWff             	     	;; Copy a estimator wff so that a completely different set of Pair objects is returned.
		createGrammarEstimator       	;; Create and score a grammar estimator wff over each training time period.
		createJavaScriptEstimator      	;; Create and score a JavaScript estimator wff over each training time period.
		grandom							;; Pseudo random number generator which takes a long time before repetitions.
		estimator			         	;; The private WFF language used for genetic programming of estimator Lambdas Note: (ParseLib "Gsm" "gsm:estimator").
		evalRule            	     	;; Evaluate an GSM grammar generator rule.
		findEstimatorID       	     	;; Return the Estimator Lambda, with the specified ID, by searching all of the distinct island populations.
		getEstimatorChampions       	;; Return a vector of the current champions as pretty printed source strings.
		standAloneEstimatorRules        ;; Return a stand alone set of estimator rules from the specified Lambda.
        initDifficultSamplingData       ;; Initialize the sampling data into sequential vertical slices and select a "difficult" training subset.
        initSamplingData             	;; Initialize the sampling data into sequential vertical slices and select a training subset at random.
        initTrainingData             	;; Initialize the training data into sequential time segments.
        isAbstract                 		;; Returns true iff the WFF is an abstract expression.
        isConcrete                 		;; Returns true iff the WFF is a concrete expression.
		listWff             	     	;; Convert a estimator wff to a set of Pair objects (a list).
	    multipleRegression           	;; Performs a Gaussian multiple regression on the N x M+1 matrix
        saveUniqueNumericWffs        	;; Save the best unique numeric WFFs.
        scoreNLSE					    ;; Compute and insert the normalized least squared error (NLSE) for the specified WFF Lambda.
		scoreNLSEHves				    ;; Compute and insert the normalized least squared error and the Error Vectors for the best resulting Lambda from the GP run
        scoreTCEandNLSE					;; Compute and insert the tail classification error (TCE) and the normalized least squared error (NLSE) for the specified WFF Lambda.
		scoreWff   		             	;; Compute the score for a estimator wff over each training time period.
		simplify   		            	;; Returns the normalized form of any basic Estimator expression.
		stringWff             	     	;; Convert a estimator wff to a string (from a list of Pair objects).
        stringSortedWff              	;; Convert a estimator wff to a sorted string (from a list of Pair objects).
        trunc                    	    ;; Truncate a estimator wff to the specified maximum display length.
		verboseOFF             	     	;; Turns the verbose testing mode off.
		verboseON             	     	;; Turns the verbose testing mode on.
     	;; Population Operators (these Lambdas promote the Estimator WFF population to a "more fit" Estimator population).
		makeCrossover                	;; Introduce a new Estimator WFF (by splicing two parent WFFs) to the current population.
		makeCrossoverAware              ;; Introduce a new Estimator WFF (by splicing -all possible- two parent WFF pairs) to the current population.
		makeMutation                 	;; Introduce a new Estimator WFF (by mutating a candidate WFF) to the current population.
     	;; GSM Training Scripts.
        scriptBOOST      			    ;; Genetic and evolutionary programming using REG-MVL grammar boosting training script. 
        scriptGSOALPS      			   	;; Genetic and evolutionary programming, with age layered populations, training script. 
        scriptGEP      			     	;; Genetic and evolutionary programming training script. 
        scriptGEPALPS      			   	;; Genetic and evolutionary programming, with age layered populations, training script. 
        scriptGAB      			     	;; Grammar swarm optimizer training script. 
        scriptGABALPS      			   	;; Genetic and evolutionary programming, with age layered populations, training script. 
        scriptGABBOOST      			;; Grammar swarm optimizer using REG grammar boosting training script. 
        scriptGABMultiBOOST      		;; Grammar swarm optimizer using REG grammar boosting-muti-modal training script. 
		scriptHVES						;; Same as scriptGSOALPS, but switches to HVES Algorithm for modal problems, training script. 
        scriptMVLALPS      			   	;; Genetic and evolutionary programming, with age layered populations, training script.
        scriptMVLALPSRQ                 ;; Genetic and evolutionary programming, with age layered populations, runqueue parallelized, training script.
        scriptSWARM			      		;; Grammar swarm optimizer training script. 
     	;; WFF Expression Grammars.
        eGrammar      			        ;; The WFF grammar rules for all Estimator default numeric expressions. 
        expressionGrammarGab      		;; The WFF grammar rules for all Abstract Estimator grammar swarm optimizer numeric expressions. 
        expressionGrammarGen      		;; The WFF grammar rules for all generated training model genetic programming numeric expressions. 
        expressionGrammarGep      		;; The WFF grammar rules for all Concrete Estimator genetic programming numeric expressions. 
        expressionGrammarGso      		;; The WFF grammar rules for all mixed Concrete/Abstract Estimator genetic programming numeric expressions. 
     	;; WFF Regression Rules.
        ruleFrm      			     	;; The WFF grammar rules for all Estimator multivariate factor regression Lambdas. 
        ruleMdl      			     	;; The WFF grammar rules for all Estimator model regression Lambdas. 
        ruleMvl      			     	;; The WFF grammar rules for all Estimator multivariate linear regression Lambdas. 
        ruleReg      			     	;; The WFF grammar rules for all Estimator linear regression Lambdas. 
        ruleSvm      			     	;; The WFF grammar rules for all Estimator support vector machine Lambdas. 
     	;; WFF Operators (these Lambdas all link directly into the Estimator numeric expression grammar).
		checkNumericWFF   		     	;; Checks a numeric Estimator WFF for validity.
        concreteWFF                     ;; Converts the specified Lambda's WFF into a concrete WFF.  
		cutoutNumericWFF   		     	;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
        extractNumericWFF		     	;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
        growWFF                      	;; Returns a randomly grown Estimator WFF. 
        growCTermWFF                 	;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
        growRootWFF                  	;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
        growTermWFF                  	;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column.
		lengthWFF   		         	;; Returns the left-depth-first length of any Estimator WFF.
        marryNumericWFFs		     	;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}.
		mutateNumericWFF   		     	;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}.
		spliceNumericWFF    	     	;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
     	;; Machine Learning Child Lambdas
        frmRegress                   	;; Manages the multivariate factor regression learning technology.
        mvlRegress                   	;; Manages the multiple linear regression learning technology.
        svmRegress                   	;; Manages the support vector machine learning technology.
		;; Maintenance Child Lambdas
        buildTrainingModel              ;; Build a training model for generating training data.
        exportDocs                   	;; Export all embedded ontology objects from this Lambda Note: (gsm.exportDocs).
		makeEstimator			     	;; Generate the private WFF language used for genetic programming of estimator Lambdas Note: (gsm.makeEstimator).
		memoryCursor			     	;; Manages a primate in memory table utility for use by maintenance operations.
		myRandom     			        ;; Pseudo random number routine.
		setOptions   			     	;; Set predefined default option information, by name, for the current training run.
		setRandomSeed   			    ;; Set the pseudo random number function seed for the current training run.
		setUserGrammarWFFs   			;; Set user defined grammar WFFs for the current training run.
		setUserJavaScriptWFFs   		;; Set user defined javaScript source code candidates for the current training run.
		randomModalLogTest			    ;; Perform a series of random modal, logged self tests of this learning machine.
		randomRootLogTest			    ;; Perform a series of random root, logged self tests of this learning machine.
        selfLogTest                     ;; Perform a user specified model, logged self test of this learning machine.
		selfTest			         	;; Perform a series of diagnostic self tests of this learning machine.
        ) ; end persistant variables
   ;; *******************************************************************************
   ;; Define Public Child Lambdas 
   ;; *******************************************************************************
   ;; Return the "fittest" regressor WFF from all of the distinct island populations.
   (defun bestRegressor()
      regs:(m M n N)
      vars:(Lambda bestLambda population score)
      ;; Return the "fittest" Estimator WFF form all islands (including all campion and Best-of-Breed islands).
      (if (<> myBest #void) (setq bestLambda myBestRegressor) (setq bestLambda myBest))
      (setq M (length myPopulationIslands)) 
      (loop for m from 0 until M do
         (setq N (length myPopulationIslands[m]))
         (loop for n from 0 until N do
           (setq Lambda myPopulationIslands[m][n])
           (if (< Lambda.NLSE bestLambda.NLSE) (setq bestLambda Lambda))
           ) ; end M loop
         ) ; end M loop
      ;; Insert the best Lambda into the Best-of-Breed island population
      (setq population myPopulationIslands[myBestRegressorIsland])
      (setq myBest bestLambda)
      (setq myBestEstimator bestLambda)
      (setq score bestLambda.NLSE)
      (if (or (= bestLambda population[0]) (and (= score population[0].NLSE) (= Lambda.WFF population[0].WFF))) (return bestLambda))
      (setq N (length population))
      (loop for n from 0 until N do 
        (if (< score population[n].NLSE) (goto ReadyToInsert:))
        ); end insertion loop
      ReadyToInsert::
      (insert population n bestLambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length population)) mySurvivors) then (resize population mySurvivors))
      (setq bestLambda population[0])
      (setq myBest bestLambda)
      (setq myBestEstimator bestLambda)
      (setq myBestRegressor bestLambda)
      bestLambda) ; end bestRegressor
   ;; Checks a numeric Estimator WFF for validity.
   (defun checkNumericWFF(wff) (eGrammar.checkNumericWFF wff))
   ;; Converts the specified Lambda's WFF into a concrete WFF.  
   (defun concreteWFF(Lambda)
      regs:(n N fn)
      vars:(rule wff wffSource function)
      (setq wff Lambda.WFF)
      (if (not (isPair wff)) (setq wff (listWff wff)))
      (setq rule wff[0])
      ;; Is this a grammar WFF?
      (if (<> rule JavaScriptWFF:) (return (eGrammar.concreteWFF Lambda)))
      (setq wffSource Lambda.JSRC)
      ;; Translate any abstract constants into real constants.
      (if (isVector Lambda.CC)
          (begin
             (setq N (length Lambda.CC))
             (loop for n from 0 until N do
               (setq wffSource (substitute wffSource (append "c" n) (string Lambda.CC[n])))
               ) ; end N loop
          )); end abstract constants if
      ;; Translate any abstract features into concrete features.
      (if (isVector Lambda.VV)
          (begin
             (setq N (length Lambda.VV))
             (loop for n from 0 until N do
               (setq wffSource (substitute wffSource (append "v" n) (append "x" Lambda.VV[n])))
               ) ; end N loop
          )); end abstract constants if
      ;; Translate any abstract functions into concrete functions.
      (if (isVector Lambda.FF)
          (begin
             (setq N (length Lambda.FF))
             (loop for n from 0 until N do
               (setq fn Lambda.FF[n])
               (setq function expressionGrammarGso.myAbstractOperNames[fn])
               (setq wffSource (substitute wffSource (append "f" n) function))
               ) ; end N loop
          )); end abstract constants if
      ;; Translate any abstract terms into concrete functions.
      (if (isVector Lambda.TT)
          (begin
             (setq N (length Lambda.TT))
             (loop for n from 0 until N do
               (if (= Lambda.TT[n] 1)
                   (setq wffSource (substitute wffSource (append "t" n) (string Lambda.CC[n])))
                   (setq wffSource (substitute wffSource (append "t" n) (append "x" Lambda.VV[n])))
                   ) ; end
               ) ; end N loop
          )); end abstract constants if
      wffSource) ; end concreteWFF
   ;; Clear all persistent memory.
   (defun clear()
      ;; Redirect important public methods
	  (setq checkNumericWFF eGrammar.Pv.checkNumericWFF)
	  (setq cutoutNumericWFF eGrammar.Pv.cutoutNumericWFF)
	  (setq extractNumericWFF eGrammar.Pv.extractNumericWFF)
	  (setq growWFF eGrammar.Pv.growWFF)
	  (setq growCTermWFF eGrammar.Pv.growCTermWFF)
	  (setq growRootWFF eGrammar.Pv.growRootWFF)
	  (setq growTermWFF eGrammar.Pv.growTermWFF)
	  (setq lengthWFF eGrammar.Pv.lengthWFF)
	  (setq marryNumericWFFs eGrammar.Pv.marryNumericWFFs)
	  (setq mutateNumericWFF eGrammar.Pv.mutateNumericWFF)
	  (setq spliceNumericWFF eGrammar.Pv.spliceNumericWFF)
      ;; Clear important public variables (BUT do NOT clear option settings)
      (setq myBest #void)
      (setq myBestModel #void)
      (setq myBestLinear #void)
      (setq myBestLinearAxis #void)
      (setq myBestLinearCoefficients #void)
      (setq myBestLinearModel #void)
      (setq myBestBoosted #void)
      (setq myBestEstimator #void)
      (setq myBestEstimatorChampions #void)
      (setq myBestEstimatorBestOfBest #void)
      (setq myBestRegressor #void)
      (setq myBestRegressorChampions #void)
      (setq myBestRegressorIsland #void)
      (setq myBestSampler #void)
      (setq myBestUncorrelatedIsland #void)
      (setq myColumnGenome #void)
	  (setq	myG 0)
	  (setq	myGc 0)
	  (setq	myIslands 0)
	  (setq	myM	10)
	  (setq	myMaxRootWFFs 0)
	  (setq	myN	0)
      (setq myNextID 0)
	  (setq	myParent #void)
	  (setq	myPopulation #void)
	  (setq	myPopulationIslands #void)
	  (setq	myS	0)
	  (setq	mySeed 0)
	  (setq	mySvmModelCount 1)
      (setq myTrainingSize 0)
	  (setq	myWFFs #void)
	  (setq	myX	#void)
	  (setq	myXtrain #void)
	  (setq	myY	#void)
	  (setq	myYtrain #void)
      ;; Clear important system wide run statistics (BUT do NOT clear option settings)
      (setq myTotalCompileTime 0.0)
      (setq myTotalEvaluations 0.0)
      (setq myTotalParseTime 0.0)
      (setq myTotalRegressions 0.0)
      true) ; end clear
   ;; Compile a estimator wff and return a Estimator Lambda.
   (defun compileEstimator(wffSource) 
      vars:(Lambda parseTree startTime elapsedTime) 
      (onError (lambda(err) #void))
      (if (<> wffSource "regress();")
          (begin
            (setq startTime (getTickCount 0))
            (setq parseTree (estimator wffSource))
            (setq elapsedTime (getTickCount startTime))
            (+= myTotalParseTime elapsedTime)
            (setq startTime (getTickCount 0))
            (setq Lambda (eval (compile parseTree)))
            (setq elapsedTime (getTickCount startTime))
            (+= myTotalCompileTime elapsedTime)
          )) ; end if
      (setq Lambda.WFF wffSource)
      Lambda) ; end compileEstimator
   ;; Compile a model source statement (i.e. "y = avg(x0,x1,x2);" and return a Estimator Lambda.
   (defun compileModelSource(modelSource) 
      vars:(Lambda parseTree wffSource startTime elapsedTime) 
      (onError (lambda(err) #void))
      (if (and (<> (left modelSource 4) "y = ") (<> (right modelSource 1) ";")) (return #void))
      (setq wffSource (append "model(" (mid modelSource 4 (- (length modelSource) 5)) ");"))
      (setq parseTree (estimator wffSource))
      (setq Lambda (eval (compile parseTree)))
      (setq Lambda.WFF wffSource)
      Lambda) ; end compileModelSource
   ;; Copy a estimator wff so that a completely unique list of Pair objects is returned.
   ;; Note: Always returns a list of Pair objects.
   (defun copyWff(wff)
      vars:(newWff)
      (if (isString wff) 
          (setq newWff (Lisp wff)[0]) 
          (setq newWff (Lisp (string wff true))[0])
          ) ; end if
      newWff) ; end copyWff
   ;; Create and score a grammar estimator wff over each training time period and save in the user selected island (myPopulation global variable).
   ;; Args: command (concrete:) provides the command to save only the concrete genome version of the WFF.
   ;;               (nosave:) provides the command not to save any version of the WFF.
   (defun createGrammarEstimator(wff ...)
      regs:(n N nn NN m M)
      vars:(Lambda source score errPct hurdleErrPct result command ID)
      vars:(regPopulation wffSource wffString wffPair stemp genome rule)
      (onError (lambda(msg) false))
      (if (>= (argCount) 2) (setq command (argFetch 1)))
      ;; Do not score if the WFF is too long or if we have seen this WFF before.
      ;; Note: Within the limitations of memory, we save each WFF so that 
      ;;       we will not waste time retesting WFFs we have already tested.
      (if (= wff #void) (return false))
      (if (isPair wff) (setq wffPair wff) (setq wffPair (listWff wff)))
      (setq rule wffPair[0]) 
      (setq genome wffPair[1])
      (if (and (= eGrammar expressionGrammarGep) (not (isConcrete wffPair))) (error "gsm.createGrammarEstimator: expected a concrete WFF here"))
      (setq wffString (stringWff wff))
      (if (> (length wffString) myWFFLengthLimit) (return false))
      (setq wffSource (evalRule wff))
      (if (> (length wffSource) myWFFLengthLimit) (return false))
      (if (= wffSource "regress();") (return false))
      ;; Have we ever seen this WFF before?
      (if (<> (setq ID myWFFs[wffString]) #void)
          then
          ;; We have compiled and scored this WFF before.
          (begin
             (setq Lambda (findEstimatorID ID))
             (if (= Lambda false) (return false))
          ) else
          ;; We have never compiled or scored this WFF before.
          (begin
             ;; Compile the estimator WFF and save into the already-seen-list, until memory limitations are exceeded.
             (setq result (new Structure: ID:myNextID NLSE:BIGPOSNUM WFF:wffString))
             (++ myNextID)
             (if (< (length myWFFs) myWFFSaveLimit) 
                 (setq myWFFs[wffString] result.ID)
                 ) ; end if
             (setq Lambda (compileEstimator wffSource))
             (if (not (isLambda Lambda)) (begin (if myVerboseSW (writeln "gsm.createGrammarEstimator: compile failure warning on [" wffSource "]")) (return false)))
             ;; Score the WFF against the training data.
             (setq Lambda.Rule rule)
             (if (= (setq result (scoreWff Lambda result genome)) false) then (if (= command nosave:) (return Lambda) (return false)))
             (setq Lambda.Genome genome)
             (setq Lambda.Rule rule)
          )) ; end seen before if
      ;; If we are not saving any WFFs, then we return the current trained Lambda here.
      (setq Lambda.WFF (listWff Lambda.WFF))
      (if (= command nosave:) (return Lambda))
      ;; If we are only saving concrete WFFs, then call ourselves recursively here.
      (if (= command concrete:)
          (begin
            (cond
             ;; Is this an SVM which currently cannot be easily converted to concrete form?
             ((= rule ruleSvm:) (return Lambda))
             ;; Is this an REG WFF which can be easily converted to concrete form?
             ((and (= rule ruleReg:) (<> genome[1] #void) (= myUseMVL true)) (return (createGrammarEstimator (setq (concreteWFF Lambda)[0] ruleMvl:))))
             ;; Is this any other WFF which can be easily converted to concrete form?
             (else (return (createGrammarEstimator (concreteWFF Lambda))))
             ) ; end cond
           )) ; end concrete if
      ;; Enter the estimator WFF into the best regressor fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInRegressorIsland::
      (if (not (isNumber Lambda.NLSE)) then (return false))
      (if (not (isNumber myBestRegressorIsland)) (goto ReadyToSaveInUncorrelatedIsland:))
      (setq regPopulation myPopulationIslands[myBestRegressorIsland])
      (setq errPct Lambda.NLSE)
      (setq N (length regPopulation))
      (loop for n from 0 until N do 
        (if (< errPct regPopulation[n].NLSE) (goto ReadyToInsertInRegressorIsland:))
        (if (and (= errPct regPopulation[n].NLSE) (= Lambda.WFF regPopulation[n].WFF)) (goto ReadyToSaveInUncorrelatedIsland:))
        (if (and (= mySurvivorStyle equalOFF:) (= errPct regPopulation[n].NLSE)) (goto ReadyToSaveInUncorrelatedIsland:))
        ); end insertion loop
      ReadyToInsertInRegressorIsland::
      (insert regPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length regPopulation)) mySurvivors) then (resize regPopulation mySurvivors))
      (setq myBestRegressor regPopulation[0])
      (if (= myBest #void) (setq myBestEstimator (setq myBest myBestRegressor)))
      ;; Enter the estimator WFF into the best uncorrelated regressor fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInUncorrelatedIsland::
      (if (not (isNumber myBestUncorrelatedIsland)) (goto ReadyToSaveInUserIsland:))
      (setq regPopulation myPopulationIslands[myBestUncorrelatedIsland])
      (setq errPct Lambda.NLSE)
      (setq N (length regPopulation))
      (setq hurdleErrPct (if (<= N 0) BIGPOSNUM regPopulation[(- N 1)].NLSE))
      (if (> errPct hurdleErrPct) (goto ReadyToSaveInUserIsland:))
      (setq Lambda.EY (Lambda.run myX))
      (setq NN (min myBestAverage (length myPopulationIslands[myBestRegressorIsland])))
      (loop for nn from 0 until NN do
        (if (= myPopulationIslands[myBestRegressorIsland][nn].EY #void) (setq myPopulationIslands[myBestRegressorIsland][nn].EY (myPopulationIslands[myBestRegressorIsland][nn].run myX)))
        (if (> (abs (setq result (math.correlation Lambda.EY myPopulationIslands[myBestRegressorIsland][nn].EY))) myCovarianceLimit) (goto ReadyToSaveInUserIsland:))
        ) ; end anti-correlation loop
      (loop for n from 0 until N do 
        (if (< errPct regPopulation[n].NLSE) (goto ReadyToInsertInUncorrelatedIsland:))
        (if (and (= errPct regPopulation[n].NLSE) (= Lambda.WFF regPopulation[n].WFF)) (goto ReadyToSaveInUserIsland:))
        (if (and (= mySurvivorStyle equalOFF:) (= errPct regPopulation[n].NLSE)) (goto ReadyToSaveInUserIsland:))
        ); end insertion loop
      ReadyToInsertInUncorrelatedIsland::
      (insert regPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length regPopulation)) mySurvivors) then (resize regPopulation mySurvivors))
      ;; Enter the estimator WFF into the user selected fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInUserIsland::
      (if (= myPopulation regPopulation) (return Lambda)) 
      (setq score Lambda.NLSE)
      (setq N (length myPopulation))
      (loop for n from 0 until N do 
        (if (< score myPopulation[n].NLSE) (goto ReadyToInsertInUserIsland:))
        (if (and (= score myPopulation[n].NLSE) (= Lambda.WFF myPopulation[n].WFF)) (return Lambda))
        (if (and (= mySurvivorStyle equalOFF:) (= score myPopulation[n].NLSE)) (return Lambda))
        ); end insertion loop
      ReadyToInsertInUserIsland::
      (insert myPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length myPopulation)) mySurvivors) then (resize myPopulation mySurvivors))
      Lambda) ; end createGrammarEstimator
   ;; Create and score a JavaScript estimator wff over each training time period and save in the user selected island (myPopulation global variable).
   (defun createJavaScriptEstimator(wffSource)
      regs:(n N nn NN m M)
      vars:(Lambda source score errPct hurdleErrPct result command ID)
      vars:(regPopulation wffSource wffString wffPair stemp genome rule)
      (onError (lambda(msg) false))
      ;; Do not score if the WFF is too long or if we have seen this WFF before.
      ;; Note: Within the limitations of memory, we save each WFF so that 
      ;;       we will not waste time retesting WFFs we have already tested.
      (if (= wffSource #void) (begin (if myVerboseSW (writeln "gsm.createJavaScriptEstimator: compile failure warning on [" wffSource "]")) (return false)))
      (setq wffString (setq wff "(JavaScriptWFF #())"))
      (setq wff (setq wffPair (listWff wffString)))
      (setq rule wffPair[0]) 
      (setq genome wffPair[1])
      (if (not (isVector genome)) (error (append "gsm.setUserJavaScriptWFFs: expected vector genome here [" wffString "]")))
      (if (<> eGrammar expressionGrammarGso) (error (append "gsm.setUserJavaScriptWFFs: expected the GSO grammar here [" eGrammar "]")))
      ;; Have we ever seen this WFF before?
      (if (<> (setq ID myWFFs[wffSource]) #void)
          then
          ;; We have compiled and scored this WFF before.
          (begin
             (setq Lambda (findEstimatorID ID))
             (if (= Lambda false) (return false))
          ) else
          ;; We have never compiled or scored this WFF before.
          (begin
             ;; Compile the estimator WFF and save into the already-seen-list, until memory limitations are exceeded.
             (setq result (new Structure: ID:myNextID NLSE:BIGPOSNUM WFF:wffString JSRC: wffSource))
             (++ myNextID)
             (if (< (length myWFFs) myWFFSaveLimit) 
                 (setq myWFFs[wffString] result.ID)
                 ) ; end if
             (setq Lambda (compileEstimator wffSource))
             (if (not (isLambda Lambda)) (begin (if myVerboseSW (writeln "gsm.createJavaScriptEstimator: compile failure warning on [" wffSource "]")) (return false)))
             ;; Score the WFF against the training data.
             (setq Lambda.Rule rule)
             (if (= (setq result (scoreWff Lambda result genome)) false) then (return false))
             (setq Lambda.Genome genome)
             (setq Lambda.Rule rule)
             (setq Lambda.JSRC wffSource)
             (setq Lambda.WFF wffPair)
          )) ; end seen before if
      ;; Enter the estimator WFF into the best regressor fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInRegressorIsland::
      (if (not (isNumber Lambda.NLSE)) then (return false))
      (if (not (isNumber myBestRegressorIsland)) (goto ReadyToSaveInUncorrelatedIsland:))
      (setq regPopulation myPopulationIslands[myBestRegressorIsland])
      (setq errPct Lambda.NLSE)
      (setq N (length regPopulation))
      (loop for n from 0 until N do 
        (if (< errPct regPopulation[n].NLSE) (goto ReadyToInsertInRegressorIsland:))
        (if (and (= errPct regPopulation[n].NLSE) (= Lambda.JSRC regPopulation[n].JSRC)) (goto ReadyToSaveInUncorrelatedIsland:))
        (if (and (= mySurvivorStyle equalOFF:) (= errPct regPopulation[n].NLSE)) (goto ReadyToSaveInUncorrelatedIsland:))
        ); end insertion loop
      ReadyToInsertInRegressorIsland::
      (insert regPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length regPopulation)) mySurvivors) then (resize regPopulation mySurvivors))
      (setq myBestRegressor regPopulation[0])
      (if (= myBest #void) (setq myBestEstimator (setq myBest myBestRegressor)))
      ;; Enter the estimator WFF into the best uncorrelated regressor fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInUncorrelatedIsland::
      (if (not (isNumber myBestUncorrelatedIsland)) (goto ReadyToSaveInUserIsland:))
      (setq regPopulation myPopulationIslands[myBestUncorrelatedIsland])
      (setq errPct Lambda.NLSE)
      (setq N (length regPopulation))
      (setq hurdleErrPct (if (<= N 0) BIGPOSNUM regPopulation[(- N 1)].NLSE))
      (if (> errPct hurdleErrPct) (goto ReadyToSaveInUserIsland:))
      (setq Lambda.EY (Lambda.run myX))
      (setq NN (min myBestAverage (length myPopulationIslands[myBestRegressorIsland])))
      (loop for nn from 0 until NN do
        (if (= myPopulationIslands[myBestRegressorIsland][nn].EY #void) (setq myPopulationIslands[myBestRegressorIsland][nn].EY (myPopulationIslands[myBestRegressorIsland][nn].run myX)))
        (if (> (abs (setq result (math.correlation Lambda.EY myPopulationIslands[myBestRegressorIsland][nn].EY))) myCovarianceLimit) (goto ReadyToSaveInUserIsland:))
        ) ; end anti-correlation loop
      (loop for n from 0 until N do 
        (if (< errPct regPopulation[n].NLSE) (goto ReadyToInsertInUncorrelatedIsland:))
        (if (and (= errPct regPopulation[n].NLSE) (= Lambda.JSRC regPopulation[n].JSRC)) (goto ReadyToSaveInUserIsland:))
        (if (and (= mySurvivorStyle equalOFF:) (= errPct regPopulation[n].NLSE)) (goto ReadyToSaveInUserIsland:))
        ); end insertion loop
      ReadyToInsertInUncorrelatedIsland::
      (insert regPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length regPopulation)) mySurvivors) then (resize regPopulation mySurvivors))
      ;; Enter the estimator WFF into the user selected fittness island.
      ;; Note1: We save these statistics:= Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
      ;; Note2: We do NOT allow duplicates.
      ReadyToSaveInUserIsland::
      (if (= myPopulation regPopulation) (return Lambda)) 
      (setq score Lambda.NLSE)
      (setq N (length myPopulation))
      (loop for n from 0 until N do 
        (if (< score myPopulation[n].NLSE) (goto ReadyToInsertInUserIsland:))
        (if (and (= score myPopulation[n].NLSE) (= Lambda.JSRC myPopulation[n].JSRC)) (return Lambda))
        (if (and (= mySurvivorStyle equalOFF:) (= score myPopulation[n].NLSE)) (return Lambda))
        ); end insertion loop
      ReadyToInsertInUserIsland::
      (insert myPopulation n Lambda)
      ;; Kill off all except the most fit estimator WFFs.
      (if (> (setq N (length myPopulation)) mySurvivors) then (resize myPopulation mySurvivors))
      Lambda) ; end createJavaScriptEstimator
   ;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
   (defun cutoutNumericWFF(wff ...) (if (= (argCount) 1) (eGrammar.cutoutNumericWFF wff) (eGrammar.cutoutNumericWFF wff (argFetch 1))))
   ;; Evaluate an GSM grammar production rule.
   (defun evalRule(rule)
      vars:(ruleHdr)
      (onError (lambda(msg) "...Error..."))
      (if (isString rule) (setq rule (listWff rule)))
      (if (isPair rule) (setq rule (apply (setq ruleHdr gsm.eGrammar[(car rule)]) (cdr rule))) (setq rule (string rule true)))
      rule) ; end evalRule
   ;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
   (defun extractNumericWFF(wff ...) (if (= (argCount) 1) (eGrammar.extractNumericWFF wff) (eGrammar.extractNumericWFF wff (argFetch 1))))
   ;; Return the Estimator Lambda, with the specified ID, by searching all of the distinct island populations.
   (defun findEstimatorID(Integer:id)
      regs:(m M n N)
      vars:(Lambda)
      ;; Search independent island populations.
      (setq M (length myPopulationIslands)) 
      (loop for m from 0 until M do
         (setq N (length myPopulationIslands[m]))
         (loop for n from 0 until N do
           (setq Lambda myPopulationIslands[m][n])
           (if (= Lambda.ID id) then (return Lambda))
           ) ; end M loop
         ) ; end M loop
      ;; Search best regressor champions
      (setq N (length myBestRegressorChampions))
      (loop for n from 0 until N do
        (setq Lambda myBestRegressorChampions[n])
        (if (= Lambda.ID id) then (return Lambda))
        ) ; end M loop
      ;; Search best estimator champions
      (setq N (length myBestEstimatorChampions))
      (loop for n from 0 until N do
        (setq Lambda myBestEstimatorChampions[n])
        (if (= Lambda.ID id) then (return Lambda))
        ) ; end M loop
      ;; Search best of best champions
      (setq N (length myBestEstimatorBestOfBest))
      (loop for n from 0 until N do
        (setq Lambda myBestEstimatorBestOfBest[n])
        (if (= Lambda.ID id) then (return Lambda))
        ) ; end M loop
      false) ; end findEstimatorID
   ;; Return a vector of the current champions as pretty printed source strings.
   ;; Args:  showSW           (Optional) IFF true then display list of champions.
   ;;        translationTable (Optional) IFF present then translate element variables in all champions.
   (defun getEstimatorChampions(...)
      regs:(m M n N)
      vars:(result wff rule genome wffSource Lambda CC (showSW false) translationTable)
      (if (>= (argCount) 1) (setq showSW (argFetch 0)))
      (if (>= (argCount) 2) (setq translationTable (argFetch 1)))
      (setq myPopulation (copy myPopulationIslands[myBestRegressorIsland]))
      (if (<> myBest myPopulation[0]) (insert myPopulation 0 myBest))
      (setq N (length myPopulation))
      (setq result (new Vector: Object:))
      (loop for n from 0 until N do 
        (setq Lambda myPopulation[n])
        (setq wff (listWff Lambda.WFF))
        (setq rule wff[0])
        (setq genome wff[1])
        (cond
         ;; Pretty print a JavaScript formula
         ((= rule JavaScriptWFF:)
          (begin
            (setq wffSource (gsm.concreteWFF Lambda))
            (cond
             ;; singlton regression: regress(...);
             ((= (left wffSource 8) "regress(")
              (begin
                (setq wffSource (append "y = " Lambda.A "+" Lambda.B "*sum" (mid wffSource 7 10000000)))
              )) ; end singlton regression case
             ;;  singlton modeling: model(...);
             ((= (left wffSource 6) "model(")
              (begin
                (setq wffSource (append "y = sum" (mid wffSource 5 10000000)))
              )) ; end singlton modeling case
             ;; unknown regression command
             (else (setq wffSource = (append "y = " wffSource)))
             ) ; end JavaScript statements cond
          )) ; end JavaScriptWFF case
         ;; Pretty print an mvlregress formula
         ((= rule ruleMvl:)
          (begin
            (if (not (isMember Mvl: Lambda.Pv)) (goto ruleREG:))
            (setq M (length genome))
            (setq CC Lambda.Mvl.myW)
            (setq wffSource (append "y = " Lambda.A))
            (loop for m from 0 until M do
              (setq wffSource (append wffSource "+(" CC[m] "*" (gsm.evalRule genome[m]) ")"))
              ) ; end M loop
            (setq wffSource (append wffSource ";"))
          )) ; end ruleMvl case
         ;; Pretty print an svmregress formula
         ((= rule ruleSvm:)
          (begin
            (if (isMember Svm: Lambda.Pv)
                then  
                (begin 
                  (setq M (length genome))
                  (setq wffSource (append "y = " (gsm.ruleSvm.wffSource genome)))
                ) else
                (begin
                  (setq M (length genome))
                  (setq CC Lambda.CC)
                  (setq wffSource (append "y = " Lambda.A))
                  (loop for m from 0 until M do
                    (if (< CC[m] 0.0)
                        (setq wffSource (append wffSource "-(" (abs CC[m]) "*" (gsm.evalRule genome[m]) ")"))
                        (setq wffSource (append wffSource "+(" CC[m] "*" (gsm.evalRule genome[m]) ")"))
                        ) ; end if 
                    ) ; end M loop
                  (setq wffSource (append wffSource ";"))
                )) ; end if
          )) ; end ruleSvm case
         ;; Pretty print an frmregress formula
         ((= rule ruleFrm:)
          (begin
            (if (isMember Frm: Lambda.Pv)
                then  
                (begin 
                  (setq M (length genome))
                  (setq CC Lambda.Frm.myW)
                  (setq wffSource (append "y = rescaled(" Lambda.A))
                  (loop for m from 0 until M do
                    (setq wffSource (append wffSource "+(" CC[m] "*" (gsm.evalRule genome[m]) ")"))
                    ) ; end M loop
                  (setq wffSource (append wffSource ");"))
                ) else
                (begin
                  (setq M (length genome))
                  (setq CC Lambda.CC)
                  (setq wffSource (append "y = " Lambda.A))
                  (loop for m from 0 until M do
                    (setq wffSource (append wffSource "+(" CC[m] "*" (gsm.evalRule genome[m]) ")"))
                    ) ; end M loop
                  (setq wffSource (append wffSource ";"))
                )) ; end if
          )) ; end ruleFrm case
         ;; Pretty print a regress formula
         ((= rule ruleReg:)
          (begin
            ruleREG::
            (setq wff (gsm.concreteWFF Lambda))
            (setq M (length genome))
            (setq wffSource (append "y = " Lambda.A))
            (setq wffSource (append wffSource "+(" Lambda.B "*(" (gsm.evalRule genome[0])))
            (loop for m from 1 until M do
              (if (<> genome[m] #void)
                  (setq wffSource (append wffSource "+" (gsm.evalRule genome[m])))
                  ) ; end if 
              ) ; end M loop
            (setq wffSource (append wffSource "));"))
          )) ; end ruleReg case
         ;; Pretty print a model formula
         ((= rule ruleMdl:)
          (begin
            (setq wff (gsm.concreteWFF Lambda))
            (setq M (length genome))
            (setq wffSource (append "y = " (gsm.evalRule genome[0])))
            (loop for m from 1 until M do
              (if (<> genome[m] #void)
                  (setq wffSource (append wffSource "+" (gsm.evalRule genome[m])))
                  ) ; end if 
              ) ; end M loop
            (setq wffSource (append wffSource ";"))
          )) ; end ruleMdl case
         (else (setq wffSource "...formula cannot be pretty printed..."))
         ) ; end cond
        (setq result[(length result)] wffSource)
        ) ; end loop
      ;; Translate element references in  pretty printed formulas?
      (if (isVector translationTable)
          (begin
             (setq N (length result))
             (loop for n from 0 until N do
               (setq M (length translationTable))
               (loop for m from (- M 1) to 0 by -1 do 
                 (if (and (isString result[n]) (isString translationTable[m])) (setq result[n] (substitute result[n] (append "x" m) translationTable[m])))
                 ) ; end M loop
               ) ; end N loop
          )); end translate if
      ;; Display pretty printed formulas?
      (if (= showSW true)
          (begin
             (setq N (length result))
             (loop for n from 0 until N do (writeln "[" n "] " result[n]))
          )); end show if
      result) ; end getEstimatorChampions
   ;; Returns a randomly grown Estimator WFF. 
   (defun growWFF(Symbol:rule Integer:level) (eGrammar.growWFF rule level))
   ;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
   (defun growCTermWFF(Integer:columnChoice) (eGrammar.growCTermWFF columnChoice))
   ;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
   (defun growRootWFF(Integer:rootChoice) (eGrammar.growRootWFF rootChoice))
   ;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column. 
   (defun growTermWFF(Integer:rootChoice Integer:columnChoice) (eGrammar.growTermWFF rootChoice columnChoice))
   ;; Initialize the sampling data into sequential vertical slices and select a "difficult" training subset.
   (defun initDifficultSamplingData()
      regs:(n N nn k sn SN stepInc sliceLow sliceHigh)
      regs:(Number:timeStamp Number:difficultSampleErr difficultSampleIndex)
      vars:(IntVector:sortedY NumVector:EYErr)
      vars:(NumVector:x Number:y timeVector mgrVector mgr (Integer:minTN 100))
      ;; Compute the estimated error vector for the current best champion.
      (if (not (isLambda myBest)) (error "gsm.initDifficultSamplingData: expected myBest to be an Lambda"))
      (setq myBestSampler myBest)
      (setq EYErr (myBest.run myX))
      (if (<> (length EYErr) myN) (error "gsm.initDifficultSamplingData: expected myBest.run to return a NumVector of size myN"))
      (loop for n from 0 until myN do
        (setq EYErr[n] (abs (- myY[n] EYErr[n])))
        ) ; end estimated error loop 
      ;; Create a larger training data set for abbreviated quick scoring.
      ;; Note: Compute optimal larger training size for abbreviated quick learning.
      (if (>= myN 700) (setq myTrainingSize (integer (min myN (max (divi myN myTrainingFactor) (* 20 myM))))) (setq myTrainingSize myN))
      (setq SN myTrainingSize)
      (setq sortedY (|Gv:sort| myX (lambda(xa xb) (or (< xa[0] xb[0]) (and (= xa[0] xb[0]) (< (cdr xa) (cdr xb)))) ) true))
      (setq myXtrain (new Vector: Object: SN))
      (setq myYtrain (new Vector: Number: SN))
      (setq stepInc (integer (/ myN myTrainingSize)))
      (setq n 0)
      (loop for sn from 0 until SN do
        (setq difficultSampleErr 0.0)       
        (setq difficultSampleIndex (setq sliceLow n))
        (setq sliceHigh (+ n stepInc))
        (loop for nn from sliceLow until sliceHigh do
		  (setq k sortedY[nn])
          (if (< difficultSampleErr EYErr[k]) then (begin (setq difficultSampleIndex nn) (setq difficultSampleErr EYErr[k])))
          ) ; end difficult sampling loop
        (setq k sortedY[difficultSampleIndex])
        (setq myXtrain[sn] myX[k])
        (setq myYtrain[sn] myY[k])
        (+= n stepInc)
        ) ; end loop 
      true) ; end initDifficultSamplingData
   ;; Initialize the sampling data into sequential vertical slices and select a training subset at random.
   (defun initSamplingData()
      regs:(n Number:timeStamp)
      regs:(k sn SN stepInc)
      vars:(IntVector:sortedY)
      vars:(NumVector:x Number:y timeVector mgrVector mgr (Integer:minTN 100))
      ;; Compute the sampling and training vertical slices from the most difficult cases?
      (if (and (isLambda myBest) (<> (inspect myBest) (inspect myBestSampler))) then (return (initDifficultSamplingData)))
      (setq myBestSampler #void)
      ;; ------------------------------------------------------------
      ;; Compute the sampling and training vertical slices at random.
      ;; ------------------------------------------------------------
      ;; Create a larger training data set for abbreviated quick scoring.
      ;; Note: Compute optimal larger training size for abbreviated quick learning.
      (if (>= myN 700) (setq myTrainingSize (integer (min myN (max (divi myN myTrainingFactor) (* 20 myM))))) (setq myTrainingSize myN))
      (setq SN myTrainingSize)
      (setq sortedY (|Gv:sort| myX (lambda(xa xb) (or (< xa[0] xb[0]) (and (= xa[0] xb[0]) (< (cdr xa) (cdr xb)))) ) true))
      (setq myXtrain (new Vector: Object: SN))
      (setq myYtrain (new Vector: Number: SN))
      (setq stepInc (integer (/ myN myTrainingSize)))
      (setq n (integer (gsm.myRandomFunction stepInc)))
      (loop for sn from 0 until SN do
		(setq k sortedY[n])
        (setq myXtrain[sn] myX[k])
        (setq myYtrain[sn] myY[k])
        (+= n stepInc)
        ) ; end loop 
      true) ; end initTrainingData
   ;; Initialize the training data into sequential time segments.
   (defun initTrainingData()
      regs:(n Number:timeStamp)
      regs:(k sn SN stepInc)
      vars:(IntVector:sortedY)
      vars:(NumVector:x Number:y timeVector mgrVector mgr (Integer:minTN 100))
      (onError (lambda(msg) (error (append "gsm.initTrainingData: got an error preparing training data =[" msg "]"))))
      (setq myYAvg (avg myY))
      (setq myYStdev (stdev myY))
      ;; Make sure we attached the appropriate y value to each matching x vector.
      (loop for n from 0 until myN do
         ;; Attach the score (y) to the cdr of each training example (x)
         (setq x myX[n])
         (setq y myY[n])
         (setCdr x y)
         (if (<= BIGPOSNUM (* y y))
             (begin
                (writeln "gsm.initTrainingData: found an out of range number at Y[" n "]=" y)
                (return false)
             )); end if
         ) ; end loop
      ;; Create a small sample of the training data for abbreviated quick learning.
      ;; Note: Compute optimal small sample size for abbreviated quick learning.
      (initSamplingData)
      true) ; end initTrainingData
   ;; Returns true iff the WFF is an abstract expression   
   (defun isAbstract(wff)
      regs:(n N)
      vars:(rule wff)
      vars:((abstractReference false))

      ;; Convert wff to a list grammar format.
      (if (isLambda wff) (setq wff (listWff wff.WFF)))

      ;; Check for abstract grammar rules which may need to be converted.
      (cond
       ((and (isSymbol wff) (= wff[0] #\v)  (isCharNumeric wff[1])) (setq abstractReference true))
       ((and (isSymbol wff) (= wff[0] #\x) (isCharNumeric wff[1])) (return false))
       ((and (isSymbol wff) (= wff[0] #\c) (isCharNumeric wff[1])) (setq abstractReference true))
       ((isNumber wff) (return false))
       ((isVector wff)
        (begin
           (setq N (length wff)) 
           (loop for n from 0 until N do 
             (if (isPair wff[n]) (if (not (isAbstract wff[n])) (return false)))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq abstractReference true))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\x) (isCharNumeric wff[n][1])) (return false))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq abstractReference true))
             (if (isNumber wff[n]) (return false))
        ))) ; end case: Vector
       ((isPair wff)
        (begin
           (setq rule wff[0])
           (cond
            ((isVector wff[1]) (if (not (isAbstract wff[1])) (return false)))
            ((= rule ruleVar:) (setq abstractReference true))
            ((= rule ruleName:) (return false))
            ((= rule ruleCons:) (setq abstractReference true))
            ((= rule ruleNum:) (return false))
            (else 
              (begin 
                (setq N (length wff)) 
                (loop for n from 0 until N do 
                  (if (isPair wff[n]) (if (not (isAbstract wff[n])) (return false)))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq abstractReference true))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\x) (isCharNumeric wff[n][1])) (return false))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq abstractReference true))
                  (if (isNumber wff[n]) (return false))
              ))) ; end else
            ))) ; end case: Pair
       ) ; end cond

      true) ; end isAbstract
   ;; Returns true iff the WFF is a concrete expression   
   (defun isConcrete(wff)
      regs:(n N)
      vars:(rule wff)
      vars:((concreteReference false))

      ;; Convert wff to a list grammar format.
      (if (isLambda wff) (setq wff (listWff wff.WFF)))

      ;; Check for abstract grammar rules which may need to be converted.
      (cond
       ((and (isSymbol wff) (= wff[0] #\v)  (isCharNumeric wff[1])) (return false))
       ((and (isSymbol wff) (= wff[0] #\x) (isCharNumeric wff[1])) (setq concreteReference true))
       ((and (isSymbol wff) (= wff[0] #\c) (isCharNumeric wff[1])) (return false))
       ((isNumber wff) (setq concreteReference true))
       ((isVector wff)
        (begin
           (setq N (length wff)) 
           (loop for n from 0 until N do 
             (if (isPair wff[n]) (if (not (isConcrete wff[n])) (return false)))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (return false))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\x) (isCharNumeric wff[n][1])) (setq concreteReference true))
             (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (return false))
             (if (isNumber wff[n]) (setq concreteReference true))
        ))) ; end case: Vector
       ((isPair wff)
        (begin
           (setq rule wff[0])
           (cond
            ((isVector wff[1]) (if (not (isConcrete wff[1])) (return false)))
            ((= rule ruleVar:) (return false))
            ((= rule ruleName:) (setq concreteReference true))
            ((= rule ruleCons:) (return false))
            ((= rule ruleNum:) (setq concreteReference true))
            (else 
              (begin 
                (setq N (length wff)) 
                (loop for n from 0 until N do 
                  (if (isPair wff[n]) (if (not (isConcrete wff[n])) (return false)))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (return false))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\x) (isCharNumeric wff[n][1])) (setq concreteReference true))
                  (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (return false))
                  (if (isNumber wff[n]) (setq concreteReference true))
              ))) ; end else
            ))) ; end case: Pair
       ) ; end cond

      true) ; end isConcrete
   ;; Returns the left-depth-first length of any Estimator WFF. 
   (defun lengthWFF(wff) (eGrammar.lengthWFF wff))
   ;; Convert a estimator wff to a set of Pair objects (a list).
   (defun listWff(wff)
      vars:(newWff wffSource)
      (if (isString wff) (setq wffSource wff) (setq wffSource (string wff true)))
      (setq newWff (Lisp wffSource))
      newWff[0]) ; end listWff
   (defun makeCrossover(father mother)
   ;; *******************************************************************
   ;; summary:  Introduce a new Estimator WFF (by splicing two parent WFFs) 
   ;;           to the current population (genetic crossover).
   ;;
   ;; args:     father     The father Estimator Lambda (or WFF) to be mated.           
   ;;           mother     The mother Estimator Lambda (or WFF) to be mated.           
   ;;           
   ;; Return:   none.
   ;;
   ;; *******************************************************************
      vars:(rule wff)
      (if (or (= father #void) (= mother #void)) (return false))
      (if (isLambda father) (setq wff (listWff father.WFF)) (setq wff father))
      (if (not (isPair wff)) (setq wff (listWff wff)))
      (setq rule wff[0])
      (if (= rule #void) (return false))
      (gsm[rule].crossOver father mother)
      true) ; end makeCrossover 
   (defun makeCrossoverAware(father mother)
   ;; *******************************************************************
   ;; summary:  Introduce a new Estimator WFF (by splicing -all possible- 
   ;;           two parent WFF pairs) to the current population. 
   ;;
   ;; args:     father     The father Estimator Lambda (or WFF) to be mated.           
   ;;           mother     The mother Estimator Lambda (or WFF) to be mated.           
   ;;           
   ;; Return:   none.
   ;;
   ;; Note:     ...under development...
   ;; *******************************************************************
      vars:(rule wff)
      (if (or (= father #void) (= mother #void)) (return false))
      (if (isLambda father) (setq wff (listWff father.WFF)) (setq wff father))
      (if (not (isPair wff)) (setq wff (listWff wff)))
      (setq rule wff[0])
      (if (= rule #void) (return false))
      (gsm[rule].crossOverAware father mother)
      true) ; end makeCrossoverAware 
   (defun makeMutation(mutant)
   ;; *******************************************************************
   ;; summary:  Introduce a new Estimator WFF (by mutating a candidate WFF) 
   ;;           to the current population.
   ;;
   ;; args:     mutant     The candidate Estimator Lambda (or WFF) to be mutated.           
   ;;           
   ;; Return:   none.
   ;;
   ;; *******************************************************************      
      vars:(rule wff)
      (if (= mutant #void) (return false))
      (if (isLambda mutant) (setq wff (listWff mutant.WFF)) (setq wff mutant))
      (if (not (isPair wff)) (setq wff (listWff wff)))
      (setq rule wff[0])
      (if (= rule #void) (return false))
      (gsm[rule].mutate wff)
      true) ; end makeMutation 
   ;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}. 
   (defun marryNumericWFFs(wff1 wff2 ...) (if (= (argCount) 2) (eGrammar.marryNumericWFFs wff1 wff2) (eGrammar.marryNumericWFFs wff1 wff2 (argFetch 2))))
   ;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}. 
   (defun mutateNumericWFF(wff ...) (if (= (argCount) 1) (eGrammar.mutateNumericWFF wff) (eGrammar.mutateNumericWFF wff (argFetch 1))))
   ;; summary:  Performs a Gaussian multiple regression on the N by M+1 matrix
   ;; Parms:    MXY:     The N by M+1 matrix representing the original observations
   ;;                    in the form of:    x x ... x y
   ;;                                       x x ... x y
   ;;                                           ... 
   ;;                                       x x ... x y
   ;; Return:   C:       The M coefficient vector for the regression.
   ;; Note1:    Average error statistics are computed as a percent of the target (dependent variable).
   ;; Note2:    See Sedgewick[2] chap 37.
   (defun multipleRegression(NumMatrix:MXY)
       vars:(NumMatrix:Xt NumVector:C)
       ;; Perform a least squares regression on all the factors.
       (setq Xt (|Gv:makeGaussianMatrix| MXY))
       (setq Xt (|Gv:matrixGaussianEliminate| Xt true))
       (setq C (|Gv:matrixGaussianSubstitute| Xt))
       ;; Return the coefficient vector for the regression.
       C) ; end multipleRegression
   ;; Save the best unique numeric WFFs.
   (defun saveUniqueNumericWffs(Integer:maxWFFs)
      regs:(m n N)
      vars:(wffBest wffString1 wffString2)
      ;; Save the "best" five WFFs.
      (setq wffBest (new Vector: Object: 5))
      (setq wffString1 (string (extractNumericWFF myPopulation[0].WFF) true))
      (setq wffBest[0] (Lisp wffString1)[0])
      (setq N (length myPopulation))
      (setq m 0)
      (loop for n from 1 until N do
         (setq wffString2 (string (extractNumericWFF myPopulation[n].WFF) true))
         (if (<> wffString1 wffString2) (setq wffBest[(++ m)] (Lisp wffString2)[0]))
         (if (>= m 4) (setq n N))
         ) ; end N loop
      wffBest) ; end saveUniqueNumericWffs
   ;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
   (defun spliceNumericWFF(wff swff ...) (if (= (argCount) 2) (eGrammar.spliceNumericWFF wff swff) (eGrammar.spliceNumericWFF wff swff (argFetch 2))))
   ;; Return a stand alone set of estimator rules from the specified Lambda.
   (defun standAloneEstimatorRules(Lambda)
      regs:(m M n N)
      vars:(wff wffString rule genome CC)
      (setq wff (gsm.concreteWFF Lambda))
      (setq rule wff[0])
      (setq genome wff[1])
      (cond
         ;; Pretty print an mvlregress formula
         ((= rule ruleMvl:)
          (begin
            (if (not (isMember Mvl: Lambda.Pv)) (goto ruleREG:))
            (setq M (length genome))
            (setq CC Lambda.Mvl.myW)
            (setq wffString "")
            (loop for m from 0 until M do
              (if (<> genome[m] #void)
                  (if (= wffString "")
                      (setq wffString (append "(ruleMul " (abs CC[m]) " " (stringWff genome[m]) ")"))
                      (setq wffString (append "(ruleAdd " wffString "(ruleMul " (abs CC[m]) " " (stringWff genome[m]) "))"))
                      ) ; end blank if
                  ) ; end void if
              ) ; end M loop
          )) ; end ruleMvl case
         ;; Pretty print a regress formula
         ((= rule ruleReg:)
          (begin
            ruleREG::
            (setq M (length genome))
            (setq wffString "")
            (loop for m from 0 until M do
              (if (<> genome[m] #void)
                  (if (= wffString "")
                      (setq wffString (stringWff genome[m]))
                      (setq wffString (append "(ruleAdd " wffString " " (stringWff genome[m]) ")"))
                      ) ; end blank if
                  ) ; end void if
              ) ; end M loop
            (setq wffString (append "(ruleMul " (string Lambda.B) " " wffString ")"))
          )) ; end ruleReg case
         ;; Pretty print a model formula
         ((= rule ruleMdl:)
          (begin
            (setq M (length genome))
            (setq wffString "")
            (loop for m from 0 until M do
              (if (<> genome[m] #void)
                  (if (= wffString "")
                      (setq wffString (stringWff genome[m]))
                      (setq wffString (append "(ruleAdd " wffString " " (stringWff genome[m]) ")"))
                      ) ; end blank if
                  ) ; end void if
              ) ; end M loop
            (setq wffString (append "(ruleMul " (string Lambda.B) " " wffString ")"))
          )) ; end ruleMdl case
         (else (setq wffString "0.0"))
         ) ; end cond
      wffString) ; end standAloneEstimatorRules
   ;; Convert a estimator wff to a string (from a list of Pair objects).
   (defun stringWff(wff)
      vars:(wffSource)
      (if (isString wff) (setq wffSource wff) (setq wffSource (string wff true)))
      wffSource) ; end stringWff
   ;; Convert a estimator wff to a sorted string (from a list of Pair objects).
   (defun stringSortedWff(wff)
      regs:(m M)
      vars:(wffSource rule genome)
      vars:(chromosome0 chromosome1)
      vars:(collisionSW (collision #{dic|| ruleFrm true ruleMdl false ruleMvl true ruleReg false ruleSvm true }))
      (if (isString wff) (setq wff (Lisp wff)[0]))
      (if (or (not (isPair wff)) (<> (length wff) 2)) (error "gsm.stringSortedWff: invalid WFF"))
      (setq rule wff[0])
      (setq genome (sort (copy wff[1]) >))
      ;; Eliminate collisions for those rules which demand collision protection.
      (if (= (setq collisionSW collision[rule]) #void) (error (append "gsm.stringSortedWff: unknown regression rule [" rule "]")))
      (if (= collisionSW true)
          (begin
             (setq M (length genome))
             (loop for m from 1 until M do
               (setq chromosome0 genome[(- m 1)])
               (setq chromosome1 genome[m])
               (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
                   (setq genome[(- m 1)] #void)
                   ) ; end if
               ) ; end loop   
             (setq genome (sort genome >))
          )) ; end collision if
      (setq wffSource (string (list rule genome) true))
      wffSource) ; end stringSortedWff
   ;; Truncate a estimator wff to the specified maximum display length.
   (defun trunc(s len) (if (> (length s) len) then (setq s (append (left s len) " ... ;"))) s)
   ;; Turns the verbose testing mode off.
   (defun verboseOFF() (setq myVerboseSW false))
   ;; Turns the verbose testing mode on.
   (defun verboseON() (setq myVerboseSW true))
   ;; *******************************************************************************
   ;; Define Private Child Lambdas 
   ;; *******************************************************************************
   ;; Build a training model for generating training data.
   (defun buildTrainingModel(columns modalSW)
      regs:(m M n N)
      vars:(model genome oldMyM oldGrammar wffSource rootLimit)
      (setq oldMyM myM)
      (setq oldGrammar eGrammar)
      (setq myM (integer columns))
      (setq M myM)
      (setq eGrammar expressionGrammarGen)
      (setq rootLimit (expressionGrammarGen.growRootWFF -1))
      (setq genome (new Vector: M))
      (setq wffSource (append "regress(" (- (gsm.myRandomFunction 100.0) 50.0)))
      (loop for m from 0 until M do
         (if (= modalSW true)
             (setq wffSource (append wffSource "+(" (- (gsm.myRandomFunction 100.0) 50.0) "*" (evalRule (expressionGrammarGen.growCTermWFF m)) ")"))
             (setq wffSource (append wffSource "+(" (- (gsm.myRandomFunction 100.0) 50.0) "*" (evalRule (expressionGrammarGen.growTermWFF -2 m)) ")"))
             ) ; end modal if
         ) ; end loop
      (setq wffSource (append wffSource ");"))
      (if (>= (length wffSource) myWFFLengthLimit) (goto Last:))
      (setq model (compileEstimator wffSource))
      (if (not (isLambda model)) (goto Last:))
      (setq model.WFF wffSource)
      (setq model.A 0.0)
      (setq model.B 1.0)
      Last::
      (setq myM oldMyM)
      (setq eGrammar oldGrammar)
      model) ; end buildTrainingModel
   ;; Pseudo random number routine.
   ;; Note: very time consuming but repeats only every hundred billion numbers.
   (defun grandom(upperLimit)
      regs:(n N)
      vars:((elements #(0.5  0.25  0.125  0.0625  0.03125  0.015625  0.0078125  0.00390625  0.001953125  0.0009765625  0.00048828125  0.000244140625  0.0001220703125  6.103515625E-005  3.0517578125E-005  1.52587890625E-005  7.62939453125E-006  3.814697265625E-006  1.907348632813E-006  9.536743164063E-007  4.768371582031E-007  2.384185791016E-007  1.192092895508E-007  5.960464477539E-008  2.98023223877E-008  1.490116119385E-008  7.450580596924E-009  3.725290298462E-009  1.862645149231E-009  9.313225746155E-010  4.656612873077E-010  2.328306436539E-010  1.164153218269E-010  5.820766091347E-011  2.910383045673E-011  1.455191522837E-011  7.275957614183E-012  3.637978807092E-012  1.818989403546E-012  9.094947017729E-013  4.547473508865E-013  2.273736754432E-013  1.136868377216E-013  5.684341886081E-014  2.84217094304E-014  1.42108547152E-014  7.105427357601E-015)))
      vars:(result)
      ;; Support existing or argument persistent variables structure.
      (setq N (length elements))
      (loop for n from 0 until N do (if (>= (srandom 1.0) .5) (+= result elements[n])))
      (*= result upperLimit)
      result) ; end grandom
   ;; Export all embedded ontology objects from this Lambda.
   (defun exportDocs(...)
      regs:(k K m M n N)
      vars:(embeddedOntologyNames embeddedOntologyPrefix tempNames currentFocus)
      vars:(ontologyObject (cabinetPrefix ";#text#") (cabinetPrefixLength 7))
      vars:((targetCabinetName "Gsm") (targetLambdaName "gsm") exportFolder)

	  ;; Convert the argument and initialize.
      (setq exportFolder (if (= (argCount) 0) "C:\\RefGuide\\Foundry\\" (argFetch 0)))
	  (setq exportFolder (string exportFolder))
	  (setq embeddedOntologyPrefix (append targetLambdaName ":%%"))
	
      ;; Load the names of all embedded Ontology objects.
      (setq currentFocus (browseLib.getFocus))
      (browseLib.setFocus targetCabinetName)
      (setq tempNames (browseLib.getChildNames))
      (browseLib.setFocus currentFocus)
      (setq K (length embeddedOntologyPrefix))
      (setq N (length tempNames))
      (setq m -1)(setq embeddedOntologyNames (new Vector:))
      (loop for n from 0 until N do (if (stringCiEQ (left tempNames[n] K) embeddedOntologyPrefix) (setq embeddedOntologyNames[(++ m)] (mid tempNames[n] K 100000))))  
      (setq N (length embeddedOntologyNames))

      ;; Export all embedded Ontology objects (only export no HTML generation).
      (setq N (length embeddedOntologyNames))
      (loop for n from 0 until N do
         (setq ontologyObject (browseLib.checkout targetCabinetName (append embeddedOntologyPrefix embeddedOntologyNames[n])))
         (setq ontologyObject (mid ontologyObject cabinetPrefixLength 10000000))
         (browseLib.writeSourceFile (append exportFolder embeddedOntologyNames[n] ".xml") ontologyObject)
         ) ; end loop
      true) ; end exportDocs
   ;; Generate the private WFF language used for genetic programming of estimator Lambdas Note: (gsm.makeEstimator)).
   (defun makeEstimator()
      (ParseLib "Gsm" "gsm:estimator")
      true) ; end makeEstimator
   ;; Set predefined default option information, by name, for the current training run.
   ;; Args: name			The name of the option information script to be used.
   ;;       randomError		The amount of random error noise to insert into all self tests (00%, 10%, 20%, 40%, etc).
   ;;       verboseSW		The verbose switch for use with all self tests (TRUE iff verbose mode is to be set on).
   ;;       maxTime	        (Optional) The maximum elapsed time for learning (must be entered in hours and fractions of an hour).
   ;;       svmKernelID	    (Optional) The SVM regression kernel identifier (composite, cube, etc.)
   (defun setOptions(name randomError verboseSW ...)
      vars:(kernelID)
      (setq myUserGrammarWFFs #void)    ;; Clear all user defined grammar WFFs.
      (setq myUserJavaScriptWFFs #void) ;; Clear all user defined JavaScript WFFs.
      (if (>= (argCount) 4) (setq myEvolutionMaxTickCount (* (number (argFetch 3)) 3600.0)) (setq myEvolutionMaxTickCount 99999999999999.9))
      (if (>= (argCount) 5) (setq kernelID (argFetch 4)))

      ;; Set the Default User Defined Learning Options
	  (setq myAbstractConsPct .25)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  (setq myAbstractNoisePct .10)  	;; The percent chance that an abstract random noise term will be generated during variable generation.
	  (setq myAbstractVarsPct .10)  	;; The percent chance that an abstract variable will be generated during variable generation.
	  (setq myAbstractOperators full:)  ;; The valid abstract operators (math trig full noop).
      (setq myAcceptMaxErr 9999.00)     ;; The maximum acceptable fitness score, higher than this will result in a void candidate being returned. 
	  (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
      (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	  (setq myBestAsConcreteWFF false)  ;; The switch to return the myBest WFF, grown in the best-of-breed island, as a concrete WFF. 
      (setq myBestOfBest 10)            ;; The maximum number of best of the best estimator champions to save.
      (setq myChromosomeGEN 0000)       ;; The maximum random root-chromosome genomes from different columns to grow during each generation step.
      (setq myChromosomeINIT 0000)      ;; The maximum random root-chromosome genomes from different columns to grow during the initialization step.
	  (setq myChromosomeRule MVL:)      ;; The rule used for root-chromosome search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
      (setq myContextColPct 0.00)  		;; The probability of context aware cross over in each column island during each generation step.
      (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
      (setq myContextSelPct 0.00)  		;; The probability of context aware cross over in the best-of-breed island during each generation step.
	  (setq myCovarianceLimit .25)      ;; The maximum absolute value of the covariance between champions for entry into the alternate champion pool (only scriptGSOALPS).
      (setq myCrossAbsPct 0.00) 	    ;; The probability of cross over, using abstract expressions, during each generation step.
      (setq myCrossColPct 0.00)  		;; The probability of cross over in each column island during each generation step.
      (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
      (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
      (setq myCrossOverStrategy normal:);; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).
      (setq myFRMMaximum 1000)     		;; The maximum number of chromosomes to allowed in any one FRM regression.
      (setq myGetSeriousErr	2.0)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	  (setq myGetSeriousGens 1000)		;; The count of generations after which we turn sampling off and set the training factor to 4.
      (setq myGreedyDepth 00)    		;; The depth of greedy search exploration of each chosen column island  during each generation step. 
      (setq myGreedyGEN  000)    		;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
      (setq myGreedyINIT 0000)    	    ;; The number of greedy search WFFs the system will grow in the best-of-breed island  during the initialization step. 
      (setq myGreedyRule MVL:)          ;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
      (setq myGreedyWidth narrow:)    	;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
      (setq myGrowColINIT 00)   		;; The number of random WFFs the system will grow in each column island during the initialization step.
      (setq myGrowColGEN 00)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
      (setq myGrowRootRule REG:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
      (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in each column island (FRM, MVL, REG, or SVM). 
      (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
      (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
      (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
      (setq myGrowWFFStyle term:)       ;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
      (setq myMaxColWFFLen 05)  		;; The maximum length of a single WFF for each column.
      (setq myMigratePct 0.00)   		;; The probability of Column island mutation during each generation step.
      (setq myMutateAbsPct 0.00) 	    ;; The probability of mutation, using abstract expressions, during each generation step.
      (setq myMutateColPct 0.00) 		;; The probability of mutation in each column island during each generation step.
      (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
      (setq myMVLMaximum 1000)     		;; The maximum number of chromosomes to allowed in any one MVL regression.
      (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
	  (setq myNumberPct .25)     		;; The percent chance that a numeric constant will be generated during term generation.
      (setq myOptionSetting (symbol name)) ;; The last option setting for this Lambda.
      (setq myRandomError randomError)  ;; The amount of random error to add to each selfTest test case (0.00 thru .50).
      (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
      (setq myREGMultiple true)         ;; Support multiple columns when growing REG regression expressions.
      (setq myREGMaximum 1000)     		;; The maximum number of chromosomes to allowed in any one REG regression.
      (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
      (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm training regression.
      (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm training regression.
      (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population.
      (setq myRandomFunction ^srandom)	;; The pseudo random number function currently selected for use.
      (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
      (setq myRootINIT 00)  	 		;; The number of root WFFs the system will grow in each column island during the initialization step.
      (setq myRootGEN 00)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
      (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
      (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
      (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
      (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
      (setq mySurvivorStyle equalOFF:)  ;; The option allowing surviving estimator WFFs to have equal scores (equalON, or equalOFF).
      (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
      (setq mySVMMaximum 1000)     		;; The maximum number of chromosomes to allowed in any one SVM regression.
      (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
      (setq mySvmMaxLayers 1)           ;; The maximum number of training layers to use for all SVM learning (see svmRegress).
      (setq mySvmModelCount 1)          ;; The maximum number of training models to use for all SVM learning (see svmRegress).
      (setq myTournamentSize 05)		;; The size of the myBestEstimatorChampions queue which initiates a tournament-of-champions when the next evolutionary process begins.
	  (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
	  (setq myTrainingScript scriptGEP) ;; The training script used for training this symbolic regression machine.
      (setq myUseFRM false)             ;; Grow FRM estimator candidates during the initialization step and during each generation step.
      (setq myUseMVL false)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
      (setq myUseREG false)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
      (setq myUseSVM false)             ;; Grow SVM estimator candidates during the initialization step and during each generation step.
      (setq myUseREGRatio 1.0)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
      (setq myVerboseSW verboseSW)	 	;; The switch controlling verbose mode during testing, maintennance, and development.
	  (setq myWFFLengthLimit 5000)      ;; The maximum length, after which, any Estimator WFF will be rejected on the basis of size alone.
	  (setq myWFFSaveLimit 5000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
      (setq myWFFReinitSW true)         ;; The switch controlling the reinitialization of WFF cache at the start of every new run.
      (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to genetic and evolutionary programming.

      ;; Set the Named User Defined Learning Options
      (cond 
       ;; Note: These options are our best recommendation for regression and sequencing of all individuals using classic genetic programming symbolic regression.

       ;; Set the default option settings.
       ;; Note1: These options work well for serious regression and sequencing of all individuals using unconstrained classic grammar swarm symbolic regressions.
       ;; Note2: This option includes full out of sample testing and works well for multiple competition swarm symbolic regressions.
       ((= name default:)
        (begin
	      (setq myAbstractConsPct .00)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .00)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .00)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptMVLALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossAbsPct 0.05)         ;; The probability of cross over, using abstract expressions, during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 0500)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateAbsPct 0.05)        ;; The probability of mutation, using abstract expressions, during each generation step.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple true)         ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       	    ;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)         ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySWMMaxGap 20)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  false)            ;; Grow SVM estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .00)          ;; The ratio of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end default case
       ;; Set the regressMVLALPS option settings.
       ;; Note1: These options work well for serious regression and sequencing of all individuals using unconstrained classic grammar swarm symbolic regressions.
       ;; Note2: This option includes full out of sample testing and works well for multiple competition swarm symbolic regressions.
       ((= name regressMVLALPS:)
        (begin
	      (setq myAbstractConsPct .00)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .00)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .00)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptMVLALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossAbsPct 0.05)         ;; The probability of cross over, using abstract expressions, during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 0500)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateAbsPct 0.05)        ;; The probability of mutation, using abstract expressions, during each generation step.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple true)         ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       	    ;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)         ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySWMMaxGap 20)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  true)             ;; Grow SVM estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .00)          ;; The ratio of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressMVLALPS case
       ;; Set the regressMVLALPSRQ option settings.
       ;; Note1: These options work well for serious regression and sequencing of all individuals using unconstrained classic grammar swarm symbolic regressions.
       ;; Note2: This option includes full out of sample testing and works well for multiple competition swarm symbolic regressions.
       ((= name regressMVLALPSRQ:)
        (begin
	      (setq myAbstractConsPct .00)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .00)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .00)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptMVLALPSRQ) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossAbsPct 0.05)         ;; The probability of cross over, using abstract expressions, during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 0500)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateAbsPct 0.05)        ;; The probability of mutation, using abstract expressions, during each generation step.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple true)         ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       	    ;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)         ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySWMMaxGap 20)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  true)             ;; Grow SVM estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .00)          ;; The ratio of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressMVLALPSRQ case
       ;; Set the regressNVSGSOALPS option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using "fill training" classic grammar swarm symbolic regressions.
       ;; Note2: There is NO vertical slicing in this option.
       ((= name regressNVSGSOALPS:)
        (begin
	      (setq myAbstractConsPct .00)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .00)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .00)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptMVLALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossAbsPct 0.05)         ;; The probability of cross over, using abstract expressions, during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 0500)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateAbsPct 0.05)        ;; The probability of mutation, using abstract expressions, during each generation step.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple true)         ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       	    ;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  false)        ;; Turn off initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySWMMaxGap 20)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 1)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  false)            ;; Grow SVM estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .00)          ;; The ratio of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressNVSGSOALPS case
       ;; Set the regressGSOALPS option settings.
       ;; Note1: These options work well for serious regression and sequencing of all individuals using unconstrained classic grammar swarm symbolic regressions.
       ;; Note2: This option includes full out of sample testing and works well for multiple competition swarm symbolic regressions.
       ((= name regressGSOALPS:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 10)            ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGSOALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossAbsPct 0.05)         ;; The probability of cross over, using abstract expressions, during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 5000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule REG:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateAbsPct 0.05)        ;; The probability of mutation, using abstract expressions, during each generation step.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00010) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       	    ;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)         ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  false)            ;; Grow SVM estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressGSOALPS case
       ;; Set the regressSWARM option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using classic grammar swarm symbolic regressions.
       ;; Note2: This option includes out of sample testing and works well for multiple competition swarm symbolic regressions.
       ((= name regressSWARM:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myBaggingCnt 1)             ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptSWARM) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
          (setq myMaxColWFFLen 10000)		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 50)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 500)              ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq mySamplingON  false)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
	      (setq myTrainingFactor 2)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressSWARM case
       ;; Set the regressSWARMSingle option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using classic grammar swarm symbolic regressions.
       ;; Note2: This option includes NO out of sample testing and works well for SINGLE swarm symbolic regressions.
       ((or (= name regressSWARMSingle:)(= name regressSWARMFull:))
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myAbstractOperators full:)  ;; The valid abstract operators (math trig full noop).
          (setq myAcceptMaxErr BIGPOSNUM)   ;; The maximum acceptable fitness score, higher than this will result in a void candidate being returned. 
	      (setq myBaggingCnt 1)             ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptSWARM) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
          (setq myMaxColWFFLen 10000)		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 50)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 500)              ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq mySamplingON  false)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
	      (setq myTrainingFactor 1)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressSWARMSingle case
       ;; Set the regressSWARMMath option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using classic grammar swarm symbolic regressions.
       ;; Note2: This option includes NO out of sample testing and works well for SINGLE swarm symbolic regressions.
       ((= name regressSWARMMath:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myAbstractOperators math:)  ;; The valid abstract operators (math trig full noop).
	      (setq myBaggingCnt 1)             ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptSWARM) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
          (setq myMaxColWFFLen 10000)		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 50)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 500)              ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq mySamplingON  false)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
	      (setq myTrainingFactor 1)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressSWARMMath case
       ;; Set the regressSWARMTrig option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using classic grammar swarm symbolic regressions.
       ;; Note2: This option includes NO out of sample testing and works well for SINGLE swarm symbolic regressions.
       ((= name regressSWARMTrig:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myAbstractOperators trig:)  ;; The valid abstract operators (math trig full noop).
	      (setq myBaggingCnt 1)             ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptSWARM) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
          (setq myMaxColWFFLen 10000)		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 50)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 500)              ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq mySamplingON  false)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
	      (setq myTrainingFactor 1)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressSWARMTrig case
       ;; Set the regressSWARMNoop option settings.
       ;; Note1: These options work well for regression and sequencing of all individuals using classic grammar swarm symbolic regressions.
       ;; Note2: This option includes NO out of sample testing and works well for SINGLE swarm symbolic regressions.
       ((= name regressSWARMNoop:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
	      (setq myAbstractOperators noop:)  ;; The valid abstract operators (math trig full noop).
	      (setq myBaggingCnt 1)             ;; The number of champion Lambdas to use when bagging creates a composite champion.
          (setq myBaggingPct .50)           ;; The percent error score above which bagging is to start.
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptSWARM) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
          (setq myMaxColWFFLen 10000)		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMMaxGap 25)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 50)             ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 500)              ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq mySamplingON  false)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
	      (setq myTrainingFactor 1)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressSWARMTrig case
       ;; Set the regressHVES option settings.
       ;; Note1: These options work well for serious regression and sequencing of all individuals using unconstrained classic grammar swarm symbolic regressions.
       ;; Note2: This option includes full out of sample testing and works well for multiple competition swarm symbolic regressions.
	   ;; Note3: This uses the HVES Error classification and analysis technique and works well for multimodal problems
       ( (= name regressHVES:)
        (begin
	      (setq myAbstractConsPct .01)      ;; The percent chance that an abstract constant will be generated during numeric constant generation.
	  	  (setq myAbstractNoisePct .01)     ;; The percent chance that an abstract random noise term will be generated during variable generation.
	      (setq myAbstractVarsPct .01)  	;; The percent chance that an abstract variable will be generated during variable generation.
	      (setq myNumberPct .01)     		;; The percent chance that a numeric constant will be generated during term generation.
    	  (setq myTrainingScript scriptHVES) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGso) ;; Set the numeric expression rule to mixed concrete and grammar swarm optimization.
      	  (setq myContextColPct 0.10)       ;; The probability of context aware cross over in each column island during each generation step.
          (setq myContextSelPct 0.10)       ;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGetSeriousErr	.50)    	;; The best champion NLSE after which we turn sampling off and set the training factor to 4.
	      (setq myGetSeriousGens 1)	     	;; The count of generations after which we turn sampling off and set the training factor to 4.
          (setq myGrowColGEN 5000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
  		  (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
          (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySamplingON  true)         ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myScoreFocus full:)  	    ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).
          (setq mySurvivors  25)     		;; The count of surviving estimator WFFs in each generation.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq mySWMPool 0100)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	      (setq myTrainingFactor 10)        ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREGRatio .70)          ;; The ration of REG/MVL estimator candidates to grow during the initialization step and during each generation step.
	      (setq myWFFSaveLimit 0000)        ;; The maximum size of all WFFs saved by the system (after this size no more WFFs are saved).
        )) ; end regressHVES case
       ;; Set the regressGEPALPS option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name regressGEPALPS:)
        (begin
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGEPALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
      	  (setq myContextColPct 0.00)  		;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.00)  		;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 5000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term).
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm regression.
          (setq myRestartEpoch 00010) 	    ;; The count of generations to allow before initializing a new age layered population.
          (setq myRootGEN 0000)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressGEPALPS case
       ;; Set the regressGABALPS option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name regressGABALPS:)
        (begin
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGABALPS) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGab) ;; Set the numeric expression rule to grammar swarm optimization.
      	  (setq myContextColPct 0.00)  		;; The probability of context aware cross over in each column island during each generation step.
          (setq	myContextRegPct 0.00)  		;; The probability of context aware cross over in the best-regressor island during each generation step.
          (setq myContextSelPct 0.00)  		;; The probability of context aware cross over in the best-of-breed island during each generation step.
          (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
          (setq	myCrossRegPct 0.00)  		;; The probability of cross over in the best-regressor island during each generation step.
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelGEN 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowColGEN 0025)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
          (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowRootRule MVL:)        ;; The rule used for random root WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)			;; The maximum length of a single WFF for each column.
          (setq myMutateColPct 1.00) 		;; The probability of mutation in each column island during each generation step.
      	  (setq myMutateRegPct 0.00) 		;; The probability mutation in the best-regressor island during each generation step.
      	  (setq myMutateSelPct 1.00) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0050)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartEpoch 00002) 	    ;; The count of generations to allow before initializing a new age layered population. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
          (setq myRestartGap 00002) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 0000)       		;; The number of root WFFs the system will grow in each column island during the initialization step. 
          (setq myRootGEN 0025)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressGABALPS case
       ;; Set the defaultFRM option settings.
       ;; Note: These options work well for time series, factored, multivariate regressions.
       ((= name defaultFRM:)
        (begin
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule FRM:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myUseFRM  true)             ;; Grow FRM estimator candidates during the initialization step and during each generation step.
        )) ; end defaultFRM case
       ;; Set the regressBOOST option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using grammar swarm symbolic regression.
       ((or (= name regressBOOST:) (= name regressGEPBOOST:))
        (begin
	      (setq myTrainingScript scriptBOOST) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressBOOST case
       ;; Set the regressGABBOOST option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using grammar swarm symbolic regression.
       ((= name regressGABBOOST:)
        (begin
	      (setq myTrainingScript scriptGABBOOST) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGab) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm swarm training regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGABBOOST case
       ;; Set the regressGABMultiBOOST option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using grammar swarm symbolic regression.
       ((= name regressGABMultiBOOST:)
        (begin
	      (setq myTrainingScript scriptGABMultiBOOST) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGab) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm training regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGABMultiBOOST case
       ;; Set the rootGABSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using grammar swarm symbolic regression.
       ((= name rootGABSR:)
        (begin
	      (setq myTrainingScript scriptGAB) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGab) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myNoiseMaxGen 10)           ;; The maximum number of training generations in any one random noise swarm training regression.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm training regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm training regression.
          (setq myRestartGap 00005) 		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 1000)  	 		;; The number of root WFFs the system will grow in each column island during the initialization step.
          (setq myRootGEN 00)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end rootGABSR case
       ;; Set the regressGPSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name regressGPSR:)
        (begin
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGEP) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGPSR case
       ;; Set the ensambleGPSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name ensambleGPSR:)
        (begin
      	  (setq myBestAverage 5)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGEP) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end ensambleGPSR case
       ;; Set the rootGPSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name rootGPSR:)
        (begin
	      (setq myTrainingScript scriptGEP) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)       ;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end rootGPSR case
       ;; Set the defaultGPSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using classic genetic programming symbolic regression.
       ((= name defaultGPSR:)
        (begin
      	  (setq myBestAverage 1)  	    	;; The count of best estimator champions to average in creating the final myBest estimator Lambda.
	      (setq myTrainingScript scriptGEP) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGep) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end defaultGPSR case
       ;; Set the regressGABSR option settings.
       ;; Note: These options work well for regression and sequencing of all individuals using grammar swarm symbolic regression.
       ((= name regressGABSR:)
        (begin
	      (setq myTrainingScript scriptGAB) ;; The training script used for training this symbolic regression machine.
          (setq eGrammar expressionGrammarGab) ;; Set the numeric expression rule to grammar swarm optimization.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule REG:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle full:)      	;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
          (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
          (setq mySWMMaxGen 5)              ;; The maximum number of training generations in any one swarm regression.
          (setq myREGMaximum 1000)          ;; The maximum number of chromosomes to allowed in any one REG regression.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq mySWMPool 0025)             ;; The maximum size of the particle population pool allowed in any one swarm regression.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGABSR case
       ;; Set the defaultMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((or (= name defaultMVL:) (= name regressRGMVL:))
        (begin
	      (setq myCrossColPct 0.00)  		;; The probability of cross over in each column island during each generation step.
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
	      (setq myGreedyDepth 25)    		;; The depth of greedy search exploration of each chosen column island  during each generation step. 
	      (setq myGreedyGEN 100)    		;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
	      (setq myGreedyWidth random:)    	;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
	      (setq myGreedyRule MVL:)          ;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myGrowColINIT 0000)   		;; The number of random WFFs the system will grow in each column island during the initialization step.
	      (setq myGrowColGEN 000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
	      (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateColPct 0.00) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartGap 0010)  		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT 1000)  	 		;; The number of root WFFs the system will grow in each column island during the initialization step.
          (setq myRootGEN 100)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end defaultMVL case
       ;; Set the defaultSVM option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name defaultSVM:)
        (begin
	      (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule SVM:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myMutateColPct 0.10) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq mySamplingON  true)   	    ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
          (setq mySvmKernelID composite:)   ;; The kernelID to use for all SVM learning (see svmRegress: all, binary, bipolar, composite, cosine, cube, euclid, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
          (setq mySVMMaximum 1000)     		;; The maximum number of chromosomes to allowed in any one SVM regression.
          (setq mySvmMaxGen 1)             	;; The maximum number of training generations to use for all SVM learning (see svmRegress).
          (setq mySvmMaxLayers 1)           ;; The maximum number of training layers to use for all SVM learning (see svmRegress).
          (setq mySvmModelCount 1)          ;; The maximum number of training models to use for all SVM learning (see svmRegress).
          (setq myUseSVM  true)             ;; Grow SVM estimator candidates during the initialization step and during each generation step.
        )) ; end defaultSVM case
       ;; Set the regressCMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressCMVL:)
        (begin
	      (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
	      (setq myGreedyDepth 10)    		;; The depth of greedy search exploration of each chosen column island  during each generation step. 
	      (setq myGreedyGEN 025)    		;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
	      (setq myGreedyWidth narrow:)    	;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
	      (setq myGreedyRule MVL:)          ;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myGrowColINIT 1000)   		;; The number of random WFFs the system will grow in each column island during the initialization step.
	      (setq myGrowColGEN 000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
	      (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq myGrowSelINIT 1000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateColPct 0.10) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressCMVL case
       ;; Set the regressGaMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressGaMVL:)
        (begin
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myCrossOverStrategy normal) ;; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressGaMVL case
       ;; Set the regressGaCMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressGaCMVL:)
        (begin
          (setq myChromosomeGEN 0000)       ;; The maximum random root-chromosome genomes from different columns to grow during each generation step.
          (setq myChromosomeINIT 1000)      ;; The maximum random root-chromosome genomes from different columns to grow during the initialization step.
	      (setq myChromosomeRule MVL:)      ;; The rule used for root-chromosome search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myCrossColPct 0.00)  		;; The probability of cross over in each column island during each generation step.
          (setq myCrossOverStrategy normal) ;; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).      	  
          (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
	      (setq myGrowColINIT 1000)   		;; The number of random WFFs the system will grow in each column island during the initialization step.
	      (setq myGrowColGEN 000)    		;; The number of random WFFs the system will grow in each column island during each generation step. 
	      (setq myGrowColRule REG:)         ;; The rule used for random WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq myGrowWFFStyle term:)       ;; The style used for random WFFs grown in the best-of-breed island (full, or term). 
	      (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateColPct 0.00) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartGap 0010)  		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT  0000)  	    	;; The number of root WFFs the system will grow in each column island during the initialization step.
          (setq myRootGEN 00)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGaCMVL case
       ;; Set the regressGPMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressGPMVL:)
        (begin
      	  (setq myCrossSelPct 0.05)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myMutateSelPct 0.05) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq mySurvivors 500)     		;; The count of surviving estimator WFFs in each generation.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressGPMVL case
       ;; Set the regressGreedyMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressGreedyMVL:)
        (begin
          (setq myChromosomeGEN 0000)       ;; The maximum random root-chromosome genomes from different columns to grow during each generation step.
          (setq myChromosomeINIT 0200)      ;; The maximum random root-chromosome genomes from different columns to grow during the initialization step.
	      (setq myChromosomeRule MVL:)      ;; The rule used for root-chromosome search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myCrossColPct 0.00)  		;; The probability of cross over in each column island during each generation step.
          (setq myCrossOverStrategy aggressive:) ;; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGreedyDepth 10)    		;; The depth of greedy search exploration of each chosen column island during each generation step. 
          (setq myGreedyGEN  000)    		;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
          (setq myGreedyINIT 0000)    	    ;; The number of greedy search WFFs the system will grow in the best-of-breed island  during the initialization step. 
          (setq myGreedyRule MVL:)          ;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGreedyWidth narrow:)    	;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
	      (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateColPct 0.00) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartGap 0010)  		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT  5000)  	    	;; The number of root WFFs the system will grow in each column island during the initialization step.
          (setq myRootGEN 00)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq mySurvivors 010)     		;; The count of surviving estimator WFFs in each generation.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
        )) ; end regressGreedyMVL case
       ;; Set the regressGreedySMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressGreedySMVL:)
        (begin
          (setq myChromosomeGEN 0000)       ;; The maximum random root-chromosome genomes from different columns to grow during each generation step.
          (setq myChromosomeINIT 0200)      ;; The maximum random root-chromosome genomes from different columns to grow during the initialization step.
	      (setq myChromosomeRule MVL:)      ;; The rule used for root-chromosome search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myCrossColPct 0.00)  		;; The probability of cross over in each column island during each generation step.
          (setq myCrossOverStrategy aggressive:) ;; The strategy used in the cross over operation (normal, aggressive, constrained, genetic).
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGreedyDepth 10)    		;; The depth of greedy search exploration of each chosen column island during each generation step. 
          (setq myGreedyGEN  000)    		;; The number of greedy search WFFs the system will grow in the best-of-breed island  during each generation step. 
          (setq myGreedyINIT 0000)    	    ;; The number of greedy search WFFs the system will grow in the best-of-breed island  during the initialization step. 
          (setq myGreedyRule MVL:)          ;; The rule used for greedy search WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myGreedyWidth narrow:)    	;; The width of each greedy search WFF the system will grow in the best-of-breed island (base, full, narrow, random). 
	      (setq myMaxColWFFLen 100)  		;; The maximum length of a single WFF for each column.
	      (setq myMutateColPct 0.00) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myREGMultiple false)        ;; Support multiple columns when growing REG regression expressions.
          (setq myRestartGap 0010)  		;; The count of generations to allow, without measurable improvement, before initiating a new evolutionary process.
          (setq myRootINIT  5000)  	    	;; The number of root WFFs the system will grow in each column island during the initialization step.
          (setq myRootGEN 00)       		;; The number of root WFFs the system will grow in each column island during each generation step. 
          (setq myRootRule REG:)            ;; The rule used for root WFFs grown in each column island (FRM, MVL, REG, or SVM). 
          (setq mySurvivors 010)     		;; The count of surviving estimator WFFs in each generation.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseREG  true)             ;; Grow REG estimator candidates during the initialization step and during each generation step.
          (setq myWFFReinitSW false)        ;; The switch controlling the reinitialization of WFF cache at the start of every new run.
        )) ; end regressGreedySMVL case
       ;; Set the regressMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressMVL:)
        (begin
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelINIT 0010)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq mySurvivors 025)     		;; The count of surviving estimator WFFs in each generation.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressMVL case
       ;; Set the regressSMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressSMVL:)
        (begin
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
        )) ; end regressSMVL case
       ;; Set the regressSvmMVL option settings.
       ;; Note: These options work well for general multivariate regressions.
       ((= name regressSvmMVL:)
        (begin
	      (setq myCrossColPct 1.00)  		;; The probability of cross over in each column island during each generation step.
      	  (setq myCrossSelPct 1.00)  		;; The probability of cross over in the best-of-breed island during each generation step.
          (setq myGrowSelINIT 5000)   		;; The number of random WFFs the system will grow in the best-of-breed island during the initialization step.
          (setq myGrowSelGEN 00)    		;; The number of random WFFs the system will grow in the best-of-breed island during each generation step. 
          (setq myGrowSelRule MVL:)         ;; The rule used for random WFFs grown in the best-of-breed island (FRM, MVL, REG, or SVM). 
	      (setq myMutateColPct 0.10) 		;; The probability of mutation in each column island during each generation step.
	      (setq myMutateSelPct 0.10) 		;; The probability mutation in the best-of-breed island during each generation step.
          (setq myUseMVL  true)             ;; Grow MVL estimator candidates during the initialization step and during each generation step.
          (setq myUseSVM  true)             ;; Grow SVM estimator candidates during the initialization step.
        )) ; end regressSvmMVL case
      (else (error (append "gsm.setOptions: invalid default option name [" name "]")))
       ) ; end option cond
      ;; Has the user asked to override the kernelID to use for all SVM learning? 
      ;; Note see svmRegress:(binary, bipolar, composite, cosine, cube, exp, linear, log, poly, quart, sigmoid, sine, square, tan, tanh).
      (if (<> kernelID #void) (setq mySvmKernelID kernelID))
      true) ; end setOptions
   ;; Set pseudo randum number function seed for the current training run.
   (defun setRandomSeed(Number:seed) (setq srandom.seed (setq mySeed seed)))
   ;; Set user defined grammar WFFs for the current training run.
   ;; Note: userWFFs may be either a Vector of wffs or a single wff.
   (defun setUserGrammarWFFs(userWFFs)
       regs:(n N)
       vars:(wffVector wff wffPair wffString wffSource)
       vars:(rule genome Lambda)
       ;; Convert userWFFs argument into a vector of wffs.
       (if (isVector userWFFs) (setq wffVector userWFFs) (setq wffVector (new Vector: Object: 1 userWFFs)))
       ;; Clear all user defined grammar WFFs.
       (setq myUserGrammarWFFs (new Vector: Object:))
       (setq N (length wffVector))
       (loop for n from 0 until N do
          (setq wff wffVector[n])
          (if (= wff #void) (goto SkipThisWFF:))
          (setq wffString (stringWff wff))
          (if (isPair wff) (setq wffPair wff) (setq wffPair (listWff wff)))
          (setq rule wffPair[0]) 
          (setq genome wffPair[1])
          (if (and (<> rule ruleReg:) (<> rule ruleMdl:) (<> rule ruleMvl:) (<> rule ruleFrm:) (<> rule ruleSvm:)) 
              (error (append "gsm.setUserGrammarWFFs: expected either ruleReg, ruleMdl, ruleMvl, ruleFrm, or ruleSvm here [" wffString "]"))
              ) ; end if
          (if (not (isVector genome)) (error (append "gsm.setUserGrammarWFFs: expected vector genome here [" wffString "]")))
          (if (and (= eGrammar expressionGrammarGep) (not (isConcrete wffPair))) (error (append "gsm.setUserGrammarWFFs: expected a concrete WFF here [" wffString "]")))
          (if (> (length wffString) myWFFLengthLimit) (return false))
          (setq wffSource (evalRule wff))
          (if (> (length wffSource) myWFFLengthLimit) (goto SkipThisWFF:))
          (if (= wffSource "regress();") (goto SkipThisWFF:))
          (setq Lambda (compileEstimator wffSource))
          (if (not (isLambda Lambda)) (begin (writeln "gsm.setUserGrammarWFFs: compile failure warning on [" wffSource "]") (goto SkipThisWFF:)))
          (setq myUserGrammarWFFs[(length myUserGrammarWFFs)] wffString)
          SkipThisWFF::
          ) ; end wff vector loop
      true) ; end setUserGrammarWFFs
   ;; Set user defined javaScript source code WFFs for the current training run.
   ;; Note: userWFFs may be either a Vector of wffs or a single wff.
   (defun setUserJavaScriptWFFs(userWFFs)
       regs:(n N)
       vars:(wffVector wff wffPair wffString wffSource)
       vars:(rule genome Lambda errMsg)
       ;; Convert userWFFs argument into a vector of wffs.
       (if (isVector userWFFs) (setq wffVector userWFFs) (setq wffVector (new Vector: Object: 1 userWFFs)))
       ;; Clear all user defined grammar WFFs.
       (setq myUserJavaScriptWFFs (new Vector: Object:))
       (setq N (length wffVector))
       (loop for n from 0 until N do
          (setq wffSource wffVector[n])
          (if (= wffSource #void) (goto SkipThisWFF:))
          (setq wffString (setq wff "(JavaScriptWFF #())"))
          (setq wffPair (listWff wff))
          (setq rule wffPair[0]) 
          (setq genome wffPair[1])
          (if (not (isVector genome)) (error (append "gsm.setUserJavaScriptWFFs: expected vector genome here [" wffString "]")))
          (if (<> eGrammar expressionGrammarGso) (error (append "gsm.setUserJavaScriptWFFs: expected the GSO grammar here [" eGrammar "]")))
          (setq Lambda (compileEstimator wffSource))
          (if (not (isLambda Lambda)) (begin (writeln (setq errMsg (append "gsm.setUserJavaScriptWFFs: compile failure warning on [" wffSource "]"))) (error errMsg)))
          (setq myUserJavaScriptWFFs[(length myUserJavaScriptWFFs)] wffSource)
          SkipThisWFF::
          ) ; end wff vector loop
      true) ; end setUserJavaScriptWFFs
   ;; Perform a series of random modal, logged self tests of this learning machine.
   (defun randomModalLogTest(logFileName Integer:Rp Integer:Ms Integer:Gs Number:Noise ...)
       regs:(n N)
       vars:(logTable logRecord colNames Number:Seed)
       (setq colNames (new Vector: Object:	10 TestSeed: Version: TrainGens: TrainNoise: TrainTime: TrainErr: TestErr: TestClass: Champion: Model:))
       (if (>= (argCount) 6) (setq Seed (number (argFetch 5))) (setq Seed (floor (* 100000000.0 (fraction (now))))))
       (setq logTable (memoryCursor logTable: colNames))
       (setq N Rp)
       (loop for n from 0 until Rp do
          (setOptions regressGSOALPS: Noise true)
          (writeln "Starting random test with seed = [" Seed "]")
          (setq logRecord (selfTest randomModal: 10000 Ms Gs .10 (/ Seed 10000.0)))
          (if (and (isStructure logRecord) (> logRecord.TrainGens -1))
              (begin
                 (setq logRecord.TestSeed (integer Seed))
                 (logTable.writeLast logRecord)
                 (logTable.exportTab logFileName)
                 (getEstimatorChampions true)
              )) ; end if
          (+= Seed 1)
          ) ; end logged testing loop
      true) ; end randomLogTest
   ;; Perform a series of random root, logged self tests of this learning machine.
   (defun randomRootLogTest(logFileName Integer:Rp Integer:Ms Integer:Gs Number:Noise ...)
       regs:(n N)
       vars:(logTable logRecord colNames Number:Seed)
       (setq colNames (new Vector: Object:	10 TestSeed: Version: TrainGens: TrainNoise: TrainTime: TrainErr: TestErr: TestClass: Champion: Model:))
       (if (>= (argCount) 6) (setq Seed (number (argFetch 5))) (setq Seed (floor (* 100000000.0 (fraction (now))))))
       (setq logTable (memoryCursor logTable: colNames))
       (setq N Rp)
       (loop for n from 0 until Rp do
          (setOptions regressGSOALPS: Noise true)
          (writeln "Starting random test with seed = [" Seed "]")
          (setq logRecord (selfTest randomRoot: 10000 Ms Gs .10 (/ Seed 10000.0)))
          (if (and (isStructure logRecord) (> logRecord.TrainGens -1))
              (begin
                 (setq logRecord.TestSeed (integer Seed))
                 (logTable.writeLast logRecord)
                 (logTable.exportTab logFileName)
                 (getEstimatorChampions true)
              )) ; end if
          (+= Seed 1)
          ) ; end logged testing loop
       true) ; end randomLogTest
   ;; Perform a user specified model, logged self test of this learning machine.
   (defun selfLogTest(logFileName Integer:Ms Integer:Gs Number:Noise modelSource)
       regs:(n N)
       vars:(logTable logRecord colNames Number:Seed)
       (setq colNames (new Vector: Object:	10 TestSeed: Version: TrainGens: TrainNoise: TrainTime: TrainErr: TestErr: TestClass: Champion: Model:))
       (setq logTable (memoryCursor logTable: colNames))
       (setOptions regressGSOALPS: Noise true)
       (writeln "Starting user specified model test with model y = " (mid modelSource  7 100000))
       (setq logRecord (selfTest userModel: 10000 Ms Gs .10 mySeedDefault modelSource))
       (if (and (isStructure logRecord) (> logRecord.TrainGens -1))
           (begin
              (setq logRecord.TestSeed (integer Seed))
              (logTable.writeLast logRecord)
              (logTable.exportTab logFileName)
           )) ; end if
       true) ; end randomLogTest
   ;; Perform a series of diagnostic self tests of this learning machine.
   (defun selfTest(Symbol:Test Integer:Ns Integer:Ms Integer:Gs Number:Ss ...)
       regs:(B i I k m M mstart Mp1 mm1 mm MM n N nn NX)
       regs:(Number:sortScore Number:diffScore Number:diffRange Number:diffLow)
       regs:(Number:y Number:ey Number:score Number:sortScore Number:oldY Number:errPct Number:trainErrPct Number:testErrPct Number:err  Number:avgY Number:avgDevY Number:avgFactor)
       vars:(Lambda XT Rf SeedaHistory eHistory dHistory yHistory (Integer:minTN 100) Seed
             NumVector:C NumVector:x X NumVector:Y NumVector:EY IntVector:sortedY IntVector:sortedEY
             Number:startTime Number:endTime Number:startTimeT Number:endTimeT
             (maxFormulaDisplayLen 800) logRecord
			 model modelSource modelString modelLambda aHistory
             ) ; end temporary variables
       (clear)
       (if (>= (argCount) 6) then (setq Seed (number (argFetch 5))) else (setq Seed mySeedDefault))
       (if (>= (argCount) 7) then (setq modelSource (string (argFetch 6))) else (setq modelSource "regress(x0);"))
       (writeln ";; *************************************************************************************************************")
       (writeln ";; (gsm.setOptions " myOptionSetting ": " (text myRandomError "##%") " " myVerboseSW " " mySvmKernelID ":)(gsm.selfTest " Test ": " Ns " " Ms " " Gs " " Ss")")
       (writeln ";; *************************************************************************************************************")
	   (setq myBest #void)
       ;; Always make sure the test data is created using the same nil seed.
       ;; Note: We may want to vary the random seeds for finding solutions,
       ;;       but we always want to be finding solutions to the same problem.
       ;;       Therefore we always generate the training data with a fixed seed.    
       (setRandomSeed 0.0)      
       ;; Select the requested test case
       ;; Test Case userModel 
       (if (= Test userModel:)
           (begin
		       (writeln _eol "Starting test case: user specified model training")
		       (setq M Ms)
               (setq mstart 0)
               (setq Mp1 (addi M mstart))
               (setRandomSeed Seed)      
               (setq model (compileEstimator modelSource))
               (if (not (isLambda model)) (goto Last:))
               (setq model.WFF modelSource)
               (setq model.A 0.0)
               (setq model.B 1.0)
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
               (setq nn 0)
			   (loop for n from 0 until N do
			      (setq X[nn] (setq x (new Vector: Number: Mp1))) 
			      (loop for m from mstart until Mp1 do
			        (setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
			         ) ; end M loop
	              ;; Generate dependent variable (y) using model previously generated.
                  (setq y (model x))
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
			      (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
			      ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
			   (loop for n from 0 until N do
			      (setq X[nn] (setq x (new Vector: Number: Mp1)))
			      (loop for m from mstart until Mp1 do
			       	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
			         ) ; end M loop
                  (setq y (model x))
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
			      (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
			      ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[userModel]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case userModel
       ;; Test Case randomRoot 
       (if (= Test randomRoot:)
           (begin
		       (writeln _eol "Starting test case: random root generated model training")
		       (setq M Ms)
               (setq mstart 0)
               (setq Mp1 (addi M mstart))
               (setRandomSeed Seed)      
               (setq model (buildTrainingModel M false))
               (if (not (isLambda model)) (goto Last:))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
               (setq nn 0)
			   (loop for n from 0 until N do
			      (setq X[nn] (setq x (new Vector: Number: Mp1)))
			      (loop for m from mstart until Mp1 do
			        (setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
			         ) ; end M loop
	              ;; Generate dependent variable (y) using model previously generated.
                  (setq y (model x))
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
			      (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
			      ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
			   (loop for n from 0 until N do
			      (setq X[nn] (setq x (new Vector: Number: Mp1)))
			      (loop for m from mstart until Mp1 do
			       	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
			         ) ; end M loop
                  (setq y (model x))
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
			      (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
			      ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[randomRoot]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case randomRoot
       ;; Test Case randomModal 
       (if (= Test randomModal:)
           (begin
		       (writeln _eol "Starting test case: random modal generated model training")
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
               (setRandomSeed Seed)      
               (setq model (buildTrainingModel M true))
               (if (not (isLambda model)) (goto Last:))
               (setq modelSource model.WFF)
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
               (setq nn 0)
			   (loop for n from 0 until N do
			      (setq X[nn] (setq x (new Vector: Number: Mp1)))
			      (loop for m from mstart until Mp1 do
			       	 (setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
			         ) ; end M loop
	              ;; Generate dependent variable (y) using model previously generated.
                  (setq y (model x)) 
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
			      (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
			      ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		          (setq X[nn] (setq x (new Vector: Number: Mp1)))
		          (loop for m from mstart until Mp1 do
		           	 (setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		             ) ; end M loop
                  (setq y (model x))
                  (if (>= y BIGPOSNUM) (begin (setq Lambda #void) (goto Last:)))
                  (if (<= y BIGNEGNUM) (begin (setq Lambda #void) (goto Last:)))
		          (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                  (setCdr x y)
                  (++ nn)
		          ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[randomModal]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case randomModal
       ;; Test Case crossCorrelation 
       (if (= Test crossCorrelation:)
           (begin
		       (writeln _eol "Starting test case: crossCorrelation")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] -9.16))
	                ((= m 1) (setq C[m] -19.56))
	                ((= m 2) (setq C[m] 21.87))
	                ((= m 3) (setq C[m] -17.48))
	                ((= m 4) (setq C[m] 38.81))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop
		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from 0 until Mp1 do
                  (cond 
	                ((= m 0) (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")")))
	                ((= m 1) (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")")))
	                (else (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName (- m 2)) "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) ")")))
                    ) ; end cond
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[crossCorrelation]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")
         )) ; end Test Case crossCorrelation
       ;; Test Case squareRoot 
       (if (= Test squareRoot:)
           (begin
		       (writeln _eol "Starting test case: squareRoot")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Mutation and Crossover using Abstract Expression Grammars" GEECO Proceedings 2009
	                ((= m 0) (setq C[m] 1.23))
	                ((= m 1) (setq C[m] -9.16))
	                ((= m 2) (setq C[m] 11.27))
	                ((= m 3) (setq C[m] 7.42))
	                ((= m 4) (setq C[m] 8.21))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop
		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from 0 until Mp1 do
                  (cond 
	                ((= m 0) (setq modelSource (append modelSource " + (" C[m]  "*sqrt(" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "))")))
	                ((= m 1) (setq modelSource (append modelSource " + (" C[m]  "*sqrt(" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "))")))
	                (else (setq modelSource (append modelSource " + (" C[m]  "*sqrt(" (gsm.eGrammar.ruleName (- m 2)) "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) "))")))
                    ) ; end cond
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[squareRoot]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")
         )) ; end Test Case squareRoot
       ;; Test Case trigonometric 
       (if (= Test trigonometric:)
           (begin
		       (writeln _eol "Starting test case: trigonometric")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond
	                ((= m 0) (setq C[m] -9.16))
	                ((= m 1) (setq C[m] 22.19))
	                ((= m 2) (setq C[m] 1.07))
	                ((= m 3) (setq C[m] -17.48))
	                ((= m 4) (setq C[m] 18.81))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop
		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from 0 until Mp1 do
                  (cond 
	                ((= m 0) (setq modelSource (append modelSource " + cos(" C[m] "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")")))
	                ((= m 1) (setq modelSource (append modelSource " + sin(" C[m] "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")")))
	                ((= (modi m 2) 0) (setq modelSource (append modelSource " + cos(" C[m] "*" (gsm.eGrammar.ruleName (- m 2)) "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) ")")))
	                (else (setq modelSource (append modelSource " + sin(" C[m] "*" (gsm.eGrammar.ruleName (- m 2)) "*" (gsm.eGrammar.ruleName (- m 1)) "*" (gsm.eGrammar.ruleName m) ")")))
                    ) ; end cond
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[trigonometric]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")
         )) ; end Test Case trigonometric
       ;; Test Case cubicRegression 
       (if (= Test cubicRegression:)
           (begin
		       (writeln _eol "Starting test case: cubicRegression")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")"))
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)

		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest)
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[cubicRegression]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case cubicRegression
       ;; Test Case hyperTangent 
       (if (= Test hyperTangent:)
           (begin
		       (writeln _eol "Starting test case: hyperTangent")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (setq modelSource (append modelSource " + (" C[m]  "*tanh(" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) "))"))
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[hyperTangent]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case hyperTangent
       ;; Test Case elipsoid 
       (if (= Test elipsoid:)
           (begin
		       (writeln _eol "Starting test case: elipsoid")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 0.0))
	                ((= m 1) (setq C[m] 1.0))
	                ((= m 2) (setq C[m] 2.0))
	                ((= m 3) (setq C[m] 3.0))
	                ((= m 4) (setq C[m] 4.0))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (setq modelSource (append modelSource " + (" C[m]  "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m) ")"))
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[elipsoid]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case elipsoid
       ;; Test Case hiddenModel 
       (if (= Test hiddenModel:)
           (begin
		       (writeln _eol "Starting test case: hiddenModel")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop
               (setq nn 0)

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (if (= (divi Mp1 2) m) (setq modelSource (append modelSource " + (" C[m] "*sin(" (gsm.eGrammar.ruleName m) "))")))
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[hiddenModel]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case hiddenModel
       ;; Test Case linearRegression 
       (if (= Test linearRegression:)
           (begin
		       (writeln _eol "Starting test case: linearRegression")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) ")"))
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))
		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[linearRegression]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case linearRegression
       ;; Test Case mixedModels
       (if (= Test mixedModels:)
           (begin
		       (writeln _eol "Starting test case: mixedModels")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource "model(")
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 0.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; log model
                  (setq modelSource (append modelSource " + (" C[m] "*log(.000001+abs(" (gsm.eGrammar.ruleName m) ")))"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 1.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; square model
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m)")"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 2.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; sine model
                  (setq modelSource (append modelSource " + (" C[m] "*sin(" (gsm.eGrammar.ruleName m) "))"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 3.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; linear model
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) ")"))
		          ) ; end C loop
		       (setq modelSource (append modelSource "});"))
               (writeln modelSource)
			   (setq myModelLambda (compileEstimator modelSource))

		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[mixedModel]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case mixedModel
       ;; Test Case ratioRegression 
       (if (= Test ratioRegression:)
           (begin
		       (writeln _eol "Starting test case: ratioRegression")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 1.57))
	                ((= m 1) (setq C[m] -39.34))
	                ((= m 2) (setq C[m] 2.13))
	                ((= m 3) (setq C[m] 46.59))
	                ((= m 4) (setq C[m] 11.54))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource "model(")
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 0.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; linear model
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) ")"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 1.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; square model
                  (setq modelSource (append modelSource " + (" C[m] "*" (gsm.eGrammar.ruleName m) "*" (gsm.eGrammar.ruleName m)")"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 2.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; sine model
                  (setq modelSource (append modelSource " + (" C[m] "*sin(" (gsm.eGrammar.ruleName m) "))"))
		          ) ; end C loop
			   (setq modelSource (append modelSource "} else "))
		       (setq modelSource (append modelSource " if (abs(ninteger(" (gsm.eGrammar.ruleName 0) " % 4.0)) == 3.0) {" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  ;; log model
                  (setq modelSource (append modelSource " + (" C[m] "*log(.000001+abs(" (gsm.eGrammar.ruleName m) ")))"))
		          ) ; end C loop
		       (setq modelSource (append modelSource "});"))
               (writeln modelSource)
			   (setq myModelLambda (compileEstimator modelSource))

		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[ratioRegression]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case ratioRegression
       ;; Test Case cyclicSeries 
       (if (= Test cyclicSeries:)
           (begin
		       (writeln _eol "Starting test case: cyclicSeries")
               (setRandomSeed Seed)      
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: Mp1))
		       (loop for m from 0 until Mp1 do
                 (cond  ;; Should match test case published in "Genetic Programming Theory and Practive V" Springer Verlag 2008
	                ((= m 0) (setq C[m] 14.65))
	                ((= m 1) (setq C[m] -6.73))
	                ((= m 2) (setq C[m] -18.35))
	                ((= m 3) (setq C[m] -40.32))
	                ((= m 4) (setq C[m] -4.43))
	                (else (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0)))
                    ) ; end cond
		          ) ; end C loop

		       ;; Build training model WFF.
		       (setq modelSource (append "model(" (string C[0])))
		       (loop for m from mstart until Mp1 do
                  (cond
                   ((= (modi m 3) 0) (setq modelSource (append modelSource " + (" C[m] "*sin(" (gsm.eGrammar.ruleName m) "))")))
                   ((= (modi m 3) 1) (setq modelSource (append modelSource " + (" C[m] "*cos(" (gsm.eGrammar.ruleName m) "))")))
                   ((= (modi m 3) 2) (setq modelSource (append modelSource " + (" C[m] "*tan(" (gsm.eGrammar.ruleName m) "))")))
                   (else (error "gsm.selfTest: invalid cyclicSeries condition during model building"))
                   ) ; end cond
		          ) ; end C loop
		       (setq modelSource (append modelSource ");"))
			   (setq myModelLambda (compileEstimator modelSource))

		       ;; Build training data.
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Train against the model and show final scores on the training data.
               (setq modelString modelSource)
               (setq modelString (mid modelString 7 10000000)) 
		       (setq modelString (append "Building training model data as: y = " modelString))
		       (writeln modelString)
               (if (<> myRandomError 0.0) (writeln "Additionally, we add random error as: y = (y * " (- 1.0 (* .50 myRandomError)) ") + (random " myRandomError ");")) 
               (setq startTimeT (getTickCount 0))
		       (setq Lambda (gsm X Y Gs Ss Seed))
               (setq endTimeT (getTickCount startTimeT))
               (if (not (isLambda Lambda)) (goto SelfTestFailed:))
		       (writeln "") 
		       (writeln "Final results of training")
		       (writeln "gsm: N = [" Ns "], M = [" Mp1 "], LinearNLSE = [" (if (isLambda myBestLinear) (text myBestLinear.NLSE "#0.00") "NA") "], Generations = [" myGc "], WFFs = [" (length myWFFs)  "]") 
               (writeln "gsm.myBest, NLSE=[" (text Lambda.NLSE "#0.00") "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
               (writeln "gsm.myBest, isConcrete=[" (gsm.isConcrete gsm.myBest) "], WFF = " (trunc (gsm.evalRule (gsm.concreteWFF gsm.myBest)) maxFormulaDisplayLen))

               (if (= myVerboseSW true)
                   (begin
		             
                     ;; Show the champions from each island population.
		             (writeln "") 
		             (writeln "Show the champions from each island population")
                     (setq M (length gsm.myPopulationIslands))
                     (loop for m from 0 until M do
                       (writeln "Champions of Island [" m "], RootWFFCount=[" myIslands[m] "]...")
                       (setq N (length gsm.myPopulationIslands[m])) 
                       (loop for n from 0 until N do
                          (setq Lambda gsm.myPopulationIslands[m][n])
		                  (if (<> Lambda #void) (writeln "gsm.myPopulationIslands[" m "][" n "], NLSE=[" Lambda.NLSE "], lengthWFF=[" (length Lambda.WFF) "], WFF = " (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))) 
                          ) ; end population loop
                       ) ; end island loop

                   )) ; end if 

		       ;; Run on the training data.
		       (writeln "")
               (setq Lambda gsm.myBest) 
		       (writeln "Show final results on training data with reported NLSE=[" (text Lambda.NLSE "#0.00") "]")
               (setq EY (scoreTCEandNLSE Lambda X Y false))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on training data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

		       ;; Build the test data.
               (setRandomSeed (* mySeed (pi)))
		       (setq M Ms)
               (setq mstart 0) 
               (setq Mp1 (addi M mstart))
		       (setq N Ns)
		       (setq X (new Vector: Object: (muli N)))
		       (setq Y (new Vector: Number: (muli N)))
               (setq nn 0)
		       (loop for n from 0 until N do
		         (setq X[nn] (setq x (new Vector: Number: Mp1)))
		         (loop for m from mstart until Mp1 do
		          	(setq x[m] (- (gsm.myRandomFunction 100.0) 50.0))
		            ) ; end M loop
                 (setq y (myModelLambda x))
		         (setq Y[nn] (setq y (+ (* y (- 1.0 (* .50 myRandomError))) (* y (gsm.myRandomFunction myRandomError)))))
                 (setCdr x y)
                 (++ nn)
		         ) ; end N loop

		       ;; Run on the test data.
		       (writeln "") 
		       (writeln "Show final results on testing data:")
               (setq EY (scoreTCEandNLSE Lambda X Y myVerboseSW))
               (setq NX (length Y))
               (setq yHistory (new Vector: Number: 10))
               (setq eHistory (new Vector: Number: 10))
               (setq aHistory (new Vector: Number: 10))
               (setq dHistory (new Vector: Number: 5))
               (setq MM (integer (max 1 (/ NX 10))))
               (setq sortedY (|Gv:sort| Y < true))
               (setq sortedEY (|Gv:sort| EY < true))
               (loop for n from 0 until NX do
                  (setq k sortedEY[n])
                  (setq ey EY[k])
                  (setq y Y[k])
                  (setq mm (/ n MM))
                  (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                  (setq k sortedY[n])
                  (setq y Y[k])
                  (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                  ) ; end N loop
               (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
               (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
               (setq aHistory[1] (avg eHistory[1] eHistory[0]))
               (setq aHistory[8] (avg eHistory[8] eHistory[9]))
               (setq aHistory[0] eHistory[0])
               (setq aHistory[9] eHistory[9])
               (setq dHistory[4] (- aHistory[9] aHistory[0]))
               (setq dHistory[3] (- aHistory[8] aHistory[1]))
               (setq dHistory[2] (- aHistory[7] aHistory[2]))
               (setq dHistory[1] (- aHistory[6] aHistory[3]))
               (setq dHistory[0] (- aHistory[5] aHistory[4]))
		       (writeln "Actual computed error on testing data is NLSE=[" (text Lambda.NLSE "#0.00") "], TCE=[" (text Lambda.TCE "#0.00") "], RSQ=[" (text Lambda.RSQ "#0.00") "], while average Y is AvgY=[" (avg Y) "]")
		       (writeln "yHistory=[" (string yHistory true) "]")
		       (writeln "eHistory=[" (string eHistory true) "]")
		       (writeln "aHistory=[" (string aHistory true) "]")
		       (writeln "dHistory=[" (string dHistory true) "]")
		       (writeln "") 

               (writeln "gsm.selfTest[cyclicSeries]: completed in [" (text (/ endTimeT 60.0) "#0.00") "] minutes.")       
         )) ; end Test Case cyclicSeries

       ;; Fill the log record with the training and testing results.
       Last::
       (if (= myVerboseSW true) (writeln "myTotalEvaluations=[" myTotalEvaluations 
                                         "], myTotalRegressions=[" myTotalRegressions 
                                         "], myTotalParseTime=[" (/ myTotalParseTime 60.0) 
                                         "], myTotalCompileTime=[" (/ myTotalCompileTime 60.0) 
                                         "]"))       
       (if (= myVerboseSW true) (gsm.getEstimatorChampions true))

       SelfTestFailed::
       (if (and (not (isLambda myBest)) (= myVerboseSW true)) (writeln "gsm.selfTest: failed returning a void champion."))
       (setq logRecord (new Structure:	TestSeed: 	#void 
                                       	Version: 	#void
                                       	TrainGens: 	#void
                          				TrainNoise: #void
                          				TrainTime: 	#void
                          				TrainErr: 	#void
                          				TestErr: 	#void
                          				TestClass: 	#void
                          				Champion:	#void
                          				Model:	 	#void))
       (if (<> Lambda #void)
           (begin
             (setq logRecord.TestSeed (integer Seed))
             (setq logRecord.Version myVersion)
             (setq logRecord.TrainGens myGc)
             (setq logRecord.TrainNoise (text myRandomError "##.##%"))
             (setq logRecord.TrainTime (text (/ endTimeT 60.0) "##.##"))
             (setq logRecord.TrainErr (text trainErrPct "##.##%"))
             (setq logRecord.TestErr (text testErrPct "##.##%"))
             (setq logRecord.TestClass (text diffScore "##.##%"))
             (setq logRecord.Champion (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
             (setq logRecord.Model modelString)
             ) else
           (begin
             (setq logRecord.TestSeed (integer Seed))
             (setq logRecord.Version myVersion)
             (setq logRecord.TrainGens -1)
             (setq logRecord.TrainNoise (text myRandomError "##.##%"))
             (setq logRecord.TrainTime -1)
             (setq logRecord.TrainErr -1)
             (setq logRecord.TestErr -1)
             (setq logRecord.TestClass -1)
             (setq logRecord.Champion (trunc (gsm.evalRule Lambda.WFF) maxFormulaDisplayLen))
             (setq logRecord.Model modelString)
             )) ; end if
       logRecord) ; end selfTest

  	;; *******************************************************************************
  	;; Begin Main Logic 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1)  (Integer:VerboseSample 1))
  	vars:(result Lambda wff newWff wffString rule Number:seed)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore Number:seec)

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (clear)
    (gc compact:)
    (if (= myTrainingScript #void) (setOptions default: 00% false))
    (if (>= (argCount) 5) then (setq seed (number (argFetch 4))) else (setq seed mySeedDefault))

    ;; Make sure the necessary dependencies are satisfied.
    (if (or (= browseLib #void) (= math #void) (= rulesLib #void)) (error "gem: missing dependencies on browseLib, math, or rulesLib")) 

    ;; Run the training script
	(setq myBest (myTrainingScript X Y G S seed))

    ;; Return the best WFF seen so far.
    myBest) ; end gsm

















































































































































;;**EXPORTKEY**:gsm.%%%validate
;; ********************************************************************
;; summary:  Gsm User defined macros
;;
;; 			 Compile time child Lambdas for the selector compiler.
;; 			 These child Lambdas support the selector compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.selector:%DEFINITION|.
;;
;; ********************************************************************

;; *************************************
;; Number Validation Macro
;; *************************************
(defmacro gsm:validate(x) (list (symbol "if") 
                            (list |<|: 'BIGPOSNUM x) 
                                'BIGPOSNUM
                                (list (symbol "if") 
                                      (list |>|: 'BIGNEGNUM x) 
                                           'BIGNEGNUM
			                               (list (symbol "if")
			                                     (list and: 
			                                           (list |<|: 'LOWNEGNUM x) 
			                                           (list |>|: 'LOWPOSNUM x)) 
			                                           0.0 
			                                           x)))
         ) ; end validate






































































































































































;;**EXPORTKEY**:gsm.estimator
(defriend gsm:estimator(_input)
;; ********************************************************************
;; summary:  The gsm.estimator compiler generated from gsm:estimator:DEFINITION.
;; Summary:  This Lambda implements the gsm.estimator compiler as defined
;;           in the gsm:estimator:DEFINITION compiler definition file.
;;           Much code has been marked with a boxed comment lines for
;;           ease of human understanding.
;; Note:     This code was machine generated by ParseLib.
;; Parms:    _input   The gsm.estimator language source string
;; return:   _result  The Lambda resulting from compiling the _input source.
;; Modification history:
;; TM Jan 15 99 Added Console Error suppression (see _consoleError, _makeError and _lastError)
;; TM Jan 20 99 Added _verboseLexIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSynIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSemIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Changes _verbosexxxIn so that you supply a stop count
;;              example: (setq gsm:estimator._verboseSynIn.MYRULE 2})  ; error after 2nd pass
;;                       (setq gsm:estimator._verboseSynIn.MYRULE 0})  ; verbose on every pass
;;                       (setq gsm:estimator._verboseSynIn.MYRULE: -1}) ; not verbose
;; TM Nov 13 01 Added _verboseLex   - flag forcing _verbose only in Lex
;;                    _verboseSyn   - flag forcing _verbose only in Syntax
;;                    _verboseSem   - flag forcing _verbose only in Semantic
;; TM Nov 19 10 Added new error handling that automatically turns verbose on near the 
;;              parse error. This makes most of the other error handling in the tool 
;;              obsolete except when you want to see a full trace of all rule attempts from
;;              the begining of one of the passes.
;; ********************************************************************
   pvars:(_changeCount             ;; Number of rule based substitutions
          _explainOnOff            ;; Switch for saving semantic explanation steps in the _explanation variable 
          _explanation             ;; Variable for saving semantic explanation steps (see _explainOnOff) 
          _indent                  ;; Indent for displaying each explanation step on the console
          _io                      ;; Current parse tree index object
          _ip                      ;; Current parse tree index pointer
          (_maxPasses 200)         ;; Maximum number of passes before issuing error (singlePass = false)
          (morphFail |*failure*|:) ;; Morph rule failure RHS value
          _name                    ;; Name of the current compiler definition
          _parseLen                ;; Current parse tree length
          _parseTree               ;; Current head of the parse tree during recognition
          _passCount               ;; Current number of passes already executed by apply
          _result                  ;; Final result of parsing the submitted compiler definition rules 
          _semanticRule            ;; Current semantic rule to be applied by _applyRule 
          _semanticStack           ;; Current semantic stack for use by _applyRule 
          _semanticVerbose         ;; Switch for displaying each semantic explanation step on the console 
          _showTokens              ;; Show only the token list resulting from the lexical analyzer
          _syntaxFeatures          ;; Syntax features supplied in the compiler definition
          _tkIN                    ;; Place holder for the input source string (see $IN) 
          _tkLIST                  ;; The output token list from the lexer rules.
          _tkOUT                   ;; Output a feature based token to the token list.
          tokenDirectory           ;; Lexicon of token and their attributes
          _userFunctions           ;; User functions source code supplied in the compiler definition
          _verbose                 ;; Switch for displaying each explanation step on the console
          _verboseHold            ;; Switch for displaying each explanation step on the console
          _verboseLex			   ;; Switch for displaying only lexical steps
          _verboseSyn              ;; Switch for displaying only syntax steps
          _verboseSem              ;; Switch for displaying only sematic steps
          _verboseLexIn            ;; Structure of lex parse routines in which we should force _verbose true
          _verboseSynIn            ;; Structure of syntax parse routines in which we should force _verbose true
          _verboseSemIn            ;; Structure of semantic parse routines in which we should force _verbose true
          _verboseLexCount         ;; Structure of Counts used by _verboseLexCount (not set by user!)
          _verboseSynCount         ;; Structure of Counts used by _verboseSynCount (not set by user!)
          _verboseSemCount         ;; Structure of Counts used by _verboseSemCount (not set by user!)
          _lastError               ;; Error encountered during parse 
          
          _ruleCount               ;; Number of rules tried 
          _ruleCountLex
          _ruleCountSyn
          _ruleCountSem
          _failurePass
          _failureIn
          _verboseState
          (_verboseTrigger -1)     ;; If more than zero this indicates at what _ruleCount _verbose should be turned on
     
          _incCount				   ;; increment number of rules tried and test for error condition
          _startLog
           
          (_consoleErrors true)    ;; Error messaging flag is false no messages will be printed to console
          ;; Methods list 
          _findLineNum             ;; find the line the error ocurred in
          _makeError               ;; _error function wrapper that creates pretty errors and sets _lastError values
          _error                   ;; error function wrapper allowing silent or console messaging
          _apply                   ;; Apply the specified semantic rule to the result
          _applyRule               ;; Apply the current semantic rule to a sub list
          appendList               ;; Append multiple arguments into a list
          defaultLexer             ;; Default lexical analyzer for recognizing input symbols
          defaultTokenRule         ;; Modified default rule for adding attributes to a parsed token
          _eofToken                ;; Return true if we are at the end of the parse tree
          _errorHandler            ;; Handle any errors which may occur during compilation
          _getToken                ;; Get the next attributed token in the parse tree
          _Initialize              ;; Initialization routine for setting token dicrectory, etc.
          _initializeSW            ;; Initialization switch (set true after first initialization).
          initRule                 ;; User defined initialization routine for setting token dicrectory, etc.
          _lastIp                  ;; Move the current parse tree index to the previous position
          _lenIp                   ;; Return the length of the current parse tree
          _nextIp                  ;; Move the current parse tree index to the next position
          outputRule               ;; Default rule for returning the final output from the compiler
          _popIp                   ;; Pop the current parse tree index up one level to the next position
          preLexRule               ;; Default rule for any pre-lexical compiler operations.
          _pushIp                  ;; Push the current parse tree index down one level to the next position
          _setLexicalFeature       ;; Assign a set of letters to the specified lexical feature
          _setSyntaxFeature        ;; Set a whole class of syntax tokens with the specified attribute
          _setWordFeatures         ;; Set or enhance a whole word with the specified features and feature values
          _showInput               ;; Show a fragment of the input source string in lexical verbose mode
          _showSource              ;; Show a fragment of the input source string in syntax verbose mode
          startRule                ;; Default rule for starting the compiler
          _writeRule               ;; Display the results of a rule firing in verbose mode
          $IN                      ;; Place holder for the input source string (see _tkIN)
          $LIST                    ;; The output token list from the lexer rules.
          $OUT                     ;; Output a feature based token to the token list.
          $ASIS                    ;; Output a feature based token to the token list (as is).












          ;; Variables to hold lexical feature bit maps
          _LF_Digit
          _LF_Alpha
          _LF_AlphaNum
          _LF_NameChar
          _LF_Letter
          _LF_NameStart
          _LF_Special
          _LF_DQuote
          _LF_NotDQuote
          _LF_Quote
          _LF_NotQuote
          _LF_Whitespace
          _LF_Eol
          _LF_NotEol
          _LF_Period
          _LF_Exponent
          _LF_Sign
          ;; Functions to implement Lexical Rules
          _LEXRULE_MAIN
          ;; Functions to implement Syntax Rules
          _SYNRULE_ARGLIST
          _SYNRULE_CFCALL
          _SYNRULE_CHILD
          _SYNRULE_CLASS
          _SYNRULE_CUT
          _SYNRULE_EXPRESSION
          _SYNRULE_FIELDLIST
          _SYNRULE_FILTER
          _SYNRULE_FRIEND
          _SYNRULE_FSTATEMENT
          _SYNRULE_FSTMTLIST
          _SYNRULE_FUNCTION
          _SYNRULE_MAIN
          _SYNRULE_METHOD
          _SYNRULE_NAME
          _SYNRULE_NUMLIST
          _SYNRULE_OPRLIST
          _SYNRULE_ORPHAN
          _SYNRULE_PARMLIST
          _SYNRULE_PHRASE
          _SYNRULE_QUALIFY
          _SYNRULE_REFLIST
          _SYNRULE_SCORE
          _SYNRULE_SEXPRESSION
          _SYNRULE_SSTATEMENT
          _SYNRULE_STATEMENT
          _SYNRULE_STMTLIST
          _SYNRULE_TERM
          _SYNRULE_VAR
          _SYNRULE_WEIGHTLIST
          ;; Functions to implement Semantic Rules
          _SEMRULE_LAMBDA
          _SEMRULE_LET
          _SEMRULE_LETOMIT
          _SEMRULE_LETTRUNCATE
          _SEMRULE_MAIN
          _SEMRULE_OMIT
          _SEMRULE_REFOMIT
          _SEMRULE_REFTRUNCATE
          _SEMRULE_TRUNCATE
         ) ;; end of persistent variables
   vars:(i verboseHold outString outExplain)
   ;; ***************************************************
   ;; Define the child Lambdas which belong to this parent
   ;; ***************************************************

   ;;*********************************************************************
   ;; 
   ;;*********************************************************************
   (defun _incCount()
   	(setq _ruleCount (+ _ruleCount 1)) 
   	(if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog))
   	
   	true)

   ;;*********************************************************************
   ;; 
   ;;*********************************************************************
   (defun _startLog()
   		vars:(i len)
		(setq _verbose true)
		(writeln "*********Lexed Tokens with Features Near Failure*********")
		(setq len (min (+ _ip 50) (length _parseTree)))
		(loop for i from _ip until len do
			(writeln "[" i "] " _parseTree[i])
		) ; end loop
		(writeln "*********Source near Failure***********")
		(writeln "Charpos=" _parseTree[_ip].Charpos)
		(writeln (substring $IN _parseTree[_ip].Charpos (+ _parseTree[_ip].Charpos 1000)))
		(writeln "*********Rules starting near Failure*****")
   			
   true)


   ;;*********************************************************************
   ;; Centralized print routine for logging errors to console. 
   ;;*********************************************************************
   (defun _logLine(lineArg show)
   		vars:(lineText)
   		(setq lineText (new Vector: byte: 30000))
   		(cond
   			((= show source:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg (_showSource 20))))
   			((= show input:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg (_showInput 20))))
   			((= show none:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg)))
		);cond   			
 		(writeln lineText)  
   true)

   ;;*********************************************************************
   ;; Finds the line number given a character position
   ;;*********************************************************************
   (defun _findLineNum(pos)
      vars: (i j l)
      (setq j 0)
      (setq l (length $IN))
      (if (< pos l) (setq l pos))
      (loop for i from 0 until l do
         (if (= $IN[i] 10) (setq j (iadd j 1)))
         ); end loop
      j; return number of linefeeds found
      ); end findLineNum

   ;;*********************************************************************
   ;; Construct Error
   ;;*********************************************************************
   (defun _makeError(errorKey pos desc)
      vars: (i j line1 line2 line3 line4 eof nontabs tabs temp result)

      (setq eof (length $IN))
      (setq nontabs 0)
      (setq tabs 0)


      ;find start of error line - line2
      (setq i pos)
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line2 (iadd i 1)) (setq line2 0))

      ;Count number of tabs and non-tabs up to error in error line
      (setq j line2)
      (while (< j pos) (if (= $IN[j] 9) (setq tabs (iadd tabs 1)) (setq nontabs (iadd nontabs 1))) (setq j (iadd j 1)))

      ;find start of line1
      (while (and (>= i 0) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (isub i 1))) 
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line1 (iadd i 1)) (setq line1 0))

      ;find start of line 3
      (setq i pos) ; reset to error position
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
       (setq line3 i)

      ;find start of line 4
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
      (setq line4 i)

      ;Create error window
      (setq temp (append 
           (if (> (- line2 line1) 0) (substring $IN line1 (isub line2 1)) "") ;line 1
           (if (> (- line3 line2) 0) (substring $IN line2 (isub line3 1)) "") ;line 2 
           (if (= line3 eof) _eol ""); add an _eol if line2 is the only line!
           (rept " " nontabs) (rept (string (char 9)) tabs) "^error" _eol 
           (if (> line4 line3) (substring $IN line3 (isub line4 1)) "")
           ))

      ; Normalize tabs to 4 chars each
      (setq j (length temp))
      (setq result "")
      (loop for i from 0 until j do
         (setq result (append result (if (= temp[i] 9) "    " (string temp[i]))))
         ); end loop

      ;insert values into the _lastError structure
      (setq _lastError.errorKey errorKey)
      (setq _lastError.line (_findLineNum pos))
      (setq _lastError.desc desc)
      (setq _lastError.charpos pos)
      (setq _lastError.message result)

      ;(_error errorKey (append " " desc " Line:" _lastError.line " Charpos:" pos _eol _lastError.message))
      (_error (append " " desc " Line:" _lastError.line " Char:" pos _eol _lastError.message))

      ); end _makeError

   ;; _error wraps the builtin error function so that it 
   ;; is possible to disable console errors for silent
   ;; operation. The _consoleErrors variable determines
   ;; the function of _error.
   (defun _error ( ... )
      vars:(argc i e)

      (setq argc (argCount))
      (setq e (new Vector: argc))
      (loop for i from 0 until argc do
         (setq e[i] (argFetch i))
         ); end loop

       (if _consoleErrors (apply error e) (error e[0]))

      false ; we will never actually get here but put in a return anyway
      ); of defun _error

   ;; Append multiple arguments into a list.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun appendList(one two ...)
       vars:(result argc i)
       (cond 
           ((and (isPair one) (isPair two)) (setq result (append one two)))
           ((= one #void) (setq result two))
           ((and (isPair one) (= two #void)) (setq result one))
           ((isPair one) (setq result (append one (list two))))
           ((= two #void) (setq result (list one)))
           (else (setq result (list one two)))
           ) ; end cond
       (setq argc (argCount))
       (loop for i from 2 until argc do
           (setq result (appendList result (argFetch i)))
           ) ;; end loop
       result) ;; end appendList
   ;; Apply the specified semantic rule to the result.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun _apply(theRule multiplePass)
       vars:(outList outString outExplain)
       ;(if _semanticVerbose (setq outString (append "Replacing: " (string _result true) " ==> ")))
       ;(if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string _result true) " ==> "))))
       (setq outList _result)
       (setq _passCount 0)
       (setq _semanticRule theRule)
       Retry::
       (if (> _passCount _maxPasses) (_error "ParseLib_Pass" "Exceeded maximum number of apply rules."))
       (setq _changeCount 0)
       (setq outList (morph (list outList) _applyRule morphFail))
       (if (isPair outList) (setq outList (car outList)))
       (if (and (> _changeCount 0) (= multiplePass true) (isPair outList)) (goto Retry:))
       ;(if (= _semanticVerbose true) (writeln outString  (string outList true)))
       ;(if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
       (setq _result outList)
       _result) ;; end of _apply
   ;; Apply the current semantic rule to a sub list
   ;; Note: This Lambda is called by morph for every sub list
   ;;       in the larger result list. 
   (defun _applyRule(sexp)
      vars:(ret outString outExplain)
      (setq _ip -1)
      (setq _io sexp)
      (if _semanticVerbose (setq outString (append "Replacing: " (string sexp true) " ==> ")))
      (if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string sexp true) " ==> "))))
      (setq _semanticStack (new Structure: _io _ip))
      (if (<> (setq ret (_semanticRule)) morphFail)
          (begin
             (++ _changeCount)
             (if (= _semanticVerbose true) (writeln outString  (string ret true)))
             (if _explainOnOff (setq _explanation (append _explanation outExplain (string ret true) _eol)))
             (return ret)
          )) ;; end if
      morphFail) ;; end of _applyRule
   ;; Modified default rule for adding attributes to a parsed token.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun defaultTokenRule(token)
       vars:(result tokenLen tokenEnd)
       ;; Is this token a delimited constant?
       (if (isVector token) 
           (begin
              (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
              (return result)
              )) ;; end if delimited constant
       ;; Is this token an integer constant?
       (if (isInteger token) 
           (begin
              (setq result (new Structure: Value: token  Integer: true  Number: true  Constant: true))
              (return result)
              )) ;; end if integer constant
       ;; Is this token an numeric constant?
       (if (isNumber token) 
           (begin
              (setq result (new Structure: Value: token  Number: true  Constant: true))
              (return result)
              )) ;; end if numeric constant
       ;; Is this token a name token?
       (if (isCharName token) 
           (begin
              (setq result (new Structure: Value: token  Name: true  Default: true))
              ;; Add the token to the directory so we don't have to do this again.
              (setq tokenDirectory[token] result) 
              (return result)
              )) ;; end if numeric constant
       ;; Create a default attributed structure for this token
       (setq result (new Structure: Value: token Default: true))
       ;; Add the token to the directory so we don't have to do this again.
       (setq tokenDirectory[token] result) 
       result) ;; end defaultTokenRule
   ;; Return true if the we are at the end of the parse tree.
   (defun _eofToken()
       (if (>= (_nextIp) (_lenIp)) true (_lastIp))) ;; end _eofToken
   ;; Manages any errors which may occur during compilation.
   (defun _errorHandler(errMsg)
      vars:(stemp n)
      (setq stemp (string errMsg true))
      (setq n (length stemp))
      (setq stemp (right (left stemp (- n 2)) (- n 4)))
      (error stemp)) ;; end of _errorHandler
   ;; Get the next token in the current parse tree.
   (defun _getToken()
       vars:(result i io n)
       ;; Load the next token in the parse tree.
       ;(if (>= (_nextIp) (_lenIp)) (begin (setq result morphFail) (_lastIp) (return result)))
       (if (>= (_nextIp) (_lenIp)) (return morphFail))
       (if (isNumber _ip) (return _io[_ip]))
       (setq n (subi (length _ip) 1))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (setq result io[_ip[n]]) 
       result) ;; end of _getToken
   ;; Initialization routine for setting token dicrectory, etc.
   ;; Note: This Lambda is run once during the lifetime of the
   ;;       parent Lambda.
   (defun _Initialize()
       (setq _initializeSW true)
       ;; Reset the verbose mode indent.
       (setq _indent 0)
       ;; Create the token directory for the compiler definition language.
       (setq tokenDirectory (new Directory:))
       ;; Adjust the lexical analyzer for the compiler definition language.
       (defaultLexer._Initialize)












       ;; Initialization of Delimited Strings
       (defaultLexer.addStringDelimiters  String: {"} {"})
       (defaultLexer.addStringDelimiters   Symbol: {'} {'})
       (defaultLexer.addStringDelimiters   Whitespace: {/*} {*/})
       (defaultLexer.addStringDelimiters   Whitespace2: {//} _eol)
         ;; Initialization of Lexical Features
       (setq _LF_Digit (_setLexicalFeature _LF_Digit #( 1 48 57)))
       (setq _LF_Alpha (_setLexicalFeature _LF_Alpha #( 1 97 122 1 65 90)))
       (setq _LF_AlphaNum (_setLexicalFeature _LF_AlphaNum #( 1 97 122 1 65 90 1 48 57)))
       (setq _LF_NameChar (_setLexicalFeature _LF_NameChar #( 1 97 122 1 65 90 1 48 57 1 95 95)))
       (setq _LF_Letter (_setLexicalFeature _LF_Letter #( 1 97 122 1 65 90)))
       (setq _LF_NameStart (_setLexicalFeature _LF_NameStart #( 1 97 122 1 65 90 1 95 95)))
       (setq _LF_Special (_setLexicalFeature _LF_Special #( 1 60 60 1 62 62 1 61 61 1 38 38 1 37 37 1 33 33 1 94 94 1 126 126 1 43 43 1 47 47 1 42 42 1 45 45 1 124 124 1 35 35)))
       (setq _LF_DQuote (_setLexicalFeature _LF_DQuote #( 1 34 34)))
       (setq _LF_NotDQuote (_setLexicalFeature _LF_NotDQuote #( 1 0 255 0 34 34)))
       (setq _LF_Quote (_setLexicalFeature _LF_Quote #( 1 39 39)))
       (setq _LF_NotQuote (_setLexicalFeature _LF_NotQuote #( 1 0 255 0 39 39)))
       (setq _LF_Whitespace (_setLexicalFeature _LF_Whitespace #( 1 0 32)))
       (setq _LF_Eol (_setLexicalFeature _LF_Eol #( 1 10 10 1 13 13)))
       (setq _LF_NotEol (_setLexicalFeature _LF_NotEol #( 1 0 255 0 10 10 0 13 13)))
       (setq _LF_Period (_setLexicalFeature _LF_Period #( 1 46 46)))
       (setq _LF_Exponent (_setLexicalFeature _LF_Exponent #( 1 101 101 1 69 69)))
       (setq _LF_Sign (_setLexicalFeature _LF_Sign #( 1 43 43 1 45 45)))
         ;; Initialization of Syntax Features
       (_setSyntaxFeature Operator: #( |+| |-| |*| |/| |%| "&&" "||" "#") #void)
       (_setSyntaxFeature Lisp: #( |+| |-| |*| |/| |%| "&&" "||" "#") #(+ - * pdiv pmod and or pdiv ))
       (_setSyntaxFeature Charop: #( |+| |-| |*| |/| |%| "&&" "||") #(cadd csub cmul pdiv pmod and or ))
       (_setSyntaxFeature Chartyp: #( |+| |-| |*| |/| |%| "&&" "||") #(char char char char char bool bool ))
       (_setSyntaxFeature Boolop: #( |+| |-| |*| |/| |%| "&&" "||") #(badd bsub bmul pdiv pmod and or ))
       (_setSyntaxFeature Booltyp: #( |+| |-| |*| |/| |%| "&&" "||") #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |+| |-| |*| |/| |%| "&&" "||") #(iadd isub imul pdiv pmod and or ))
       (_setSyntaxFeature Inttyp: #( |+| |-| |*| |/| |%| "&&" "||") #(int int int int int bool bool ))
       (_setSyntaxFeature Floatop: #( |+| |-| |*| |/| |%| "&&" "||") #(nadd nsub nmul pdiv pmod and or ))
       (_setSyntaxFeature Floattyp: #( |+| |-| |*| |/| |%| "&&" "||") #(float float float float float bool bool ))
       (_setSyntaxFeature Operator: #( |==| |<| |<=| |>| |>=| |<>|) #void)
       (_setSyntaxFeature Lisp: #( |==| |<| |<=| |>| |>=| |<>|) #(= < <= > >= <> ))
       (_setSyntaxFeature Boolop: #( |==| |<| |<=| |>| |>=| |<>|) #(bcompareEQ bcompareLT bcompareLE bcompareGT bcompareGE bcompareNE ))
       (_setSyntaxFeature Booltyp: #( |==| |<| |<=| |>| |>=| |<>|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Charop: #( |==| |<| |<=| |>| |>=| |<>|) #(ccompareEQ ccompareLT ccompareLE ccompareGT ccompareGE ccompareNE ))
       (_setSyntaxFeature Chartyp: #( |==| |<| |<=| |>| |>=| |<>|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |==| |<| |<=| |>| |>=| |<>|) #(icompareEQ icompareLT icompareLE icompareGT icompareGE icompareNE ))
       (_setSyntaxFeature Inttyp: #( |==| |<| |<=| |>| |>=| |<>|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Floatop: #( |==| |<| |<=| |>| |>=| |<>|) #(ncompareEQ ncompareLT ncompareLE ncompareGT ncompareGE ncompareNE ))
       (_setSyntaxFeature Floattyp: #( |==| |<| |<=| |>| |>=| |<>|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature MathAssignmentOperator: #( |+=| |-=| |/=| |*=| "%=") #void)
       (_setSyntaxFeature Lisp: #( |+=| |-=| |/=| |*=| |%| |=|) #(+ - pdiv * pmod ))
       (_setSyntaxFeature Charop: #( |+=| |-=| |/=| |*=| |%| |=|) #(cadd csub cmul pdiv pmod ))
       (_setSyntaxFeature Chartyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(char char char char char ))
       (_setSyntaxFeature Boolop: #( |+=| |-=| |/=| |*=| |%| |=|) #(badd bsub bmul pdiv pmod ))
       (_setSyntaxFeature Booltyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |+=| |-=| |/=| |*=| |%| |=|) #(iadd isub imul pdiv pmod ))
       (_setSyntaxFeature Inttyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(int int int int int int ))
       (_setSyntaxFeature Floatop: #( |+=| |-=| |/=| |*=| |%| |=|) #(nadd nsub nmul pdiv pmod ))
       (_setSyntaxFeature Floattyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(float float float float float ))
       (_setSyntaxFeature AssignmentOperator: #( |=|) #void)
       (_setSyntaxFeature Lisp: #( |=|) #(setq ))
       (_setSyntaxFeature InitializeOperator: #( |=|) #void)
       (_setSyntaxFeature RelationOperator: #( |==| |<| |<=| |>| |>=| |<>|) #void)
       (_setSyntaxFeature Boolean: #( |true| |false|) #(true false ))
       (_setSyntaxFeature Term: #( |true| |false|) #void)
       (_setSyntaxFeature Increment: #( |++| |--|) #void)
       (_setSyntaxFeature Lisp: #( |++| |--|) #(+ - ))
       (_setSyntaxFeature Boolop: #( |++| |--|) #(badd bsub ))
       (_setSyntaxFeature Booltyp: #( |++| |--|) #(bool bool ))
       (_setSyntaxFeature Charop: #( |++| |--|) #(cadd csub ))
       (_setSyntaxFeature Chartyp: #( |++| |--|) #(char char ))
       (_setSyntaxFeature Intop: #( |++| |--|) #(iadd isub ))
       (_setSyntaxFeature Inttyp: #( |++| |--|) #(int int ))
       (_setSyntaxFeature Floatop: #( |++| |--|) #(nadd nsub ))
       (_setSyntaxFeature Floattyp: #( |++| |--|) #(float float ))
       (_setSyntaxFeature Logical: #( |!|) #void)
       (_setSyntaxFeature Lisp: #( |!|) #(not ))
       (_setSyntaxFeature For: #( |for|) #void)
       (_setSyntaxFeature Function: #( |function|) #void)
       (_setSyntaxFeature Friend: #( |friend|) #void)
       (_setSyntaxFeature Class: #( |class|) #void)
       (_setSyntaxFeature Extends: #( |extends|) #void)
       (_setSyntaxFeature Child: #( |child|) #void)
       (_setSyntaxFeature Orphan: #( |orphan|) #void)
       (_setSyntaxFeature Method: #( |method|) #void)
       (_setSyntaxFeature If: #( |if|) #void)
       (_setSyntaxFeature Name: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #void)
       (_setSyntaxFeature Of: #( |of|) #void)
       (_setSyntaxFeature Type: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #void)
       (_setSyntaxFeature Reftyp: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(int float char bool obj char char char obj obj obj obj int char float int float obj int obj float ))
       (_setSyntaxFeature Refop: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(ref ref ref ref ref reftext refSymbol refString ref ref ref refVector refBitVector refBytVector refNumVector refIntVector refFltVector refObjVector refPcdVector ref ref ))
       (_setSyntaxFeature Setop: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(setq setq setq setq setq setq setq setString setq setq setq setVector setBitVector setBytVector setNumVector setIntVector setFltVector setObjVector setPcdVector setq setq ))
       (_setSyntaxFeature While: #( |while|) #void)
       (_setSyntaxFeature Else: #( |else|) #void)
       (_setSyntaxFeature Reg: #( |reg|) #void)
       (_setSyntaxFeature Var: #( |var|) #void)
       (_setSyntaxFeature Pvar: #( |pvar|) #void)
       (_setSyntaxFeature Cvar: #( |cvar|) #void)
       (_setSyntaxFeature Semicolon: #( ";") #void)
       (_setSyntaxFeature Colon: #( ":") #void)
       (_setSyntaxFeature Question: #( "?") #void)
       (_setSyntaxFeature LeftParen: #( "(") #void)
       (_setSyntaxFeature RightParen: #( ")") #void)
       (_setSyntaxFeature LeftBrace: #( "{") #void)
       (_setSyntaxFeature RightBrace: #( "}") #void)
       (_setSyntaxFeature LeftBracket: #( "[") #void)
       (_setSyntaxFeature RightBracket: #( "]") #void)
       (_setSyntaxFeature Comma: #( ",") #void)
       (_setSyntaxFeature DotOperator: #( ".") #void)
       (_setSyntaxFeature Pound: #( |#|) #void)
       (_setSyntaxFeature Bar: #( "|") #void)
       (_setSyntaxFeature Reserved: #( |if| |then| |else| |while| |do| |reg| |var| |pvar| |cvar| |for| |function| |orphan| |friend| |child| |class| |method| |extends|) #void)
       (_setSyntaxFeature Select: #( |select|) #void)
       (_setSyntaxFeature Percent: #( |%|) #void)
       (_setSyntaxFeature Sort: #( |sort|) #void)
       (_setSyntaxFeature Backup: #( |backup|) #void)
       (_setSyntaxFeature Direction: #( |up| |down|) #void)
       (_setSyntaxFeature All: #( |all|) #void)
       (_setSyntaxFeature Scale: #( |scale|) #void)
       (_setSyntaxFeature Regress: #( |regress|) #void)
       (_setSyntaxFeature Model: #( |model|) #void)
       (_setSyntaxFeature Frmregress: #( |frmregress|) #void)
       (_setSyntaxFeature Mvlregress: #( |mvlregress|) #void)
       (_setSyntaxFeature Svmregress: #( |svmregress|) #void)
       (_setSyntaxFeature Highest: #( |highest|) #void)
       (_setSyntaxFeature Extract: #( |extract|) #void)
       (_setSyntaxFeature Omit: #( |omit|) #void)
       (_setSyntaxFeature Check: #( |check|) #void)
       (_setSyntaxFeature Checkoff: #( |checkoff| |nocheck|) #void)
       (_setSyntaxFeature Checkon: #( |checkon|) #void)
       (_setSyntaxFeature Cut: #( |bottom| |top|) #void)
       (_setSyntaxFeature Slice: #( |slice|) #void)
       (_setSyntaxFeature Lisp: #( |slice| |bottom| |up| |top| |down| |highest| |all|) #(<= <= <= >= >= >= true ))
       (_setSyntaxFeature Score: #( |score|) #void)
       (_setSyntaxFeature ScoreCommand: #( |average| |averageForAll| |total| |totalForAll| |maximum| |minimum| |deviation| |sharpe|) #void)
       (_setSyntaxFeature Set: #( |Set| |set|) #void)
       (_setSyntaxFeature Setnr: #( |Setnr| |setnr|) #void)
       (_setSyntaxFeature Run: #( |run|) #void)
       (_setSyntaxFeature Restore: #( |restore|) #void)
       (_setSyntaxFeature Reserved: #( |all| |average| |averageForAll| |backup| |bottom| |check| |checkoff| |checkon| |down| |filter|) #void)
       (_setSyntaxFeature Reserved: #( |nocheck| |omit| |restore| |run| |score| |set| |sort| |up| |top| |total| |totalForAll|) #void)
       ;; Call the user defined initialization routine
       (initRule)
       true) ;; end _Initialize
   ;; Default rule for user defined compiler initialization tasks.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun initRule()
       true) ;; end initRule
   ;; Move the current parse tree index to the previous position.
   (defun _lastIp()
       (if (isNumber _ip) (return (setq _ip (subi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (subi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _lastIp
   ;; Return the length of the current parse.
   (defun _lenIp()
       vars:(i io n)
       (if (isNumber _ip) (return (length _io)))
       (setq n (sub1 (length _ip)))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (length io)) ;; end _lenIp
   ;; Default main Lexical Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _LEXRULE_MAIN()
       (defaultLexer $IN)) ;; end _LEXRULE_MAIN
   ;; Move the current parse tree index to the next position.
   (defun _nextIp()
       (if (isNumber _ip) (return (setq _ip (addi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (addi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _nextIp
   ;; Default rule for returning the final output from the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun outputRule(result)
       result) ;; end outputRule
   ;; Pop the current parse tree index up one level to the next position.
   (defun _popIp()
       (if (isNumber _ip) (return true))
       (if (<= (length _ip) 1) (begin (setq _ip _ip[0]) (return true)))
       (resize _ip (subi (length _ip) 1))
       true) ;; end _popIp
   ;; Default rule for any pre-lexical compiler operations.
   (defun preLexRule(input) input)
   ;; Push the current parse tree index down one level to the next position.
   (defun _pushIp()
       (if (isNumber _ip) (setq _ip (new Vector: 1 _ip)))
       (setq _ip[(length _ip)] -1)
       true) ;; end _pushIp
   ;; Assign a set of letters to the specified lexical feature
   (defun _setLexicalFeature(letterBitMap values)
       vars:(i j valueLen start end bit)
       (setq valueLen (length values))
       (if (= letterBitMap #void) (setq letterBitMap (new Vector: bit: 255)))
       (loop for i from 0 until valueLen by 3 do
          (setq bit values[i])
          (setq start (integer (min values[(+ i 1)] values[(+ i 2)])))
          (setq end (integer (max values[(+ i 1)] values[(+ i 2)])))
          (loop for j from start to end do
              (setq letterBitMap[j] bit)
              ) ; end j loop
           ) ; end i loop
       letterBitMap) ; end _setLexicalFeature
   ;; Set a whole class of syntax tokens with the specified attribute and values
   (defun _setSyntaxFeature(name words values)
       vars:(i wordLen token)
       (setq wordLen (length words))
       (loop for i from 0 until wordLen do
           (setq token tokenDirectory[words[i]])
           (if (= token #void) (setq token (new Structure:)))
           (if (= values[i] #void)
               (setq token[name] true)
               (setq token[name] values[i])
               ) ; end if
           (setq token.Value words[i])
           (setq tokenDirectory[words[i]] token)
           ) ; end loop
       true) ; end _setSyntaxFeature 
   ;; Set or enhance a whole word with the specified features and feature values
   ;; Note1: The word may be a single word or a vector starting with the word
   ;;        and proceeding with all of its gramatical synonyms. 
   ;;        For instance:   #(give gives gave given giving) 
   ;;        Each synonym may be a single word or a vector starting with the word
   ;;        and proceeding with all of its special features. 
   ;;        For instance:   #(give gives gave given #(giving Noun))
   ;; Note2: Each feature may be a single word or a vector starting with the feature
   ;;        and proceeding with the value of the feature. A singleton feature is
   ;;        assumed to have a value of true. 
   ;;        For instance:   Noun: Name: #(Color blue) 
   (defun _setWordFeatures(words commonFeatures)
       vars:(k K m M n N token feature featureName word extraFeatures)
       ;; If there are more than one grammatical synonym, then define each one.
       (if (not (isVector words)) (setq words (new Vector: 1 words)))
       (setq M (length words)) 
	   (setq N (length commonFeatures))
       ;; Extract the common feature name from the first word.
       ;; Note: Words with extra features are entered as Vectors
       (if (isVector words[0])
           then
           ;; The common word has extra features
           (setq featureName (downcase (makeString words[0][0])))
           else
           ;; The common word has no extra features
           (setq featureName (downcase (makeString words[0])))
           ) ; end if
       (setq featureName[0] (upcase featureName[0]))
       (setq featureName (symbol featureName))
       ;; Set all words to upper case.
       (loop for m from 0 until M do
           ;; Each word is stored upper case.
           ;; Note: Words with extra features are entered as Vectors
           (if (isVector words[m])
               then
               ;; This word has extra features
               (begin
                  (setq extraFeatures words[m])
                  (setq K (length extraFeatures))
                  (setq word (makeString extraFeatures[0]))
               ) ; end then
               else
               ;; This word has no extra features
               (begin
                  (setq extraFeatures #void)
                  (setq K 0)
                  (setq word (makeString words[m]))
               )) ; end if
	       (setq token tokenDirectory[word])
	       (if (= token #void) (setq token (new Structure:)))
	       (setq token.Value word)
           ;; Each word has its main word as a feature.
	       (setq token[featureName] true)
           ;; Each word has itself as a feature.
	       (setq feature (downcase (makeString word)))
	       (setq feature[0] (upcase word[0]))
	       (setq feature (symbol feature))
	       (setq token[feature] true)
	       ;; Add common features to this word.
	       (loop for n from 0 until N do
	           (setq feature commonFeatures[n])
	           (if (isVector feature) 
	               (setq token[feature[0]] feature[1])
	               (setq token[feature] true)
	               ) ; end if
	           ) ; end feature loop
	       ;; Add extra features to this word.
	       (loop for k from 1 until K do
	           (setq feature extraFeatures[k])
	           (if (isVector feature) 
	               (setq token[feature[0]] feature[1])
	               (setq token[feature] true)
	               ) ; end if
	           ) ; end feature loop
           (setq tokenDirectory[word] token)
	       ) ; end word loop
       true) ; end _setWordFeatures
   ;; Show a fragment of the input source string in lexical verbose mode
   (defun _showInput(size)
       vars:(sourceIndex sourceLen result)
       (setq sourceLen (length $IN))
       (setq sourceIndex (addi _ip 1))
       (if (< sourceIndex sourceLen)
           (setq result (mid $IN sourceIndex size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showInput
   ;; Show a fragment of the input source string in syntax verbose mode
   (defun _showSource(size)
       vars:(treeIndex treeLen result)
       (setq treeLen (length _parseTree))
       (setq treeIndex (addi _ip 1))
       (if (< treeIndex treeLen)
           (setq result (mid $IN _parseTree[treeIndex].Charpos size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showSource
   ;; Default rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun startRule()
       true) ;; end startRule
   ;; Default main Syntax Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _SYNRULE_MAIN()
       _parseTree) ;; end _SYNRULE_MAIN
   ;; Display the results of a rule firing in verbose mode.
   (defun writeRule(ruleID _ret t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10)
   	   vars:(ruleText)
   	   (setq ruleText (new Vector: byte: 5000))
   	   (appendWriteln ruleText 
   	   		"Firing " 
   	   		ruleID
	       	(if (<> t1 #void)  (append "  " (rept " " _indent) "t1 = " (string t1 true) _eol) "")
	       	(if (<> t2 #void)  (append "  " (rept " " _indent) "t2 = " (string t2 true) _eol) "")
	       	(if (<> t3 #void)  (append "  " (rept " " _indent) "t3 = " (string t3 true) _eol) "")
	       	(if (<> t4 #void)  (append "  " (rept " " _indent) "t4 = " (string t4 true) _eol) "")
	       	(if (<> t5 #void)  (append "  " (rept " " _indent) "t5 = " (string t5 true) _eol) "")
	       	(if (<> t6 #void)  (append "  " (rept " " _indent) "t6 = " (string t6 true) _eol) "")
	       	(if (<> t7 #void)  (append "  " (rept " " _indent) "t7 = " (string t7 true) _eol) "")
	       	(if (<> t8 #void)  (append "  " (rept " " _indent) "t8 = " (string t8 true) _eol) "")
	       	(if (<> t9 #void)  (append "  " (rept " " _indent) "t9 = " (string t9 true) _eol) "")
	       	(if (<> t10 #void)  (append "  " (rept " " _indent) "t10 = "(string t10 true) _eol) "")
       		(append "  " (rept " " _indent) " ==> " (string _ret true)))
       (_logLine ruleText none:)
       true) ;; end writeRule
    ;; Output a feature based token to the token list (output as is).
    (defun _tkASIS(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (error "$ASIS must have at least two arguments"))
       (if (isOdd (argCount)) (error "$ASIS must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Use these value as is. Do not use the syntax feature directory.
       ;; Note: Create an attributed token using the user supplied features.
       (setq tokenAttr (new Structure:))
       (setq tokenAttr.Value value)
       (setq tokenAttr.Charpos charpos)
       (loop for argIndex from 2 until (argCount) by 2 do
          (setq featureName (argFetch argIndex))
          (setq featureValue (argFetch (iadd argIndex 1)))
          (setq tokenAttr[(symbol featureName)] featureValue)
          ) ; end feature loop
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkASIS
    ;; Output a feature based token to the token list.
    (defun _tkOUT(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (_error "$OUT must have at least two arguments"))
       (if (isOdd (argCount)) (_error "$OUT must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Load any syntax features for this value.
       (setq tokenAttr tokenDirectory[value])
       (if (= tokenAttr #void)
           then
           ;; This value is not found in the syntax feature directory.
           ;; Note: Create an attributed token using the user supplied features.
           (begin
              (setq tokenAttr (new Structure:))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              (loop for argIndex from 2 until (argCount) by 2 do
                 (setq featureName (argFetch argIndex))
                 (setq featureValue (argFetch (iadd argIndex 1)))
                 (setq tokenAttr[(symbol featureName)] featureValue)
                 ) ; end feature loop
              ) ; end then
           else
           ;; This value is found in the syntax feature directory.
           ;; Note: Copy the features from the dictionary and set the value.
           (begin
              (setq tokenAttr (copy tokenAttr))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              ) ; end else
           ) ; end if
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkOUT

	(defun _substitute(begIp endIp newItem)
		vars:(n N)
		(setq _ip (- begIp 1))
		(setq N (+ (- endIp begIp) 1))
		(setq _parseTree[begIp] newItem)
		(++ begIp)
		(loop for n from 1 until N do
			(delete _parseTree begIp)
		);n
		true)

   ;; ************************************************
   ;; Define the main entry code for this parent Lambda
   ;; ************************************************
   ;; ************************************************
   ;; Define the main entry code for this parent Lambda
   ;; ************************************************
   ;; Perform any pre-lexical work required before compilation
   (setq _verboseState _verbose)
   (setq _verboseTrigger -1)
   (setq _ruleCount 0)
   (setq _failurePass false)
   RESTART::	; come here if we have an error so we can turn _verbose on close to the failure
   (if (> _ruleCount 0) ; this means we are restarting after a failure
    	(begin
    	(setq _failurePass true)
   	    (cond
   	    ((= _failureIn lex:) ; error found in Lexical Pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) 15))) ; show at least 15 rules before failure
	   	((= _failureIn syn:) ; error found in syntax pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) _ruleCountSyn))) ; make sure we don't start _verbose in lexical analysis
	   	((= _failureIn sem:) ; error found in semantic pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) _ruleCountSem))) ; make sure we dont start _verbose in syntax analysis
   		)));if

   (setq _ruleCount 0)
   (setq _verbose _verboseState)
   (setq _lastError (new Structure:)) ;; Clear _lastError 
   (onError _errorHandler)
   (setq _verboseLexCount (new Structure:)) ;Clear routine pass counts
   (setq _verboseSynCount (new Structure:))
   (setq _verboseSemCount (new Structure:))

   (setq _input (preLexRule _input))
   ;; Initialize the parent Lambda once and only once.
   (setq _indent 0)
   (setq _tkIN _input)
   (setq $IN _input)
   (setq $OUT _tkOUT)
   (setq $ASIS _tkASIS)
   (if (= _initializeSW #void) (_Initialize))
   (setq defaultLexer.defaultTokenRule defaultTokenRule)
   (setq defaultLexer.tokenDirectory tokenDirectory)
   
   ;; In verbose mode, display the source string contents
   (if _verbose (writeln _eol "************Input Source************" _eol $IN))
   ;; Run the user defined start rule.
   (startRule)


   ;; Run the Lexical Rules
   ;; Note: Create the attributed token stream parse tree.
   (setq _verboseHold _verbose)
   (setq _verbose (or _verboseHold _verboseLex))
   (if _verbose (writeln "*********Lexical Rule Firings*********"))
   (setq _tkLIST #void)
   (setq $LIST _tkLIST)
   (setq _ip -1)
   (setq _indent 0)
   (setq _parseTree (_LEXRULE_MAIN)) 
   (if (and (not _failurePass) (not _verbose)(= _parseTree |*failure*|:)) (begin (setq _failureIn lex:) (goto RESTART:)))
   ;; In verbose mode, display the parse tree contents
   (if _showTokens
      (begin
         (writeln "*********Lexed Tokens with Features*********")
         (loop for i from 0 until (length _parseTree) do
             (writeln "[" i "] " _parseTree[i])
             ) ; end loop
         )) ; end if
   (if (= _parseTree |*failure*|:) (goto END:))
   
    ;; Run the Syntax Rules
   (setq _verbose (or _verboseHold _verboseSyn))
   (if _verbose (writeln "*********Syntax Rule Firings*********"))
   (setq _ruleCountSyn _ruleCount)
   (setq _ip -1)
   (setq _io _parseTree)
   (setq _parseLen (length _parseTree))
   (setq _indent 0)
   (setq _result (_SYNRULE_MAIN))
   (if (and (not _failurePass) (not _verbose) (= _result |*failure*|:)) (begin (setq _failureIn syn:) (goto RESTART:)))
   (if (= _result |*failure*|:) (goto END:))
   
   ;; Run the Semantic Rules
   (if _verbose (writeln "*********Semantic Rule Firings*********"))
   (setq _ruleCountSem _ruleCount)
   (setq _verbose (or _verboseHold _verboseSem))
   (setq _explanation #void)
   
   (if _verbose (setq outString (append "Reducing:= " (string _result true) " ==> " )))
   (if _explainOnOff (setq outExplain (append "Reducing:= " (string _result true) " ==> " )))
   (setq _indent 0)




   ;; Perform semantic passes (if any)
   (_apply _SEMRULE_MAIN true)
   ;; Return the final output by invoking the user defined output rule.
   (if _semanticVerbose (writeln outString (string _result true)))
   (if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
   (setq _verbose verboseHold)
   
   (setq _result (outputRule _result))
   (setq _verbose _verboseState)   
   (if (and (not _failurePass) (not _verbose) (= _result |*failure*|:)) (begin (setq _failureIn sem:) (goto RESTART:)))
   (if _verbose (writeln "*********Final Output*********" _eol _result)) 
   
   END::
   
   _result) ;; end of compiler














;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS
;; ********************************************************************
;; summary:  estimator User defined functions
;;
;; 			 Compile time child Lambdas for the estimator compiler.
;; 			 These child Lambdas support the estimator compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; ********************************************************************

;; ********************************************************************************
;; Lisp function which returns a parse tree even when the compiler is in debug mode
;; ********************************************************************************
(defun Lisp(s)         
   vars:(parseTree)
   (setq parseTree (lisp s))
   (if (isLambda parseTree) (setq parseTree parseTree.In.dbgParseTree))
   parseTree) ; end Lisp

;;*********************************************************************
;; Function start pushes a new variable dictionary on the stack
;; Note: These persistant variables will extend the java environment
;;*********************************************************************
(defchild gsm.estimator startRule()
    pvars:(pvarVector           ;; Vector of declared persistant variables.
           cvarVector           ;; Vector of declared class variables. 
           gvarVector           ;; Vector of declared global variables.
           varVector            ;; Vector of declared temporary variables.
           regVector            ;; Vector of declared register variables.
           avarVector           ;; Vector of declared argument variables.
           startRuleFilterStmt  ;; Filter statement extended start rule.
           maxConstants         ;; Maximum number of constant references ever seen
           maxNoiseTerms        ;; Maximum number of random noise term references ever seen
           maxVariables         ;; Maximum number of variable references ever seen
           maxAbsOperators      ;; Maximum number of abstract operator references ever seen
           maxTerms             ;; Maximum number of term references ever seen
           ) ; end of persistant variables
    ;; Initialize the variable vectors.
    (setq gvarVector (new Vector: 1 (new Dictionary:)))
    (setq pvarVector (new Vector: 0))
    (setq cvarVector (new Vector: 0))
    (setq regVector (new Vector: 0))
    (setq varVector (new Vector: 0))
    (setq avarVector (new Vector: 0))
    (setq maxConstants 0)
    (setq maxNoiseTerms 0)
    (setq maxVariables 0)
    (setq maxAbsOperators 0)
    (setq maxTerms 0)
    ;; Extend this start rule for the Filter statement.
    (startRuleFilterStmt)
    true) ; end startRule

;;*********************************************************************
;; Test to see if the expression is a record field name. 
;;*********************************************************************
(defchild gsm.estimator isFieldName(nameStruct)
    vars:(result)
    ;; Check to see if the name is an element name of a record in the selected row set.
    ;; Estimator makes the following translations:
    ;;
    ;;    X       ==>  XT.selectedRows
    ;;    xv      ==>  ...the current row being studied...
    ;;    yv      ==>  ...the current second row being studied in a sort...
    ;;    xtime   ==>  xv[0] ...the time stamp element of the vector
    ;;    xn      ==>  xv[n] ...the nth element of the vector
    ;;    y       ==>  (cdr xv) ...the score element of the vector
    ;;    cn      ==>  CC[n] ...the nth element of the real constant vector
    ;;    en      ==>  EE[n] ...the nth element of the real random noise vector
    ;;    vn      ==>  xv[VV[n]] ...the indirect nth element of the vector
    ;;    fn      ==>  AG[FF[n]] ...the indirect nth element of the abstract operator vector
    ;;    tn      ==>  ((TT[n] == 1) ? CC[n] : xv[VV[n]]) ...the indirect nth feature or constant
    ;;
    (cond
     ;; Recognize cn
     ((and (= nameStruct.Value[0] #\c) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize en
     ((and (= nameStruct.Value[0] #\e) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize vn
     ((and (= nameStruct.Value[0] #\v) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize xm
     ((and (= nameStruct.Value[0] #\x) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize fm
     ((and (= nameStruct.Value[0] #\f) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize tm
     ((and (= nameStruct.Value[0] #\t) (isCharNumeric (mid nameStruct.Value 1 10000))) (setq result true))
     ;; Recognize xtime
     ((= nameStruct.Value "xtime") (setq result true))
     ;; Recognize y
     ((= nameStruct.Value "y") (setq result true))
     ;; else
     (else (setq result false))
     ) ; end cond
    ;; Return true so the recognition step will continue
    result) ; end isFieldName

;;*********************************************************************
;; Convert a record field name ro canstant reference into an integer index. 
;;*********************************************************************
(defchild gsm.estimator cnvFieldName(name)
    vars:(xRef num)
    ;; Convert an element name of a record in the row manager.
    ;; Estimator makes the following translations:
    ;;
    ;;    X       ==>  XT.selectedRows
    ;;    xv      ==>  ...the current row being studied...
    ;;    yv      ==>  ...the current second row being studied in a sort...
    ;;    xtime   ==>  xv[0] ...the time stamp element of the vector
    ;;    xn      ==>  xv[n] ...the nth element of the vector
    ;;    y       ==>  (cdr xv) ...the score element of the vector
    ;;    cn      ==>  CC[n] ...the nth element of the real constant vector
    ;;    en      ==>  EE[n] ...the nth element of the real random noise vector
    ;;    vn      ==>  xv[VV[n]] ...the indirect nth element of the vector
    ;;    fn      ==>  AG[FF[n]] ...the indirect nth element of the abstract operator vector
    ;;    tn      ==>  ((TT[n] == 1) ? CC[n] : xv[VV[n]]) ...the indirect nth feature or constant
    ;;
    (cond
     ((= name "xtime") (setq xRef (list ref: xv: 0)))
     ((= name "y") (setq xRef (list cdr: xv:)))
     ((and (= name[0] #\x) (isCharNumeric (setq num (mid name 1 10000)))) (setq xRef (list ref: xv: (setq num (integer num))))) 
     ((and (= name[0] #\c) (isCharNumeric (setq num (mid name 1 10000)))) (setq maxConstants (max maxConstants (+ (integer num) 1))) (setq xRef (list ref: CC: (setq num (integer num))))) 
     ((and (= name[0] #\e) (isCharNumeric (setq num (mid name 1 10000)))) (setq maxNoiseTerms (max maxNoiseTerms (+ (integer num) 1))) (setq xRef (list ref: EE: (setq num (integer num))))) 
     ((and (= name[0] #\v) (isCharNumeric (setq num (mid name 1 10000)))) (setq maxVariables (max maxVariables (+ (integer num) 1))) (setq xRef (list ref: xv: (list (makeQuotedSymbol "Integer") (list ref: VV: (setq num (integer num))))))) 
     ((and (= name[0] #\f) (isCharNumeric (setq num (mid name 1 10000)))) (setq maxAbsOperators (max maxAbsOperators (+ (integer num) 1))) (setq xRef (list ref: AG: (list (makeQuotedSymbol "Integer") (list ref: FF: (setq num (integer num))))))) 
     ((and (= name[0] #\t) (isCharNumeric (setq num (mid name 1 10000)))) (setq maxTerms (max maxTerms (+ (integer num) 1))) (setq maxConstants (max maxConstants (+ (integer num) 1))) (setq maxVariables (max maxVariables (+ (integer num) 1))) (setq xRef (list |if|: (list |=|: (list ref: TT: (setq num (integer num))) 1) |then|: (list ref: CC: (setq num (integer num))) |else|: (list ref: xv: (list (makeQuotedSymbol "Integer") (list ref: VV: (setq num (integer num))))) ))) 
     (else (setq xRef name))  
     ) ; end cond
    xRef) ; end cnvFieldName

;;*********************************************************************
;; Constructs a function call argument list from an argument vector.
;;*********************************************************************
(defchild gsm.estimator argList(struct name args)
    ;; Create the special transendential function calls as inline instructions with register arguments.
    (cond

     ;; Unary concrete operators
     ((= name "abs") (setq struct.Value (list (symbol "abs") (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "cos") (setq struct.Value (list (symbol "cos") (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "cube") (setq struct.Value (list (symbol "*") (append (list (makeQuotedSymbol "Number")) (objectToList args))  (append (list (makeQuotedSymbol "Number")) (objectToList args)) (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "exp") (setq struct.Value (list (symbol "exp") (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "log") (setq struct.Value (list (symbol "log") (list (symbol "abs") (append (list (makeQuotedSymbol "Number")) (objectToList args))) ))) 
     ((= name "sin") (setq struct.Value (list (symbol "sin") (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "sqrt") (setq struct.Value (list (symbol "sqrt") (list (symbol "abs") (append (list (makeQuotedSymbol "Number")) (objectToList args))) ))) 
     ((= name "square") (setq struct.Value (list (symbol "*") (append (list (makeQuotedSymbol "Number")) (objectToList args))  (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ((= name "tan") (setq struct.Value (list (symbol "tan") (append (list (makeQuotedSymbol "Number")) (objectToList args)) ))) 
     ;; Create all other function calls with or without arguments.
     ((= args #void) (setq struct.Value (list name)))
     ;; Create all other function calls with or without arguments.
     (else (setq struct.Value (append (list name) (objectToList args))))
      ) ; end function call cond
    (setq struct.Term true)
    struct) ; end argList

;;*********************************************************************
;; Function start pushes a new variable dictionary on the stack
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator pushVars(struct)
    ;; Create a new variable dictionary for this function.
    (setq pvarVector[(length pvarVector)] (new Dictionary:))
    (setq cvarVector[(length cvarVector)] (new Dictionary:))
    (setq varVector[(length varVector)] (new Dictionary:))
    (setq avarVector[(length avarVector)] (new Dictionary:))
    struct) ; end pushVars

;;*********************************************************************
;; Function end pops the variable dictionary from the stack
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator popVars()
    vars:(result pvarDic cvarDic varDic vecLast varLen i varList)
    ;; Pop the variable dictionaries from the stack.
    (setq vecLast (subi (length pvarVector) 1))
    (setq pvarDic pvarVector[vecLast])
    (setq cvarDic cvarVector[vecLast])
    (setq varDic varVector[vecLast])
    (resize pvarVector vecLast)
    (resize cvarVector vecLast)
    (resize varVector vecLast)
    (resize avarVector vecLast)
    ;; If there are any pvars, append them to the result.
    (if (> (length pvarDic) 0)
        (begin
           (setq result (list (makeQuotedSymbol "pvars")))
           (setq varLen (length pvarDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList pvarDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if pvars
    ;; If there are any cvars, append them to the result.
    (if (> (length cvarDic) 0)
        (begin
           (setq result (list (makeQuotedSymbol "cvars")))
           (setq varLen (length cvarDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList cvarDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if cvars
    ;; If there are any vars, append them to the result.
    (if (> (length varDic) 0)
        (begin
           (setq result (appendList result (list (makeQuotedSymbol "vars"))))
           (setq varLen (length varDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList varDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if vars
    result) ; end popVars

;;*********************************************************************
;; Add a new variable to the pvars or the vars variable list
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator addVar(var vtype name struct struct2)
    pvars:(addToBeginList)
    vars:(vecLast)
    ;; Add a new variable to the variable dictionary for this function.
    (setq vecLast (subi (length var) 1))
    ;; Manage variable declarations at the global level.
    (if (< vecLast 0)
        (begin
           ;; At the global level, we always substitute the global 
           ;; variable vector (gvarVector) as the variable vector.
           (setq var gvarVector)
           (setq vecLast (subi (length var) 1))
        )) ; end if
    (setq var[vecLast][(symbol name)] vtype)
    (addToBeginList struct struct2.Value)
    struct) ; end addVar

;;*********************************************************************
;; The the variable type of the Name token just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator setVType(token)
    vars:(vecLast)
    ;; Locate a new variable in the variable dictionary for this level.
    (setq vecLast (subi (length varVector) 1))
    ;; If this is a constant, then set its type accordingly.
    (cond
       ;; If the token is an Integer constant, set the type to int.
       ((= token.Integer true)
        (setq token.VType int:))
       ;; If the token is a Number constant, set the type to float.
       ((= token.Number true)
        (setq token.VType float:))
       ;; If the token is a Boolean constant, set the type to bool.
       ((= token.Boolean true)
        (setq token.VType bool:))
       ;; If the token is a Character constant, set the type to char.
       ((= token.Character true)
        (setq token.VType char:))
       ;; If the token is a Name, set the type to char.
       ((= token.Name true)
        (begin
           ;; Set all Name tokens to type obj as a default.
           (setq token.VType obj:)
           ;; If the Name is a registered global, set its type as registered.
           (if (<> gvarVector[0][token.Value] #void) 
               (setq token.VType gvarVector[0][token.Value]))
           ;; If the Name is a registered cvar, set its type as registered.
           (if (<> cvarVector[vecLast][token.Value] #void) 
               (setq token.VType cvarVector[vecLast][token.Value]))
           ;; If the Name is a registered pvar, set its type as registered.
           (if (<> pvarVector[vecLast][token.Value] #void) 
               (setq token.VType pvarVector[vecLast][token.Value]))
           ;; If the Name is a registered var, set its type as registered.
           (if (<> varVector[vecLast][token.Value] #void) 
               (setq token.VType varVector[vecLast][token.Value]))
           ;; If the Name is a registered arg, set its type as registered.
           (if (<> avarVector[vecLast][token.Value] #void) 
               (setq token.VType avarVector[vecLast][token.Value]))
           )) ; end begin
       ;; Otherwise, set the type to obj.
       (else 
        (setq token.VType obj:))
       ) ; end cond
    token) ; end setVType

;;*********************************************************************
;; The the variable type of the binary expression just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator setExpVType(struct token1 optok token2)
    vars:(op resultTyp typ1 typ2)
    ;; Determine the type of both token and the operator.
    (setq typ1 token1.VType)
    (setq typ2 token2.VType)
    (cond
       ;; Is this an Boolean expression?
       ((and (= typ1 bool:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Boolop)
           (setq resultTyp optok.Booltyp)
        )) ; end Boolean expression
       ;; Is this an Character expression?
       ((and (= typ1 char:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Charop)
           (setq resultTyp optok.Chartyp)
        )) ; end Character expression
       ;; Is this an Integer expression?
       ((and (= typ1 int:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Intop)
           (setq resultTyp optok.Inttyp)
        )) ; end Integer expression
       ;; Is this an Number expression?
       ((and (= typ1 float:) (= typ2 float:))
        (begin
           (setq op optok.Floatop)
           (setq resultTyp optok.Floattyp)
        )) ; end Number expression
       ;; Is this any other expression?
       (else
        (begin
           (setq op optok.Lisp)
           (setq resultTyp obj:)
        )) ; end any other expression
       ) ; end cond
    ;; Make sure operators generate fastest possible register code.
    (cond
     ((= op pdiv:) (setq struct.Value (list (makeQuotedSymbol "Number") (list |if|: (list |=|: token2.Value 0.0) BIGPOSNUM: (list |/|: token1.Value token2.Value)))))
     ((= op |/|:) (setq struct.Value (list (makeQuotedSymbol "Number") (list |if|: (list |=|: token2.Value 0.0) BIGPOSNUM: (list |/|: token1.Value token2.Value)))))
     (else (setq struct.Value (list op token1.Value token2.Value)))
     ) ; end cond
    (setq struct.VType resultTyp)
    struct) ; end setExpVType

;;*********************************************************************
;; The the variable type of the binary expression just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator setExpList(struct token1 rightHand)
    regs:(n N)
    ;; Apply the operators from left to right one at a time.
    (setq N (length rightHand.Value))
    (setq struct (setExpVType struct token1 rightHand.Value[0] rightHand.Value[1]))
    (loop for n from 2 until N by 2 do
      (setq struct (setExpVType struct struct rightHand.Value[n] rightHand.Value[(+ n 1)]))
      ) ; end loop
    struct) ; end setExpList

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild gsm.estimator addToList(struct x) 
    (setq struct.Value (appendList struct.Value x))) ; end addToList

;;*********************************************************************
;; Constructs a defstruct statement from an argument vector.
;;*********************************************************************
(defchild gsm.estimator fieldList(struct newType parent args)
    ;; Create a defstruct with or without fields.
    (cond
       ;; Build a defstruct with no parent and no field list.
       ((and (= args #void) (= parent #void)) 
        (setq struct.Value (list defstruct: (makeQuotedSymbol newType))))
       ;; Build a defstruct with no parent and a field list.
       ((and (<> args #void) (= parent #void)) 
        (setq struct.Value (append (list defstruct: (makeQuotedSymbol newType)) (objectToList args))))
       ;; Build a defstruct with a parent and no field list.
       ((and (= args #void) (<> parent #void)) 
        (setq struct.Value (list defstruct: (makeQuotedSymbol newType) ''include parent)))
       ;; Build a defstruct with a parent and a field list.
       ((and (<> args #void) (<> parent #void)) 
        (setq struct.Value (append (list defstruct: (makeQuotedSymbol newType) ''include parent) (objectToList args))))
        ) ; end cond
    struct) ; end fieldList

;;*********************************************************************
;; Constructs a message send argument list from an argument vector.
;;*********************************************************************
(defchild gsm.estimator sendList(struct method receiver args)
    ;; Return if there are no arguments.
    (if (= args #void) 
        (setq struct.Value (list send: (makeQuotedSymbol method) receiver))
        (setq struct.Value (append (list send: (makeQuotedSymbol method) receiver) (objectToList args)))
        ) ; end if
    (setq struct.Term true)
    struct) ; end sendList

;;*********************************************************************
;; AddToBeginList
;; Note: Avoid using append for repeatedly linking long lists together.
;;       Use the setCdr function, it is much faster. Append was never
;;       meant to be used for long lists repeatedly.
;;*********************************************************************
(defchild gsm.estimator addToBeginList(struct x)
    ;; Return if there is nothing to append.
    (if (= x #void) (return struct))
    (cond
        ;; Set up begin list header the first time.
        ((= struct.Value #void)
         (begin 
            (setq struct.Value x)
            (setq struct._noBeginList true)
            ))
        ;; Set up begin list header the second time.
        ((= struct._noBeginList true)
         (begin
            ;; Singletons can be ignored because they have no side effects.
            (if (= (isPair struct.Value) false)
                then
                (setq struct.Value x)
                else
                (begin 
                   (setq struct._noBeginList false)
                   (setq struct.Value (list |begin|: struct.Value))
                   (setCdr struct (last struct.Value))
                   (setCdr (cdr struct) (list x))
                   (setCdr struct (last (cdr struct)))
                   ) ; end else
                ) ; end if
            ))
        ;; Append to the begin list the remaining times.
        (else 
         (begin
            (setCdr (cdr struct) (list x))
            (setCdr struct (last (cdr struct)))
            ))
        ) ; end conf
    struct) ; end addToBeginList

;;*********************************************************************
;; Constructs a java child definition from an argument list.
;;*********************************************************************
(defchild gsm.estimator childList(defname struct parent name args body)
    vars:(varList)
    ;; Retrieve all the declare variables
    (setq varList (popVars))
    ;; Set up |()| if there are no arguments.
    (if (= args.Value #void)
        (setq args (symbol "()"))
        (setq args (objectToList args.Value))
        ) ; end if
    ;; Create the function declaration up to the variables
    (setq struct.Value (list defname (makeQuotedSymbol parent.Value) name.Value args))
    ;; Append the variable declarations (if any)
    (if (<> varList #void)
        (setq struct.Value (appendList struct.Value varList (list body.Value)))
        (setq struct.Value (appendList struct.Value (list body.Value)))
        ) ; end if
    (setq struct.Func true)
    struct) ; end childList

;;*********************************************************************
;; Modified default rule for adding Term attributes to all name tokens.
;;*********************************************************************
(defchild gsm.estimator defaultTokenRule(token)
    vars:(result tokenLen tokenEnd)
    ;; Is this token a delimited constant?
    (if (isVector token) 
        (begin
           (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
           ;; If this is a String constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] String:) 
               (begin
                  (setq result.Value (mid result.Value 1 (subi (length result.Value) 2)))
                  (setq result.Term true)
                  )) ; end if
           ;; If this is a Symbol constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] Symbol:) 
               (begin
                  (setq result.Value (makeQuotedSymbol (mid result.Value 1 (subi (length result.Value) 2))))
                  (setq result.Term true)
                  )) ; end if
           (return result)
           )) ;; end if delimited constant
    ;; Is this token an integer constant?
    (if (isInteger token) 
        (begin
           (setq result (new Structure: Value: token  Integer: true  Number: true  Term: true))
           (return result)
           )) ;; end if integer constant
    ;; Is this token a numeric constant?
    (if (isNumber token) 
        (begin
           (setq result (new Structure: Value: token  Number: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Is this token a name token?
    (if (isCharName token) 
        (begin
           (setq result (new Structure: Value: token  Name: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Create a default attributed structure for this token
    (setq result (new Structure: Value: token Default: true))
    result) ;; end defaultTokenRule

;;*********************************************************************
;; Constant Folding Function 
;;*********************************************************************
(defchild gsm.estimator foldConstants(struct op x y) 
    vars:(f n)
    (setq f (getGlobalValue (symbol op)))
    (cond 
      ((= op |+|:) (setq n (+ x y)))
      ((= op |-|:) (setq n (- x y)))
      ((= op |*|:) (setq n (* x y)))
      ((= op |/|:) (setq n (pdiv x y)))
      ((= op |pdiv|:) (setq n (pdiv x y)))
      ((= op |%|:) (setq n (pmod x y)))
      ((= op |#|:) (setq n (pmod x y)))
      ((= op |pmod|:) (setq n (pmod x y)))
      ((= op |and|:) (setq n (and x y)))
      ((= op |or|:) (setq n (or x y)))
      ((= op |<|:) (setq n (< x y)))
      ((= op |<=|:) (setq n (<= x y)))
      ((= op |=|:) (setq n (= x y)))
      ((= op |!=|:) (setq n (<> x y)))
      ((= op |>=|:) (setq n (>= x y)))
      ((= op |>|:) (setq n (> x y)))
      (else (error (append "gsm.estimator.foldConstants: unknown operator=[" op "]")))
      ) ; end cond
    (if (<> struct #void)
        (begin
           (cond
              ((isInteger n) (setq struct.Integer true))
              ((isBoolean n) (setq struct.Boolean true))
              ((isChar n) (setq struct.Character true))
              ((isNumber n) (setq struct.Number true))
              ) ; end cond
           (setq struct.Value (appendList struct.Value n))
           (setVType struct))
        else
        n)) ; end foldConstants

;;*********************************************************************
;; Constructs a java function definition from an argument list.
;;*********************************************************************
(defchild gsm.estimator funList(struct name args body)
    vars:(varList)
    ;; Retrieve all the declare variables
    (setq varList (popVars))
    ;; Set up |()| if there are no arguments.
    (if (= args.Value #void)
        (setq args (symbol "()"))
        (setq args (objectToList args.Value))
        ) ; end if
    ;; Create the function declaration up to the variables
    ;; Note: A function name of #void indicates an unnamed lambda
    (if (= name #void)
        (setq struct.Value (list |lambda|: args))
        (setq struct.Value (list |defun|: name.Value args))
        ) ; end if
    ;; Append the variable declarations (if any)
    (if (<> varList #void)
        (setq struct.Value (appendList struct.Value varList (list body.Value)))
        (setq struct.Value (appendList struct.Value (list body.Value)))
        ) ; end if
    (setq struct.Func true)
    struct) ; end funList

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild gsm.estimator postfix(struct token optok style)
    vars:(op resultTyp inc)
    ;; Determine the type of this operation.
    (cond
       ;; Manage a Boolean operation.
       ((= token.VType bool:)
        (begin
           (setq op optok.Boolop)
           (setq inc 1)
           (setq resultTyp optok.Booltyp)
        )) ; end Boolean operation
       ;; Manage a Character operation.
       ((= token.VType char:)
        (begin
           (setq op optok.Charop)
           (setq inc 1)
           (setq resultTyp optok.Chartyp)
        )) ; end Character operation
       ;; Manage an Integer operation.
       ((= token.VType int:)
        (begin
           (setq op optok.Intop)
           (setq inc 1)
           (setq resultTyp optok.Inttyp)
        )) ; end Integer operation
       ;; Manage a Number operation.
       ((= token.VType float:)
        (begin
           (setq op optok.Floatop)
           (setq inc 1.0)
           (setq resultTyp optok.Floattyp)
        )) ; end Number operation
       ;; Manage all other types.
       (else
        (begin
           (setq op optok.Lisp)
           (setq inc 1)
           (setq resultTyp obj:)
        )) ; end all other types
       ) ; end cond
    (setq struct.VType resultTyp)
    (if (= style false)
        (setq struct.Value (list |setq|: token.Value (list op token.Value inc)))
        else
        (setq struct.Value 
               (list |begin|: 
                   (list |setq|: |_currentResult|: token.Value) 
                   (list |setq|: token.Value (list op token.Value inc))
               _currentResult:))
        ) ; end if
    struct) ; end postfix

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild gsm.estimator qualifyName(struct target index indexExp)
    vars:(refOp setOp)
    (if (= target.VType #void) (setVType target))
    (setq struct.VType tokenDirectory[target.VType].Reftyp)
    ;; Determine the reference operator for this name qualifier.
    (cond
        ;; Manage a single strongly typped index expression.
        ((and (or (= index.VType int:) (= index.VType char:) (= index.VType bool:)) (<> target.VType #void) (<= (length indexExp) 1))
         (begin
	         (setq refOp tokenDirectory[target.VType].Refop)
		     (if (isVector indexExp) 
			     (setq struct.Value (append (list refOp target.Value) (objectToList indexExp)))
			     (setq struct.Value (list refOp target.Value indexExp))
		         ) ; end if
	          (setq struct.Setop tokenDirectory[target.VType].Setop)
         )) ; end strong typped case 
        ;; Any other type of reference uses a generic ref qualfier.
        (else
         (begin
		     (if (isVector indexExp) 
	             (setq struct.Value (append (list |ref|: target.Value) (objectToList indexExp)))
	             (setq struct.Value (list |ref|: target.Value indexExp))
		         ) ; end if
	         (setq struct.Setop |setq|:)
		 )) ; end else case
        ) ; end cond
    (setq struct.Name true)
    (setq struct.Term true)
    (setq struct.NAME true)) ; end qualifyName 
    
;;*********************************************************************
;; Sets up an assignment into a singleton or collection target 
;;*********************************************************************
(defchild gsm.estimator assignMe(struct op target newValue)
    ;; Compute assignment operator.
    (cond
        ((and (<> target.Setop #void) (<> target.Setop |setq|:) (isPair target.Value)) 
         (begin
            (setq struct.Value (appendList target.Value (list newValue.Value)))
            (setCar struct.Value target.Setop) 
         )) ; end strong typped case
        (else  
         (setq struct.Value (appendList |setq|: target.Value (list newValue.Value)))
         ) ; end else case
       ) ; end cond
    struct) ; end assignMe 
    
;;*********************************************************************
;; Sets up an math assignment into a singleton or collection target 
;;*********************************************************************
(defchild gsm.estimator assignMath(struct optok target newValue)
    vars:(temp)
    (setq temp (copy struct))
    (setq temp (setExpVType temp target optok newValue))
    (setq struct (assignMe struct optok target temp))
    struct) ; end assignMath 
    
;;*********************************************************************
;; Finds the line number given a character position
;;*********************************************************************
(defchild gsm.estimator findLineNum(pos)
   vars: (i j l)
   (setq l (length $IN))
   (if (< pos l) (setq l pos))
   (loop for i from 0 until l do
      (if (= $IN[i] 10) (setq j (iadd j 1)))
      ); end loop
   j; return number of linefeeds found
   ); end findLineNum

;; --------------------------------------------------------------------
;; User functions for Filter extensions
;; --------------------------------------------------------------------

;;*********************************************************************
;; Extend the normal estimator startRule with these initialization
;; functions required for the Filter extensions.
;; Note: This function will run right after the normal startRule.
;;*********************************************************************
(defchild gsm.estimator startRuleFilterStmt()
    pvars:(autoCheck           ;; The function for generating auto check truncation.
           autoCheckSW         ;; The switch for auto checking on/off.
           autoXReferentSW     ;; The switch for automatic field names to x referents on/off.
           haveSeenDataCmdsSW  ;; The we have seen dataMineLib filter/score commands switch.
           fieldRefs           ;; The dictionary of field name references seen.
           KB                  ;; The rule base for x to y referent conversion.
           OKB                 ;; The rule base for optimizing the final filter Lambda.
          ) ; end of persistent variables
    ;; Initialize the automatic field names to x referents switch.
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    ;; Initialize the variable vectors.
    (setq pvarVector (new Vector: 0))
    (setq varVector (new Vector: 0))
    (setq avarVector (new Vector: 0))
    ;; Initialize the field references Dictionary.
    (setq autoCheckSW true)
    (setq fieldRefs (new Dictionary:))
    ;; Initialize the rulesLib for swapping x and y referents.
    (setq KB (new rulesLib))
    (KB.assert '(ref xv $X) '(ref yv $X))
    (setq KB.singlePass false)
    ;; Initialize the rulesLib for optimizing the final filter Lambda.
    (setq OKB (new rulesLib))
    (OKB.assert '(($X*)) '$X)
    (OKB.assert '(begin $X) '$X)
    ;; ---------------------------------------------------------------
    ;; merge filter statement All commands to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref XT truncate:) (lambda (xv) $E $P1)) 
                      ((ref XT truncate:) (lambda (xv) $E $P2)) $B*)                  
                  '(<$> $A (((ref XT truncate:) (lambda (xv) $E (and $P1 $P2)))) $B))

    (OKB.assert '($A* ((ref XT truncate:) (let $V (lambda (xv) $E $P1))) 
                      ((ref XT truncate:) (let $V (lambda (xv) $E $P2))) $B*)                  
                  '(<$> $A (((ref XT truncate:) (let $V (lambda (xv) $E (and $P1 $P2))))) $B))
    ;; ---------------------------------------------------------------
    ;; merge filter statement All commands with field check at beginning
    ;;                        of sort command to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref XT truncate:) (lambda (xv) $E1 $P1)) 
                      (begin ((ref XT truncate:) (lambda (xv) $E $P2)) $B*) $C*)                  
                  '(<$> $A (((ref XT truncate:) (lambda (xv) $E (and $P1 $P2)))) $B $C))

    (OKB.assert '($A* ((ref XT truncate:) (let $V (lambda (xv) $E1 $P1))) 
                      (begin ((ref XT truncate:) (let $V (lambda (xv) $E $P2))) $B*) $C*)                  
                  '(<$> $A (((ref XT truncate:) (let $V (lambda (xv) $E (and $P1 $P2))))) $B $C))
    ;; ---------------------------------------------------------------
    ;; merge filter statement Omit commands to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref XT omit:) (lambda (xv) $E $P1)) 
                      ((ref XT omit:) (lambda (xv) $E $P2)) $B*)                  
                  '(<$> $A (((ref XT omit:) (lambda (xv) $E (or $P1 $P2)))) $B))

    (OKB.assert '($A* ((ref XT omit:) (let $V (lambda (xv) $E $P1))) 
                      ((ref XT omit:) (let $V (lambda (xv) $E $P2))) $B*)                  
                  '(<$> $A (((ref XT omit:) (let $V (lambda (xv) $E (or $P1 $P2))))) $B))

    ;; ---------------------------------------------------------------
    ;; Turn off all rulesLib assertions so we can use the new compiled semantic rules.
    ;; ---------------------------------------------------------------
    (setq OKB (new rulesLib))

    ;; Initialize the rulesLib for single pass.
    (setq OKB.singlePass false)
    true) ; end startRule

;;*********************************************************************
;; Create a lambda list enclosed in a let expression, which contains
;; definitions of all the locally defined variables.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator letLambda(...)
    vars:(letList lambdaList result i argc varCount vecLast)
    ;; Set up the letList expression with the locally defined variables.
    (setq letList #void)
    (setq vecLast (subi (length varVector) 1))
    ;; If the Name is a registered cvar, then add it to the let lambda list.
    (setq varCount (length cvarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list cvarVector[vecLast][i 0] cvarVector[vecLast][i 0]))))
       ) ; end cvar loop
    ;; If the Name is a registered pvar, then add it to the let lambda list.
    (setq varCount (length pvarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list pvarVector[vecLast][i 0] pvarVector[vecLast][i 0]))))
       ) ; end pvar loop
    ;; If the Name is a registered var, then add it to the let lambda list.
    (setq varCount (length varVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list varVector[vecLast][i 0] varVector[vecLast][i 0]))))
       ) ; end var loop
    ;; If the Name is a registered arg, then add it to the let lambda list.
    (setq varCount (length avarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list avarVector[vecLast][i 0] avarVector[vecLast][i 0]))))
       ) ; end avar loop
    ;; Add all the arguments to the let lambda list.
    (setq argc (argCount))
    (setq lambdaList (list lambda:))
    (loop for i from 0 until argc do
       (setq lambdaList (append lambdaList (list (argFetch i)))) 
       ) ; end arg loop
    ;; Add the let list and the let lambda list together.
    (if (= letList #void)
        (setq result lambdaList)
        (setq result (list let: letList lambdaList))    
        ) ; end if
    result) ; end letLambda

;;*********************************************************************
;; Run the named current project filter on the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator runFilter(struct filterName)
    vars:(cutLambda errLambda)
    ;; If filter name is void, then return true.
    (if (= filterName #void) (return (setq struct.Value true)))
    ;; Create a call to the specified function.
    (if (isPair filterName) (return (setq struct.Value filterName)))
    ;; Create a call to the runProjectFilter function from the arguments.
    (setq struct.Value (list (list |ref|: (list |ref|: dataMineLib: ''miner) ''runProjectFilter) filterName XT:))
    (setq autoXReferentSW false)
    struct) ; end runFilter

;;*********************************************************************
;; Create an updateView lambda of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator filterUpdate(struct name setExp resetSW)
    vars:(setLambda errLambda)
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a set lambda from the arguments.
    (setq setLambda (letLambda (list  xv:) errLambda (list setq: name setExp)))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= resetSW true)
        then
        (setq struct.Value (list (list |ref|: XT: ''updateView) setLambda))
        else
        (setq struct.Value (list (list |ref|: XT: ''updateView) setLambda ''noreset))
        ) ; end if
    (setq autoXReferentSW false)
    (setq fieldRefs (new Dictionary:))
    struct) ; end filterUpdate

;;*********************************************************************
;; Create a find cut of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator fieldCut(struct cutExp command)
    vars:(cutLambda errLambda)
    ;; If cut expression is void, then return true.
    (if (= cutExp #void) (return (setq struct.Value true)))
    ;; If the command is to omit, then turn auto checking off.
    (if (= command "omit") (setq autoCheckSW false))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a cut lambda from the arguments.
    (setq cutLambda (letLambda (list xv:) errLambda cutExp))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= command "omit")
        (setq struct.Value (list (list |ref|: XT: ''omit) cutLambda))
        (setq struct.Value (list (list |ref|: XT: ''truncate) cutLambda))
        ) ; end if
    (setq autoXReferentSW false)
    struct) ; end fieldCut

;;*********************************************************************
;; Extract columns from the the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator extractColumns(struct spineVectorType extractExp)
    vars:(extractLambda errLambda)
    ;; If cut expression is void, then return true.
    (if (= extractExp #void) (return (setq struct.Value true)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) #void)))
    ;; Create an extraction lambda from the arguments.
    (setq extractLambda (letLambda (list xv:) errLambda extractExp))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create an extract lambda to eliminate any void fields.
    (addToBeginList struct (list (list |ref|: XT: ''extractColumns) (makeQuotedSymbol spineVectorType) extractLambda))
    (setq autoXReferentSW false)
    struct) ; end extractColumns

;;*********************************************************************
;; Create a find cut of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator filterCut(struct cutExp command)
    vars:(cutLambda errLambda)
    ;; If cut expression is void, then return true.
    (if (= cutExp #void) (return (setq struct.Value true)))
    ;; If the command is to omit, then turn auto checking off.
    (if (= command "omit") (setq autoCheckSW false))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a cut lambda from the arguments.
    (setq cutLambda (letLambda (list xv:) errLambda cutExp))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= command "omit")
        (addToBeginList struct (list (list |ref|: XT: ''omit) cutLambda))
        (addToBeginList struct (list (list |ref|: XT: ''truncate) cutLambda))
        ) ; end if
    (setq autoXReferentSW false)
    struct) ; end filterCut

;;*********************************************************************
;; Create an inline sort followed by a cut of the all row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator highestCut(struct eyExp cutExp)
    vars:(selectLambda eyLambda)
    ;; If regress expression is void, then return true.
    (if (= eyExp #void) (return (setq struct.Value true)))
    ;; Create a select lambda from the arguments.
    (setq eyLambda (string eyExp true))
    ;; Create a validate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create the proper expression for the select loop.
    (setq selectLambda  "(lambda (XT) pvars:(Number:B Number:NLSE Number:Penalty Notes WFF Rule Genome) vars:(n N Number:ey Number:ty) vars:(NumVector:xv NumVector:EY rows) (onError (lambda(s) false)) (setq rows XT.selectedRows) (setq N (length rows)) (setq EY (|Gv:new| Vector: Number: N)) (loop for n from 0 until N do (setq xv rows[n]) (setq ey {***replace me***}) (setq EY[n] ey)) (XT.truncate EY) XT)" )
    (setq selectLambda (substitute selectLambda "{***replace me***}" eyLambda))
    (addToBeginList struct (Lisp selectLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end highestCut

;;*********************************************************************
;; Create a sort followed by a tile of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator sliceCut(struct relOp fieldExp tileIndexExp tileCountExp)
    vars:(yReferent sortLambda errLambda)
    ;; Create a y referent version of the field expression.
    (setq yReferent (KB.apply (copy fieldExp)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a sort lambda from the arguments.
    (setq sortLambda (letLambda (list  xv:  yv:) errLambda (list relOp fieldExp yReferent)))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create sort and tile commands from the various lambdas.
    (addToBeginList struct (list (list |ref|: XT: ''sort) sortLambda))
    (addToBeginList struct (list (list |ref|: XT: ''tile) tileCountExp tileIndexExp))
    (setq autoXReferentSW false)
    struct) ; end sliceCut

;;*********************************************************************
;; Create a sort followed by a cut of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator sortCut(struct relOp fieldExp cutExp)
    vars:(yReferent sortLambda errLambda)
    ;; Create a y referent version of the field expression.
    (setq yReferent (KB.apply (copy fieldExp)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a sort lambda from the arguments.
    (setq sortLambda (letLambda (list xv: yv:) errLambda (list relOp fieldExp yReferent)))
    ;; Create a truncate lambda to eliminate any void fields.
    ;(addToBeginList struct (autoCheck))
    ;; Create sort and cut commands from the various lambdas.
    (if (< cutExp -1)
        (addToBeginList struct (list (list |ref|: XT: ''sort) sortLambda ''backup))
        (addToBeginList struct (list (list |ref|: XT: ''sort) sortLambda))
        ) ; end if
    (cond
        ;; Create cut command for integer cuts
        ((>= cutExp 1) (addToBeginList struct (list (list |ref|: XT: ''truncate) cutExp)))
        ;; Create cut command for percent cuts
        ((>= cutExp 0) (addToBeginList struct 
                           (list (list |ref|: XT: ''truncate) 
                                 (list integer: 
                                       (list *: (list |ref|: XT: ''recordCount) cutExp)))))
        ;; Do not create a cut command for negative cuts
        ) ; end cond
    (setq autoXReferentSW false)
    struct) ; end sortCut

;;*********************************************************************
;; Set automatic field name to x referent conversion on. 
;;*********************************************************************
(defchild gsm.estimator xReferentOn() (setq haveSeenDataCmdsSW (setq autoXReferentSW true)))

;;*********************************************************************
;; Set automatic field name to x referent conversion off. 
;;*********************************************************************
(defchild gsm.estimator xReferentOff() (setq autoXReferentSW false) (setq haveSeenDataCmdsSW true))

;;*********************************************************************
;; Create an x referent expression from a record field name. 
;;*********************************************************************
(defchild gsm.estimator xReferent(struct nameStruct)
    vars:(vname fieldNameSW vecLast)
    ;; Determine whether or not the variable is 
    ;; a field name, or a registered variable name.
    (setq vname nameStruct.Value) 
    (setq fieldNameSW true)
    (setq vecLast (subi (length varVector) 1))
    (if (<> gvarVector[0][vname] #void) (setq fieldNameSW false))
    ;; If the Name is a registered cvar, then this is not a field name.
    (if (<> cvarVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered pvar, then this is not a field name.
    (if (<> pvarVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered var, then this is not a field name.
    (if (<> varVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered arg, then this is not a field name.
    (if (<> avarVector[vecLast][vname] #void) (setq fieldNameSW false))
    ;; Check to see if the name is a valid column name.
    ;; Note: old code ==> (if (and (and autoXReferentSW fieldNameSW (<> vname void:) (<> vname nil:)) (isFieldName nameStruct))
    (if (and (and fieldNameSW (<> vname void:) (<> vname nil:)) (isFieldName nameStruct))
        then
        (begin
           ;; If a column name, then record the field in the field references dictionary.
           ;(setq fieldRefs[vname] true)
           (setq fieldRefs[vname] #void)
           ;; If a column name, then return an x reference to the record.
           (setq struct.Value (cnvFieldName vname))
           ) ; end then
        else
        (begin
           ;; If not column name, then delete the name from the field references dictionary.
           (setq fieldRefs[vname] #void)
           ;; If not a column name, then return the name as entered.
           (setq struct.Value vname)
        )) ; end if
    (setq struct[Charpos:] nameStruct.Charpos)) ; end xReferent

;;*********************************************************************
;; Add an automatic Check command for all record field names seen. 
;;*********************************************************************
(defchild gsm.estimator autoCheck()
    vars:(i checkExp xRef result)
    ;; Set automatic field name to x referent conversion off.
    (setq autoXReferentSW false)
    ;; If auto checking is off, then just return true.
    (if (= autoCheckSW false) (return true))
    ;; Build the auto check command for all referenced fields.
    (loop for i from 0 until (length fieldRefs) do
        ;; Return an x reference to the record field name.
        (setq xRef (list |<>|: (list ref: xv: (makeQuotedSymbol fieldRefs[i 0])) #void))
        ;; Are there previous field references recorded?
        (if (= checkExp #void)
            then
            (setq checkExp xRef)
            else
            (setq checkExp (list and: checkExp xRef))
            ) ; end if
        ) ; end loop
    ;; Create a truncate expression.
    (setq result (fieldCut (new Structure:) checkExp "all"))
    (setq fieldRefs (new Dictionary:))
    result.Value) ; end autoCheck

;;*********************************************************************
;; Turn off automatic Checking for all record field names seen. 
;;*********************************************************************
(defchild gsm.estimator autoCheckOff(struct)
    ;; Turn off auto checking.
    (setq autoCheckSW false)
    (setq fieldRefs (new Dictionary:))
    (setq struct.Value true)) ; end autoCheckOff

;;*********************************************************************
;; Turn on automatic Checking for all record field names seen. 
;;*********************************************************************
(defchild gsm.estimator autoCheckOn(struct)
    ;; Turn on auto checking.
    (setq autoCheckSW true)
    (setq fieldRefs (new Dictionary:))
    (setq struct.Value true)) ; end autoCheckOn

;;*********************************************************************
;; Create a final filter expression on the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator filterFinal(filterExp)
    vars:(result)
    ;; Do nothing, if we've never seen a dataMineLib filter command.
    (if (<> haveSeenDataCmdsSW true) (return filterExp))
    ;; We must add a lambda wrapper if we are stand alone or global.
    (if (<= (length pvarVector) 0)
        then
        ;; If we are stand alone or global, add a lambda wrapper.
        (setq result (list lambda: (list XT:) ''|pvars| (list ''Number B: ''Number NLSE: ''Number Penalty: WFF: Rule: Genome:) filterExp))
        else
        ;; If we are inside an existing function, add a begin wrapper.
        (setq result (list (symbol "begin") filterExp))
        ) ;; end if
    (setq fieldRefs (new Dictionary:))
    (setq result (OKB.apply (copy result)))
    (setq autoXReferentSW false)
    (if (= result '(begin true #void)) (setq result (list )))
    (if (= result '(lambda (XT) true #void XT)) (setq result (list )))
    result) ; end filterFinal

;;*********************************************************************
;; Create a score cut of the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator scoreCut(struct scoreExp command)
    vars:(scoreLambda errLambda)
    ;; If score expression is void, then return zero.
    (if (= scoreExp #void) (return (setq struct.Value 0)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a score lambda from the arguments.
    (setq scoreLambda (letLambda (list xv:) errLambda scoreExp))
    ;; Create a score command from the various lambda.
    (setq struct.Value (list (list |ref|: XT: (makeQuotedSymbol command)) scoreLambda))
    (setq autoXReferentSW false)
    struct) ; end scoreCut

;;*********************************************************************
;; Create a final score expression on the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator scoreFinal(scoreExp)
    vars:(result)
    ;; Do nothing, if we've never seen a dataMineLib score command.
    (if (<> haveSeenDataCmdsSW true) (return scoreExp))
    ;; We must add a lambda wrapper if we are stand alone or global.
    (if (<= (length pvarVector) 0)
        then
        ;; If we are stand alone or global, add a lambda wrapper.
        (setq result (list lambda: (list XT:) scoreExp))
        else
        ;; If we are inside an existing function, add a begin wrapper.
        (setq result (list (symbol "begin") scoreExp))
        ) ;; end if
    (setq fieldRefs (new Dictionary:))
    (setq result (OKB.apply (copy result)))
    result) ; end scoreFinal

;;*********************************************************************
;; Create a regression Lambda for the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator filterScale(struct regressExp)
    vars:(regressLambda eyLambda)
    ;; If regress expression is void, then return true.
    (if (= regressExp #void) (return (setq struct.Value true)))
    ;; Create a regress lambda from the arguments.
    (setq eyLambda (string regressExp true))
    ;; Create a regress lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create the proper expression for the regression loop.
    (setq regressLambda "(lambda (NumVector:xv) regs:(Number:ey ) (onError (lambda(s) false)) (setq ey {***replace me***}) (gsm@validate ey))" )
    (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end filterScale































































































;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS.templateRegressFrm
;; ********************************************************************
;; summary:  estimator User defined functions
;;
;; 			 Compile time child Lambdas for the estimator compiler.
;; 			 These child Lambdas support the estimator compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; ********************************************************************

;;*********************************************************************
;; Create a regression Lambda for the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator templateRegressFrm(struct expressionVector)
    regs:(n N)
    vars:(regressLambda eyLambda cvLambda )
    ;; Create the proper Estimator FRM Lambda based upon the contents of the expression vector.
    ;; Create a regress lambda from the arguments.
    (setq eyLambda "(Frm xv)")
    ;; Create a conversion lambda from the expression vector.
    (setq N (length expressionVector))
    (setq cvLambda (append "(setq xxv (new Vector: Number: " N "))")) 
    (loop for n from 0 until N do
       (setq cvLambda (append cvLambda " (setq fx " (string expressionVector[n] true) ") (setq xxv[" n "] fx)"))
       ) ; end expression loop
    ;; Create a regress lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create the proper expression for the regression loop.
    (setq regressLambda (append {
                                (lambda (NumVector:xv) 
                                  pvars:(Integer:ID (Train full:) (Number:A 0.0) (Number:B 1.0) Number:AvgYSq Number:BandNLSE (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) NumVector:EY Frm WFF JSRC Rule Genome convert run score train)  
                                  (defun convert(NumVector:xv) 
                                     regs:(n N) 
                                     regs:(Number:fx ) 
                                     vars:(NumVector:xxv) 
                                     {***convert me***} 
                                     xxv)
                                  (defun run(ObjVector:X) 
                                     regs:(n N) 
                                     regs:(Number:y Number:fx ) 
                                     vars:(NumVector:xv NumVector:ey) 
                                     vars:(ObjVector:XX) 
                                     (onError (lambda(s) false)) 
                                     (setq N (length X))
                                     (setq M (length X[0])) 
                                     (+= gsm.myTotalEvaluations (number (* M N)))
                                     (setq XX (copy X)) 
                                     (loop for n from 0 until N do (setq XX[n] (convert X[n]))) 
                                     (setq X XX) 
                                     (Frm.rescale X) 
                                     (setq ey (new Vector: Number: N)) 
                                     (loop for n from 0 until N do 
                                       (setq xv X[n]) 
                                       (setq fx {***replace me***}) 
                                       (setq y B) 
                                       (*= y fx) 
                                       (+= y A) 
                                       (setq y (gsm@validate y)) 
                                       (setq ey[n] y)) 
                                     ey)  
                                  (defun score(ObjVector:X NumVector:Y) 
                                     regs:(n N) 
                                     regs:(Number:y Number:fx Number:ey Number:err Number:errPct) 
                                     vars:(NumVector:xv (isEYConstant true)) 
                                     vars:(ObjVector:XX) 
                                     (onError (lambda(s) false)) 
                                     (setq NLSE BIGPOSNUM)   
                                     (setq TCE BIGPOSNUM)
                                     (setq N (length X))
                                     (setq M (length X[0])) 
                                     (+= gsm.myTotalEvaluations (number (* M N)))
                                     (setq XX (copy X)) 
                                     (loop for n from 0 until N do (setq XX[n] (convert X[n]))) 
                                     (setq X XX) 
                                     (Frm.rescale X) 
                                     (setq EY (new Vector: Number: N)) 
                                     (loop for n from 0 until N do 
                                       (setq y Y[n]) 
                                       (setq xv X[n]) 
                                       (setq fx {***replace me***}) 
                                       (setq ey B) 
                                       (*= ey fx) 
                                       (+= ey A) 
                                       (setq EY[n] (setq ey (gsm@validate ey)))                                       
                                       (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                       (setq eyOld ey)
                                       (setq err (- ey y))
                                       (*= err err)
                                       (if (< BIGPOSNUM err) (return false))
                                       (+= errPct err))
	                                 (/= errPct (number N))
                                     (vmregSqrtNumber errPct errPct)
                                     (/= errPct gsm.myYStdev)
                                     ;; Disallow constant functions where myY is not also a constant. 
                                     (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                     (setq NLSE (gsm@validate errPct))
                                     (if (<= BIGPOSNUM NLSE) (return false))
                                     NLSE)  
                                  (defun train(ObjVector:X NumVector:Y ...) 
                                     regs:(n N) 
                                     regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err) 
                                     regs:(Number:xmean Number:xsum Number:x) 
                                     regs:(Number:ymean Number:ysum Number:y) 
                                     regs:(Number:xxdot Number:yydot Number:xydot) 
                                     vars:(ObjVector:XX NumVector:xv NumVector:EY) 
                                     (onError (lambda(s) false)) 
                                     (setq XX (copy X)) 
                                     (setq N (length X))
                                     (setq M (length X[0])) 
                                     (+= gsm.myTotalRegressions (number (* M N)))
                                     (loop for n from 0 until N do (setq XX[n] (convert X[n]))) 
                                     (setq Frm (gsm.frmRegress XX Y)) 
                                     (setq A 0.0)   
                                     (setq B 1.0)   
                                     ;; Now regress for the final A and B coefficients   
                                     (setq EY (run X))   
                                     (+= gsm.myTotalEvaluations (number (* M N)))
                                     (loop for n from 0 until N do 
                                        (setq y Y[n]) 
                                        (setq x EY[n]) 
                                        (+= xsum x) 
                                        (+= ysum y) 
                                        (+= xxdot (* x x)) 
                                        (+= xydot (* x y)) 
                                        (+= yydot (* y y)))                                           
                                     (setq xmean (/ xsum N)) 
                                     (setq ymean (/ ysum N)) 
                                     (setq AvgY ymean) 
                                     (setq numerator (- xydot (* ysum xmean))) 
                                     (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                                     (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                                     (setq a (- ymean (* b xmean))) 
                                     (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                                     (setq A (gsm@validate a))
                                     (setq B (gsm@validate b))
                                     (setq NLSE BIGPOSNUM)   
                                     true) 
                                  regs:(Number:y Number:fx )
                                  (setq M (length xv)) 
                                  (+= gsm.myTotalEvaluations M)
                                  (setq xv (convert xv)) 
                                  (setq fx {***replace me***}) 
                                  (setq y B) 
                                  (*= y fx) 
                                  (+= y A) 
                                  (setq y (gsm@validate y)) 
                                  y)
                                }))
    (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
    (setq regressLambda (substitute regressLambda "{***convert me***}" cvLambda))
    ;; Complete the final Estimator SVM Lambda as a ParseLib attributed grammar token.
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end templateRegressFrm


















































































;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS.templateRegressMdl
;; ********************************************************************
;; summary:  estimator User defined functions
;;
;; 			 Compile time child Lambdas for the estimator compiler.
;; 			 These child Lambdas support the estimator compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; ********************************************************************

;;*********************************************************************
;; Create a grammar swarm variable Lambda for the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator templateRegressMdl(struct expressionVector)
    regs:(n N)
    vars:(regressLambda eyLambda ncc nee nvv nff ntt)
    ;; Create a regression lambda from the expression vector.
    (setq N (length expressionVector))
    (if (= N 0) (return (setq struct.Value true)))
    (if (= N 1)
        then 
        (setq eyLambda (string expressionVector[0] true))
        else
        (begin
          (setq eyLambda "(+")
          (loop for n from 0 until N do
            (setq eyLambda (append eyLambda " " (string expressionVector[n] true)))
            ) ; end expression loop
          (setq eyLambda (append eyLambda " )"))
        )) ; end expressionVector if
    ;; Create a regress lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create a the length of the constant vector.
    (setq maxConstants (integer maxConstants))
    (setq ncc (string maxConstants))
    ;; Create a the length of the constant vector.
    (setq maxNoiseTerms (integer maxNoiseTerms))
    (setq nee (string maxNoiseTerms))
    ;; Create a the length of the variable vector.
    (setq maxVariables (integer maxVariables))
    (setq nvv (string maxVariables))
    ;; Create a the length of the abstract operator vector.
    (setq maxAbsOperators (integer maxAbsOperators))
    (setq nff (string maxAbsOperators))
    ;; Create a the length of the terms vector.
    (setq maxTerms (integer maxTerms))
    (setq ntt (string maxTerms))
    ;; Create the proper expression for the regression loop.
    (setq regressLambda (append {(lambda (NumVector:xv) 
                                    pvars:(Integer:ID (Train full:)   
                                           (Number:A 0.0) (Number:B 1.0) NumVector:CC IntVector:VV IntVector:FF NumVector:EE ObjVector:AG BitVector:TT 
	                                       (Integer:PNN {***PNN***}) (Number:F {***F***}) (Integer:GEN {***GEN***}) (Integer:TRY {***TRY***}) (Integer:FTLEN {***FTLEN***})
                                           (Integer:CCN {***CCN***}) (Integer:VVN {***VVN***}) (Integer:FFN {***FFN***}) (Integer:EEN {***EEN***}) (Integer:TTN {***TTN***}) (Integer:GAP {***GAP***})                                      
                                           (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) Number:BandNLSE (learning trainDE:)                                           
                                           Number:MinScore Integer:TrainGens NumVector:EY Number:AvgY Number:AvgYSq 
                                           WFF JSRC Rule Genome
                                           ;; WARNING: These operators in their number and order must match expressionGrammarGso.myAbstractOperators vector exactly!
                                           (FT #(obj| _fadd _fsub _fmul _fdiv _fcos _fsin _ftan _ftanh _flog _fsqrt _fsquare _fcube _fnop ))
                                           _fadd _fsub _fmul _fdiv _fcos _fsin _ftan _ftanh _flog _fsqrt _fsquare _fcube _fnop
                                           _favg _fmax _fmin _fmod _fexpt _fabs _fexp _frac _fint _finv _fsig _fsgn
                                           evaluate run score train trainMore trainDE trainPSO)
                                    (defun _fabs(a1 ...) (abs a1))
                                    (defun _fadd(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (+ a1 a2)))
                                    (defun _favg(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (avg a1 a2)))
                                    (defun _fcos(a1 ...) (cos a1))
                                    (defun _fcube(a1 ...) (* a1 a1 a1))
                                    (defun _fdiv(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (if (<> a2 0.0) (number (/ a1 a2)) 0.0))
                                    (defun _fexp(a1 ...) (exp a1))
                                    (defun _fexpt(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (expt a1 a2)))
                                    (defun _fint(a1 ...) (ninteger a1))
                                    (defun _finv(a1 ...) (if (<> a1 0.0) (number (/ 1.0 a1)) 0.0))
                                    (defun _flog(a1 ...) (log (abs a1)))
                                    (defun _fmax(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 a1)) (number (max a1 a2)))
                                    (defun _fmin(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 a1)) (number (min a1 a2)))
                                    (defun _fmod(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (mod a1 a2)))
                                    (defun _fmul(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (* a1 a2)))
                                    (defun _fnop(a1 ...) a1)
                                    (defun _frac(a1 ...) (fraction a1))
                                    (defun _fsub(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (- a1 a2)))
                                    (defun _fsgn(a1 ...) (sign a1))
                                    (defun _fsig(a1 ...) (abs (fraction a1)))
                                    (defun _fsin(a1 ...) (sin a1))
                                    (defun _fsqrt(a1 ...) (sqrt (abs a1)))
                                    (defun _fsquare(a1 ...) (* a1 a1))
                                    (defun _ftan(a1 ...) (tan a1))
                                    (defun _ftanh(a1 ...) (tanh a1))
                                    (defun _evaluate(ObjVector:X NumVector:Y) 
                                       regs:(n N) 
                                       regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err) 
                                       regs:(Number:xmean Number:xsum Number:x Number:highX) 
                                       regs:(Number:ymean Number:ysum Number:y Number:lowX) 
                                       regs:(Number:xxdot Number:yydot Number:xydot) 
                                       vars:(NumVector:xv) 
                                       (onError (lambda(s) false))
                                       (setq NLSE BIGPOSNUM)   
                                       (setq TCE BIGPOSNUM)
                                       (setq N (length X)) 
                                       (setq M (length X[0])) 
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (setq EY (new Vector: Number: N)) 
                                       (setq InvN (/ 1.0 (number N))) 
                                       (setq highX BIGNEGNUM)
                                       (setq lowX BIGPOSNUM)
                                       (loop for n from 0 until N do 
                                          (setq y Y[n]) 
                                          (setq xv X[n]) 
                                          (setq x {***replace me***}) 
                                          (setq x (gsm@validate x)) 
                                          (setq EY[n] x)
                                          (if (< x lowX) (setq lowX x)) 
                                          (if (> x highX) (setq highX x))
                                          (+= err (abs (* (- x y) (- x y)))) 
                                          (+= xsum x) 
                                          (+= ysum y) 
                                          (+= xxdot (* x x)) 
                                          (+= xydot (* x y)) 
                                          (+= yydot (* y y)))                                           
                                       (setq xmean (/ xsum N)) 
                                       (setq ymean (/ ysum N)) 
                                       (setq AvgY ymean) 
                                       (setq numerator (- xydot (* ysum xmean))) 
                                       (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                                       (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                                       (setq A 0.0) 
                                       (setq B 1.0) 
                                       (setq NLSE (setq err (sqrt (abs (* InvN err))))) 
                                       (setq AvgYSq (sqrt (abs (* InvN yydot))))
                                       (if (= lowX highX) (setq NLSE BIGPOSNUM))
                                       (if (<> yydot 0.0) (/= NLSE AvgYSq)) 
                                       (setq NLSE (gsm@validate NLSE))
                                       true)
                                    (defun evaluate(ObjVector:X NumVector:Y) 
                                       regs:(i I n N) 
                                       regs:(Number:InvN Number:a Number:b Number:err Number:score) 
                                       (onError (lambda(s) false))
                                       (setq A 0.0) 
                                       (setq B 1.0) 
                                       (setq NLSE BIGPOSNUM) 
                                       (if (<= EEN 0) (return (_evaluate X Y)))
                                       (if (= EE #void) (setq EE (new Vector: Number: EEN)))
                                       (setq N TRY)
                                       (setq InvN (/ 1.0 (number N))) 
                                       (setq I EEN)
                                       (loop for n from 0 until N do
                                          (loop for i from 0 until I do (setq EE[i] (- (gsm.myRandomFunction 2.0) 1.0)))
                                          (if (<> (_evaluate X Y) true) (return false))
                                          (+= a (* A InvN))
                                          (+= b (* B InvN))
                                          (+= err (* NLSE InvN)))
                                       (loop for i from 0 until I do (setq EE[i] 0.0))
                                       (setq A a) 
                                       (setq B b) 
                                       (setq NLSE err) 
                                       true)
                                    (defun train(ObjVector:X NumVector:Y ...)
                                       ;; Gather training algorithm arguments: X Y genome minScore
                                       regs:(n N me) 
                                       vars:(trainMethod Lambda) 
                                       ;; Populate the Abstract Operator Lambdas Table.
                                       (if (and (= AG #void) (> FFN 0))
										   (begin
                                              (setq me (myself))
                                              (setq AG (new Vector: Object: FTLEN))
                                              (loop for n from 0 until FTLEN do (setq AG[n] me.Pv[FT[n]]))
                                           )) ; end if
                                       ;; Gather arguments and initialize
                                       (if (= learning trainDE:) (setq trainMethod trainDE) (setq trainMethod trainPSO))
                                       (return (trainMethod X Y))
                                       true) 
                                    (defun trainMore(ObjVector:X NumVector:Y generations)
                                       ;; Gather training algorithm arguments: X Y genome minScore
                                       regs:(m M n) 
                                       vars:(trainMethod maxGensSave) 
                                       ;; Initialize
                                       (if (= learning trainDE:) (setq trainMethod trainDE) (setq trainMethod trainPSO))
                                       (setq maxGensSave GEN)
                                       (setq maxGens generations)
                                       (setq result (trainMethod X Y))
                                       (setq GEN maxGensSave)
                                        result)
                                    (defun trainDE(ObjVector:X NumVector:Y) 
                                       ;; Implement the Differential Evolution (DE) training algorithm
                                       regs:(g G m M mm n N nn iError iScore iA iB iBest iBase iP1 iP2 k1 k2) 
                                       regs:(Number:bestScore bestGap) 
                                       regs:(Number:sw Number:minY Number:maxY Number:rangeY Number:halfRangeY Number:ff Number:y) 
                                       vars:(ObjVector:PCC NumVector:PCBest NumVector:PCBase NumVector:PC1 NumVector:PC2) 
                                       vars:(ObjVector:PVV IntVector:PVBest IntVector:PVBase IntVector:PV1 IntVector:PV2) 
                                       vars:(ObjVector:PFF IntVector:PFBest IntVector:PFBase IntVector:PF1 IntVector:PF2) 
                                       vars:(ObjVector:PTT BitVector:PTBest BitVector:PTBase BitVector:PT1 BitVector:PT2) 
                                       (onError (lambda(s) false))
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq A 0.0)
                                       (setq B 1.0)
                                       (setq TrainGens 0) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (setq iError CCN) 
                                       (setq iA (+ CCN 1)) 
                                       (setq iB (+ CCN 2))
                                       (setq iScore (+ CCN 3)) 
                                       (if (and (<= CCN 0) (<= FFN 0) (<= VVN 0) (<= TTN 0)) (return (evaluate X Y)))
                                       (setq maxY (setq minY Y[0]))(loop for n from 1 until N do (setq y Y[n]) (if (< y minY) (setq minY y)) (if (> y maxY) (setq maxY y)))
                                       (setq rangeY (+ (- maxY minY) 1.0)) 
                                       (setq halfRangeY (* rangeY .50)) 
                                       ;; Initialize conditions
                                       (cond
                                        ((and (= CCN 0) (= VVN 1) (= FFN 0) (= TTN 0)) 
                                          ;; Only one abstract variable initialize case
                                          (begin
                                            (setq PNN M)
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until VVN do (setq PVBase[m] n) (setq VV[m] PVBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable initialize case
                                        ((and (= CCN 0) (= VVN 2) (= FFN 0) (= TTN 0)) 
                                          ;; Only two abstract variable initialize case
                                          (begin
                                            (setq PNN (* M M))
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            (setq n 0)
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for nn from 0 until M do 
                                              (loop for mm from 0 until M do 
                                                (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                                (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                                (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                                (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                                (setq PVBase[0] nn) (setq VV[0] PVBase[0])
                                                (setq PVBase[1] mm) (setq VV[1] PVBase[1])
                                                ;; Evaluate each swarm vector and save score.
                                                (evaluate X Y) 
                                                (setq PCBase[iError] NLSE) 
                                                (setq PCBase[iScore] NLSE) 
                                                (setq PCBase[iA] A) 
                                                (setq PCBase[iB] B)
                                                (++ n)))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable initialize case
                                        ((and (= CCN 0) (= VVN 1) (= FFN 1) (= TTN 0)) 
                                          ;; Only one abstract variable and one abstract functioninitialize case
                                          (begin
                                            (setq PNN (* M FTLEN))
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            (setq n 0)
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for nn from 0 until M do 
                                              (loop for mm from 0 until FTLEN do 
                                                (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                                (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                                (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                                (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                                (setq PVBase[0] nn) (setq VV[0] PVBase[0])
                                                (setq PFBase[0] mm) (setq FF[0] PFBase[1])
                                                ;; Evaluate each swarm vector and save score.
                                                (evaluate X Y) 
                                                (setq PCBase[iError] NLSE) 
                                                (setq PCBase[iScore] NLSE) 
                                                (setq PCBase[iA] A) 
                                                (setq PCBase[iB] B)
                                                (++ n)))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable and one abstract functioninitialize case
                                        ((and (= CCN 0) (= VVN 0) (= FFN 1) (= TTN 0)) 
                                          ;; Only one abstract function initialize case
                                          (begin
                                            (setq PNN FTLEN)
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: CCN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of random weights.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until FFN do (setq PFBase[m] n) (setq FF[m] PFBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                            (goto Last:) 
                                          )) ; end Only one abstract function initialize case
                                        (else
                                          ;; General initialize case
                                          (begin
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of random weights.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until CCN do (setq PCBase[m] (- (gsm.myRandomFunction rangeY) halfRangeY)) (setq CC[m] PCBase[m]))
                                              (loop for m from 0 until VVN do (setq PVBase[m] (integer (gsm.myRandomFunction M))) (setq VV[m] PVBase[m]))
                                              (loop for m from 0 until FFN do (setq PFBase[m] (integer (gsm.myRandomFunction FTLEN))) (setq FF[m] PFBase[m]))
                                              (loop for m from 0 until TTN do (setq PTBase[m] (integer (round (gsm.myRandomFunction 1.0)))) (setq TT[m] PTBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                          )) ; end General initialize case
                                        ) ; end initialization cond
                                       ;; Implement the DE training algorithm here.
                                       (setq iBest 0)(loop for n from 1 until PNN do (if (< PCC[n][iScore] PCC[iBest][iScore]) (setq iBest n)))
                                       (setq bestScore PCC[iBest][iScore])
                                       (setq bestGap 0)
                                       (setq G GEN)
                                       (loop for g from 0 until G do
                                         (vmtestescape)
                                         ;(writeln "...DE Training generation [" g "]")
                                         (setq TrainGens g)
                                         (if (>= bestGap GAP)
                                             (begin
                                                ;; Periodically reinitialize each new swarm vector to a set of random weights.
                                                (loop for n from 0 until PNN do
                                                  (if (<> iBest n)
                                                      (begin
                                                        (setq PCBase PCC[n])
                                                        (setq PVBase PVV[n])
                                                        (setq PFBase PFF[n])
                                                        (setq PTBase PTT[n])
                                                        (loop for m from 0 until CCN do (setq PCBase[m] (- (gsm.myRandomFunction rangeY) halfRangeY)) (setq CC[m] PCBase[m]))
                                                        (loop for m from 0 until VVN do (setq PVBase[m] (integer (gsm.myRandomFunction M))) (setq VV[m] PVBase[m]))
                                                        (loop for m from 0 until FFN do (setq PFBase[m] (integer (gsm.myRandomFunction FTLEN))) (setq FF[m] PFBase[m]))
                                                        (loop for m from 0 until TTN do (setq PTBase[m] (integer (round (gsm.myRandomFunction 1.0)))) (setq TT[m] PTBase[m]))
                                                        ;; Evaluate each swarm vector and save score.
                                                        (evaluate X Y) 
                                                        (setq PCBase[iError] NLSE) 
                                                        (setq PCBase[iScore] NLSE) 
                                                        (setq PCBase[iA] A) 
                                                        (setq PCBase[iB] B)
                                                        (if (< NLSE PCC[iBest][iScore]) (setq iBest n))
                                                      )) ; end iBest if
                                                  ) ; end reinitialize loop
                                             (setq bestScore PCC[iBest][iScore])
                                             (setq bestGap 0)
                                             )) ; end if grow candidate pool
                                         (loop for iP1 from 0 until PNN do
                                           Retry:: 
                                           ;; Add a little tournement competition in selecting iP2.
                                           (setq k1 (integer (gsm.myRandomFunction PNN)))
                                           (setq k2 (integer (gsm.myRandomFunction PNN)))
                                           (if (< PCC[k1][iScore] PCC[k2][iScore]) (setq iP2 k1) (setq iP2 k2))
                                           (if (<> iP2 iP1)
                                               (begin
                                                 (setq PCBest PCC[iBest])
                                                 (setq PC1 PCC[iP1])
                                                 (setq PC2 PCC[iP2])
                                                 (setq PVBest PVV[iBest])
                                                 (setq PV1 PVV[iP1])
                                                 (setq PV2 PVV[iP2])
                                                 (setq PFBest PFF[iBest])
                                                 (setq PF1 PFF[iP1])
                                                 (setq PF2 PFF[iP2])
                                                 (setq PTBest PTT[iBest])
                                                 (setq PT1 PTT[iP1])
                                                 (setq PT2 PTT[iP2])
                                                 (setq ff (+ F (gsm.myRandomFunction 1.0)))
                                                 (loop for m from 0 until CCN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq CC[m] (+ PCBest[m] (* ff (- PC1[m] PC2[m])))))
                                                         ((<= sw .60) (setq CC[m] PC1[m]))
                                                         ((<= sw .90) (setq CC[m] PC2[m]))
                                                         (else (setq CC[m] PCBest[m]))))
                                                 (loop for m from 0 until VVN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq VV[m] PVBest[m]))
                                                         ((<= sw .60) (setq VV[m] PV1[m]))
                                                         ((<= sw .90) (setq VV[m] PV2[m]))
                                                         (else (setq VV[m] (integer (gsm.myRandomFunction VVN))))))
                                                 (loop for m from 0 until FFN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq FF[m] PFBest[m]))
                                                         ((<= sw .60) (setq FF[m] PF1[m]))
                                                         ((<= sw .90) (setq FF[m] PF2[m]))
                                                         (else (setq FF[m] (integer (gsm.myRandomFunction FFN))))))
                                                 (loop for m from 0 until TTN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq TT[m] PTBest[m]))
                                                         ((<= sw .60) (setq TT[m] PT1[m]))
                                                         ((<= sw .90) (setq TT[m] PT2[m]))
                                                         (else (setq TT[m] (integer (round (gsm.myRandomFunction 1.0)))))))
                                                 (evaluate X Y)
                                                 (if (< NLSE PC1[iScore])
											         (begin
                                                       (loop for m from 0 until CCN do (setq PC1[m] CC[m])) 
                                                       (loop for m from 0 until VVN do (setq PV1[m] VV[m])) 
                                                       (loop for m from 0 until FFN do (setq PF1[m] FF[m])) 
                                                       (loop for m from 0 until TTN do (setq PT1[m] TT[m])) 
                                                       (setq PC1[iError] NLSE) 
                                                       (setq PC1[iScore] NLSE) 
                                                       (setq PC1[iA] A) 
                                                       (setq PC1[iB] B))) 
                                                 (if (< NLSE PCC[iBest][iScore]) (setq iBest iP1))
                                               )) ; end if
                                           ) ; end PNN loop
                                         (if (>= bestScore PCC[iBest][iScore]) then (++ bestGap) else (begin (setq bestScore PCC[iBest][iScore]) (setq bestGap 0)))             
                                         ) ; end G loop
                                       ;; Select the best swarm vector to represent the training run.
                                       Last::
                                       (loop for n from 0 until PNN do
                                         (setq PCBase PCC[n])
                                         (setq PVBase PVV[n])
                                         (if (< PCBase[iScore] NLSE)
                                             (begin 
                                               (loop for m from 0 until CCN do (setq CC[m] PCBase[m])) 
                                               (loop for m from 0 until VVN do (setq VV[m] PVBase[m])) 
                                               (loop for m from 0 until FFN do (setq FF[m] PFBase[m])) 
                                               (loop for m from 0 until TTN do (setq TT[m] PTBase[m])) 
                                               (setq NLSE PCBase[iError]) 
                                               (setq A PCBase[iA]) 
                                               (setq B PCBase[iB]))))
                                       true)
                                    (defun trainPSO(ObjVector:X NumVector:Y) 
                                       ;; Implement the Particle Swarm (PSO) training algorithm
                                       regs:(g G m M n N) 
                                       regs:(Number:sw Number:weight Number:r1 Number:r2 Number:a Number:b Number:v) 
                                       regs:(iError iScore iA iB iParticle iBest iGBest) 
                                       vars:(ObjVector:VCCurrent ObjVector:VCVelocity ObjVector:VCBest) 
                                       vars:(ObjVector:VVCurrent ObjVector:VVVelocity ObjVector:VVBest) 
                                       vars:(ObjVector:VFCurrent ObjVector:VFVelocity ObjVector:VFBest) 
                                       vars:(NumVector:PCCurrent NumVector:PCVelocity NumVector:PCBest NumVector:GCBest) 
                                       vars:(NumVector:PVCurrent NumVector:PVVelocity NumVector:PVBest NumVector:GVBest) 
                                       vars:(NumVector:PFCurrent NumVector:PFVelocity NumVector:PFBest NumVector:GFBest) 
                                       (onError (lambda(s) false))
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (setq TCE BIGPOSNUM)
                                       (setq NLSE BIGPOSNUM)
                                       (setq A 0.0)
                                       (setq B 1.0)
                                       (setq TrainGens 0) 
                                       (setq iError CCN) 
                                       (setq iA (+ CCN 1)) 
                                       (setq iB (+ CCN 2))
                                       (setq iScore (+ CCN 3)) 
                                       (if (<= CCN 0) (return (evaluate X Y))) 
                                       (setq CC (new Vector: Number: CCN)) 
                                       (setq VV (new Vector: Integer: VVN)) 
                                       (setq FF (new Vector: Integer: FFN)) 
                                       (setq VCCurrent (new Vector: Object: PNN))
                                       (setq VVCurrent (new Vector: Object: PNN))
                                       (setq VFCurrent (new Vector: Object: PNN))
                                       (setq VCVelocity (new Vector: Object: PNN))
                                       (setq VVVelocity (new Vector: Object: PNN))
                                       (setq VFVelocity (new Vector: Object: PNN))
                                       (setq VCBest (new Vector: Object: PNN))
                                       (setq VVBest (new Vector: Object: PNN))
                                       (setq VFBest (new Vector: Object: PNN))
                                       ;; Initialize each swarm location and velocity vectors to a set of random weights.
                                       (loop for n from 0 until PNN do 
                                         (setq VCBest[n] (setq PCBest (new Vector: Number: (+ CCN 4))))
                                         (setq VVBest[n] (setq PVBest (new Vector: Number: VVN)))
                                         (setq VFBest[n] (setq PFBest (new Vector: Number: FFN)))
                                         (setq VCCurrent[n] (setq PCCurrent (new Vector: Number: (+ CCN 4))))
                                         (setq VVCurrent[n] (setq PVCurrent (new Vector: Number: VVN)))
                                         (setq VFCurrent[n] (setq PFCurrent (new Vector: Number: FFN)))
                                         (loop for m from 0 until CCN do (setq PCCurrent[m] (- (gsm.myRandomFunction 2.0) 1.0)) (setq CC[m] PCCurrent[m]) (setq PCBest[m] PCCurrent[m]))
                                         (loop for m from 0 until VVN do (setq PVCurrent[m] (- (gsm.myRandomFunction (* 16.0 M)) (* 8.0 M))) (setq VV[m] (modi (abs PVCurrent[m]) M)) (setq PVBest[m] PVCurrent[m]))
                                         (loop for m from 0 until FFN do (setq PFCurrent[m] (- (gsm.myRandomFunction (* 16.0 FTLEN)) (* 8.0 FTLEN))) (setq FF[m] (modi (abs PFCurrent[m]) FTLEN)) (setq PFBest[m] PFCurrent[m]))
                                         (setq VCVelocity[n] (setq PCVelocity (new Vector: Number: CCN)))
                                         (setq VVVelocity[n] (setq PVVelocity (new Vector: Number: VVN)))
                                         (setq VFVelocity[n] (setq PFVelocity (new Vector: Number: FFN)))
                                         (loop for m from 0 until CCN do (setq PCVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         (loop for m from 0 until VVN do (setq PVVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         (loop for m from 0 until FFN do (setq PFVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         ;; Evaluate each swarm location and save score.
                                         (evaluate X Y) 
                                         (setq PCCurrent[iError] NLSE) 
                                         (setq PCCurrent[iScore] NLSE) 
                                         (setq PCCurrent[iA] A) 
                                         (setq PCCurrent[iB] B)
                                         (setq PCBest[iError] NLSE) 
                                         (setq PCBest[iScore] NLSE) 
                                         (setq PCBest[iA] A) 
                                         (setq PCBest[iB] B))
                                       (setq iGBest 0)(loop for n from 1 until PNN do (if (< VCBest[n][iScore] VCBest[iGBest][iScore]) (setq iGBest n)))
                                       (setq GCBest VCBest[iGBest])
                                       (setq GVBest VVBest[iGBest])
                                       ;; Implement the PSO training algorithm here.
                                       (setq G GEN)
                                       (loop for g from 0 until G do
                                         (vmtestescape)
                                         (setq TrainGens g) 
                                         (setq weight (+ .25 (/ (- G g) G)))
                                         (loop for n from 0 until PNN do
                                           (setq r1 (gsm.myRandomFunction 2.0))
                                           (setq r2 (gsm.myRandomFunction 2.0))
                                           (setq PCCurrent VCCurrent[n])
                                           (setq PCVelocity VCVelocity[n])
                                           (setq PCBest VCBest[n])
                                           (loop for m from 0 until CCN do
                                             (setq a (* weight r1 (- PCBest[m] PCCurrent[m])))
                                             (setq b (* weight r2 (- GCBest[m] PCCurrent[m])))
                                             (setq v (+ PCVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PCVelocity[m] v)
                                             (setq PCCurrent[m] (+ PCCurrent[m] v))
                                             (setq CC[m] PCCurrent[m]))
                                           (setq PVCurrent VVCurrent[n])
                                           (setq PVVelocity VVVelocity[n])
                                           (setq PVBest VVBest[n])
                                           (loop for m from 0 until VVN do
                                             (setq a (* weight r1 (- PVBest[m] PVCurrent[m])))
                                             (setq b (* weight r2 (- GVBest[m] PVCurrent[m])))
                                             (setq v (+ PVVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PVVelocity[m] v)
                                             (setq PVCurrent[m] (+ PVCurrent[m] v))
                                             (setq VV[m] (modi (abs PVCurrent[m]) M)))
                                           (setq PFCurrent VFCurrent[n])
                                           (setq PFVelocity VFVelocity[n])
                                           (setq PFBest VFBest[n])
                                           (loop for m from 0 until FFN do
                                             (setq a (* weight r1 (- PFBest[m] PFCurrent[m])))
                                             (setq b (* weight r2 (- GFBest[m] PFCurrent[m])))
                                             (setq v (+ PFVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PFVelocity[m] v)
                                             (setq PFCurrent[m] (+ PFCurrent[m] v))
                                             (setq FF[m] (modi (abs PFCurrent[m]) FTLEN)))
                                           (evaluate X Y)
                                           (setq PCCurrent[iError] NLSE) 
                                           (setq PCCurrent[iScore] NLSE) 
                                           (setq PCCurrent[iA] A) 
                                           (setq PCCurrent[iB] B) 
                                           (if (< NLSE PCBest[iScore])
											   (begin
                                                 (loop for m from 0 until CCN do (setq PCBest[m] CC[m])) 
                                                 (loop for m from 0 until VVN do (setq PVBest[m] PVCurrent[m])) 
                                                 (setq PCBest[iError] NLSE) 
                                                 (setq PCBest[iScore] NLSE) 
                                                 (setq PCBest[iA] A) 
                                                 (setq PCBest[iB] B)))
                                           (setq iGBest 0)(loop for n from 1 until PNN do (if (< VCBest[n][iScore] VCBest[iGBest][iScore]) (setq iGBest n)))
                                           (setq GCBest VCBest[iGBest])
                                           (setq GVBest VVBest[iGBest])
                                           )) ; end loops
                                       ;; Select the best swarm vector to represent the training run.
                                       Last::
                                       (setq GCBest VCBest[iGBest]) 
                                       (setq GVBest VVBest[iGBest]) 
                                       (setq GFBest VFBest[iGBest]) 
                                       (loop for m from 0 until CCN do (setq CC[m] GCBest[m])) 
                                       (loop for m from 0 until VVN do (setq VV[m] (modi (abs GVBest[m]) M))) 
                                       (loop for m from 0 until FFN do (setq FF[m] (modi (abs GFBest[m]) FTLEN))) 
                                       (setq NLSE GCBest[iError]) 
                                       (setq A GCBest[iA]) 
                                       (setq B GCBest[iB])
                                       Finish::
                                       true)
                                    (defun run(ObjVector:X) 
                                       regs:(m M n N) 
                                       regs:(Number:y Number:fx ) 
                                       vars:(NumVector:xv NumVector:ey) 
                                       (onError (lambda(s) false)) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (+= gsm.myTotalEvaluations (number (* M N))) 
                                       (setq ey (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq xv X[n]) 
                                          (setq fx {***replace me***}) 
                                          (setq y B) 
                                          (*= y fx) 
                                          (+= y A) 
                                          (setq y (gsm@validate y)) 
                                          (setq ey[n] y)) 
                                        ey)
                                    (defun score(ObjVector:X NumVector:Y) 
                                       regs:(m M n N) 
                                       regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                       vars:(NumVector:xv (isEYConstant true)) 
                                       (onError (lambda(s) false)) 
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (+= gsm.myTotalEvaluations (number (* N M))) 
                                       (setq EY (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq y Y[n]) 
                                          (setq xv X[n]) 
                                          (setq fx {***replace me***}) 
                                          (setq ey B) 
                                          (*= ey fx) 
                                          (+= ey A) 
                                          (setq EY[n] (setq ey (gsm@validate ey))) 
                                          (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                          (setq eyOld ey)
                                          (setq err (- ey y))
                                          (*= err err)
                                          (if (< BIGPOSNUM err) (return false))
                                          (+= errPct err))
	                                   (/= errPct (number N))
                                       (vmregSqrtNumber errPct errPct)
                                       (/= errPct gsm.myYStdev)
                                       ;; Disallow constant functions where myY is not also a constant. 
                                       (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                       (setq NLSE (gsm@validate errPct))
                                       (if (<= BIGPOSNUM NLSE) (return false))
                                       NLSE)
                                    regs:(m M n N)
                                    regs:(Number:y Number:fx ) 
                                    (setq M (length xv))
                                    (+= gsm.myTotalEvaluations (number M))
                                    (setq fx {***replace me***}) 
                                    (setq y B) 
                                    (*= y fx) 
                                    (+= y A) 
                                    (setq y (gsm@validate y)) 
                                    y)
                                }))
    (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
    (setq regressLambda (substitute regressLambda "{***CCN***}" ncc))
    (setq regressLambda (substitute regressLambda "{***EEN***}" nee))
    (setq regressLambda (substitute regressLambda "{***PNN***}" (string mySWMPool)))
    (setq regressLambda (substitute regressLambda "{***GEN***}" (string mySWMMaxGen)))
    (setq regressLambda (substitute regressLambda "{***GAP***}" (string mySWMMaxGap)))
    (setq regressLambda (substitute regressLambda "{***TRY***}" (string myNoiseMaxGen)))
    (setq regressLambda (substitute regressLambda "{***VVN***}" nvv))
    (setq regressLambda (substitute regressLambda "{***FFN***}" nff))
    (setq regressLambda (substitute regressLambda "{***TTN***}" ntt))
    (setq regressLambda (substitute regressLambda "{***F***}" "0.5"))
    (cond   ;; The valid abstract operators (math trig full noop).
	 ((= myAbstractOperators math:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "4")))
	 ((= myAbstractOperators trig:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "8")))
	 ((= myAbstractOperators full:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "12")))
	 (else (setq regressLambda (substitute regressLambda "{***FTLEN***}" "13")))
     ) ; end cond
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end templateRegressMdl


































































































































































;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS.templateRegressMvl
;; ********************************************************************
;; summary:  estimator User defined functions
;;
;; 			 Compile time child Lambdas for the estimator compiler.
;; 			 These child Lambdas support the estimator compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; ********************************************************************

;;*********************************************************************
;; Create a regression Lambda for the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator templateRegressMvl(struct expressionVector)
    regs:(n N)
    vars:(regressLambda eyLambda cvLambda )
    ;; Create the proper Estimator MVL Lambda based upon the contents of the expression vector.
    ;; Create a regress lambda from the arguments.
    (setq eyLambda "(Mvl xv)")
    ;; Create a conversion lambda from the expression vector.
    (setq N (length expressionVector))
    (setq cvLambda (append "(setq xxv (new Vector: Number: " N "))")) 
    (loop for n from 0 until N do
       (setq cvLambda (append cvLambda " (setq fx " (string expressionVector[n] true) ") (setq xxv[" n "] fx)"))
       ) ; end expression loop
    ;; Create a regress lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create the proper expression for the regression loop.
    (setq regressLambda (append {(lambda (NumVector:xv)                                     
                                    pvars:(Integer:ID (Train full:) (Number:A 0.0) (Number:B 1.0) Number:AvgYSq Number:BandNLSE (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) NumVector:EY Mvl WFF JSRC Rule Genome convert run score train) 
                                    (defun convert(NumVector:xv) 
                                       regs:(n N) 
                                       regs:(Number:fx ) 
                                       vars:(NumVector:xxv) 
                                       {***convert me***} 
                                       xxv)
                                    (defun run(ObjVector:X) 
                                       regs:(n N) 
                                       regs:(Number:y Number:fx ) 
                                       vars:(NumVector:xv NumVector:ey) 
                                       (onError (lambda(s) false)) 
                                       (setq N (length X))
                                       (setq M (length X[0])) 
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (setq ey (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq xv X[n]) 
                                          (setq xv (convert xv)) 
                                          (setq fx {***replace me***}) 
                                          (setq y B) 
                                          (*= y fx) 
                                          (+= y A) 
                                          (setq y (gsm@validate y)) 
                                          (setq ey[n] y)) 
                                       ey)
                                    (defun score(ObjVector:X NumVector:Y) 
                                       regs:(n N) 
                                       regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                       vars:(NumVector:xv (isEYConstant true)) 
                                       (onError (lambda(s) false)) 
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq N (length X)) 
                                       (setq M (length X[0]))
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (setq EY (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq y Y[n])
                                          (setq xv X[n]) 
                                          (setq xv (convert xv)) 
                                          (setq fx {***replace me***}) 
                                          (setq ey B) 
                                          (*= ey fx) 
                                          (+= ey A) 
                                          (setq EY[n] (setq ey (gsm@validate ey))) 
                                          (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                          (setq eyOld ey)
                                          (setq err (- ey y))
                                          (*= err err)
                                          (if (< BIGPOSNUM err) (return false))
                                          (+= errPct err))
	                                   (/= errPct (number N))
                                       (vmregSqrtNumber errPct errPct)
                                       (/= errPct gsm.myYStdev)
                                       ;; Disallow constant functions where myY is not also a constant. 
                                       (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                       (setq NLSE (gsm@validate errPct))
                                       (if (<= BIGPOSNUM NLSE) (return false))
                                       NLSE)
                                    (defun train(ObjVector:X NumVector:Y ...) 
                                       regs:(n N) 
                                       regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err) 
                                       regs:(Number:xmean Number:xsum Number:x) 
                                       regs:(Number:ymean Number:ysum Number:y) 
                                       regs:(Number:xxdot Number:yydot Number:xydot) 
                                       vars:(ObjVector:XX NumVector:xv NumVector:EY) 
                                       (onError (lambda(s) false)) 
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq XX (copy X)) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (+= gsm.myTotalRegressions (number (* M N)))
                                       (loop for n from 0 until N do (setq XX[n] (convert X[n]))) 
                                       (setq Mvl (gsm.mvlRegress XX Y)) 
                                       (setq A 0.0)   
                                       (setq B 1.0)
                                       ;; Now regress for the final A and B coefficients   
                                       (setq EY (run X))   
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (loop for n from 0 until N do 
                                          (setq y Y[n]) 
                                          (setq x EY[n]) 
                                          (+= xsum x) 
                                          (+= ysum y) 
                                          (+= xxdot (* x x)) 
                                          (+= xydot (* x y)) 
                                          (+= yydot (* y y)))                                           
                                       (setq xmean (/ xsum N)) 
                                       (setq ymean (/ ysum N)) 
                                       (setq AvgY ymean) 
                                       (setq numerator (- xydot (* ysum xmean))) 
                                       (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                                       (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                                       (setq a (- ymean (* b xmean))) 
                                       (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                                       (setq A (gsm@validate a))
                                       (setq B (gsm@validate b))
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       true)
                                    regs:(Number:y Number:fx )
                                    (setq M (length xv)) 
                                    (+= gsm.myTotalEvaluations M)
                                    (setq xv (convert xv)) 
                                    (setq fx {***replace me***}) 
                                    (setq y B) 
                                    (*= y fx) 
                                    (+= y A) 
                                    (setq y (gsm@validate y)) 
                                    y)
                                }))
    (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
    (setq regressLambda (substitute regressLambda "{***convert me***}" cvLambda))
    ;; Complete the final Estimator SVM Lambda as a ParseLib attributed grammar token.
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end templateRegressMvl


















































































;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS.templateRegressReg
;; ********************************************************************
;; summary:  estimator User defined functions
;;
;; 			 Compile time child Lambdas for the estimator compiler.
;; 			 These child Lambdas support the estimator compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; ********************************************************************

;;*********************************************************************
;; Create a grammar swarm variable Lambda for the current selected row set.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild gsm.estimator templateRegressReg(struct expressionVector)
    regs:(n N)
    vars:(regressLambda eyLambda ncc nee nvv nff ntt)
    ;; Create a regression lambda from the expression vector.
    (setq N (length expressionVector))
    (if (= N 0) (return (setq struct.Value true)))
    (if (= N 1)
        then 
        (setq eyLambda (string expressionVector[0] true))
        else
        (begin
          (setq eyLambda "(+")
          (loop for n from 0 until N do
            (setq eyLambda (append eyLambda " " (string expressionVector[n] true)))
            ) ; end expression loop
          (setq eyLambda (append eyLambda " )"))
        )) ; end expressionVector if
    ;; Create a regress lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create a the length of the constant vector.
    (setq maxConstants (integer maxConstants))
    (setq ncc (string maxConstants))
    ;; Create a the length of the constant vector.
    (setq maxNoiseTerms (integer maxNoiseTerms))
    (setq nee (string maxNoiseTerms))
    ;; Create a the length of the variable vector.
    (setq maxVariables (integer maxVariables))
    (setq nvv (string maxVariables))
    ;; Create a the length of the abstract operator vector.
    (setq maxAbsOperators (integer maxAbsOperators))
    (setq nff (string maxAbsOperators))
    ;; Create a the length of the terms vector.
    (setq maxTerms (integer maxTerms))
    (setq ntt (string maxTerms))
    ;; Create the proper expression for the regression loop.
    (setq regressLambda (append {(lambda (NumVector:xv) 
                                    pvars:(Integer:ID (Train full:)   
                                           (Number:A 0.0) (Number:B 1.0) NumVector:CC IntVector:VV IntVector:FF NumVector:EE ObjVector:AG BitVector:TT 
	                                       (Integer:PNN {***PNN***}) (Number:F {***F***}) (Integer:GEN {***GEN***}) (Integer:TRY {***TRY***}) (Integer:FTLEN {***FTLEN***})
                                           (Integer:CCN {***CCN***}) (Integer:VVN {***VVN***}) (Integer:FFN {***FFN***}) (Integer:EEN {***EEN***}) (Integer:TTN {***TTN***}) (Integer:GAP {***GAP***})                                      
                                           (Number:NLSE 1.797693134862E+308) (Number:TCE 1.797693134862E+308) Number:BandNLSE (learning trainDE:) 
                                           Number:MinScore Integer:TrainGens NumVector:EY Number:AvgY Number:AvgYSq 
                                           WFF JSRC Rule Genome
                                           ;; WARNING: These operators in their number and order must match expressionGrammarGso.myAbstractOperators vector exactly!
                                           (FT #(obj| _fadd _fsub _fmul _fdiv _fcos _fsin _ftan _ftanh _flog _fsqrt _fsquare _fcube _fnop ))
                                           _fadd _fsub _fmul _fdiv _fcos _fsin _ftan _ftanh _flog _fsqrt _fsquare _fcube _fnop
                                           _favg _fmax _fmin _fmod _fexpt _fabs _fexp _frac _fint _finv _fsig _fsgn
                                           evaluate run score train trainMore trainDE trainPSO)
                                    (defun _fabs(a1 ...) (abs a1))
                                    (defun _fadd(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (+ a1 a2)))
                                    (defun _favg(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (avg a1 a2)))
                                    (defun _fcos(a1 ...) (cos a1))
                                    (defun _fcube(a1 ...) (* a1 a1 a1))
                                    (defun _fdiv(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (if (<> a2 0.0) (number (/ a1 a2)) 0.0))
                                    (defun _fexp(a1 ...) (exp a1))
                                    (defun _fexpt(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (expt a1 a2)))
                                    (defun _fint(a1 ...) (ninteger a1))
                                    (defun _finv(a1 ...) (if (<> a1 0.0) (number (/ 1.0 a1)) 0.0))
                                    (defun _flog(a1 ...) (log (abs a1)))
                                    (defun _fmax(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 a1)) (number (max a1 a2)))
                                    (defun _fmin(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 a1)) (number (min a1 a2)))
                                    (defun _fmod(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (mod a1 a2)))
                                    (defun _fmul(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 1.0)) (number (* a1 a2)))
                                    (defun _fnop(a1 ...) a1)
                                    (defun _frac(a1 ...) (fraction a1))
                                    (defun _fsub(a1 ...) vars:(a2) (if (>= (argCount) 2) (setq a2 (argFetch 1)) (setq a2 0.0)) (number (- a1 a2)))
                                    (defun _fsgn(a1 ...) (sign a1))
                                    (defun _fsig(a1 ...) (abs (fraction a1)))
                                    (defun _fsin(a1 ...) (sin a1))
                                    (defun _fsqrt(a1 ...) (sqrt (abs a1)))
                                    (defun _fsquare(a1 ...) (* a1 a1))
                                    (defun _ftan(a1 ...) (tan a1))
                                    (defun _ftanh(a1 ...) (tanh a1))
                                    (defun _evaluate(ObjVector:X NumVector:Y) 
                                       regs:(n N) 
                                       regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err) 
                                       regs:(Number:xmean Number:xsum Number:x Number:highX) 
                                       regs:(Number:ymean Number:ysum Number:y Number:lowX) 
                                       regs:(Number:xxdot Number:yydot Number:xydot) 
                                       vars:(NumVector:xv) 
                                       (onError (lambda(s) false))
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq N (length X))
                                       (setq M (length X[0])) 
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (setq EY (new Vector: Number: N)) 
                                       (setq InvN (/ 1.0 (number N))) 
                                       (setq highX BIGNEGNUM)
                                       (setq lowX BIGPOSNUM)
                                       (loop for n from 0 until N do 
                                          (setq y Y[n]) 
                                          (setq xv X[n]) 
                                          (setq x {***replace me***}) 
                                          (setq x (gsm@validate x)) 
                                          (setq EY[n] x)
                                          (if (< x lowX) (setq lowX x)) 
                                          (if (> x highX) (setq highX x)) 
                                          (+= xsum x) 
                                          (+= ysum y) 
                                          (+= xxdot (* x x)) 
                                          (+= xydot (* x y)) 
                                          (+= yydot (* y y)))                                           
                                       (setq xmean (/ xsum N)) 
                                       (setq ymean (/ ysum N)) 
                                       (setq AvgY ymean) 
                                       (setq numerator (- xydot (* ysum xmean))) 
                                       (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                                       (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                                       (setq a (- ymean (* b xmean))) 
                                       (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                                       (setq A a) 
                                       (setq B b) 
                                       (setq NLSE (sqrt (abs (* InvN err)))) 
                                       (setq AvgYSq (sqrt (abs (* InvN yydot))))
                                       (if (= lowX highX) (setq NLSE BIGPOSNUM))
                                       (if (<> yydot 0.0) (/= NLSE AvgYSq)) 
                                       (setq NLSE (gsm@validate NLSE))
                                       (setq A (gsm@validate A))
                                       (setq B (gsm@validate B))
                                       true)
                                    (defun evaluate(ObjVector:X NumVector:Y) 
                                       regs:(i I n N) 
                                       regs:(Number:InvN Number:a Number:b Number:err Number:score) 
                                       (onError (lambda(s) false))
                                       (setq A 0.0) 
                                       (setq B 1.0) 
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (if (<= EEN 0) (return (_evaluate X Y)))
                                       (if (= EE #void) (setq EE (new Vector: Number: EEN)))
                                       (setq N TRY)
                                       (setq InvN (/ 1.0 (number N))) 
                                       (setq I EEN)
                                       (loop for n from 0 until N do
                                          (loop for i from 0 until I do (setq EE[i] (- (gsm.myRandomFunction 2.0) 1.0)))
                                          (if (<> (_evaluate X Y) true) (return false))
                                          (+= a (* A InvN))
                                          (+= b (* B InvN))
                                          (+= err (* NLSE InvN)))
                                       (loop for i from 0 until I do (setq EE[i] 0.0))
                                       (setq A a) 
                                       (setq B b) 
                                       (setq NLSE err) 
                                       true)
                                    (defun train(ObjVector:X NumVector:Y ...)
                                       ;; Gather training algorithm arguments: X Y genome minScore
                                       regs:(n N me) 
                                       vars:(trainMethod Lambda) 
                                       ;; Populate the Abstract Operator Lambdas Table.
                                       (if (and (= AG #void) (> FFN 0))
										   (begin
                                              (setq me (myself))
                                              (setq AG (new Vector: Object: FTLEN))
                                              (loop for n from 0 until FTLEN do (setq AG[n] me.Pv[FT[n]]))
                                           )) ; end if
                                       ;; Gather arguments and initialize
                                       (if (= learning trainDE:) (setq trainMethod trainDE) (setq trainMethod trainPSO))
                                       (return (trainMethod X Y))
                                       true) 
                                    (defun trainMore(ObjVector:X NumVector:Y generations)
                                       ;; Gather training algorithm arguments: X Y genome minScore
                                       regs:(m M n) 
                                       vars:(trainMethod maxGensSave) 
                                       ;; Initialize
                                       (if (= learning trainDE:) (setq trainMethod trainDE) (setq trainMethod trainPSO))
                                       (setq maxGensSave GEN)
                                       (setq maxGens generations)
                                       (setq result (trainMethod X Y))
                                       (setq GEN maxGensSave)
                                        result)
                                    (defun trainDE(ObjVector:X NumVector:Y) 
                                       ;; Implement the Differential Evolution (DE) training algorithm
                                       regs:(g G m M mm n N nn iError iScore iA iB iBest iBase iP1 iP2 k1 k2) 
                                       regs:(Number:bestScore bestGap) 
                                       regs:(Number:sw Number:minY Number:maxY Number:rangeY Number:halfRangeY Number:ff Number:y) 
                                       vars:(ObjVector:PCC NumVector:PCBest NumVector:PCBase NumVector:PC1 NumVector:PC2) 
                                       vars:(ObjVector:PVV IntVector:PVBest IntVector:PVBase IntVector:PV1 IntVector:PV2) 
                                       vars:(ObjVector:PFF IntVector:PFBest IntVector:PFBase IntVector:PF1 IntVector:PF2) 
                                       vars:(ObjVector:PTT BitVector:PTBest BitVector:PTBase BitVector:PT1 BitVector:PT2) 
                                       (onError (lambda(s) false))
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq A 0.0)
                                       (setq B 1.0)
                                       (setq TrainGens 0) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (setq iError CCN) 
                                       (setq iA (+ CCN 1)) 
                                       (setq iB (+ CCN 2))
                                       (setq iScore (+ CCN 3)) 
                                       (if (and (<= CCN 0) (<= FFN 0) (<= VVN 0) (<= TTN 0)) (return (evaluate X Y)))
                                       (setq maxY (setq minY Y[0]))(loop for n from 1 until N do (setq y Y[n]) (if (< y minY) (setq minY y)) (if (> y maxY) (setq maxY y)))
                                       (setq rangeY (+ (- maxY minY) 1.0)) 
                                       (setq halfRangeY (* rangeY .50)) 
                                       ;; Initialize conditions
                                       (cond
                                        ((and (= CCN 0) (= VVN 1) (= FFN 0) (= TTN 0)) 
                                          ;; Only one abstract variable initialize case
                                          (begin
                                            (setq PNN M)
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until VVN do (setq PVBase[m] n) (setq VV[m] PVBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable initialize case
                                        ((and (= CCN 0) (= VVN 2) (= FFN 0) (= TTN 0)) 
                                          ;; Only two abstract variable initialize case
                                          (begin
                                            (setq PNN (* M M))
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            (setq n 0)
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for nn from 0 until M do 
                                              (loop for mm from 0 until M do 
                                                (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                                (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                                (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                                (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                                (setq PVBase[0] nn) (setq VV[0] PVBase[0])
                                                (setq PVBase[1] mm) (setq VV[1] PVBase[1])
                                                ;; Evaluate each swarm vector and save score.
                                                (evaluate X Y) 
                                                (setq PCBase[iError] NLSE) 
                                                (setq PCBase[iScore] NLSE) 
                                                (setq PCBase[iA] A) 
                                                (setq PCBase[iB] B)
                                                (++ n)))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable initialize case
                                        ((and (= CCN 0) (= VVN 1) (= FFN 1) (= TTN 0)) 
                                          ;; Only one abstract variable and one abstract functioninitialize case
                                          (begin
                                            (setq PNN (* M FTLEN))
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            (setq n 0)
                                            ;; Initialize each swarm vector to a set of exact values.
                                            (loop for nn from 0 until M do 
                                              (loop for mm from 0 until FTLEN do 
                                                (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                                (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                                (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                                (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                                (setq PVBase[0] nn) (setq VV[0] PVBase[0])
                                                (setq PFBase[0] mm) (setq FF[0] PFBase[1])
                                                ;; Evaluate each swarm vector and save score.
                                                (evaluate X Y) 
                                                (setq PCBase[iError] NLSE) 
                                                (setq PCBase[iScore] NLSE) 
                                                (setq PCBase[iA] A) 
                                                (setq PCBase[iB] B)
                                                (++ n)))
                                            (goto Last:) 
                                          )) ; end Only one abstract variable and one abstract functioninitialize case
                                        ((and (= CCN 0) (= VVN 0) (= FFN 1) (= TTN 0)) 
                                          ;; Only one abstract function initialize case
                                          (begin
                                            (setq PNN FTLEN)
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: CCN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of random weights.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until FFN do (setq PFBase[m] n) (setq FF[m] PFBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                            (goto Last:) 
                                          )) ; end Only one abstract function initialize case
                                        (else
                                          ;; General initialize case
                                          (begin
                                            (setq FF (new Vector: Integer: FFN)) 
                                            (setq VV (new Vector: Integer: VVN)) 
                                            (setq CC (new Vector: Number: CCN)) 
                                            (setq TT (new Vector: Bit: TTN)) 
                                            (setq PCC (new Vector: Object: PNN))
                                            (setq PVV (new Vector: Object: PNN))
                                            (setq PFF (new Vector: Object: PNN))
                                            (setq PTT (new Vector: Object: PNN))
                                            ;; Initialize each swarm vector to a set of random weights.
                                            (loop for n from 0 until PNN do 
                                              (setq PCC[n] (setq PCBase (new Vector: Number: (+ CCN 4))))
                                              (setq PVV[n] (setq PVBase (new Vector: Integer: VVN)))
                                              (setq PFF[n] (setq PFBase (new Vector: Integer: FFN)))
                                              (setq PTT[n] (setq PTBase (new Vector: Bit: TTN)))
                                              (loop for m from 0 until CCN do (setq PCBase[m] (- (gsm.myRandomFunction rangeY) halfRangeY)) (setq CC[m] PCBase[m]))
                                              (loop for m from 0 until VVN do (setq PVBase[m] (integer (gsm.myRandomFunction M))) (setq VV[m] PVBase[m]))
                                              (loop for m from 0 until FFN do (setq PFBase[m] (integer (gsm.myRandomFunction FTLEN))) (setq FF[m] PFBase[m]))
                                              (loop for m from 0 until TTN do (setq PTBase[m] (integer (round (gsm.myRandomFunction 1.0)))) (setq TT[m] PTBase[m]))
                                              ;; Evaluate each swarm vector and save score.
                                              (evaluate X Y) 
                                              (setq PCBase[iError] NLSE) 
                                              (setq PCBase[iScore] NLSE) 
                                              (setq PCBase[iA] A) 
                                              (setq PCBase[iB] B))
                                          )) ; end General initialize case
                                        ) ; end initialization cond
                                       ;; Implement the DE training algorithm here.
                                       (setq iBest 0)(loop for n from 1 until PNN do (if (< PCC[n][iScore] PCC[iBest][iScore]) (setq iBest n)))
                                       (setq bestScore PCC[iBest][iScore])
                                       (setq bestGap 0)
                                       (setq G GEN)
                                       (loop for g from 0 until G do
                                         (vmtestescape)
                                         ;(writeln "...DE Training generation [" g "]")
                                         (setq TrainGens g)
                                         (if (>= bestGap GAP)
                                             (begin
                                                ;; Periodically reinitialize each new swarm vector to a set of random weights.
                                                (loop for n from 0 until PNN do
                                                  (if (<> iBest n)
                                                      (begin
                                                        (setq PCBase PCC[n])
                                                        (setq PVBase PVV[n])
                                                        (setq PFBase PFF[n])
                                                        (setq PTBase PTT[n])
                                                        (loop for m from 0 until CCN do (setq PCBase[m] (- (gsm.myRandomFunction rangeY) halfRangeY)) (setq CC[m] PCBase[m]))
                                                        (loop for m from 0 until VVN do (setq PVBase[m] (integer (gsm.myRandomFunction M))) (setq VV[m] PVBase[m]))
                                                        (loop for m from 0 until FFN do (setq PFBase[m] (integer (gsm.myRandomFunction FTLEN))) (setq FF[m] PFBase[m]))
                                                        (loop for m from 0 until TTN do (setq PTBase[m] (integer (round (gsm.myRandomFunction 1.0)))) (setq TT[m] PTBase[m]))
                                                        ;; Evaluate each swarm vector and save score.
                                                        (evaluate X Y) 
                                                        (setq PCBase[iError] NLSE) 
                                                        (setq PCBase[iScore] NLSE) 
                                                        (setq PCBase[iA] A) 
                                                        (setq PCBase[iB] B)
                                                        (if (< NLSE PCC[iBest][iScore]) (setq iBest n))
                                                      )) ; end iBest if
                                                  ) ; end reinitialize loop
                                             (setq bestScore PCC[iBest][iScore])
                                             (setq bestGap 0)
                                             )) ; end if grow candidate pool
                                         (loop for iP1 from 0 until PNN do
                                           Retry:: 
                                           ;; Add a little tournement competition in selecting iP2.
                                           (setq k1 (integer (gsm.myRandomFunction PNN)))
                                           (setq k2 (integer (gsm.myRandomFunction PNN)))
                                           (if (< PCC[k1][iScore] PCC[k2][iScore]) (setq iP2 k1) (setq iP2 k2))
                                           (if (<> iP2 iP1)
                                               (begin
                                                 (setq PCBest PCC[iBest])
                                                 (setq PC1 PCC[iP1])
                                                 (setq PC2 PCC[iP2])
                                                 (setq PVBest PVV[iBest])
                                                 (setq PV1 PVV[iP1])
                                                 (setq PV2 PVV[iP2])
                                                 (setq PFBest PFF[iBest])
                                                 (setq PF1 PFF[iP1])
                                                 (setq PF2 PFF[iP2])
                                                 (setq PTBest PTT[iBest])
                                                 (setq PT1 PTT[iP1])
                                                 (setq PT2 PTT[iP2])
                                                 (setq ff (+ F (gsm.myRandomFunction 1.0)))
                                                 (loop for m from 0 until CCN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq CC[m] (+ PCBest[m] (* ff (- PC1[m] PC2[m])))))
                                                         ((<= sw .60) (setq CC[m] PC1[m]))
                                                         ((<= sw .90) (setq CC[m] PC2[m]))
                                                         (else (setq CC[m] PCBest[m]))))
                                                 (loop for m from 0 until VVN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq VV[m] PVBest[m]))
                                                         ((<= sw .60) (setq VV[m] PV1[m]))
                                                         ((<= sw .90) (setq VV[m] PV2[m]))
                                                         (else (setq VV[m] (integer (gsm.myRandomFunction VVN))))))
                                                 (loop for m from 0 until FFN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq FF[m] PFBest[m]))
                                                         ((<= sw .60) (setq FF[m] PF1[m]))
                                                         ((<= sw .90) (setq FF[m] PF2[m]))
                                                         (else (setq FF[m] (integer (gsm.myRandomFunction FFN))))))
                                                 (loop for m from 0 until TTN do
                                                   (setq sw (gsm.myRandomFunction 1.0))
                                                   (cond ((<= sw .30) (setq TT[m] PTBest[m]))
                                                         ((<= sw .60) (setq TT[m] PT1[m]))
                                                         ((<= sw .90) (setq TT[m] PT2[m]))
                                                         (else (setq TT[m] (integer (round (gsm.myRandomFunction 1.0)))))))
                                                 (evaluate X Y)
                                                 (if (< NLSE PC1[iScore])
											         (begin
                                                       (loop for m from 0 until CCN do (setq PC1[m] CC[m])) 
                                                       (loop for m from 0 until VVN do (setq PV1[m] VV[m])) 
                                                       (loop for m from 0 until FFN do (setq PF1[m] FF[m])) 
                                                       (loop for m from 0 until TTN do (setq PT1[m] TT[m])) 
                                                       (setq PC1[iError] NLSE) 
                                                       (setq PC1[iScore] NLSE) 
                                                       (setq PC1[iA] A) 
                                                       (setq PC1[iB] B))) 
                                                 (if (< NLSE PCC[iBest][iScore]) (setq iBest iP1))
                                               )) ; end if
                                           ) ; end PNN loop
                                         (if (>= bestScore PCC[iBest][iScore]) then (++ bestGap) else (begin (setq bestScore PCC[iBest][iScore]) (setq bestGap 0)))             
                                         ) ; end G loop
                                       ;; Select the best swarm vector to represent the training run.
                                       Last::
                                       (loop for n from 0 until PNN do
                                         (setq PCBase PCC[n])
                                         (setq PVBase PVV[n])
                                         (if (< PCBase[iScore] NLSE)
                                             (begin 
                                               (loop for m from 0 until CCN do (setq CC[m] PCBase[m])) 
                                               (loop for m from 0 until VVN do (setq VV[m] PVBase[m])) 
                                               (loop for m from 0 until FFN do (setq FF[m] PFBase[m])) 
                                               (loop for m from 0 until TTN do (setq TT[m] PTBase[m])) 
                                               (setq NLSE PCBase[iError]) 
                                               (setq A PCBase[iA]) 
                                               (setq B PCBase[iB]))))
                                       true)
                                    (defun trainPSO(ObjVector:X NumVector:Y) 
                                       ;; Implement the Particle Swarm (PSO) training algorithm
                                       regs:(g G m M n N) 
                                       regs:(Number:sw Number:weight Number:r1 Number:r2 Number:a Number:b Number:v) 
                                       regs:(iError iScore iA iB iParticle iBest iGBest) 
                                       vars:(ObjVector:VCCurrent ObjVector:VCVelocity ObjVector:VCBest) 
                                       vars:(ObjVector:VVCurrent ObjVector:VVVelocity ObjVector:VVBest) 
                                       vars:(ObjVector:VFCurrent ObjVector:VFVelocity ObjVector:VFBest) 
                                       vars:(NumVector:PCCurrent NumVector:PCVelocity NumVector:PCBest NumVector:GCBest) 
                                       vars:(NumVector:PVCurrent NumVector:PVVelocity NumVector:PVBest NumVector:GVBest) 
                                       vars:(NumVector:PFCurrent NumVector:PFVelocity NumVector:PFBest NumVector:GFBest) 
                                       (onError (lambda(s) false))
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq A 0.0)
                                       (setq B 1.0)
                                       (setq TrainGens 0) 
                                       (setq iError CCN) 
                                       (setq iA (+ CCN 1)) 
                                       (setq iB (+ CCN 2))
                                       (setq iScore (+ CCN 3)) 
                                       (if (<= CCN 0) (return (evaluate X Y))) 
                                       (setq CC (new Vector: Number: CCN)) 
                                       (setq VV (new Vector: Integer: VVN)) 
                                       (setq FF (new Vector: Integer: FFN)) 
                                       (setq VCCurrent (new Vector: Object: PNN))
                                       (setq VVCurrent (new Vector: Object: PNN))
                                       (setq VFCurrent (new Vector: Object: PNN))
                                       (setq VCVelocity (new Vector: Object: PNN))
                                       (setq VVVelocity (new Vector: Object: PNN))
                                       (setq VFVelocity (new Vector: Object: PNN))
                                       (setq VCBest (new Vector: Object: PNN))
                                       (setq VVBest (new Vector: Object: PNN))
                                       (setq VFBest (new Vector: Object: PNN))
                                       ;; Initialize each swarm location and velocity vectors to a set of random weights.
                                       (loop for n from 0 until PNN do 
                                         (setq VCBest[n] (setq PCBest (new Vector: Number: (+ CCN 4))))
                                         (setq VVBest[n] (setq PVBest (new Vector: Number: VVN)))
                                         (setq VFBest[n] (setq PFBest (new Vector: Number: FFN)))
                                         (setq VCCurrent[n] (setq PCCurrent (new Vector: Number: (+ CCN 4))))
                                         (setq VVCurrent[n] (setq PVCurrent (new Vector: Number: VVN)))
                                         (setq VFCurrent[n] (setq PFCurrent (new Vector: Number: FFN)))
                                         (loop for m from 0 until CCN do (setq PCCurrent[m] (- (gsm.myRandomFunction 2.0) 1.0)) (setq CC[m] PCCurrent[m]) (setq PCBest[m] PCCurrent[m]))
                                         (loop for m from 0 until VVN do (setq PVCurrent[m] (- (gsm.myRandomFunction (* 16.0 M)) (* 8.0 M))) (setq VV[m] (modi (abs PVCurrent[m]) M)) (setq PVBest[m] PVCurrent[m]))
                                         (loop for m from 0 until FFN do (setq PFCurrent[m] (- (gsm.myRandomFunction (* 16.0 FTLEN)) (* 8.0 FTLEN))) (setq FF[m] (modi (abs PFCurrent[m]) FTLEN)) (setq PFBest[m] PFCurrent[m]))
                                         (setq VCVelocity[n] (setq PCVelocity (new Vector: Number: CCN)))
                                         (setq VVVelocity[n] (setq PVVelocity (new Vector: Number: VVN)))
                                         (setq VFVelocity[n] (setq PFVelocity (new Vector: Number: FFN)))
                                         (loop for m from 0 until CCN do (setq PCVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         (loop for m from 0 until VVN do (setq PVVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         (loop for m from 0 until FFN do (setq PFVelocity[m] (- (gsm.myRandomFunction 20.0) 10.0)))
                                         ;; Evaluate each swarm location and save score.
                                         (evaluate X Y) 
                                         (setq PCCurrent[iError] NLSE) 
                                         (setq PCCurrent[iScore] NLSE) 
                                         (setq PCCurrent[iA] A) 
                                         (setq PCCurrent[iB] B)
                                         (setq PCBest[iError] NLSE) 
                                         (setq PCBest[iScore] NLSE) 
                                         (setq PCBest[iA] A) 
                                         (setq PCBest[iB] B))
                                       (setq iGBest 0)(loop for n from 1 until PNN do (if (< VCBest[n][iScore] VCBest[iGBest][iScore]) (setq iGBest n)))
                                       (setq GCBest VCBest[iGBest])
                                       (setq GVBest VVBest[iGBest])
                                       ;; Implement the PSO training algorithm here.
                                       (setq G GEN)
                                       (loop for g from 0 until G do
                                         (vmtestescape)
                                         (setq TrainGens g) 
                                         (setq weight (+ .25 (/ (- G g) G)))
                                         (loop for n from 0 until PNN do
                                           (setq r1 (gsm.myRandomFunction 2.0))
                                           (setq r2 (gsm.myRandomFunction 2.0))
                                           (setq PCCurrent VCCurrent[n])
                                           (setq PCVelocity VCVelocity[n])
                                           (setq PCBest VCBest[n])
                                           (loop for m from 0 until CCN do
                                             (setq a (* weight r1 (- PCBest[m] PCCurrent[m])))
                                             (setq b (* weight r2 (- GCBest[m] PCCurrent[m])))
                                             (setq v (+ PCVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PCVelocity[m] v)
                                             (setq PCCurrent[m] (+ PCCurrent[m] v))
                                             (setq CC[m] PCCurrent[m]))
                                           (setq PVCurrent VVCurrent[n])
                                           (setq PVVelocity VVVelocity[n])
                                           (setq PVBest VVBest[n])
                                           (loop for m from 0 until VVN do
                                             (setq a (* weight r1 (- PVBest[m] PVCurrent[m])))
                                             (setq b (* weight r2 (- GVBest[m] PVCurrent[m])))
                                             (setq v (+ PVVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PVVelocity[m] v)
                                             (setq PVCurrent[m] (+ PVCurrent[m] v))
                                             (setq VV[m] (modi (abs PVCurrent[m]) M)))
                                           (setq PFCurrent VFCurrent[n])
                                           (setq PFVelocity VFVelocity[n])
                                           (setq PFBest VFBest[n])
                                           (loop for m from 0 until FFN do
                                             (setq a (* weight r1 (- PFBest[m] PFCurrent[m])))
                                             (setq b (* weight r2 (- GFBest[m] PFCurrent[m])))
                                             (setq v (+ PFVelocity[m] a b))
                                             (if (> v AvgY) (setq v AvgY))
                                             (if (< v (- 0.0 AvgY)) (setq v (- 0.0 AvgY)))
                                             (setq PFVelocity[m] v)
                                             (setq PFCurrent[m] (+ PFCurrent[m] v))
                                             (setq FF[m] (modi (abs PFCurrent[m]) FTLEN)))
                                           (evaluate X Y)
                                           (setq PCCurrent[iError] NLSE) 
                                           (setq PCCurrent[iScore] NLSE) 
                                           (setq PCCurrent[iA] A) 
                                           (setq PCCurrent[iB] B) 
                                           (if (< NLSE PCBest[iScore])
											   (begin
                                                 (loop for m from 0 until CCN do (setq PCBest[m] CC[m])) 
                                                 (loop for m from 0 until VVN do (setq PVBest[m] PVCurrent[m])) 
                                                 (setq PCBest[iError] NLSE) 
                                                 (setq PCBest[iScore] NLSE) 
                                                 (setq PCBest[iA] A) 
                                                 (setq PCBest[iB] B)))
                                           (setq iGBest 0)(loop for n from 1 until PNN do (if (< VCBest[n][iScore] VCBest[iGBest][iScore]) (setq iGBest n)))
                                           (setq GCBest VCBest[iGBest])
                                           (setq GVBest VVBest[iGBest])
                                           )) ; end loops
                                       ;; Select the best swarm vector to represent the training run.
                                       Last::
                                       (setq GCBest VCBest[iGBest]) 
                                       (setq GVBest VVBest[iGBest]) 
                                       (setq GFBest VFBest[iGBest]) 
                                       (loop for m from 0 until CCN do (setq CC[m] GCBest[m])) 
                                       (loop for m from 0 until VVN do (setq VV[m] (modi (abs GVBest[m]) M))) 
                                       (loop for m from 0 until FFN do (setq FF[m] (modi (abs GFBest[m]) FTLEN))) 
                                       (setq NLSE GCBest[iError]) 
                                       (setq A GCBest[iA]) 
                                       (setq B GCBest[iB])
                                       Finish::
                                       true)
                                    (defun run(ObjVector:X) 
                                       regs:(m M n N) 
                                       regs:(Number:y Number:fx ) 
                                       vars:(NumVector:xv NumVector:ey) 
                                       (onError (lambda(s) false)) 
                                       (setq N (length X)) 
                                       (setq M (length X[0])) 
                                       (+= gsm.myTotalEvaluations (number (* M N)))
                                       (setq ey (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq xv X[n]) 
                                          (setq fx {***replace me***}) 
                                          (setq y B) 
                                          (*= y fx) 
                                          (+= y A) 
                                          (setq y (gsm@validate y)) 
                                          (setq ey[n] y)) 
                                        ey)
                                    (defun score(ObjVector:X NumVector:Y) 
                                       regs:(m M n N) 
                                       regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                       vars:(NumVector:xv (isEYConstant true)) 
                                       (onError (lambda(s) false)) 
                                       (setq NLSE BIGPOSNUM) 
                                       (setq TCE BIGPOSNUM) 
                                       (setq N (length X))
                                       (setq M (length X[0]))
                                       (+= gsm.myTotalEvaluations (number (* M N))) 
                                       (setq EY (new Vector: Number: N)) 
                                       (loop for n from 0 until N do 
                                          (setq y Y[n]) 
                                          (setq xv X[n]) 
                                          (setq fx {***replace me***}) 
                                          (setq ey B) 
                                          (*= ey fx) 
                                          (+= ey A) 
                                          (setq EY[n] (setq ey (gsm@validate ey))) 
                                          (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                          (setq eyOld ey)
                                          (setq err (- ey y))
                                          (*= err err)
                                          (if (< BIGPOSNUM err) (return false))
                                          (+= errPct err))
	                                   (/= errPct (number N))
                                       (vmregSqrtNumber errPct errPct)
                                       (/= errPct gsm.myYStdev)
                                       ;; Disallow constant functions where myY is not also a constant. 
                                       (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                       (setq NLSE (gsm@validate errPct))
                                       (if (<= BIGPOSNUM NLSE) (return false))
                                       NLSE)
                                    regs:(m M n N)
                                    regs:(Number:y Number:fx )
                                    (setq M (length xv)) 
                                    (+= gsm.myTotalEvaluations M)
                                    (setq fx {***replace me***}) 
                                    (setq y B) 
                                    (*= y fx) 
                                    (+= y A) 
                                    (setq y (gsm@validate y)) 
                                    y)
                                }))
    (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
    (setq regressLambda (substitute regressLambda "{***CCN***}" ncc))
    (setq regressLambda (substitute regressLambda "{***EEN***}" nee))
    (setq regressLambda (substitute regressLambda "{***PNN***}" (string mySWMPool)))
    (setq regressLambda (substitute regressLambda "{***GEN***}" (string mySWMMaxGen)))
    (setq regressLambda (substitute regressLambda "{***GAP***}" (string mySWMMaxGap)))
    (setq regressLambda (substitute regressLambda "{***TRY***}" (string myNoiseMaxGen)))
    (setq regressLambda (substitute regressLambda "{***VVN***}" nvv))
    (setq regressLambda (substitute regressLambda "{***FFN***}" nff))
    (setq regressLambda (substitute regressLambda "{***TTN***}" ntt))
    (setq regressLambda (substitute regressLambda "{***F***}" "0.5"))
    (cond   ;; The valid abstract operators (math trig full noop).
	 ((= myAbstractOperators math:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "4")))
	 ((= myAbstractOperators trig:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "8")))
	 ((= myAbstractOperators full:) (setq regressLambda (substitute regressLambda "{***FTLEN***}" "12")))
	 (else (setq regressLambda (substitute regressLambda "{***FTLEN***}" "13")))
     ) ; end cond
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end templateRegressReg

































































































































































;;**EXPORTKEY**:gsm.estimator.%COMPILER_USERFUNCTIONS.templateRegressSvm
(defchild gsm.estimator templateRegressSvm(struct ...)
;; ********************************************************************
;; Title:    estimator templateRegressSvm
;;
;; summary:  Create an SVM regression Lambda for the current selected 
;;           row set. The regression command may specify user defined
;;           element expressions, as follows:
;;
;;              regressSvm(x1,log(x2),x2*x10);
;;
;;           If the regression command specifies NO element expressions,
;;           as below left, then it is assumed that the raw elements were
;;           expressed without transformation, as follows:
;;
;;              regressSvm(); ==> regressSvm(x1,x2,x3,...,xM);
;;
;;           If the regression command specifies the special argument "quick",
;;           as below left, then it is assumed that the raw elements were
;;           expressed without transformation and only a single generation
;;           is spend on training, as follows:
;;
;;              regressSvm(quick); ==> regressSvm(x1,x2,x3,...,xM);
;;
;; Note1:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm.estimator:%DEFINITION|.
;;
;; Note2: 	 We use the persistant variables from startRule
;;
;; ********************************************************************
    regs:(n N)
    vars:(regressLambda eyLambda cvLambda expressionVector)
    ;; Load the expression vector (if one was provided).
    (if (>= (argCount) 2) (setq expressionVector (argFetch 1)) (setq expressionVector #void))
    ;; Create the proper Estimator SVM Lambda depending upon the contents of the expression vector.
    (cond
     ;; A simple quick support vector regression is requested.
     ;; For example: regressSvm(quick);
     ((= expressionVector[0] quick:)
      (begin
         ;; Create a regress lambda from the arguments.
         (setq eyLambda "(Svm xv)")
         ;; Create a regress lambda to eliminate any void fields.
         (addToBeginList struct (autoCheck))
         ;; Create the proper expression for the regression loop.
         (setq regressLambda (append {(lambda (NumVector:xv)  
                                         pvars:(Integer:ID (Train full:) Number:A Number:B (Integer:GEN 1) Number:AvgYSq Number:BandNLSE (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) NumVector:EY Svm WFF JSRC Rule Genome run score train)  
                                         (defun run(ObjVector:X)  
                                            regs:(n N)   
                                            regs:(Number:y Number:fx )   
                                            vars:(NumVector:xv NumVector:ey)   
                                            (onError (lambda(s) false))   
                                            (setq N (length X))   
                                            (setq ey (new Vector: Number: N))   
                                            (loop for n from 0 until N do   
                                               (setq xv X[n])    
                                               (setq fx {***replace me***})    
                                               (setq y B)    
                                               (*= y fx)    
                                               (+= y A)    
                                               (setq y (gsm@validate y))    
                                               (setq ey[n] y))    
                                            ey) 
                                         (defun score(ObjVector:X NumVector:Y) 
                                            regs:(n N) 
                                            regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                            vars:(NumVector:xv (isEYConstant true)) 
                                            (onError (lambda(s) false)) 
                                            (setq N (length X))
                                            (setq M (length X[0])) 
                                            (+= gsm.myTotalEvaluations (number (* M N)))
                                            (setq EY (new Vector: Number: N)) 
                                            (loop for n from 0 until N do 
                                               (setq y Y[n]) 
                                               (setq xv X[n]) 
                                               (setq xv (convert xv)) 
                                               (setq fx {***replace me***}) 
                                               (setq ey B) 
                                               (*= ey fx) 
                                               (+= ey A) 
                                               (setq EY[n] (setq ey (gsm@validate ey))) 
                                               (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                               (setq eyOld ey)
                                               (setq err (- ey y))
                                               (*= err err)
                                               (if (< BIGPOSNUM err) (return false))
                                               (+= errPct err))
	                                        (/= errPct (number N))
                                            (vmregSqrtNumber errPct errPct)
                                            (/= errPct gsm.myYStdev)
                                            ;; Disallow constant functions where myY is not also a constant. 
                                            (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                            (setq NLSE (gsm@validate errPct))
                                            (if (<= BIGPOSNUM NLSE) (return false))
                                            NLSE) 
                                         (defun train(ObjVector:X NumVector:Y ...)    
                                            regs:(n N)     
                                            regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err)     
                                            regs:(Number:xmean Number:xsum Number:x )     
                                            regs:(Number:ymean Number:ysum Number:y)     
                                            regs:(Number:xxdot Number:yydot Number:xydot)     
                                            vars:(NumVector:xv)     
                                            (onError (lambda(s) false))     
                                            (setq Svm (gsm.svmRegress X Y GEN))     
                                            (setq N (length X))     
                                            (setq EY #void)  
                                            (setq A 0.0)   
                                            (setq B 1.0)   
                                            (setq NLSE BIGPOSNUM)   
                                            (setq AvgYSq 0.0)   
                                            (setq TCE BIGPOSNUM)   
                                            true) 
                                         regs:(Number:y Number:fx )       
                                         (setq fx {***replace me***})        
                                         (setq y B)        
                                         (*= y fx)        
                                         (+= y A)        
                                         (setq y (gsm@validate y)) 
                                         y)
                                     }))
         (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
      )) ; end case Data input expressions
     ;; User defined data input expressions have been provided.
     ;; For example: regressSvm(x1,log(x2),x2*x10);
     ((isVector expressionVector)
      (begin
         ;; Create a regress lambda from the arguments.
         (setq eyLambda "(Svm xv)")
         ;; Create a conversion lambda from the expression vector.
         (setq N (length expressionVector))
         (setq cvLambda (append "(setq xxv (new Vector: Number: " N "))")) 
         (loop for n from 0 until N do
            (setq cvLambda (append cvLambda " (setq fx " (string expressionVector[n] true) ") (setq xxv[" n "] fx)"))
            ) ; end expression loop
         ;; Create a regress lambda to eliminate any void fields.
         (addToBeginList struct (autoCheck))
         ;; Create the proper expression for the regression loop.
         (setq regressLambda (append {(lambda (NumVector:xv) 
                                         pvars:(Integer:ID (Train full:) (Number:A 0.0) (Number:B 1.0) (Integer:GEN {***GEN***}) Number:AvgYSq Number:BandNLSE (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) NumVector:EY Svm WFF Rule Genome convert run score train)  
                                         (defun convert(NumVector:xv) 
                                            regs:(n N) 
                                            regs:(Number:fx ) 
                                            vars:(NumVector:xxv) 
                                            {***convert me***} 
                                            xxv) 
                                         (defun run(ObjVector:X) 
                                            regs:(n N) 
                                            regs:(Number:y Number:fx ) 
                                            vars:(NumVector:xv NumVector:ey) 
                                            (onError (lambda(s) false)) 
                                            (setq N (length X)) 
                                            (setq ey (new Vector: Number: N)) 
                                            (loop for n from 0 until N do 
                                               (setq xv X[n]) 
                                               (setq xv (convert xv)) 
                                               (setq fx {***replace me***}) 
                                               (setq y B) 
                                               (*= y fx) 
                                               (+= y A) 
                                               (setq y (gsm@validate y)) 
                                               (setq ey[n] y)) 
                                            ey) 
                                         (defun score(ObjVector:X NumVector:Y) 
                                            regs:(n N) 
                                            regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                            vars:(NumVector:xv (isEYConstant true)) 
                                            (onError (lambda(s) false)) 
                                            (setq NLSE BIGPOSNUM) 
                                            (setq TCE BIGPOSNUM) 
                                            (setq N (length X))
                                            (setq M (length X[0])) 
                                            (+= gsm.myTotalEvaluations (number (* M N)))
                                            (setq EY (new Vector: Number: N)) 
                                            (loop for n from 0 until N do 
                                               (setq y Y[n]) 
                                               (setq xv X[n]) 
                                               (setq xv (convert xv)) 
                                               (setq fx {***replace me***}) 
                                               (setq ey B) 
                                               (*= ey fx) 
                                               (+= ey A) 
                                               (setq EY[n] (setq ey (gsm@validate ey)))
                                               (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                               (setq eyOld ey)
                                               (setq err (- ey y))
                                               (*= err err)
                                               (if (< BIGPOSNUM err) (return false))
                                               (+= errPct err))
	                                        (/= errPct (number N))
                                            (vmregSqrtNumber errPct errPct)
                                            (/= errPct gsm.myYStdev)
                                            ;; Disallow constant functions where myY is not also a constant. 
                                            (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                            (setq NLSE (gsm@validate errPct))
                                            (if (<= BIGPOSNUM NLSE) (return false))
                                            NLSE) 
                                         (defun train(ObjVector:X NumVector:Y ...) 
                                            regs:(n N) 
                                            regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err) 
                                            regs:(Number:xmean Number:xsum Number:x) 
                                            regs:(Number:ymean Number:ysum Number:y) 
                                            regs:(Number:xxdot Number:yydot Number:xydot) 
                                            vars:(ObjVector:XX NumVector:xv NumVector:EY) 
                                            (onError (lambda(s) false))  
                                            (setq NLSE BIGPOSNUM) 
                                            (setq TCE BIGPOSNUM) 
                                            (setq XX (copy X))  
                                            (setq N (length X))  
                                            (loop for n from 0 until N do (setq XX[n] (convert X[n])))  
                                            (setq Svm (gsm.svmRegress XX Y GEN gsm.myVerboseSW))  
                                            (setq A 0.0)   
                                            (setq B 1.0)   
                                            ;; Now regress for the final A and B coefficients   
                                            (setq EY (run X))   
                                            (+= gsm.myTotalEvaluations (number (* M N)))
                                            (loop for n from 0 until N do 
                                               (setq y Y[n]) 
                                               (setq x EY[n]) 
                                               (+= xsum x) 
                                               (+= ysum y) 
                                               (+= xxdot (* x x)) 
                                               (+= xydot (* x y)) 
                                               (+= yydot (* y y)))                                           
                                            (setq xmean (/ xsum N)) 
                                            (setq ymean (/ ysum N)) 
                                            (setq AvgY ymean) 
                                            (setq numerator (- xydot (* ysum xmean))) 
                                            (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                                            (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                                            (setq a (- ymean (* b xmean))) 
                                            (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                                            (setq A (gsm@validate a))
                                            (setq B (gsm@validate b))
                                            (setq NLSE BIGPOSNUM) 
                                            (setq TCE BIGPOSNUM) 
                                            true) 
                                         regs:(Number:y Number:fx ) 
                                         (setq xv (convert xv))  
                                         (setq fx {***replace me***})  
                                         (setq y B)  
                                         (*= y fx)  
                                         (+= y A)  
                                         (setq y (gsm@validate y))  
                                         y)
                                     }))
         (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
         (setq regressLambda (substitute regressLambda "{***convert me***}" cvLambda))
         (setq regressLambda (substitute regressLambda "{***GEN***}" (string mySvmMaxGen)))
      )) ; end case Data input expressions
     ;; No data input expressions have been provided.
     ;; For example: regressSvm();
     ;; Note: No specified elements implies ==> regressSvm(x1,x2,x3,...,XM);
     (else
      (begin
         ;; Create a regress lambda from the arguments.
         (setq eyLambda "(Svm xv)")
         ;; Create a regress lambda to eliminate any void fields.
         (addToBeginList struct (autoCheck))
         ;; Create the proper expression for the regression loop.
         (setq regressLambda (append {(lambda (NumVector:xv)  
                                         pvars:(Integer:ID (Train full:) Number:A Number:B (Integer:GEN {***GEN***}) Number:AvgYSq Number:BandNLSE (Number:TCE 1.797693134862E+308) (Number:NLSE 1.797693134862E+308) NumVector:EY Svm WFF Rule Genome run score train)  
                                         (defun run(ObjVector:X)  
                                            regs:(n N)   
                                            regs:(Number:y Number:fx )   
                                            vars:(NumVector:xv NumVector:ey)   
                                            (onError (lambda(s) false))   
                                            (setq N (length X))   
                                            (setq ey (new Vector: Number: N))   
                                            (loop for n from 0 until N do   
                                               (setq xv X[n])    
                                               (setq fx {***replace me***})    
                                               (setq y B)    
                                               (*= y fx)    
                                               (+= y A)    
                                               (setq y (gsm@validate y))    
                                               (setq ey[n] y))    
                                            ey) 
                                         (defun score(ObjVector:X NumVector:Y) 
                                            regs:(n N) 
                                            regs:(Number:y Number:fx Number:ey Number:err Number:errPct Number:eyOld) 
                                            vars:(NumVector:xv (isEYConstant true)) 
                                            (onError (lambda(s) false)) 
                                            (setq N (length X))
                                            (setq M (length X[0])) 
                                            (+= gsm.myTotalEvaluations (number (* M N)))
                                            (setq EY (new Vector: Number: N)) 
                                            (loop for n from 0 until N do 
                                               (setq y Y[n]) 
                                               (setq xv X[n]) 
                                               (setq xv (convert xv)) 
                                               (setq fx {***replace me***}) 
                                               (setq ey B) 
                                               (*= ey fx) 
                                               (+= ey A) 
                                               (setq EY[n] (setq ey (gsm@validate ey))) 
                                               (if (and (> n 0) (<> eyOld ey)) (setq isEYConstant false))
                                               (setq eyOld ey)
                                               (setq err (- ey y))
                                               (*= err err)
                                               (if (< BIGPOSNUM err) (return false))
                                               (+= errPct err))
	                                        (/= errPct (number N))
                                            (vmregSqrtNumber errPct errPct)
                                            (/= errPct gsm.myYStdev)
                                            ;; Disallow constant functions where myY is not also a constant. 
                                            (if (and (<> gsm.myYStdev 0.0) (= isEYConstant true)) then (setq errPct BIGPOSNUM))
                                            (setq NLSE (gsm@validate errPct))
                                            (if (<= BIGPOSNUM NLSE) (return false))
                                            NLSE) 
                                         (defun train(ObjVector:X NumVector:Y ...)    
                                            regs:(n N)     
                                            regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err)     
                                            regs:(Number:xmean Number:xsum Number:x )     
                                            regs:(Number:ymean Number:ysum Number:y)     
                                            regs:(Number:xxdot Number:yydot Number:xydot)     
                                            vars:(NumVector:xv)     
                                            (onError (lambda(s) false))     
                                            (setq Svm (gsm.svmRegress X Y GEN))     
                                            (setq N (length X))     
                                            (setq EY #void)  
                                            (setq A 0.0)   
                                            (setq B 1.0)   
                                            (setq NLSE BIGPOSNUM)   
                                            (setq AvgYSq 0.0)   
                                            (setq TCE BIGPOSNUM)   
                                            true) 
                                         regs:(Number:y Number:fx )       
                                         (setq fx {***replace me***})        
                                         (setq y B)        
                                         (*= y fx)        
                                         (+= y A)        
                                         (setq y (gsm@validate y)) 
                                         y)
                                     }))
         (setq regressLambda (substitute regressLambda "{***replace me***}" eyLambda))
         (setq regressLambda (substitute regressLambda "{***GEN***}" (string mySvmMaxGen)))
      )) ; end case Data input expressions
     ) ; end cond 
    ;; Complete the final Estimator SVM Lambda as a ParseLib attributed grammar token.
    (addToBeginList struct (Lisp regressLambda)[0])
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    struct) ; end templateRegressSvm




























































































;;**EXPORTKEY**:gsm.estimator.%DEFINITION
;#text#
;; ********************************************************************
;; summary:  This Estimator compiler definition includes all the features
;;           of a full JavaScript compiler for the LambdaServer engine.
;;           See the following references:
;;
;;           [1]  "JavaScript Language Ref Guide", Korns Associates
;;           [2]  "JavaScript For The World Wide Web", Postscript Press
;;           [3]  "JavaScript Developer's Resource", Prentice Hall
;;
;; Notes:    Requires the browseLib, the ParseLib, and this compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |gsm:estimator:DEFINITION|.
;; Parms:    none
;; return:   java   The ParseLib checks in a newly updated copy of the
;;                  java compiler source and compiles the "gsm.estimator" compiler.
;; ********************************************************************
   
#LexicalRules#

 MAIN: user ordering :: true ::    
 MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>    
 MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>    
 MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>    
 MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>    
 MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>    
 MAIN: Digit+ Period Digit* Exponent Sign Digit+ 
                                  << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>    
 MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>    
 MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>    
 MAIN: Period Digit+    << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>    
 MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*  * / << true >>    
 MAIN: / / NotEol* Eol? << true >>    
 MAIN: "=" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "+" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "-" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "/" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "*" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "%" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "<" ">"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "&" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "|" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "<" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: ">" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "&" "&"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "|" "|"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "="       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "+"       << ($OUT $ch (string $1) Operator: true Sign: true) >>    
 MAIN: "-"       << ($OUT $ch (string $1) Operator: true Sign: true) >>    
 MAIN: "/"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "*"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "%"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "!"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "&"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "|"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "<"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: ">"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "~"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>    
 MAIN: # < NameStart NameChar* Whitespace*  Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>    
 MAIN: Whitespace+      << true >>    
 MAIN: Any              << ($OUT $ch (symbol (string $1)) Default: true) >>    
 MAIN: Eof :: $LIST ::

#End#

#LexicalFeatures#

Digit: [|"0"-"9"|]
Alpha: [|a-z| |A-Z|]
AlphaNum: [|a-z| |A-Z| |"0"-"9"|]
NameChar: [|a-z| |A-Z| |"0"-"9"| "_"]
Letter: [|a-z| |A-Z|]  
NameStart: [|a-z| |A-Z| "_"]  
Special: [< > = & % ! ^ "~" + / * - "|" "#"]
DQuote: [34]
NotDQuote: [|0-255| ~ 34]
Quote: [39]
NotQuote: [|0-255| ~ 39]
Whitespace: [|0-32|]
Eol: [10 13]
NotEol: [|0-255| ~ 10 13]
Period: ["."]
Exponent: [e E]
Sign: [+ -]

#End#

#SyntaxRules#

  MAIN: user ordering :: true ::
  MAIN: # "estimator" # || (= $3.Charpos 8) || << true >>
  MAIN: STMTLIST Eof :: (list $1.Value) ::
  MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::
  MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::
  MAIN: Eof :: (list #void) ::

  ;; ********************************************************************
  ;; Start rules for compiling Estimator extensions.
  ;; ********************************************************************
  FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>
  FSTMTLIST: Semicolon << $0 >>

  FSTATEMENT: user ordering :: true ::
  FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::
  FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::
  FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::
  FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::
  FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::
  FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
  FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::
  FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::
  FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: XT: ''restore))) ::
  FSTATEMENT: Scale{(xReferentOn)} SEXPRESSION Semicolon :: (filterScale $0 $2.Value) ::
  FSTATEMENT: Regress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressReg $0 $3.Value) ::
  FSTATEMENT: Regress{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressReg $0 (new Vector: 1 $2.Value)) ::
  FSTATEMENT: Regress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressReg $0 (new Vector: 1 "0")) ::
  FSTATEMENT: Model{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMdl $0 $3.Value) ::
  FSTATEMENT: Model{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressMdl $0 (new Vector: 1 $2.Value)) ::
  FSTATEMENT: Model{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressMdl $0 (new Vector: 1 "0")) ::
  FSTATEMENT: Frmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressFrm $0 $3.Value) ::
  FSTATEMENT: Mvlregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMvl $0 $3.Value) ::
  FSTATEMENT: Svmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressSvm $0 $3.Value) ::
  FSTATEMENT: Svmregress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressSvm $0) ::
  FSTATEMENT: Svmregress{(xReferentOn)} Semicolon :: (templateRegressSvm $0) ::
  FSTATEMENT: Highest{(xReferentOn)} SEXPRESSION CUT :: (highestCut $0 $2.Value $3.Value) ::

  CUT: user ordering :: true ::
  CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::
  CUT: Number :: $1 ::
  CUT: SEXPRESSION :: $1 ::

  FILTER: Select FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::
  FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::
 
  STATEMENT: FILTER :: $1 ::

  SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::
  SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::
  SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION :: (extractColumns $0 $3.Value $5.Value) ::
  SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION Semicolon :: (extractColumns $0 $3.Value $5.Value) ::
  SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION :: (extractColumns $0 Object: $2.Value) ::
  SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION Semicolon :: (extractColumns $0 Object: $2.Value) ::

  SCORE: user ordering :: true ::
  SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::
  SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::
  SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::
  SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::

  STATEMENT: SCORE :: $1 ::
  ;; ********************************************************************
  ;; End rules for compiling Estimator extensions.
  ;; ********************************************************************

  STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>
  STMTLIST: Semicolon << $0 >>

  SEXPRESSION: user ordering :: true ::
  SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION 
               :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::
  SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::
  SEXPRESSION: EXPRESSION :: $1 ::
 
  OPRLIST: user ordering :: true ::
  OPRLIST: Operator PHRASE OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
  OPRLIST: Operator TERM OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
  OPRLIST: Operator STATEMENT OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
  OPRLIST: Operator SEXPRESSION :: (setq $0.Value (new Vector: 2 $1 $2)) ::
  OPRLIST: Operator 
            :: (_makeError "JS 102" $1.Charpos (append "Invalid use of " $1.Value " operator")) ::
 
  EXPRESSION: user ordering :: true ::
  EXPRESSION: PHRASE OPRLIST :: (setExpList $0 $1 $2) ::
  EXPRESSION: PHRASE Operator 
               :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::
  EXPRESSION: PHRASE  :: $1 ::
  EXPRESSION: TERM OPRLIST :: (setExpList $0 $1 $2) ::
  EXPRESSION: TERM Operator 
               :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::
  EXPRESSION: TERM :: $1 ::
  EXPRESSION: STATEMENT :: $1 ::
  EXPRESSION: STATEMENT OPRLIST :: (setExpList $0 $1 $2) ::

  STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::
  STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::
  STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::
  STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::
  STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::
  STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::
  STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::
  STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::
  STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::
  STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::
  STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace 
                    :: (childList |deforphan|: $0 $2 $3 $5 $7) ::
  STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::
  STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::
  STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace 
                    :: (childList |defmethod|: $0 $2 $3 $5 $7) ::
  STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 112" $7.Charpos "Invalid statement")::
  STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::
  STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::
  STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::
  STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::

  FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  FRIEND:   Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  ORPHAN:   Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  METHOD:   Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  CHILD:    Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  CLASS:    Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::


  QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
  QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
  QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::
  QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::
  QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::
  QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::

  CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
  CFCALL: DotOperator Reserved LeftParen 
               :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
  CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
  CFCALL: DotOperator Name LeftParen 
               :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
  CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  
  ;; ********************************************************************
  ;; Start rules for compiling Estimator extensions.
  ;; ********************************************************************
  NAME: user ordering :: true ::
  NAME: Name{(isFieldName $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::
  NAME: Name{(isFieldName $1)} :: (xReferent $0 $1) ::
  ;; ********************************************************************
  ;; End rules for compiling Estimator extensions.
  ;; ********************************************************************

  NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::
  NAME: Name :: (setVType $1) ::

  PHRASE: user ordering :: true ::
  PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
  PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::
  PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::
  PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::
  PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::
  PHRASE: If SEXPRESSION SEXPRESSION Else 
          :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::
  PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::
  PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::
  PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::
  PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::
  PHRASE: While  
          :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::
  PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION
             :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::
  PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::
  PHRASE: Reg VAR(regVector setq:) :: $2 ::
  PHRASE: Reg :: (_makeError "JS 125" $1.Charpos "Invalid reg statement") ::
  PHRASE: Var VAR(varVector setq:) :: $2 ::
  PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::
  PHRASE: Pvar VAR(pvarVector define:) :: $2 ::
  PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::
  PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::
  PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::
  PHRASE: Name CFCALL($1) :: $2 ::
  PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::
  PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) :: 
  PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) :: 
  PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::
  PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::

  TERM: user ordering :: true ::
  TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::
  TERM: + TERM :: (setVType $2) ::
  TERM: + Term :: (setVType $2) ::
  TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::
  TERM: - TERM :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
  TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
  TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::
  TERM: LeftParen SEXPRESSION RightParen :: $2 ::
  TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::
  TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
  TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::
  TERM: Increment NAME :: (postfix $0 $2 $1 false) ::
  TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  TERM: Name CFCALL($1) :: $2 ::
  TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::
  TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::
  TERM: NAME Increment :: (postfix $0 $1 $2 true) ::
  TERM: NAME :: $1 ::
  TERM: Term :: (setVType $1) ::

  VAR: user ordering :: true ::
  VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1)
         :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::
  VAR: Type Name InitializeOperator SEXPRESSION Comma
         :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::
  VAR: Type Name InitializeOperator SEXPRESSION 
         :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::
  VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::
  VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::
  VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::
  VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1)
         :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::
  VAR: Name InitializeOperator SEXPRESSION Comma
         :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::
  VAR: Name InitializeOperator SEXPRESSION 
         :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::
  VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::
  VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::
  VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::
  VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::

  ARGLIST: RightParen :: (setq $0.Value #void) ::
  ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::

  WEIGHTLIST: user ordering :: true ::
  WEIGHTLIST: RightParen :: $0 ::
  WEIGHTLIST: Pound LeftParen "num" Bar NUMLIST << (setq $0.Value (append $0.Value " #(num| " $5.Value)) >>
  WEIGHTLIST: Pound LeftParen "obj" Bar WEIGHTLIST << (setq $0.Value (append $0.Value " #(obj| " $5.Value " )")) >>
  WEIGHTLIST: Pound LeftParen WEIGHTLIST << (setq $0.Value (append $0.Value " #( " $3.Value " )")) >>
  WEIGHTLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::

  NUMLIST: user ordering :: true ::
  NUMLIST: - Number RightParen :: (setq $0.Value (append $0.Value " -" $2.Value " )")) ::
  NUMLIST: Number RightParen :: (setq $0.Value (append $0.Value " " $1.Value " )")) ::
  NUMLIST: - Number NUMLIST :: (setq $0.Value (append $0.Value " -" $2.Value " " $3.Value)) ::
  NUMLIST: Number NUMLIST :: (setq $0.Value (append $0.Value " " $1.Value " " $2.Value)) ::
  NUMLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::

  PARMLIST: RightParen :: (setq $0.Value #void) ::
  PARMLIST: Type Name RightParen 
               :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::
  PARMLIST: Type Name Comma PARMLIST 
               :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::
  PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::
  PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::
  PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::

  REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::
  REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::

  FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::
  FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::

#End# 

#SemanticPasses#

  MAIN true

#End#

#SemanticRules#

  MAIN| user ordering :: true ::
  MAIN| [ Any ] ] :: $2 ::  
  MAIN| [ Any* ] ] :: (objectToList $2) ::  
  MAIN| "begin" Any ] :: $2 ::
  
  ;; ---------------------------------------------------------------
  ;; merge filter statement All commands with field check at beginning
  ;;                        of sort command to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" TRUNCATE [ "begin" TRUNCATE $SORT $TRUNCATE ] ] 
                                    :: (list (symbol "begin")
                                          (list 
                                             '(ref XT truncate:) 
                                             (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $5)))
                                          $6 $7) 
                                    ::  
  MAIN| "begin" LETTRUNCATE [ "begin" LETTRUNCATE $SORT $TRUNCATE ] ] 
                                    :: (list (symbol "begin")
                                          (list 
                                             '(ref XT truncate:) 
                                             (list (symbol "let") (ref $2 0)
                                                (list lambda: '(xv) '(onError (lambda(s) false)) 
                                                                     (list and: (ref $2 1) (ref $5 1))))) 
                                          $6 $7) 
                                    ::  

  ;; ---------------------------------------------------------------
  ;; merge filter statement All commands to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" TRUNCATE TRUNCATE ] :: (list 
                                          '(ref XT truncate:) 
                                          (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $3))) 
                                    ::  
  MAIN| "begin" LETTRUNCATE LETTRUNCATE ] 
                                    :: (list 
                                          '(ref XT truncate:)
                                          (list (symbol "let") (ref $2 0)
                                             (list lambda: '(xv) '(onError (lambda(s) false)) 
                                                                  (list and: (ref $2 1) (ref $3 1))))) 
                                    ::  
  ;; ---------------------------------------------------------------
  ;; merge filter statement Omit commands to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" OMIT OMIT ]         :: (list 
                                          '(ref XT omit) 
                                          (list lambda: '(xv) '(onError (lambda(s) false)) (list or: $2 $3))) 
                                    ::  
  MAIN| "begin" LETOMIT LETOMIT ] 
                                    :: (list 
                                          '(ref XT omit)
                                          (list (symbol "let") (ref $2 0)
                                             (list lambda: '(xv) '(onError (lambda(s) false)) 
                                                                  (list or: (ref $2 1) (ref $3 1))))) 
                                    ::  

  TRUNCATE| [ REFTRUNCATE LAMBDA ] :: $3 ::  

  LETTRUNCATE| [ REFTRUNCATE LET ] :: $3 ::  

  LETOMIT| [ REFOMIT LET ] :: $3 ::  

  REFTRUNCATE| [ "ref" "XT" "truncate" ] :: (list $2 $3 $4) ::  

  OMIT| [ REFOMIT LAMBDA ] :: $3 ::  

  REFOMIT| [ "ref" "XT" "omit" ] :: (list $2 $3 $4) ::  

  LAMBDA| [ "lambda" [ "xv" ] $E $P ]:: $7 ::  

  LET| [ "let" $V LAMBDA ] :: (new Vector: 2 $3 $4) ::  

#End#


#DelimitedStrings#
  String: {"} {"}
  Symbol: {'} {'}
  Whitespace: {/*} {*/}
  Whitespace2: {//} _eol
#End#


#SyntaxFeatures#

  Operator: [+ - * / % "&&" "||" "#"]
  Lisp:     [+ - * / % "&&" "||" "#"] [+ - * pdiv pmod and or pdiv]
  Charop:   [+ - * / % "&&" "||" ] [cadd csub cmul pdiv pmod and or]
  Chartyp:  [+ - * / % "&&" "||" ] [char char char char char bool bool]
  Boolop:   [+ - * / % "&&" "||" ] [badd bsub bmul pdiv pmod and or]
  Booltyp:  [+ - * / % "&&" "||" ] [bool bool bool bool bool bool bool]
  Intop:    [+ - * / % "&&" "||" ] [iadd isub imul pdiv pmod and or]
  Inttyp:   [+ - * / % "&&" "||" ] [int int int int int bool bool]
  Floatop:  [+ - * / % "&&" "||" ] [nadd nsub nmul pdiv pmod and or]
  Floattyp: [+ - * / % "&&" "||" ] [float float float float float bool bool]
  Operator: [== < <= > >= <>]
  Lisp:     [== < <= > >= <>] [= < <= > >= <>]
  Boolop:   [== < <= > >= <>] [bcompareEQ bcompareLT bcompareLE bcompareGT bcompareGE bcompareNE]
  Booltyp:  [== < <= > >= <>] [bool bool bool bool bool bool bool]
  Charop:   [== < <= > >= <>] [ccompareEQ ccompareLT ccompareLE ccompareGT ccompareGE ccompareNE]
  Chartyp:  [== < <= > >= <>] [bool bool bool bool bool bool bool]
  Intop:    [== < <= > >= <>] [icompareEQ icompareLT icompareLE icompareGT icompareGE icompareNE]
  Inttyp:   [== < <= > >= <>] [bool bool bool bool bool bool bool]
  Floatop:  [== < <= > >= <>] [ncompareEQ ncompareLT ncompareLE ncompareGT ncompareGE ncompareNE]
  Floattyp: [== < <= > >= <>] [bool bool bool bool bool bool bool]
  MathAssignmentOperator: [+= -= /= *= "%="]
  Lisp:     [+= -= /= *= %=] [+ - pdiv * pmod]
  Charop:   [+= -= /= *= %=] [cadd csub cmul pdiv pmod]
  Chartyp:  [+= -= /= *= %=] [char char char char char]
  Boolop:   [+= -= /= *= %=] [badd bsub bmul pdiv pmod]
  Booltyp:  [+= -= /= *= %=] [bool bool bool bool bool]
  Intop:    [+= -= /= *= %=] [iadd isub imul pdiv pmod]
  Inttyp:   [+= -= /= *= %=] [int int int int int int]
  Floatop:  [+= -= /= *= %=] [nadd nsub nmul pdiv pmod]
  Floattyp: [+= -= /= *= %=] [float float float float float]
  AssignmentOperator: [=]
  Lisp:               [=] [setq]
  InitializeOperator: [=]
  RelationOperator: [== < <= > >= <>]
  Boolean: [true false] [true false]
  Term: [true false]
  Increment: [++ --]
  Lisp:     [++ --] [+ -]
  Boolop:   [++ --] [badd bsub]
  Booltyp:  [++ --] [bool bool]
  Charop:   [++ --] [cadd csub]
  Chartyp:  [++ --] [char char]
  Intop:    [++ --] [iadd isub]
  Inttyp:   [++ --] [int int]
  Floatop:  [++ --] [nadd nsub]
  Floattyp: [++ --] [float float]
  Logical: [!]
  Lisp: [!] [not]
  For: [for]
  Function: [function]
  Friend: [friend]
  Class: [class]
  Extends: [extends]
  Child: [child]
  Orphan: [orphan]
  Method: [method]
  If: [if]
  Name: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat]
  Of: [of]
  Type: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat]
  Reftyp: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [int float char bool obj char char char obj obj obj obj int char float int float obj int obj float]
  Refop: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [ref ref ref ref ref reftext refSymbol refString ref ref ref refVector refBitVector refBytVector refNumVector refIntVector refFltVector refObjVector refPcdVector ref ref]
  Setop: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [setq setq setq setq setq setq setq setString setq setq setq setVector setBitVector setBytVector setNumVector setIntVector setFltVector setObjVector setPcdVector setq setq]
  While: [while]
  Else: [else]
  Reg: [reg]
  Var: [var]
  Pvar: [pvar]
  Cvar: [cvar]
  Semicolon: [";"]
  Colon: [":"]
  Question: ["?"]
  LeftParen: ["("]
  RightParen: [")"]
  LeftBrace: ["{"]
  RightBrace: ["}"]
  LeftBracket: ["["]
  RightBracket: ["]"]
  Comma: [","]
  DotOperator: ["."]
  Pound: [#]
  Bar: ["|"]

  Reserved: [if then else while do reg var pvar cvar for function orphan friend child class method extends ]

  ;; ********************************************************************
  ;; Start tokens for compiling Estimator extensions.
  ;; ********************************************************************

  Select: [select]
  Percent: [%]
  Sort: [sort]
  Backup: [backup]
  Direction: [up down]
  All: [all]
  Scale: [scale]
  Regress: [regress]
  Model: [model]
  Frmregress: [frmregress]
  Mvlregress: [mvlregress]
  Svmregress: [svmregress]
  Highest: [highest]
  Extract: [extract]
  Omit: [omit]
  Check: [check]
  Checkoff: [checkoff nocheck]
  Checkon: [checkon]
  Cut: [bottom top]
  Slice: [slice]
  Lisp: [slice bottom up top down highest all] [<= <= <= >= >= >= true]

  Score: [score]
  ScoreCommand: [average averageForAll total totalForAll maximum minimum deviation sharpe]

  Set: [Set set]
  Setnr: [Setnr setnr]

  Run: [run]
  Restore: [restore]
  
  Reserved: [all average averageForAll backup bottom check checkoff checkon down filter]
  Reserved: [nocheck omit restore run score set sort up top total totalForAll]

  ;; ********************************************************************
  ;; End tokens for compiling Estimator extensions.
  ;; ********************************************************************


#End#







































































































































































;;**EXPORTKEY**:gsm.estimator.@@defaultLexer
(defriend gsm.estimator defaultLexer(inString)
;; ********************************************************************
;; summary:  This Lambda converts an input string into a vector of
;;           recognized lexemes. It is the default lexical analyzer
;;           for the ParseLib compiler generator.
;;           This Lambda may be modified, in any way, by the user.
;; Parms:    inString   The source string to be broken into lexemes.
;; return:   tokenList  The vector of recognized lexemes.
;; ********************************************************************
    pvars:(;; Persistent variables
           CH                  ;; The current input character from the input string
           INLEN               ;; The length of the input string
           IP                  ;; The input pointer for the input string
           INSTRING            ;; The string of the input characters to be parsed
           keepWhitespaceSW    ;; Switch to keep all whitespace strings
           lowerCaseSW         ;; Switch to convert all names into lower case
           oldKB               ;; The old vector of character break parsing routines
           operatorList        ;; The vector of operator symbols
           KB                  ;; The vector of character break parsing routines
           SB                  ;; The vector of string terminator pairs
           tokenDirectory      ;; Lexicon of tokens and their attributes
           tokenList           ;; The vector of lexical tokens
           TP                  ;; The output pointer for the token output vector
           ;; Methods list
           addStringDelimiters ;; Add a pair of string delimiters to the lexical analyzer
           _default            ;; Recognize this one character
           defaultTokenRule    ;; Modified default rule for adding attributes to a parsed token
           _Ignore             ;; Ignore this character parsing routine
           _Initialize         ;; Initialize the vector of character break parsing routines
           _recFraction        ;; Recognize all fractions
           _recInteger         ;; Recognize all integers
           _recName            ;; Recognize all names
           _recNumber          ;; Recognize all numbers
           _recOperators       ;; Recognize all operator symbols
           _recSpecial         ;; Recognize all special symbols
           _recString          ;; Recognize all delimited strings
           _setFeatures        ;; Give features to a recognized token
           _whiteSpace         ;; Ignore all whitespace characters
           turnFractionsOnOff  ;; Turns fraction recognition on/off
           ) ;; end of persistent variables
    vars:(token oldIP)
    ;;************************************************************************
    ;;  Define the child Lambdas for this parent.
    ;;************************************************************************
    ;; Add a named pair of string delimiters to the lexical analyzer.
    (defun addStringDelimiters(name start end)
       vars:(tmpLambda)
       ;;  Initialize the ParseLib once and only once.
       (if (= KB #void) (_Initialize))
       ;;  If this is the first delimiter pair, start a new directory.
       (setq CH start[0])
       (if (= SB[CH] #void) 
           (begin
              (setq SB[CH] (new Structure:))
              (setq KB[CH] _recString)
           )) ;; end if
       ;;  Set the character directory with this new string delimiter pair.
       (setq SB[CH][name] (new Vector: 2 start end))
       ) ;; end addStringDelimiters
    ;;  Ignore this character parsing routine.
    (defun _Ignore() (++ IP))
    ;;  Create the character break vector.
    (defun _Initialize()
        vars:(i)
        (setq KB (new Vector: 256))
        (setq SB (new Vector: 256))
        (setq operatorList #(#\= #\< #\> #\! #\^ #\~ #\+ #\/ #\* #\- #\| #\&))
        ;; Actual mapping of parse routines to break character positions.
        (loop for i from 0 until 256 do (setq KB[i] _recSpecial))
        (loop for i from 0 to 32 do (setq KB[i] _whiteSpace)) 
        (loop for i from 128 until 256 do (setq KB[i] _whiteSpace)) 
        (loop for i from (code #\a) to (code #\z) do (setq KB[i] _recName)) 
        (loop for i from (code #\A) to (code #\Z) do (setq KB[i] _recName)) 
        (loop for i from (code #\0) to (code #\9) do (setq KB[i] _recNumber)) 
        (loop for i from 0 until (length operatorList) do (setq KB[operatorList[i]] _recOperators)) 
        (setq KB[(code #\_)] _recName) 
        (setq KB[(code #\.)] _recFraction) 
        (setq oldKB (copy KB))
        ) ;; end of _Initialize
    ;;  Recognize all fractions.
    (defun _recFraction()
        vars:(oldIP result)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize fraction portion of number (if any)
        (if (isCharNumeric CH)
            then
            (begin
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
               (setq result (number (substring INSTRING oldIP (subi IP 1))))
               ) ; end then
            else
            (setq result (symbol ".")) 
            ) ; end recognize fraction.
        (setq tokenList[TP] result)
        (++ TP)
        ) ;; end _recFraction
    ;;  Recognize all names.
    (defun _recName()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isCharName CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (if lowerCaseSW
            (setq tokenList[TP] (symbol (downcase (substring INSTRING oldIP (subi IP 1)))))
            (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
            ) ; end if
        (++ TP)
        ) ;; end _recName
    ;;  Recognize all numbers.
    (defun _recNumber()
        vars:(oldIP num fraction)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Recognize fraction portion of number (if any)
        (if (and (= CH #\.) (isCharNumeric INSTRING[(add1 IP)]))
            (begin
               (setq fraction true)
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
            )) ; end recognize fraction.
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (if (= fraction true) (setq num (number num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recNumber
    ;;  Recognize all integers.
    (defun _recInteger()
        vars:(oldIP num)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recInteger
    ;;  Recognize all operator symbols.
    (defun _recOperators()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isMember CH operatorList) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
        (++ TP)
        ) ;; end _recOperators
    ;; Recognize all special symbols.
    (defun _recSpecial() (setq tokenList[TP] (symbol (string CH))) (++ IP) (++ TP))
    ;; Recognize all delimited strings.
    (defun _recString()
        vars:(oldIP i delimPairs delimLen result              
              name this start end startLen endLen)
        (setq oldIP IP)
        ;; Check for a starting string delimiter.
        (setq delimPairs SB[CH])
        (setq delimLen (length delimPairs))
        (loop for i from 0 until delimLen do
           (setq name delimPairs[i 0])
           (setq start delimPairs[i 1][0])
           (setq startLen (length start))
           (setq this (mid INSTRING IP startLen))
           (if (= start this)
               (begin
                  (setq end delimPairs[i 1][1])
                  (setq endLen (length end))
                  (+= IP startLen)
                  (while (< IP INLEN) do
                     (if (= INSTRING[IP] end[0])
                         (begin
                            (setq this (mid INSTRING IP endLen))
                            (if (= end this)
                                (begin
                                   (+= IP endLen)
                                   (setq result (substring INSTRING oldIP (subi IP 1)))
                                   ;; Ignore all whitespace delimited strings
                                   (if (<> (left name 10) "Whitespace")
                                       (begin
                                          (setq tokenList[TP] (new Vector: 2 name result))
                                          (++ TP)
                                          )) ; end  if
                                   (return TP)              
                                   )) ; end inner if
                            )) ; end outter if
                     (++ IP)
                     ) ; end while
                  (setq result (substring INSTRING oldIP (subi IP 1)))
                  ;; Ignore all whitespace delimited strings
                  (if (or keepWhitespaceSW (<> (left name 10) "Whitespace"))
                      (begin
                         (setq tokenList[TP] (new Vector: 2 name result))
                         (++ TP)
                         )) ; end  if
                  (return TP)              
                  )) ; end if 
           ) ;; end loop
        ;; If we get here, this is not the start of a delimited string,
        ;; so invoke the old lexeme parser for this character.
        (oldKB[CH])) ;; end _recString
     ;; Give features to a recognized token
     (defun _setFeatures(token oldIP)
        vars:(parseTree treeIndex treeLen tokenAttr)
        ;; This Lambda tests compiled FSM style methods of attributing each parsed token.
        (setq tokenAttr tokenDirectory[token])
        (if (= tokenAttr #void)
            then
            ;; Create an attributed token using default rule
            (setq tokenAttr (defaultTokenRule token))
            else
            ;; Copy the attributes and set the Value from the dictionary
            (begin
               (setq tokenAttr (copy tokenAttr))
               (setq tokenAttr.Value token)
            )) ; end if
        ;; Set the displacement of the token in the source string
        (setq tokenAttr.Charpos (integer oldIP))
        (setq tokenList[(subi TP 1)] tokenAttr)
        true) ;; end of _setFeatures
    ;; Turns fraction recognition on/off.
    (defun turnFractionsOnOff(onOffSW)
        vars:(i)
        ;; Turn fractions on?
        (if onOffSW
            ;; Turn fractions on
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recNumber)) 
                  (setq oldKB[i] _recNumber)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recFraction))
               (setq oldKB[(code #\.)] _recFraction)
               ) ; end turn fractions on
            ;; Turn fractions off
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recInteger)) 
                  (setq oldKB[i] _recInteger)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recSpecial))
               (setq oldKB[(code #\.)] _recSpecial)
               ) ; end turn fractions off
            ) ; end if
        ) ;; end of turnFractionsOnOff
    ;;  Ignore all whitespace characters.
    (defun _whiteSpace()        
        vars:(oldIP i result)
        ;; Save old IP address
        (setq oldIP IP)
        ;; Loop until all whitespace chars are discovered
        (setq CH INSTRING[(++ IP)]) 
        (while (and (> CH 0) (<= CH 32)) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Return whitespace token (iff keepWhitespaceSW is true)
        (if keepWhitespaceSW
            (begin
               (setq result (substring INSTRING oldIP (subi IP 1)))
               (setq tokenList[TP] (new Vector: 2 "Whitespace" result))
               (++ TP)              
               )) ; end if
        ) ;; end _whiteSpace
    ;;************************************************************************
    ;;  Define the main code routines for this parent.
    ;;************************************************************************
    ;;  Initialize the ParseLib once and only once.
    (if (= KB #void) (_Initialize))
    ;;  Initialize the output token vector. 
    (setq tokenList (new Vector: 0))
    (setq TP 0)
    ;;  Recognize each character in the input string.
    (setq INSTRING inString)
    (setq INLEN (length INSTRING))
    (setq IP 0)
    (while (< IP INLEN) do
        (setq oldIP IP)
        ;; Retrieve the next input character
        (setq CH INSTRING[IP])
        ;; Invoke the parse routine for this input character
        (KB[CH])
        ;; If a token was recognized, give it some features
        (if (and (> TP 0) (not (isStructure (setq token tokenList[(subi TP 1)])))) (_setFeatures token oldIP))
        ) ;; end while
    ;;  Return the token list as the output
    tokenList) ;; end defaultLexer























;;**EXPORTKEY**:gsm.estimator.@UserDefinedFunctions
;; ************************************************
;; gsm.estimator User defined functions
;; ************************************************














;;**EXPORTKEY**:gsm.estimator._LEXRULE_MAIN
;; ************************************************
;; MAIN user defined Lexical Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _LEXRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  _tkch
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 "")
   (setq _tkn 0)
   (setq _repeatSW true)
   (setq _oldIp _ip)

   (if (= _verboseLexCount.MAIN #void) 
          (setq _verboseLexCount.MAIN 1) 
          (setq _verboseLexCount.MAIN (iadd _verboseLexCount.MAIN 1)))

   (if (and (<> _verboseLexIn.MAIN #void) (> _verboseLexIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " input:))
     (setq _ip0 _ip)
     (setq _tkch (iadd _ip 1))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************





















     ;; ====================
     ;; case: "void"
     ;; ====================
     (if (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip0))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void vtyp: obj: Term: true Constant: true) )
            (if _verbose
                (writeRule
                     {MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "void"
     ;; ====================
     ;; case: "nil"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 3)) 3))) "nil") true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void vtyp: obj: Term: true Constant: true) )
            (if _verbose
                (writeRule
                     {MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "nil"
     ;; ====================
     ;; case: DQuote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NotDQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotDQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: DQuote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2 String: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : DQuote
           ) ; end begin
         ) ; end case : NotDQuote*
       ) ; end begin
     ) ; end case : DQuote
     ;; ====================
     ;; case: Quote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NotQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Quote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch (makeQuotedSymbol _tk2) Symbol: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Quote
           ) ; end begin
         ) ; end case : NotQuote*
       ) ; end begin
     ) ; end case : Quote
     ;; ====================
     ;; case: NameStart
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NameChar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (symbol (append _tk1 _tk2)) Name: true Term: true) )
                (if _verbose
                    (writeRule
                         {MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NameChar*
       ) ; end begin
     ) ; end case : NameStart
     ;; ====================
     ;; case: Digit+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Period
         ;; ====================
         (if (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk2] 1)) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Digit*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Exponent
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Exponent[_tk4] 1)) true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Sign
                     ;; ====================
                     (if (if (and (<> (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Sign[_tk5] 1)) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit+
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip5)))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; *********************************************************
                             ;; RULE: MAIN: Digit+ Period Digit* Exponent Sign Digit+ << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2 _tk3 _tk4 _tk5 _tk6)) Number: true Term: true) )
                                (if _verbose
                                    (writeRule
                                         {MAIN: Digit+ Period Digit* Exponent Sign Digit+ << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
(setq _indent (isub _indent 1))
                                (goto Skip:))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : Digit+
                       ) ; end begin
                     ) ; end case : Sign
                   ) ; end begin
                 ) ; end case : Exponent
                 ;; *********************************************************
                 ;; RULE: MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2 _tk3)) Number: true Term: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Digit*
           ) ; end begin
         ) ; end case : Period
         ;; *********************************************************
         ;; RULE: MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkASIS _tkch (integer _tk1) Number: true Integer: true Term: true) )
            (if _verbose
                (writeRule
                     {MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Digit+
     ;; ====================
     ;; case: Period
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Digit+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2)) Number: true Term: true) )
                (if _verbose
                    (writeRule
                         {MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Digit+
       ) ; end begin
     ) ; end case : Period
     ;; ====================
     ;; case: /
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: *
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (or (<> (refString _tkIN _ip) #\*) (<> (refString _tkIN (iadd _ip 1)) #\/)) ) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: *
                 ;; ====================
                 (if (if (= (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: /
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; *********************************************************
                         ;; RULE: MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}* * / << true >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  true )
                            (if _verbose
                                (writeRule
                                     {MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}* * / << true >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent 1))
                            (goto Skip:))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : /
                   ) ; end begin
                 ) ; end case : *
               ) ; end begin
             ) ; end case : Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*
           ) ; end begin
         ) ; end case : *
         ;; ====================
         ;; case: /
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: NotEol*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotEol[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Eol?
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Eol[_tk4] 1)) true (begin (setq _ip (isub _ip 1)) (setq _tk4 {}) true))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: / / NotEol* Eol? << true >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  true )
                        (if _verbose
                            (writeRule
                                 {MAIN: / / NotEol* Eol? << true >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Eol?
               ) ; end begin
             ) ; end case : NotEol*
           ) ; end begin
         ) ; end case : /
       ) ; end begin
     ) ; end case : /
     ;; ====================
     ;; case: "="
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "=" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "=" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "=" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "=" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "="
     ;; ====================
     ;; case: "+"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\+) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "+" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "+" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "+" << ($OUT $ch (string $1) Operator: true Sign: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true Sign: true) )
            (if _verbose
                (writeRule
                     {MAIN: "+" << ($OUT $ch (string $1) Operator: true Sign: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "+"
     ;; ====================
     ;; case: "-"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\-) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "-" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "-" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "-" << ($OUT $ch (string $1) Operator: true Sign: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true Sign: true) )
            (if _verbose
                (writeRule
                     {MAIN: "-" << ($OUT $ch (string $1) Operator: true Sign: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "-"
     ;; ====================
     ;; case: "/"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "/" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "/" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "/" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "/" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "/"
     ;; ====================
     ;; case: "*"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "*" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "*" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "*" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "*" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "*"
     ;; ====================
     ;; case: "%"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\%) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "%" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "%" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "%" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "%" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "%"
     ;; ====================
     ;; case: "<"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: ">"
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "<" ">" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "<" ">" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : ">"
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "<" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "<" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "<" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "<" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "<"
     ;; ====================
     ;; case: "&"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\&) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "&" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "&" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "&"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\&) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "&" "&" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "&" "&" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "&"
         ;; *********************************************************
         ;; RULE: MAIN: "&" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "&" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "&"
     ;; ====================
     ;; case: "|"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\|) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "|" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "|" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "|"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\|) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "|" "|" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "|" "|" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "|"
         ;; *********************************************************
         ;; RULE: MAIN: "|" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "|" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "|"
     ;; ====================
     ;; case: ">"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: ">" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: ">" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: ">" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: ">" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : ">"
     ;; ====================
     ;; case: "!"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\!) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "!" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "!" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "!"
     ;; ====================
     ;; case: "~"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\~) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "~" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "~" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "~"
     ;; ====================
     ;; case: #
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\#) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Letter+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Letter[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: ,
             ;; ====================
             (if (if (= (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #\,) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Digit+
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip3)))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: ,
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\,) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit+
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip5)))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; *********************************************************
                             ;; RULE: MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (_tkASIS _tkch (date (append _tk1 _tk2 _tk3 _tk4 _tk5 _tk6)) Date: true Term: true) )
                                (if _verbose
                                    (writeRule
                                         {MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
(setq _indent (isub _indent 1))
                                (goto Skip:))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : Digit+
                       ) ; end begin
                     ) ; end case : ,
                   ) ; end begin
                 ) ; end case : Digit+
               ) ; end begin
             ) ; end case : ,
           ) ; end begin
         ) ; end case : Letter+
         ;; ====================
         ;; case: <
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: NameStart
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: NameChar*
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Whitespace*
                     ;; ====================
                     (if (begin (setq _i 0) (setq _tk5 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk5[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit*
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; ====================
                             ;; case: >
                             ;; ====================
                             (if (if (= (setq _tk7 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip)
                                 ;; *********************************************************
                                 ;; RULE: MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_tkOUT _tkch (inspect (number _tk6)) vtyp: obj: Term: true) )
                                    (if _verbose
                                        (writeRule
                                             {MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
(setq _indent (isub _indent 1))
                                    (goto Skip:))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : >
                           ) ; end begin
                         ) ; end case : Digit*
                       ) ; end begin
                     ) ; end case : Whitespace*
                   ) ; end begin
                 ) ; end case : NameChar*
               ) ; end begin
             ) ; end case : NameStart
           ) ; end begin
         ) ; end case : <
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: Whitespace+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Whitespace+ << true >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  true )
            (if _verbose
                (writeRule
                     {MAIN: Whitespace+ << true >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Whitespace+
     ;; ====================
     ;; case: Any
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (symbol (string _tk1)) Default: true) )
            (if _verbose
                (writeRule
                     {MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Any
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: $LIST ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tkLIST )
            (if _verbose
                (writeRule
                     {MAIN: Eof :: $LIST ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize 
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " input: ))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseLexIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseLexCount.MAIN _verboseLexIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _LEXRULE_MAIN























;;**EXPORTKEY**:gsm.estimator._SEMRULE_LAMBDA
;; ************************************************
;; LAMBDA user defined Semantic Rule implementation
;; Summary: This Lambda implements the LAMBDA
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_LAMBDA(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LAMBDA: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LAMBDA #void) 
          (setq _verboseSemCount.LAMBDA 1) 
          (setq _verboseSemCount.LAMBDA (iadd _verboseSemCount.LAMBDA 1)))

   (if (and (<> _verboseSemIn.LAMBDA #void) (> _verboseSemIn.LAMBDA -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LAMBDA Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "lambda")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "lambda"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "xv")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "xv"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; *********************************************************
                                     ;; RULE: LAMBDA: [ Any{(= _tk2 "lambda")} [ Any{(= _tk4 "xv")} ] Any Any ] :: $7 ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  _tk7 )
                                        (if _verbose 
                                            (writeRule
                                                 {LAMBDA: [ Any{(= _tk2 "lambda")} [ Any{(= _tk4 "xv")} ] Any Any ] :: $7 ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
(setq _indent (isub _indent))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "xv")}
               ) ; end begin
             ) ; end case : [
           ) ; end begin
         ) ; end case : Any{(= _tk2 "lambda")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LAMBDA on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LAMBDA -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LAMBDA _verboseSemIn.LAMBDA) (error "Count" "in Routine LAMBDA"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LAMBDA














;;**EXPORTKEY**:gsm.estimator._SEMRULE_LET
;; ************************************************
;; LET user defined Semantic Rule implementation
;; Summary: This Lambda implements the LET
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_LET(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LET: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LET #void) 
          (setq _verboseSemCount.LET 1) 
          (setq _verboseSemCount.LET (iadd _verboseSemCount.LET 1)))

   (if (and (<> _verboseSemIn.LET #void) (> _verboseSemIn.LET -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LET Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "let")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "let"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: LAMBDA
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: LET: [ Any{(= _tk2 "let")} Any LAMBDA ] :: (new Vector: 2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (new Vector: 2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {LET: [ Any{(= _tk2 "let")} Any LAMBDA ] :: (new Vector: 2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : LAMBDA
               ) ; end begin
             ) ; end case : Any
           ) ; end begin
         ) ; end case : Any{(= _tk2 "let")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LET on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LET -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LET _verboseSemIn.LET) (error "Count" "in Routine LET"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LET














;;**EXPORTKEY**:gsm.estimator._SEMRULE_LETOMIT
;; ************************************************
;; LETOMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the LETOMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_LETOMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LETOMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LETOMIT #void) 
          (setq _verboseSemCount.LETOMIT 1) 
          (setq _verboseSemCount.LETOMIT (iadd _verboseSemCount.LETOMIT 1)))

   (if (and (<> _verboseSemIn.LETOMIT #void) (> _verboseSemIn.LETOMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LETOMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFOMIT
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFOMIT)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LET
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LET)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: LETOMIT: [ REFOMIT LET ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {LETOMIT: [ REFOMIT LET ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LET
           ) ; end begin
         ) ; end case : REFOMIT
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LETOMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LETOMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LETOMIT _verboseSemIn.LETOMIT) (error "Count" "in Routine LETOMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LETOMIT














;;**EXPORTKEY**:gsm.estimator._SEMRULE_LETTRUNCATE
;; ************************************************
;; LETTRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the LETTRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_LETTRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LETTRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LETTRUNCATE #void) 
          (setq _verboseSemCount.LETTRUNCATE 1) 
          (setq _verboseSemCount.LETTRUNCATE (iadd _verboseSemCount.LETTRUNCATE 1)))

   (if (and (<> _verboseSemIn.LETTRUNCATE #void) (> _verboseSemIn.LETTRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LETTRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFTRUNCATE
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFTRUNCATE)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LET
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LET)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: LETTRUNCATE: [ REFTRUNCATE LET ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {LETTRUNCATE: [ REFTRUNCATE LET ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LET
           ) ; end begin
         ) ; end case : REFTRUNCATE
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LETTRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LETTRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LETTRUNCATE _verboseSemIn.LETTRUNCATE) (error "Count" "in Routine LETTRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LETTRUNCATE














;;**EXPORTKEY**:gsm.estimator._SEMRULE_MAIN
;; ************************************************
;; MAIN user defined Semantic Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: MAIN: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.MAIN #void) 
          (setq _verboseSemCount.MAIN 1) 
          (setq _verboseSemCount.MAIN (iadd _verboseSemCount.MAIN 1)))

   (if (and (<> _verboseSemIn.MAIN #void) (> _verboseSemIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: [ Any ] ] :: $2 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk2 )
                        (if _verbose 
                            (writeRule
                                 {MAIN: [ Any ] ] :: $2 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any
         ;; ====================
         ;; case: Any{(= _tk2 |Any*|:)}
         ;; ====================
         (if (begin (setq _ip _ip1)
          (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 |Any*|:)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: [ Any{(= _tk2 |Any*|:)} ] ] :: (objectToList $2) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (objectToList _tk2) )
                        (if _verbose 
                            (writeRule
                                 {MAIN: [ Any{(= _tk2 |Any*|:)} ] ] :: (objectToList $2) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any{(= _tk2 |Any*|:)}
       ) ; end begin
     ) ; end case : [
     ;; ====================
     ;; case: Any{(= _tk1 "begin")}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken)) morphFail) true (setq _ip _ip0)) (= _tk1 "begin")))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; *********************************************************
                 ;; RULE: MAIN: Any{(= _tk1 "begin")} Any ] :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {MAIN: Any{(= _tk1 "begin")} Any ] :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any
         ;; ====================
         ;; case: TRUNCATE
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "begin")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "begin"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: TRUNCATE
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; ====================
                                     ;; case: ]
                                     ;; ====================
                                     (if (if (_eofToken) (_popIp) false)
                                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 (copy _ip))
                                         ;; *********************************************************
                                         ;; RULE: MAIN: Any{(= _tk1 "begin")} TRUNCATE [ Any{(= _tk4 "begin")} TRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $5)))                                           $6 $7)                                      ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list lambda: '(xv) '(onError (lambda(s) false)) (list and: _tk2 _tk5)))                                           _tk6 _tk7)                                      )
                                            (if _verbose 
                                                (writeRule
                                                     {MAIN: Any{(= _tk1 "begin")} TRUNCATE [ Any{(= _tk4 "begin")} TRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $5)))                                           $6 $7)                                      ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
(setq _indent (isub _indent))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : ]
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : TRUNCATE
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "begin")}
               ) ; end begin
             ) ; end case : [
             ;; ====================
             ;; case: TRUNCATE
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip2)))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} TRUNCATE TRUNCATE ] :: (list                                            '(ref XT truncate:)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $3)))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref XT truncate:)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list and: _tk2 _tk3)))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} TRUNCATE TRUNCATE ] :: (list                                            '(ref XT truncate:)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list and: $2 $3)))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : TRUNCATE
           ) ; end begin
         ) ; end case : TRUNCATE
         ;; ====================
         ;; case: LETTRUNCATE
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "begin")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "begin"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: LETTRUNCATE
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; ====================
                                     ;; case: ]
                                     ;; ====================
                                     (if (if (_eofToken) (_popIp) false)
                                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 (copy _ip))
                                         ;; *********************************************************
                                         ;; RULE: MAIN: Any{(= _tk1 "begin")} LETTRUNCATE [ Any{(= _tk4 "begin")} LETTRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list (symbol "let") (ref $2 0)                                                 (list lambda: '(xv) '(onError (lambda(s) false))                                                                       (list and: (ref $2 1) (ref $5 1)))))                                            $6 $7)                                      ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list (symbol "let") (ref _tk2 0)                                                 (list lambda: '(xv) '(onError (lambda(s) false))                                                                       (list and: (ref _tk2 1) (ref _tk5 1)))))                                            _tk6 _tk7)                                      )
                                            (if _verbose 
                                                (writeRule
                                                     {MAIN: Any{(= _tk1 "begin")} LETTRUNCATE [ Any{(= _tk4 "begin")} LETTRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref XT truncate:)                                               (list (symbol "let") (ref $2 0)                                                 (list lambda: '(xv) '(onError (lambda(s) false))                                                                       (list and: (ref $2 1) (ref $5 1)))))                                            $6 $7)                                      ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
(setq _indent (isub _indent))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : ]
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : LETTRUNCATE
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "begin")}
               ) ; end begin
             ) ; end case : [
             ;; ====================
             ;; case: LETTRUNCATE
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip2)))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} LETTRUNCATE LETTRUNCATE ] :: (list                                            '(ref XT truncate:)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list and: (ref $2 1) (ref $3 1)))))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref XT truncate:)                                           (list (symbol "let") (ref _tk2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list and: (ref _tk2 1) (ref _tk3 1)))))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} LETTRUNCATE LETTRUNCATE ] :: (list                                            '(ref XT truncate:)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list and: (ref $2 1) (ref $3 1)))))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LETTRUNCATE
           ) ; end begin
         ) ; end case : LETTRUNCATE
         ;; ====================
         ;; case: OMIT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_OMIT)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: OMIT
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_OMIT)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} OMIT OMIT ] :: (list                                            '(ref XT omit)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list or: $2 $3)))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref XT omit)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list or: _tk2 _tk3)))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} OMIT OMIT ] :: (list                                            '(ref XT omit)                                            (list lambda: '(xv) '(onError (lambda(s) false)) (list or: $2 $3)))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : OMIT
           ) ; end begin
         ) ; end case : OMIT
         ;; ====================
         ;; case: LETOMIT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_LETOMIT)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LETOMIT
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LETOMIT)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} LETOMIT LETOMIT ] :: (list                                            '(ref XT omit)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list or: (ref $2 1) (ref $3 1)))))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref XT omit)                                           (list (symbol "let") (ref _tk2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list or: (ref _tk2 1) (ref _tk3 1)))))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} LETOMIT LETOMIT ] :: (list                                            '(ref XT omit)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(xv) '(onError (lambda(s) false))                                                                    (list or: (ref $2 1) (ref $3 1)))))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LETOMIT
           ) ; end begin
         ) ; end case : LETOMIT
       ) ; end begin
     ) ; end case : Any{(= _tk1 "begin")}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.MAIN _verboseSemIn.MAIN) (error "Count" "in Routine MAIN"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_MAIN














;;**EXPORTKEY**:gsm.estimator._SEMRULE_OMIT
;; ************************************************
;; OMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the OMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_OMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: OMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.OMIT #void) 
          (setq _verboseSemCount.OMIT 1) 
          (setq _verboseSemCount.OMIT (iadd _verboseSemCount.OMIT 1)))

   (if (and (<> _verboseSemIn.OMIT #void) (> _verboseSemIn.OMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting OMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFOMIT
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFOMIT)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LAMBDA
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: OMIT: [ REFOMIT LAMBDA ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {OMIT: [ REFOMIT LAMBDA ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LAMBDA
           ) ; end begin
         ) ; end case : REFOMIT
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule OMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.OMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.OMIT _verboseSemIn.OMIT) (error "Count" "in Routine OMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_OMIT














;;**EXPORTKEY**:gsm.estimator._SEMRULE_REFOMIT
;; ************************************************
;; REFOMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the REFOMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_REFOMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFOMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.REFOMIT #void) 
          (setq _verboseSemCount.REFOMIT 1) 
          (setq _verboseSemCount.REFOMIT (iadd _verboseSemCount.REFOMIT 1)))

   (if (and (<> _verboseSemIn.REFOMIT #void) (> _verboseSemIn.REFOMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFOMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "ref")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "ref"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any{(= _tk3 "XT")}
             ;; ====================
             (if (and (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2)) (= _tk3 "XT"))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "omit")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "omit"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: REFOMIT: [ Any{(= _tk2 "ref")} Any{(= _tk3 "XT")} Any{(= _tk4 "omit")} ] :: (list $2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (list _tk2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {REFOMIT: [ Any{(= _tk2 "ref")} Any{(= _tk3 "XT")} Any{(= _tk4 "omit")} ] :: (list $2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "omit")}
               ) ; end begin
             ) ; end case : Any{(= _tk3 "XT")}
           ) ; end begin
         ) ; end case : Any{(= _tk2 "ref")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFOMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.REFOMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.REFOMIT _verboseSemIn.REFOMIT) (error "Count" "in Routine REFOMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_REFOMIT














;;**EXPORTKEY**:gsm.estimator._SEMRULE_REFTRUNCATE
;; ************************************************
;; REFTRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the REFTRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_REFTRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFTRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.REFTRUNCATE #void) 
          (setq _verboseSemCount.REFTRUNCATE 1) 
          (setq _verboseSemCount.REFTRUNCATE (iadd _verboseSemCount.REFTRUNCATE 1)))

   (if (and (<> _verboseSemIn.REFTRUNCATE #void) (> _verboseSemIn.REFTRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFTRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "ref")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "ref"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any{(= _tk3 "XT")}
             ;; ====================
             (if (and (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2)) (= _tk3 "XT"))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "truncate")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "truncate"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: REFTRUNCATE: [ Any{(= _tk2 "ref")} Any{(= _tk3 "XT")} Any{(= _tk4 "truncate")} ] :: (list $2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (list _tk2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {REFTRUNCATE: [ Any{(= _tk2 "ref")} Any{(= _tk3 "XT")} Any{(= _tk4 "truncate")} ] :: (list $2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "truncate")}
               ) ; end begin
             ) ; end case : Any{(= _tk3 "XT")}
           ) ; end begin
         ) ; end case : Any{(= _tk2 "ref")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFTRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.REFTRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.REFTRUNCATE _verboseSemIn.REFTRUNCATE) (error "Count" "in Routine REFTRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_REFTRUNCATE














;;**EXPORTKEY**:gsm.estimator._SEMRULE_TRUNCATE
;; ************************************************
;; TRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the TRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SEMRULE_TRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: TRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.TRUNCATE #void) 
          (setq _verboseSemCount.TRUNCATE 1) 
          (setq _verboseSemCount.TRUNCATE (iadd _verboseSemCount.TRUNCATE 1)))

   (if (and (<> _verboseSemIn.TRUNCATE #void) (> _verboseSemIn.TRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting TRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************











     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFTRUNCATE
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFTRUNCATE)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LAMBDA
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: TRUNCATE: [ REFTRUNCATE LAMBDA ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {TRUNCATE: [ REFTRUNCATE LAMBDA ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LAMBDA
           ) ; end begin
         ) ; end case : REFTRUNCATE
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule TRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.TRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.TRUNCATE _verboseSemIn.TRUNCATE) (error "Count" "in Routine TRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_TRUNCATE














;;**EXPORTKEY**:gsm.estimator._SYNRULE_ARGLIST
;; ************************************************
;; ARGLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the ARGLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_ARGLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: ARGLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.ARGLIST #void) 
          (setq _verboseSynCount.ARGLIST 1) 
          (setq _verboseSynCount.ARGLIST (iadd _verboseSynCount.ARGLIST 1)))

   (if (and (<> _verboseSynIn.ARGLIST #void) (> _verboseSynIn.ARGLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting ARGLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ARGLIST: RightParen :: (setq $0.Value #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value #void) )
            (if _verbose 
                (writeRule
                     {ARGLIST: RightParen :: (setq $0.Value #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                (if _verbose 
                    (writeRule
                         {ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightParen
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 137" _tk1.Charpos "Invalid argument list"))
            (if _verbose 
                (writeRule
                     {ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule ARGLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.ARGLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.ARGLIST _verboseSynIn.ARGLIST) (error "Count" "in Routine ARGLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_ARGLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_CFCALL
;; ************************************************
;; CFCALL user defined Syntax Rule implementation
;; Summary: This Lambda implements the CFCALL
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_CFCALL(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CFCALL: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CFCALL #void) 
          (setq _verboseSynCount.CFCALL 1) 
          (setq _verboseSynCount.CFCALL (iadd _verboseSynCount.CFCALL 1)))

   (if (and (<> _verboseSynIn.CFCALL #void) (> _verboseSynIn.CFCALL -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CFCALL Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: DotOperator
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[DotOperator:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CFCALL (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: ARGLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (sendList _tk0 _tk2.Value _ak0.Value _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ARGLIST
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Name LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 117" _tk1.Charpos "Invalid function call") )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Name LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Name
         ;; ====================
         ;; case: Reserved
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Reserved:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CFCALL (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: ARGLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (sendList _tk0 _tk2.Value _ak0.Value _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ARGLIST
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Reserved LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 117" _tk1.Charpos "Invalid function call") )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Reserved LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Reserved
       ) ; end begin
     ) ; end case : DotOperator
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CFCALL on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CFCALL -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CFCALL _verboseSynIn.CFCALL) (error "Count" "in Routine CFCALL"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CFCALL























;;**EXPORTKEY**:gsm.estimator._SYNRULE_CHILD
;; ************************************************
;; CHILD user defined Syntax Rule implementation
;; Summary: This Lambda implements the CHILD
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_CHILD(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CHILD: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CHILD #void) 
          (setq _verboseSynCount.CHILD 1) 
          (setq _verboseSynCount.CHILD (iadd _verboseSynCount.CHILD 1)))

   (if (and (<> _verboseSynIn.CHILD #void) (> _verboseSynIn.CHILD -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CHILD Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Child
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Child:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CHILD: Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {CHILD: Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Child
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CHILD on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CHILD -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CHILD _verboseSynIn.CHILD) (error "Count" "in Routine CHILD"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CHILD























;;**EXPORTKEY**:gsm.estimator._SYNRULE_CLASS
;; ************************************************
;; CLASS user defined Syntax Rule implementation
;; Summary: This Lambda implements the CLASS
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_CLASS(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CLASS: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CLASS #void) 
          (setq _verboseSynCount.CLASS 1) 
          (setq _verboseSynCount.CLASS (iadd _verboseSynCount.CLASS 1)))

   (if (and (<> _verboseSynIn.CLASS #void) (> _verboseSynIn.CLASS -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CLASS Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Class
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Class:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CLASS: Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {CLASS: Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Class
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CLASS on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CLASS -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CLASS _verboseSynIn.CLASS) (error "Count" "in Routine CLASS"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CLASS























;;**EXPORTKEY**:gsm.estimator._SYNRULE_CUT
;; ************************************************
;; CUT user defined Syntax Rule implementation
;; Summary: This Lambda implements the CUT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_CUT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CUT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CUT #void) 
          (setq _verboseSynCount.CUT 1) 
          (setq _verboseSynCount.CUT (iadd _verboseSynCount.CUT 1)))

   (if (and (<> _verboseSynIn.CUT #void) (> _verboseSynIn.CUT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CUT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Number
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Percent
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Percent:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (foldConstants _tk0 |/|: _tk1.Value 100) )
                (if _verbose 
                    (writeRule
                         {CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Percent
         ;; *********************************************************
         ;; RULE: CUT: Number :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {CUT: Number :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CUT: SEXPRESSION :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {CUT: SEXPRESSION :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CUT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CUT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CUT _verboseSynIn.CUT) (error "Count" "in Routine CUT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CUT























;;**EXPORTKEY**:gsm.estimator._SYNRULE_EXPRESSION
;; ************************************************
;; EXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the EXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_EXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: EXPRESSION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.EXPRESSION #void) 
          (setq _verboseSynCount.EXPRESSION 1) 
          (setq _verboseSynCount.EXPRESSION (iadd _verboseSynCount.EXPRESSION 1)))

   (if (and (<> _verboseSynIn.EXPRESSION #void) (> _verboseSynIn.EXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting EXPRESSION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: PHRASE
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: OPRLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: EXPRESSION: PHRASE OPRLIST :: (setExpList $0 $1 $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setExpList _tk0 _tk1 _tk2) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: PHRASE OPRLIST :: (setExpList $0 $1 $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : OPRLIST
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: EXPRESSION: PHRASE Operator :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 102" _tk2.Charpos (append "Invalid use of " _tk2.Value " operator")) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: PHRASE Operator :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Operator
         ;; *********************************************************
         ;; RULE: EXPRESSION: PHRASE :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: PHRASE :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : PHRASE
     ;; ====================
     ;; case: TERM
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: OPRLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: EXPRESSION: TERM OPRLIST :: (setExpList $0 $1 $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setExpList _tk0 _tk1 _tk2) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: TERM OPRLIST :: (setExpList $0 $1 $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : OPRLIST
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: EXPRESSION: TERM Operator :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 103" _tk2.Charpose (append "Invalid use of " _tk2.Value " operator")) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: TERM Operator :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Operator
         ;; *********************************************************
         ;; RULE: EXPRESSION: TERM :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: TERM :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : TERM
     ;; ====================
     ;; case: STATEMENT
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_STATEMENT)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: EXPRESSION: STATEMENT :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: STATEMENT :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
         ;; ====================
         ;; case: OPRLIST
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: EXPRESSION: STATEMENT OPRLIST :: (setExpList $0 $1 $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setExpList _tk0 _tk1 _tk2) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: STATEMENT OPRLIST :: (setExpList $0 $1 $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : OPRLIST
       ) ; end begin
     ) ; end case : STATEMENT
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule EXPRESSION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.EXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.EXPRESSION _verboseSynIn.EXPRESSION) (error "Count" "in Routine EXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_EXPRESSION























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FIELDLIST
;; ************************************************
;; FIELDLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the FIELDLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FIELDLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FIELDLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FIELDLIST #void) 
          (setq _verboseSynCount.FIELDLIST 1) 
          (setq _verboseSynCount.FIELDLIST (iadd _verboseSynCount.FIELDLIST 1)))

   (if (and (<> _verboseSynIn.FIELDLIST #void) (> _verboseSynIn.FIELDLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FIELDLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Name
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: RightBrace
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[RightBrace:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                (if _verbose 
                    (writeRule
                         {FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightBrace
         ;; ====================
         ;; case: Semicolon
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Semicolon:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: FIELDLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : FIELDLIST
             ;; ====================
             ;; case: RightBrace
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightBrace:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightBrace
           ) ; end begin
         ) ; end case : Semicolon
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: RightBrace
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightBrace:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (new Vector: 0)) )
            (if _verbose 
                (writeRule
                     {FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightBrace
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 139" _tk1.Charpos "Invalid field list") )
            (if _verbose 
                (writeRule
                     {FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FIELDLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FIELDLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FIELDLIST _verboseSynIn.FIELDLIST) (error "Count" "in Routine FIELDLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FIELDLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FILTER
;; ************************************************
;; FILTER user defined Syntax Rule implementation
;; Summary: This Lambda implements the FILTER
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FILTER(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FILTER: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FILTER #void) 
          (setq _verboseSynCount.FILTER 1) 
          (setq _verboseSynCount.FILTER (iadd _verboseSynCount.FILTER 1)))

   (if (and (<> _verboseSynIn.FILTER #void) (> _verboseSynIn.FILTER -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FILTER Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: FSTMTLIST
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_FSTMTLIST)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (filterFinal _tk1.Value)) )
            (if _verbose 
                (writeRule
                     {FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FSTMTLIST
     ;; ====================
     ;; case: Select
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Select:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: FSTMTLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_FSTMTLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FILTER: Select FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (filterFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {FILTER: Select FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : FSTMTLIST
       ) ; end begin
     ) ; end case : Select
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FILTER on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FILTER -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FILTER _verboseSynIn.FILTER) (error "Count" "in Routine FILTER"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FILTER























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FRIEND
;; ************************************************
;; FRIEND user defined Syntax Rule implementation
;; Summary: This Lambda implements the FRIEND
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FRIEND(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FRIEND: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FRIEND #void) 
          (setq _verboseSynCount.FRIEND 1) 
          (setq _verboseSynCount.FRIEND (iadd _verboseSynCount.FRIEND 1)))

   (if (and (<> _verboseSynIn.FRIEND #void) (> _verboseSynIn.FRIEND -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FRIEND Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Friend
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Friend:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FRIEND: Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {FRIEND: Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Friend
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FRIEND on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FRIEND -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FRIEND _verboseSynIn.FRIEND) (error "Count" "in Routine FRIEND"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FRIEND























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FSTATEMENT
;; ************************************************
;; FSTATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the FSTATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FSTATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FSTATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FSTATEMENT #void) 
          (setq _verboseSynCount.FSTATEMENT 1) 
          (setq _verboseSynCount.FSTATEMENT (iadd _verboseSynCount.FSTATEMENT 1)))

   (if (and (<> _verboseSynIn.FSTATEMENT #void) (> _verboseSynIn.FSTATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FSTATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Sort{(xReferentOn)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Sort:] #void) true (setq _ip _ip0)) (xReferentOn))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Direction
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Direction:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (sortCut _tk0 _tk2.Lisp _tk3.Value -1) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : Direction
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (sortCut _tk0 |<=|: _tk2.Value -1) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Sort{(xReferentOn)}
     ;; ====================
     ;; case: Cut{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Cut:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CUT
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (sortCut _tk0 _tk1.Lisp _tk2.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CUT
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Cut{(xReferentOn)}
     ;; ====================
     ;; case: Slice{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Slice:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CUT
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Of
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Of:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: CUT
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (sliceCut _tk0 _tk1.Lisp _tk2.Value _tk3.Value _tk5.Value) )
                            (if _verbose 
                                (writeRule
                                     {FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : CUT
                   ) ; end begin
                 ) ; end case : Of
               ) ; end begin
             ) ; end case : CUT
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Slice{(xReferentOn)}
     ;; ====================
     ;; case: All{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[All:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Semicolon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Semicolon:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value true) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Semicolon
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (filterCut _tk0 _tk2.Value _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setq _tk0.Value true) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : All{(xReferentOn)}
     ;; ====================
     ;; case: Run{(xReferentOff)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Run:] #void) true (setq _ip _ip0)) (xReferentOff)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (runFilter _tk0 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Run{(xReferentOff)}
     ;; ====================
     ;; case: Restore{(xReferentOff)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Restore:] #void) true (setq _ip _ip0)) (xReferentOff)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: XT: ''restore))) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (list (list |ref|: XT: ''restore))) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: XT: ''restore))) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Restore{(xReferentOff)}
     ;; ====================
     ;; case: Scale{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Scale:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Scale{(xReferentOn)} SEXPRESSION Semicolon :: (filterScale $0 $2.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (filterScale _tk0 _tk2.Value) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Scale{(xReferentOn)} SEXPRESSION Semicolon :: (filterScale $0 $2.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Scale{(xReferentOn)}
     ;; ====================
     ;; case: Regress{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Regress:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Regress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressReg $0 $3.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressReg _tk0 _tk3.Value) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Regress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressReg $0 $3.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : ARGLIST
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Regress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressReg $0 (new Vector: 1 "0")) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressReg _tk0 (new Vector: 1 "0")) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Regress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressReg $0 (new Vector: 1 "0")) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Regress{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressReg $0 (new Vector: 1 $2.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (templateRegressReg _tk0 (new Vector: 1 _tk2.Value)) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Regress{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressReg $0 (new Vector: 1 $2.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Regress{(xReferentOn)}
     ;; ====================
     ;; case: Model{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Model:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Model{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMdl $0 $3.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressMdl _tk0 _tk3.Value) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Model{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMdl $0 $3.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : ARGLIST
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Model{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressMdl $0 (new Vector: 1 "0")) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressMdl _tk0 (new Vector: 1 "0")) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Model{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressMdl $0 (new Vector: 1 "0")) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Model{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressMdl $0 (new Vector: 1 $2.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (templateRegressMdl _tk0 (new Vector: 1 _tk2.Value)) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Model{(xReferentOn)} SEXPRESSION Semicolon :: (templateRegressMdl $0 (new Vector: 1 $2.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Model{(xReferentOn)}
     ;; ====================
     ;; case: Frmregress{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Frmregress:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Frmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressFrm $0 $3.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressFrm _tk0 _tk3.Value) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Frmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressFrm $0 $3.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : Frmregress{(xReferentOn)}
     ;; ====================
     ;; case: Mvlregress{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Mvlregress:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Mvlregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMvl $0 $3.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressMvl _tk0 _tk3.Value) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Mvlregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressMvl $0 $3.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : Mvlregress{(xReferentOn)}
     ;; ====================
     ;; case: Svmregress{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Svmregress:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Svmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressSvm $0 $3.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressSvm _tk0 _tk3.Value) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Svmregress{(xReferentOn)} LeftParen ARGLIST Semicolon :: (templateRegressSvm $0 $3.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : ARGLIST
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Svmregress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressSvm $0) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (templateRegressSvm _tk0) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Svmregress{(xReferentOn)} LeftParen RightParen Semicolon :: (templateRegressSvm $0) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: Semicolon
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Semicolon:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Svmregress{(xReferentOn)} Semicolon :: (templateRegressSvm $0) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (templateRegressSvm _tk0) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Svmregress{(xReferentOn)} Semicolon :: (templateRegressSvm $0) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Semicolon
       ) ; end begin
     ) ; end case : Svmregress{(xReferentOn)}
     ;; ====================
     ;; case: Highest{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Highest:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CUT
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Highest{(xReferentOn)} SEXPRESSION CUT :: (highestCut $0 $2.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (highestCut _tk0 _tk2.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Highest{(xReferentOn)} SEXPRESSION CUT :: (highestCut $0 $2.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CUT
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Highest{(xReferentOn)}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FSTATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FSTATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FSTATEMENT _verboseSynIn.FSTATEMENT) (error "Count" "in Routine FSTATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FSTATEMENT























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FSTMTLIST
;; ************************************************
;; FSTMTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the FSTMTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FSTMTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FSTMTLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FSTMTLIST #void) 
          (setq _verboseSynCount.FSTMTLIST 1) 
          (setq _verboseSynCount.FSTMTLIST (iadd _verboseSynCount.FSTMTLIST 1)))

   (if (and (<> _verboseSynIn.FSTMTLIST #void) (> _verboseSynIn.FSTMTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FSTMTLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: FSTATEMENT
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_FSTATEMENT)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToBeginList _tk0 _tk1.Value) )
            (if _verbose 
                (writeRule
                     {FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : FSTATEMENT
     ;; ====================
     ;; case: Semicolon
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Semicolon:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTMTLIST: Semicolon << $0 >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {FSTMTLIST: Semicolon << $0 >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : Semicolon
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FSTMTLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FSTMTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FSTMTLIST _verboseSynIn.FSTMTLIST) (error "Count" "in Routine FSTMTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FSTMTLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_FUNCTION
;; ************************************************
;; FUNCTION user defined Syntax Rule implementation
;; Summary: This Lambda implements the FUNCTION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_FUNCTION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FUNCTION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FUNCTION #void) 
          (setq _verboseSynCount.FUNCTION 1) 
          (setq _verboseSynCount.FUNCTION (iadd _verboseSynCount.FUNCTION 1)))

   (if (and (<> _verboseSynIn.FUNCTION #void) (> _verboseSynIn.FUNCTION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FUNCTION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Function
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Function:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Function
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FUNCTION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FUNCTION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FUNCTION _verboseSynIn.FUNCTION) (error "Count" "in Routine FUNCTION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FUNCTION























;;**EXPORTKEY**:gsm.estimator._SYNRULE_MAIN
;; ************************************************
;; MAIN user defined Syntax Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: MAIN: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.MAIN #void) 
          (setq _verboseSynCount.MAIN 1) 
          (setq _verboseSynCount.MAIN (iadd _verboseSynCount.MAIN 1)))

   (if (and (<> _verboseSynIn.MAIN #void) (> _verboseSynIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: #
     ;; ====================
     (if (if (= (setq _tk1 (_getToken))[Value:] |#|:) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: "estimator"
         ;; ====================
         (if (if (= (setq _tk2 (_getToken))[Value:] "estimator") true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: #
             ;; ====================
             (if (if (= (setq _tk3 (_getToken))[Value:] |#|:) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: MAIN: # "estimator" # || (= $3.Charpos 8) || << true >>
                 ;; *********************************************************
                 (if  (= _tk3.Charpos 8) 
                  (begin
                    (setq _ret  true )
                    (if _verbose 
                        (writeRule
                             {MAIN: # "estimator" # || (= $3.Charpos 8) || << true >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (goto Skip:))

                 ) ; end case : _default
               ) ; end begin
             ) ; end case : #
           ) ; end begin
         ) ; end case : "estimator"
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: STMTLIST
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Eof
         ;; ====================
         (if (if (_eofToken)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Eof :: (list $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (list _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {MAIN: STMTLIST Eof :: (list $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Eof
         ;; ====================
         ;; case: Value
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Value:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 100" _tk2.Charpos "Invalid expression") )
                (if _verbose 
                    (writeRule
                         {MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Value
       ) ; end begin
     ) ; end case : STMTLIST
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 101" _tk1.Charpos "Invalid expression") )
            (if _verbose 
                (writeRule
                     {MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (_eofToken)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: (list #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (list #void) )
            (if _verbose 
                (writeRule
                     {MAIN: Eof :: (list #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.MAIN _verboseSynIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_MAIN























;;**EXPORTKEY**:gsm.estimator._SYNRULE_METHOD
;; ************************************************
;; METHOD user defined Syntax Rule implementation
;; Summary: This Lambda implements the METHOD
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_METHOD(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: METHOD: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.METHOD #void) 
          (setq _verboseSynCount.METHOD 1) 
          (setq _verboseSynCount.METHOD (iadd _verboseSynCount.METHOD 1)))

   (if (and (<> _verboseSynIn.METHOD #void) (> _verboseSynIn.METHOD -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting METHOD Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Method
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Method:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: METHOD: Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {METHOD: Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Method
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule METHOD on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.METHOD -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.METHOD _verboseSynIn.METHOD) (error "Count" "in Routine METHOD"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_METHOD























;;**EXPORTKEY**:gsm.estimator._SYNRULE_NAME
;; ************************************************
;; NAME user defined Syntax Rule implementation
;; Summary: This Lambda implements the NAME
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_NAME(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: NAME: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.NAME #void) 
          (setq _verboseSynCount.NAME 1) 
          (setq _verboseSynCount.NAME (iadd _verboseSynCount.NAME 1)))

   (if (and (<> _verboseSynIn.NAME #void) (> _verboseSynIn.NAME -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting NAME Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Name{(isFieldName $1)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)) (isFieldName _tk1))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: QUALIFY((xReferent $0 $1))
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_QUALIFY (xReferent _tk0 _tk1))) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NAME: Name{(isFieldName $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk2[Charpos:] _tk1.Charpos) )
                (if _verbose 
                    (writeRule
                         {NAME: Name{(isFieldName $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : QUALIFY((xReferent $0 $1))
         ;; *********************************************************
         ;; RULE: NAME: Name{(isFieldName $1)} :: (xReferent $0 $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (xReferent _tk0 _tk1) )
            (if _verbose 
                (writeRule
                     {NAME: Name{(isFieldName $1)} :: (xReferent $0 $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name{(isFieldName $1)}
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: QUALIFY($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_QUALIFY _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk2[Charpos:] _tk1.Charpos) )
                (if _verbose 
                    (writeRule
                         {NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : QUALIFY($1)
         ;; *********************************************************
         ;; RULE: NAME: Name :: (setVType $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setVType _tk1) )
            (if _verbose 
                (writeRule
                     {NAME: Name :: (setVType $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule NAME on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.NAME -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.NAME _verboseSynIn.NAME) (error "Count" "in Routine NAME"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_NAME























;;**EXPORTKEY**:gsm.estimator._SYNRULE_NUMLIST
;; ************************************************
;; NUMLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the NUMLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_NUMLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: NUMLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.NUMLIST #void) 
          (setq _verboseSynCount.NUMLIST 1) 
          (setq _verboseSynCount.NUMLIST (iadd _verboseSynCount.NUMLIST 1)))

   (if (and (<> _verboseSynIn.NUMLIST #void) (> _verboseSynIn.NUMLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting NUMLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: -
     ;; ====================
     (if (if (= (setq _tk1 (_getToken))[Value:] |-|:) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Number
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Number:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: NUMLIST: - Number RightParen :: (setq $0.Value (append $0.Value " -" $2.Value " )")) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (append _tk0.Value " -" _tk2.Value " )")) )
                    (if _verbose 
                        (writeRule
                             {NUMLIST: - Number RightParen :: (setq $0.Value (append $0.Value " -" $2.Value " )")) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightParen
             ;; ====================
             ;; case: NUMLIST
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SYNRULE_NUMLIST)) morphFail)true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: NUMLIST: - Number NUMLIST :: (setq $0.Value (append $0.Value " -" $2.Value " " $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (append _tk0.Value " -" _tk2.Value " " _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {NUMLIST: - Number NUMLIST :: (setq $0.Value (append $0.Value " -" $2.Value " " $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : NUMLIST
           ) ; end begin
         ) ; end case : Number
       ) ; end begin
     ) ; end case : -
     ;; ====================
     ;; case: Number
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: RightParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[RightParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NUMLIST: Number RightParen :: (setq $0.Value (append $0.Value " " $1.Value " )")) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (append _tk0.Value " " _tk1.Value " )")) )
                (if _verbose 
                    (writeRule
                         {NUMLIST: Number RightParen :: (setq $0.Value (append $0.Value " " $1.Value " )")) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightParen
         ;; ====================
         ;; case: NUMLIST
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_NUMLIST)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NUMLIST: Number NUMLIST :: (setq $0.Value (append $0.Value " " $1.Value " " $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (append _tk0.Value " " _tk1.Value " " _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {NUMLIST: Number NUMLIST :: (setq $0.Value (append $0.Value " " $1.Value " " $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NUMLIST
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: NUMLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 137" _tk1.Charpos "Invalid weight list"))
            (if _verbose 
                (writeRule
                     {NUMLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule NUMLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.NUMLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.NUMLIST _verboseSynIn.NUMLIST) (error "Count" "in Routine NUMLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_NUMLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_OPRLIST
;; ************************************************
;; OPRLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the OPRLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_OPRLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: OPRLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.OPRLIST #void) 
          (setq _verboseSynCount.OPRLIST 1) 
          (setq _verboseSynCount.OPRLIST (iadd _verboseSynCount.OPRLIST 1)))

   (if (and (<> _verboseSynIn.OPRLIST #void) (> _verboseSynIn.OPRLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting OPRLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Operator
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Operator:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: PHRASE
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: OPRLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: OPRLIST: Operator PHRASE OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert (insert _tk3.Value 0 _tk2) 0 _tk1)) )
                    (if _verbose 
                        (writeRule
                             {OPRLIST: Operator PHRASE OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : OPRLIST
           ) ; end begin
         ) ; end case : PHRASE
         ;; ====================
         ;; case: TERM
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: OPRLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: OPRLIST: Operator TERM OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert (insert _tk3.Value 0 _tk2) 0 _tk1)) )
                    (if _verbose 
                        (writeRule
                             {OPRLIST: Operator TERM OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : OPRLIST
           ) ; end begin
         ) ; end case : TERM
         ;; ====================
         ;; case: STATEMENT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_STATEMENT)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: OPRLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_OPRLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: OPRLIST: Operator STATEMENT OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert (insert _tk3.Value 0 _tk2) 0 _tk1)) )
                    (if _verbose 
                        (writeRule
                             {OPRLIST: Operator STATEMENT OPRLIST :: (setq $0.Value (insert (insert $3.Value 0 $2) 0 $1)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : OPRLIST
           ) ; end begin
         ) ; end case : STATEMENT
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: OPRLIST: Operator SEXPRESSION :: (setq $0.Value (new Vector: 2 $1 $2)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (new Vector: 2 _tk1 _tk2)) )
                (if _verbose 
                    (writeRule
                         {OPRLIST: Operator SEXPRESSION :: (setq $0.Value (new Vector: 2 $1 $2)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: OPRLIST: Operator :: (_makeError "JS 102" $1.Charpos (append "Invalid use of " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 102" _tk1.Charpos (append "Invalid use of " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {OPRLIST: Operator :: (_makeError "JS 102" $1.Charpos (append "Invalid use of " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Operator
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule OPRLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.OPRLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.OPRLIST _verboseSynIn.OPRLIST) (error "Count" "in Routine OPRLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_OPRLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_ORPHAN
;; ************************************************
;; ORPHAN user defined Syntax Rule implementation
;; Summary: This Lambda implements the ORPHAN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_ORPHAN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: ORPHAN: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.ORPHAN #void) 
          (setq _verboseSynCount.ORPHAN 1) 
          (setq _verboseSynCount.ORPHAN (iadd _verboseSynCount.ORPHAN 1)))

   (if (and (<> _verboseSynIn.ORPHAN #void) (> _verboseSynIn.ORPHAN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting ORPHAN Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Orphan
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Orphan:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ORPHAN: Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {ORPHAN: Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Orphan
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule ORPHAN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.ORPHAN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.ORPHAN _verboseSynIn.ORPHAN) (error "Count" "in Routine ORPHAN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_ORPHAN























;;**EXPORTKEY**:gsm.estimator._SYNRULE_PARMLIST
;; ************************************************
;; PARMLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the PARMLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_PARMLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: PARMLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.PARMLIST #void) 
          (setq _verboseSynCount.PARMLIST 1) 
          (setq _verboseSynCount.PARMLIST (iadd _verboseSynCount.PARMLIST 1)))

   (if (and (<> _verboseSynIn.PARMLIST #void) (> _verboseSynIn.PARMLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting PARMLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Name
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PARMLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar avarVector obj: _tk1.Value (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) #void) )
                    (if _verbose 
                        (writeRule
                             {PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : PARMLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (addVar avarVector obj: _tk1.Value (setq _tk0.Value (new Vector: 1 _tk1.Value)) #void) )
                (if _verbose 
                    (writeRule
                         {PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightParen
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: PARMLIST: RightParen :: (setq $0.Value #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value #void) )
            (if _verbose 
                (writeRule
                     {PARMLIST: RightParen :: (setq $0.Value #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; ====================
     ;; case: Type
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Type:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Comma
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Comma:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: PARMLIST: Type Name Comma PARMLIST :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (addVar avarVector _tk1.Value _tk2.Value (setq _tk0.Value (insert _tk4.Value 0 _tk2.Value)) #void) )
                        (if _verbose 
                            (writeRule
                                 {PARMLIST: Type Name Comma PARMLIST :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : Comma
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PARMLIST: Type Name RightParen :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar avarVector _tk1.Value _tk2.Value (setq _tk0.Value (new Vector: 1 _tk2.Value)) #void) )
                    (if _verbose 
                        (writeRule
                             {PARMLIST: Type Name RightParen :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Name
       ) ; end begin
     ) ; end case : Type
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (error (append "Invalid argument list [" _tk1.Charpos "] " (mid _tkIN _tk1.Charpos 120))) )
            (if _verbose 
                (writeRule
                     {PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule PARMLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.PARMLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.PARMLIST _verboseSynIn.PARMLIST) (error "Count" "in Routine PARMLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_PARMLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_PHRASE
;; ************************************************
;; PHRASE user defined Syntax Rule implementation
;; Summary: This Lambda implements the PHRASE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_PHRASE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: PHRASE: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.PHRASE #void) 
          (setq _verboseSynCount.PHRASE 1) 
          (setq _verboseSynCount.PHRASE (iadd _verboseSynCount.PHRASE 1)))

   (if (and (<> _verboseSynIn.PHRASE #void) (> _verboseSynIn.PHRASE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting PHRASE Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Logical
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Logical:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list _tk1.Lisp _tk2.Value))[VType:] bool:) )
                (if _verbose 
                    (writeRule
                         {PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 118" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Logical
     ;; ====================
     ;; case: Increment
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Increment:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk2 _tk1 false) )
                (if _verbose 
                    (writeRule
                         {PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NAME
         ;; *********************************************************
         ;; RULE: PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 119" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Increment
     ;; ====================
     ;; case: LeftBrace
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftBrace:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: STMTLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightBrace
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightBrace:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightBrace
           ) ; end begin
         ) ; end case : STMTLIST
         ;; *********************************************************
         ;; RULE: PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 120" _tk1.Charpos "Invalid statement block") )
            (if _verbose 
                (writeRule
                     {PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftBrace
     ;; ====================
     ;; case: If
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[If:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Else
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Else:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: SEXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (list |if|: _tk2.Value _tk3.Value _tk5.Value)) )
                            (if _verbose 
                                (writeRule
                                     {PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : SEXPRESSION
                     ;; *********************************************************
                     ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION Else :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (_makeError "JS 121" _tk1.Charpos "Invalid else statement") )
                        (if _verbose 
                            (writeRule
                                 {PHRASE: If SEXPRESSION SEXPRESSION Else :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Else
                 ;; *********************************************************
                 ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (setq _tk0.Value (list |if|: _tk2.Value _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
             ;; *********************************************************
             ;; RULE: PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 121" _tk1.Charpos "Invalid then statement") )
                (if _verbose 
                    (writeRule
                         {PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 122" _tk1.Charpos "Invalid if statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : If
     ;; ====================
     ;; case: While
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[While:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (list |while|: _tk2.Value _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: While :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 123" _tk1.Charpos "Invalid while statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: While :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : While
     ;; ====================
     ;; case: For
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[For:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PHRASE
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: SEXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: Semicolon
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[Semicolon:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: PHRASE
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightParen
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightParen:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; ====================
                                     ;; case: SEXPRESSION
                                     ;; ====================
                                     (if (if (<> (setq _tk9 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip8))
                                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 _ip) 
                                         ;; *********************************************************
                                         ;; RULE: PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (setq _tk0.Value (list |begin|: _tk3.Value (list |while|: _tk5.Value _tk9.Value _tk7.Value))) )
                                            (if _verbose 
                                                (writeRule
                                                     {PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
                                            (setq _indent (isub _indent 1))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : SEXPRESSION
                                   ) ; end begin
                                 ) ; end case : RightParen
                               ) ; end begin
                             ) ; end case : PHRASE
                           ) ; end begin
                         ) ; end case : Semicolon
                       ) ; end begin
                     ) ; end case : SEXPRESSION
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : PHRASE
           ) ; end begin
         ) ; end case : LeftParen
         ;; *********************************************************
         ;; RULE: PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 124" _tk1.Charpos "Invalid for statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : For
     ;; ====================
     ;; case: Reg
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Reg:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(regVector setq:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR regVector setq:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Reg VAR(regVector setq:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Reg VAR(regVector setq:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(regVector setq:)
         ;; *********************************************************
         ;; RULE: PHRASE: Reg :: (_makeError "JS 125" $1.Charpos "Invalid reg statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 125" _tk1.Charpos "Invalid reg statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Reg :: (_makeError "JS 125" $1.Charpos "Invalid reg statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Reg
     ;; ====================
     ;; case: Var
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Var:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(varVector setq:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR varVector setq:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Var VAR(varVector setq:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Var VAR(varVector setq:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(varVector setq:)
         ;; *********************************************************
         ;; RULE: PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 125" _tk1.Charpos "Invalid var statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Var
     ;; ====================
     ;; case: Pvar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Pvar:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(pvarVector define:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR pvarVector define:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Pvar VAR(pvarVector define:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Pvar VAR(pvarVector define:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(pvarVector define:)
         ;; *********************************************************
         ;; RULE: PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 126" _tk1.Charpos "Invalid pvar statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Pvar
     ;; ====================
     ;; case: Cvar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Cvar:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(cvarVector setq:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR cvarVector setq:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(cvarVector setq:)
         ;; *********************************************************
         ;; RULE: PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 127" _tk1.Charpos "Invalid cvar statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Cvar
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: CFCALL($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_CFCALL _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Name CFCALL($1) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Name CFCALL($1) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : CFCALL($1)
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: NAME
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Increment
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Increment:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk1 _tk2 true) )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Increment
         ;; ====================
         ;; case: MathAssignmentOperator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[MathAssignmentOperator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (assignMath _tk0 _tk2 _tk1 _tk3) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : MathAssignmentOperator
         ;; ====================
         ;; case: AssignmentOperator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[AssignmentOperator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (assignMe _tk0 _tk2 _tk1 _tk3) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
             ;; *********************************************************
             ;; RULE: PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 128" _tk2.Charpos "Invalid assignment") )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : AssignmentOperator
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
             ;; *********************************************************
             ;; RULE: PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 129" _tk1.Charpos "Invalid function call") )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : NAME
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule PHRASE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.PHRASE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.PHRASE _verboseSynIn.PHRASE) (error "Count" "in Routine PHRASE"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_PHRASE























;;**EXPORTKEY**:gsm.estimator._SYNRULE_QUALIFY
;; ************************************************
;; QUALIFY user defined Syntax Rule implementation
;; Summary: This Lambda implements the QUALIFY
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_QUALIFY(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: QUALIFY: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.QUALIFY #void) 
          (setq _verboseSynCount.QUALIFY 1) 
          (setq _verboseSynCount.QUALIFY (iadd _verboseSynCount.QUALIFY 1)))

   (if (and (<> _verboseSynIn.QUALIFY #void) (> _verboseSynIn.QUALIFY -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting QUALIFY Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: DotOperator
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[DotOperator:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; *********************************************************
             ;; RULE: QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
         ;; ====================
         ;; case: Reserved
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Reserved:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; *********************************************************
             ;; RULE: QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Reserved
         ;; *********************************************************
         ;; RULE: QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 115" _tk1.Charpos "Invalid use of dot operator") )
            (if _verbose 
                (writeRule
                     {QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : DotOperator
     ;; ====================
     ;; case: LeftBracket
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftBracket:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: REFLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_REFLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 $2.Value))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 _tk2.Value))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 $2.Value))
             ;; *********************************************************
             ;; RULE: QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : REFLIST
         ;; *********************************************************
         ;; RULE: QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 116" _tk1.Charpos "Invalid use of [ operator" ) )
            (if _verbose 
                (writeRule
                     {QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftBracket
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule QUALIFY on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.QUALIFY -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.QUALIFY _verboseSynIn.QUALIFY) (error "Count" "in Routine QUALIFY"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_QUALIFY























;;**EXPORTKEY**:gsm.estimator._SYNRULE_REFLIST
;; ************************************************
;; REFLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the REFLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_REFLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.REFLIST #void) 
          (setq _verboseSynCount.REFLIST 1) 
          (setq _verboseSynCount.REFLIST (iadd _verboseSynCount.REFLIST 1)))

   (if (and (<> _verboseSynIn.REFLIST #void) (> _verboseSynIn.REFLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: REFLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_REFLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : REFLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightBracket
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightBracket:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (new Vector: 1 _tk1.Value))[VType:] _tk1.VType) )
                (if _verbose 
                    (writeRule
                         {REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightBracket
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 138" _tk1.Charpos "Invalid index list") )
            (if _verbose 
                (writeRule
                     {REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.REFLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.REFLIST _verboseSynIn.REFLIST) (error "Count" "in Routine REFLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_REFLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_SCORE
;; ************************************************
;; SCORE user defined Syntax Rule implementation
;; Summary: This Lambda implements the SCORE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_SCORE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SCORE: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SCORE #void) 
          (setq _verboseSynCount.SCORE 1) 
          (setq _verboseSynCount.SCORE (iadd _verboseSynCount.SCORE 1)))

   (if (and (<> _verboseSynIn.SCORE #void) (> _verboseSynIn.SCORE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SCORE Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Score
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Score:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: AssignmentOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[AssignmentOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SSTATEMENT
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq _tk0.Value (appendList _tk3.Lisp _tk2.Value (list _tk4.Value))) )
                        (if _verbose 
                            (writeRule
                                 {SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SSTATEMENT
               ) ; end begin
             ) ; end case : AssignmentOperator
           ) ; end begin
         ) ; end case : NAME
         ;; ====================
         ;; case: SSTATEMENT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (scoreFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SSTATEMENT
       ) ; end begin
     ) ; end case : Score
     ;; ====================
     ;; case: Score{(begin (pushVars $0) true)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Score:] #void) true (setq _ip _ip0)) (begin (pushVars _tk0) true)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION{(begin (popVars) true)}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)) (begin (popVars) true))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (scoreFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION{(begin (popVars) true)}
       ) ; end begin
     ) ; end case : Score{(begin (pushVars $0) true)}
     ;; ====================
     ;; case: SSTATEMENT
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (scoreFinal _tk1.Value)) )
            (if _verbose 
                (writeRule
                     {SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SSTATEMENT
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SCORE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SCORE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SCORE _verboseSynIn.SCORE) (error "Count" "in Routine SCORE"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SCORE























;;**EXPORTKEY**:gsm.estimator._SYNRULE_SEXPRESSION
;; ************************************************
;; SEXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the SEXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_SEXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SEXPRESSION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SEXPRESSION #void) 
          (setq _verboseSynCount.SEXPRESSION 1) 
          (setq _verboseSynCount.SEXPRESSION (iadd _verboseSynCount.SEXPRESSION 1)))

   (if (and (<> _verboseSynIn.SEXPRESSION #void) (> _verboseSynIn.SEXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SEXPRESSION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: EXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Question
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Question:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: EXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Colon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Colon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: EXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (list if: _tk1.Value _tk3.Value _tk5.Value)) )
                            (if _verbose 
                                (writeRule
                                     {SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : EXPRESSION
                   ) ; end begin
                 ) ; end case : Colon
               ) ; end begin
             ) ; end case : EXPRESSION
           ) ; end begin
         ) ; end case : Question
         ;; *********************************************************
         ;; RULE: SEXPRESSION: EXPRESSION :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {SEXPRESSION: EXPRESSION :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : EXPRESSION
     ;; ====================
     ;; case: LeftParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Type
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Type:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: EXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq (setq (setq _tk4.VType _tk2.Value)[SEXPRESSION:] true)[Charpos:] _tk0.Charpos) )
                        (if _verbose 
                            (writeRule
                                 {SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : EXPRESSION
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Type
       ) ; end begin
     ) ; end case : LeftParen
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SEXPRESSION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SEXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SEXPRESSION _verboseSynIn.SEXPRESSION) (error "Count" "in Routine SEXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SEXPRESSION























;;**EXPORTKEY**:gsm.estimator._SYNRULE_SSTATEMENT
;; ************************************************
;; SSTATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the SSTATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_SSTATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SSTATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SSTATEMENT #void) 
          (setq _verboseSynCount.SSTATEMENT 1) 
          (setq _verboseSynCount.SSTATEMENT (iadd _verboseSynCount.SSTATEMENT 1)))

   (if (and (<> _verboseSynIn.SSTATEMENT #void) (> _verboseSynIn.SSTATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SSTATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Extract{(xReferentOn)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Extract:] #void) true (setq _ip _ip0)) (xReferentOn))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Colon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Colon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: SEXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: Semicolon
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[Semicolon:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION Semicolon :: (extractColumns $0 $3.Value $5.Value) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (extractColumns _tk0 _tk3.Value _tk5.Value) )
                                (if _verbose 
                                    (writeRule
                                         {SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION Semicolon :: (extractColumns $0 $3.Value $5.Value) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : Semicolon
                         ;; *********************************************************
                         ;; RULE: SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION :: (extractColumns $0 $3.Value $5.Value) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ip _ip5)
                            (setq _ret  (extractColumns _tk0 _tk3.Value _tk5.Value) )
                            (if _verbose 
                                (writeRule
                                     {SSTATEMENT: Extract{(xReferentOn)} Colon Name Colon SEXPRESSION :: (extractColumns $0 $3.Value $5.Value) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : SEXPRESSION
                   ) ; end begin
                 ) ; end case : Colon
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Colon
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION Semicolon :: (extractColumns $0 Object: $2.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (extractColumns _tk0 Object: _tk2.Value) )
                    (if _verbose 
                        (writeRule
                             {SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION Semicolon :: (extractColumns $0 Object: $2.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
             ;; *********************************************************
             ;; RULE: SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION :: (extractColumns $0 Object: $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (extractColumns _tk0 Object: _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {SSTATEMENT: Extract{(xReferentOn)} SEXPRESSION :: (extractColumns $0 Object: $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Extract{(xReferentOn)}
     ;; ====================
     ;; case: ScoreCommand{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[ScoreCommand:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (scoreCut _tk0 _tk2.Value _tk1.Value) )
                    (if _verbose 
                        (writeRule
                             {SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
             ;; *********************************************************
             ;; RULE: SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (scoreCut _tk0 _tk2.Value _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : ScoreCommand{(xReferentOn)}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SSTATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SSTATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SSTATEMENT _verboseSynIn.SSTATEMENT) (error "Count" "in Routine SSTATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SSTATEMENT























;;**EXPORTKEY**:gsm.estimator._SYNRULE_STATEMENT
;; ************************************************
;; STATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the STATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_STATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STATEMENT #void) 
          (setq _verboseSynCount.STATEMENT 1) 
          (setq _verboseSynCount.STATEMENT (iadd _verboseSynCount.STATEMENT 1)))

   (if (and (<> _verboseSynIn.STATEMENT #void) (> _verboseSynIn.STATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting STATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: CHILD
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_CHILD)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 108" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defchild|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 109" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : CHILD
     ;; ====================
     ;; case: CLASS
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_CLASS)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Extends
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Extends:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Name
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Name:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: FIELDLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (fieldList _tk0 _tk2.Value _tk4.Value _tk6.Value) )
                                (if _verbose 
                                    (writeRule
                                         {STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : FIELDLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : Name
               ) ; end begin
             ) ; end case : Extends
             ;; ====================
             ;; case: LeftBrace
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftBrace:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: FIELDLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (fieldList _tk0 _tk2.Value #void _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : FIELDLIST
               ) ; end begin
             ) ; end case : LeftBrace
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 114" _tk1.Charpos "Invalid class declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : CLASS
     ;; ====================
     ;; case: FILTER
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FILTER)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STATEMENT: FILTER :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {STATEMENT: FILTER :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FILTER
     ;; ====================
     ;; case: FRIEND
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FRIEND)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 106" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defriend|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 107" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FRIEND
     ;; ====================
     ;; case: FUNCTION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FUNCTION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PARMLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftBrace
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftBrace:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: STMTLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: RightBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[RightBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (funList _tk0 #void _tk3 _tk5) )
                                (if _verbose 
                                    (writeRule
                                         {STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : RightBrace
                       ) ; end begin
                     ) ; end case : STMTLIST
                   ) ; end begin
                 ) ; end case : LeftBrace
               ) ; end begin
             ) ; end case : PARMLIST
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: RightBrace
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[RightBrace:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (funList _tk0 _tk2 _tk4 _tk6) )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : RightBrace
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (begin (setq _ip _ip6)
                              (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6)))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 104" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 105" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FUNCTION
     ;; ====================
     ;; case: METHOD
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_METHOD)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 112" $7.Charpos "Invalid statement")::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 112" _tk7.Charpos "Invalid statement"))
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 112" $7.Charpos "Invalid statement")::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defmethod|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defmethod|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defmethod|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 113" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : METHOD
     ;; ====================
     ;; case: ORPHAN
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_ORPHAN)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 110" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |deforphan|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |deforphan|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |deforphan|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 111" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : ORPHAN
     ;; ====================
     ;; case: SCORE
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SCORE)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STATEMENT: SCORE :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {STATEMENT: SCORE :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SCORE
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule STATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STATEMENT _verboseSynIn.STATEMENT) (error "Count" "in Routine STATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STATEMENT























;;**EXPORTKEY**:gsm.estimator._SYNRULE_STMTLIST
;; ************************************************
;; STMTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the STMTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_STMTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STMTLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STMTLIST #void) 
          (setq _verboseSynCount.STMTLIST 1) 
          (setq _verboseSynCount.STMTLIST (iadd _verboseSynCount.STMTLIST 1)))

   (if (and (<> _verboseSynIn.STMTLIST #void) (> _verboseSynIn.STMTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting STMTLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToBeginList _tk0 _tk1.Value) )
            (if _verbose 
                (writeRule
                     {STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Semicolon
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Semicolon:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STMTLIST: Semicolon << $0 >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {STMTLIST: Semicolon << $0 >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : Semicolon
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule STMTLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STMTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STMTLIST _verboseSynIn.STMTLIST) (error "Count" "in Routine STMTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STMTLIST























;;**EXPORTKEY**:gsm.estimator._SYNRULE_TERM
;; ************************************************
;; TERM user defined Syntax Rule implementation
;; Summary: This Lambda implements the TERM
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_TERM(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: TERM: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.TERM #void) 
          (setq _verboseSynCount.TERM 1) 
          (setq _verboseSynCount.TERM (iadd _verboseSynCount.TERM 1)))

   (if (and (<> _verboseSynIn.TERM #void) (> _verboseSynIn.TERM -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting TERM Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Boolean
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Boolean:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (setq _tk0.Value _tk1.Boolean)[VType:] bool:) )
            (if _verbose 
                (writeRule
                     {TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Boolean
     ;; ====================
     ;; case: +
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] |+|:) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: TERM
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: + TERM :: (setVType $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setVType _tk2) )
                (if _verbose 
                    (writeRule
                         {TERM: + TERM :: (setVType $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : TERM
         ;; ====================
         ;; case: Term
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Term:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: + Term :: (setVType $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setVType _tk2) )
                (if _verbose 
                    (writeRule
                         {TERM: + Term :: (setVType $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Term
       ) ; end begin
     ) ; end case : +
     ;; ====================
     ;; case: -
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] |-|:) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Number
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Number:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (foldConstants _tk0 |-|: 0 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Number
         ;; ====================
         ;; case: TERM
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: - TERM :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list |-|: 0 _tk2.Value))[VType:] _tk2.VType) )
                (if _verbose 
                    (writeRule
                         {TERM: - TERM :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : TERM
         ;; ====================
         ;; case: Term
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Term:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list |-|: 0 _tk2.Value))[VType:] _tk2.VType) )
                (if _verbose 
                    (writeRule
                         {TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Term
       ) ; end begin
     ) ; end case : -
     ;; ====================
     ;; case: LeftParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Type
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Type:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SEXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq (setq (setq _tk4.VType _tk2.Value)[TERM:] true)[Charpos:] _tk0.Charpos) )
                        (if _verbose 
                            (writeRule
                                 {TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SEXPRESSION
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Type
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: LeftParen SEXPRESSION RightParen :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {TERM: LeftParen SEXPRESSION RightParen :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 130" _tk1.Charpos "Invalid expression") )
            (if _verbose 
                (writeRule
                     {TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftParen
     ;; ====================
     ;; case: Logical
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Logical:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list _tk1.Lisp _tk2.Value))[VType:] bool:) )
                (if _verbose 
                    (writeRule
                         {TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 131" _tk1.Charpos (append "Invalid " _tk1.Value " operator")))
            (if _verbose 
                (writeRule
                     {TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Logical
     ;; ====================
     ;; case: Increment
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Increment:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Increment NAME :: (postfix $0 $2 $1 false) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk2 _tk1 false) )
                (if _verbose 
                    (writeRule
                         {TERM: Increment NAME :: (postfix $0 $2 $1 false) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NAME
         ;; *********************************************************
         ;; RULE: TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 131" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Increment
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: CFCALL($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_CFCALL _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Name CFCALL($1) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {TERM: Name CFCALL($1) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : CFCALL($1)
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: NAME
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
             ;; *********************************************************
             ;; RULE: TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 132" _tk1.Charpos "Invalid function call") )
                (if _verbose 
                    (writeRule
                         {TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: Increment
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Increment:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: NAME Increment :: (postfix $0 $1 $2 true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk1 _tk2 true) )
                (if _verbose 
                    (writeRule
                         {TERM: NAME Increment :: (postfix $0 $1 $2 true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Increment
         ;; *********************************************************
         ;; RULE: TERM: NAME :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {TERM: NAME :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : NAME
     ;; ====================
     ;; case: Number
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Number
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Number:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (foldConstants _tk0 _tk2.Lisp _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Number
           ) ; end begin
         ) ; end case : Operator
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: Term
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Term:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: TERM: Term :: (setVType $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setVType _tk1) )
            (if _verbose 
                (writeRule
                     {TERM: Term :: (setVType $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Term
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule TERM on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.TERM -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.TERM _verboseSynIn.TERM) (error "Count" "in Routine TERM"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_TERM























;;**EXPORTKEY**:gsm.estimator._SYNRULE_VAR
;; ************************************************
;; VAR user defined Syntax Rule implementation
;; Summary: This Lambda implements the VAR
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_VAR(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: VAR: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.VAR #void) 
          (setq _verboseSynCount.VAR 1) 
          (setq _verboseSynCount.VAR (iadd _verboseSynCount.VAR 1)))

   (if (and (<> _verboseSynIn.VAR #void) (> _verboseSynIn.VAR -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting VAR Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: Type
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Type:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SEXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: Comma
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[Comma:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: VAR(%0 %1)
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value (addToBeginList _tk0 (appendList _ak1 _tk2.Value (list _tk4.Value))) _tk6) )
                                (if _verbose 
                                    (writeRule
                                         {VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : VAR(%0 %1)
                         ;; *********************************************************
                         ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ip _ip5)
                            (setq _ret  (_makeError "JS 135" _tk5.Charpos "Invalid var statement") )
                            (if _verbose 
                                (writeRule
                                     {VAR: Type Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : Comma
                     ;; *********************************************************
                     ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value (addToBeginList _tk0 (appendList _ak1 _tk2.Value (list _tk4.Value))) #void) )
                        (if _verbose 
                            (writeRule
                                 {VAR: Type Name InitializeOperator SEXPRESSION :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SEXPRESSION
               ) ; end begin
             ) ; end case : InitializeOperator
             ;; ====================
             ;; case: Comma
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Comma:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: VAR(%0 %1)
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value _tk0 _tk4) )
                        (if _verbose 
                            (writeRule
                                 {VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : VAR(%0 %1)
                 ;; *********************************************************
                 ;; RULE: VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 136" _tk3.Charpos "Invalid var statement") )
                    (if _verbose 
                        (writeRule
                             {VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Comma
             ;; *********************************************************
             ;; RULE: VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value _tk0 #void) )
                (if _verbose 
                    (writeRule
                         {VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
       ) ; end begin
     ) ; end case : Type
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: InitializeOperator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Comma
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Comma:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: VAR(%0 %1)
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (addVar _ak0 obj: _tk1.Value (addToBeginList _tk0 (appendList _ak1 _tk1.Value (list _tk3.Value))) _tk5) )
                            (if _verbose 
                                (writeRule
                                     {VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : VAR(%0 %1)
                     ;; *********************************************************
                     ;; RULE: VAR: Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (_makeError "JS 133" _tk4.Charpos "Invalid var statement") )
                        (if _verbose 
                            (writeRule
                                 {VAR: Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Comma
                 ;; *********************************************************
                 ;; RULE: VAR: Name InitializeOperator SEXPRESSION :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (addVar _ak0 obj: _tk1.Value (addToBeginList _tk0 (appendList _ak1 _tk1.Value (list _tk3.Value))) #void) )
                    (if _verbose 
                        (writeRule
                             {VAR: Name InitializeOperator SEXPRESSION :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : InitializeOperator
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: VAR(%0 %1)
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar _ak0 obj: _tk1.Value _tk0 _tk3) )
                    (if _verbose 
                        (writeRule
                             {VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : VAR(%0 %1)
             ;; *********************************************************
             ;; RULE: VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 134" _tk2.Charpos "Invalid var statement") )
                (if _verbose 
                    (writeRule
                         {VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 136" _tk1.Charpos "Invalid var type") )
                (if _verbose 
                    (writeRule
                         {VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (addVar _ak0 obj: _tk1.Value _tk0 #void) )
            (if _verbose 
                (writeRule
                     {VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule VAR on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.VAR -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.VAR _verboseSynIn.VAR) (error "Count" "in Routine VAR"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_VAR























;;**EXPORTKEY**:gsm.estimator._SYNRULE_WEIGHTLIST
;; ************************************************
;; WEIGHTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the WEIGHTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild gsm.estimator _SYNRULE_WEIGHTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: WEIGHTLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.WEIGHTLIST #void) 
          (setq _verboseSynCount.WEIGHTLIST 1) 
          (setq _verboseSynCount.WEIGHTLIST (iadd _verboseSynCount.WEIGHTLIST 1)))

   (if (and (<> _verboseSynIn.WEIGHTLIST #void) (> _verboseSynIn.WEIGHTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting WEIGHTLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************




     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: WEIGHTLIST: RightParen :: $0 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {WEIGHTLIST: RightParen :: $0 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; ====================
     ;; case: Pound
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Pound:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: "num"
             ;; ====================
             (if (if (= (setq _tk3 (_getToken))[Value:] "num") true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Bar
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Bar:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: NUMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_NUMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: WEIGHTLIST: Pound LeftParen "num" Bar NUMLIST << (setq $0.Value (append $0.Value " #(num| " $5.Value)) >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (append _tk0.Value " #(num| " _tk5.Value)) )
                            (if _verbose 
                                (writeRule
                                     {WEIGHTLIST: Pound LeftParen "num" Bar NUMLIST << (setq $0.Value (append $0.Value " #(num| " $5.Value)) >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (goto Skip:))

                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : NUMLIST
                   ) ; end begin
                 ) ; end case : Bar
               ) ; end begin
             ) ; end case : "num"
             ;; ====================
             ;; case: "obj"
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (= (setq _tk3 (_getToken))[Value:] "obj") true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Bar
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Bar:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: WEIGHTLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_WEIGHTLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: WEIGHTLIST: Pound LeftParen "obj" Bar WEIGHTLIST << (setq $0.Value (append $0.Value " #(obj| " $5.Value " )")) >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (append _tk0.Value " #(obj| " _tk5.Value " )")) )
                            (if _verbose 
                                (writeRule
                                     {WEIGHTLIST: Pound LeftParen "obj" Bar WEIGHTLIST << (setq $0.Value (append $0.Value " #(obj| " $5.Value " )")) >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (goto Skip:))

                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : WEIGHTLIST
                   ) ; end begin
                 ) ; end case : Bar
               ) ; end begin
             ) ; end case : "obj"
             ;; ====================
             ;; case: WEIGHTLIST
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SYNRULE_WEIGHTLIST)) morphFail)true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: WEIGHTLIST: Pound LeftParen WEIGHTLIST << (setq $0.Value (append $0.Value " #( " $3.Value " )")) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (append _tk0.Value " #( " _tk3.Value " )")) )
                    (if _verbose 
                        (writeRule
                             {WEIGHTLIST: Pound LeftParen WEIGHTLIST << (setq $0.Value (append $0.Value " #( " $3.Value " )")) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (goto Skip:))

                 ) ; end case : _default
               ) ; end begin
             ) ; end case : WEIGHTLIST
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : Pound
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: WEIGHTLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 137" _tk1.Charpos "Invalid weight list"))
            (if _verbose 
                (writeRule
                     {WEIGHTLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid weight list")::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule WEIGHTLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.WEIGHTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.WEIGHTLIST _verboseSynIn.WEIGHTLIST) (error "Count" "in Routine WEIGHTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_WEIGHTLIST























;;**EXPORTKEY**:gsm.expressionGrammarGab
(defriend gsm:expressionGrammarGab(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator grammar abstract only
;;           swarm optimization numeric expressions. 
;;
;; Main:     Return a Estimator grammar swarm variable numeric expression, 
;;           in source format, such as 
;;
;;                    "((v1*(v2-c1))/v0)"
;; 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the numeric expression.
;;           
;; Return:   result      A Estimator grammar swarm variable numeric 
;;                       expression such as "((v1*(v2-c1))/v0)".
;;
;; Notes:    GAB expressions support the following self-learning references
;;
;;           Gab Constants:         c0 thru cI - Each of these references creates a 
;;                                   NumVector constant vector in which the PSO and 
;;                                   DE algorithms search the solution space for 
;;                                   optimal Number constant values.
;;
;;           Gab Variables:         v0 thru vK - Each of these references creates an 
;;                                   IntVector variable vector, which indirectly refers
;;                                   to the variables (x0 thru xM) in which learning 
;;                                   algorithms search the solution space for optimal 
;;                                   variable references.
;;
;;           Constants:             -45.261  +319.23 .0345 .192765 
;;
;;           Variables:             x0 thru xM 
;;
;;           Relational Operators:  < <= == <> >= > 
;;
;;           binary Operators:      ruleAdd ruleDiv ruleMul ruleSub 
;;
;;           unary Rules:           ruleAbs ruleCos ruleExp ruleInv ruleLog ruleNeg ruleSin ruleSqrt ruleSquare ruleTan  
;;
;;           conditional Operators: ruleIf  
;; *******************************************************************
  pvars:(;; Public Variables
		 myAbstractLambda   	        ;; Contains the current abstract Lambda whose WFF is being converted into a concrete WFF.
         ;; Expression operators
		 checkNumericWFF   		    ;; Checks a numeric Estimator WFF for validity.
		 concreteWFF     		    ;; Converts the specified abstract Lambda's WFF into a concrete WFF.
		 convertToAbstractWFF  	    ;; Converts a concrete/abstract Estimator WFF to an abstract WFF {x4 ==> v0 and -2.345 ==> c0}.
		 cutoutNumericWFF   		;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
         extractNumericWFF		    ;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
         growWFF                    ;; Returns a randomly grown Estimator WFF. 
         growCTermWFF               ;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
         growRootWFF                ;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
         growTermWFF                ;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column.
	  	 lengthWFF   		        ;; Returns the left-depth-first length of any Estimator WFF.
         marryNumericWFFs		    ;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}.
		 mutateAbstractC0   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v0*c0))"}.
		 mutateAbstractC1   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v1*c1))"}.
		 mutateNumericWFF   	    ;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}.
		 selectPairWFF    	        ;; Returns the specified WFF as a vector of Pair objects. 
		 selectSlotWFF    	        ;; Returns the specified WFF as a vector of Slot items. 
		 spliceImmediateWFF    	    ;; Returns a numeric Estimator WFF by immediately splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
		 spliceNumericWFF    	    ;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
         ;; Expression grammar production Rules
         ruleAbs             		;; Produce a Estimator numeric absolute function such as "abs(x1)". 
         ruleAdd                   	;; Produce a Estimator numeric addition such as x1 + xm. 
         ruleAvg                   	;; Produce a Estimator numeric average such as avg(x1,x2,...,xm). 
         ruleCons                   ;; Produce a Estimator abstract numeric constant.
         ruleCos                   	;; Produce a Estimator numeric cosine function such as "cos(x1)". 
         ruleCube                  	;; Produce a Estimator numeric cube function such as "(x1*x1*x1)". 
         ruleDiv                   	;; Produce a Estimator numeric protected division such as pdiv(x1,xm). (x3 == 0 ? x4 : x4 / x3) 
         ruleExp                   	;; Produce a Estimator exponential function such as "exp(x2)".
         ruleExpression             ;; Produce a Estimator genetic programming numeric expressions such as "((x1-x6)*cos(x2))". 
         ruleExpt                  	;; Produce a Estimator exponent function such as "expt(abs(x1),x2)".
         ruleFrac                  	;; Produce a Estimator numeric fraction function such as "fraction(x1)". 
         ruleFrm                   	;; Produce a Estimator multiple factor regression statement such as "frmregress (.23*x3,34.5*x4);". 
         ruleIf                    	;; Produce a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})".
         ruleInt                   	;; Produce a Estimator numeric integer function such as "number(integer(x1))". 
         ruleInv                   	;; Produce a Estimator inversion function such as "(1.0 /x1)". 
         ruleLog                   	;; Produce a Estimator numeric log function such as "log(abs(x1))". 
         ruleMax                   	;; Produce a Estimator numeric maximum such as max(x1,x2,...,xm).  
         ruleMdl                   	;; Produce a Estimator model statement such as "model x3*x4;". 
         ruleMin                   	;; Produce a Estimator numeric minimum such as min(x1,x2,...,xm).  
         ruleMod                   	;; Produce a Estimator numeric mod such as mod(x1,xm). 
         ruleMul                   	;; Produce a Estimator numeric multiplication such as x1 * xm. 
         ruleMvl                   	;; Produce a Estimator multiple linear regression statement such as "mvlregress (.23*x3,34.5*x4);". 
         ruleName                  	;; Produce a Estimator element name such as xtime, or x1 thru xM.
         ruleNeg                   	;; Produce a Estimator numeric negation such as -(x1 * xm). 
         ruleNop                   	;; Produce a Estimator no operation.
         ruleProd                   ;; Produce a Estimator numeric sum such as (x1*x2*...*xm). 
         ruleReg                   	;; Produce a Estimator regress statement such as "regress x3*x4;". 
         ruleSigmoid               	;; Produce a Estimator numeric sigmoid function such as "sigmoid(x1)". 
         ruleSign                  	;; Produce a Estimator numeric sign function such as "sign(x1)". 
         ruleSin                   	;; Produce a Estimator numeric sine function such as "sin(x1)". 
         ruleSqrt                  	;; Produce a Estimator numeric square root function such as "sqrt(abs(x1))". 
         ruleSquare                	;; Produce a Estimator numeric square function such as "(x1*x1)". 
         ruleSub                   	;; Produce a Estimator numeric subtraction such as x1 - xm. 
         ruleSum                   	;; Produce a Estimator numeric sum such as sum(x1,x2,...,xm). 
         ruleSvm                   	;; Produce a Estimator support vector regression statement such as "svmregress (.23*x3,34.5*x4);". 
         ruleTan                   	;; Produce a Estimator numeric tangent function such as "tan(x1)". 
         ruleTanh                  	;; Produce a Estimator numeric hyper tangent function such as "tanh(x1)". 
         ruleVar                    ;; Produce a Estimator abstract variable reference such as v0, or v1 thru vK.
         ) ; end public variables
    ;; *******************************************************************************
    ;; Define Public Child Lambdas 
    ;; *******************************************************************************

    ;; *******************************************************************************
    ;; Define Expression operators 
    ;; *******************************************************************************
   
    (defun checkNumericWFF(wff)
    ;; *******************************************************************
    ;; summary:  Checks a numeric Estimator WFF for validity.  
    ;;
    ;; args:     wff       The WFF which is to be verified.
    ;;           
    ;; Return:   wff       The new verified WFF.
    ;;
    ;; *******************************************************************
        vars:(rule)
        ;; Check to make sure the Estimator WFF is valid.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (setq rule wff[0])
        (cond
         ((isNumber wff) true)
         ((isSymbol wff) true)
         ((= rule ruleAbs:)
          (begin
            UnaryCheck::
            (if (<> (length wff) 2) (error (append "gsm.expressionGrammarGab.checkNumericWFF: invalid length for unary grammar rule [" rule "]")))
          )) ; end ruleAbs case
         ((= rule ruleAdd:)
          (begin
            BinaryCheck::
            (if (<> (length wff) 3) (error (append "gsm.expressionGrammarGab.checkNumericWFF: invalid length for binary grammar rule [" rule "]")))
          )) ; end ruleAdd case
         ((= rule ruleAvg:)
          (begin
            MultiaryCheck::
            (if (< (length wff) 2) (error (append "gsm.expressionGrammarGab.checkNumericWFF: invalid length for Multiary grammar rule [" rule "]")))
          )) ; end ruleAvg case
         ((= rule ruleCons:) (goto UnaryCheck:))
         ((= rule ruleCos:) (goto UnaryCheck:))
         ((= rule ruleCube:) (goto UnaryCheck:))
         ((= rule ruleDiv:) (goto BinaryCheck:))
         ((= rule ruleExp:) (goto UnaryCheck:))
         ((= rule ruleName:) (goto UnaryCheck:))
         ((= rule eGrammar:) (goto UnaryCheck:))
         ((= rule ruleExpt:) (goto BinaryCheck:))
         ((= rule ruleTanh:) (goto UnaryCheck:))
         ((= rule ruleIf:)
          (begin
            IfCheck::
            (if (<> (length wff) 6) (error (append "gsm.expressionGrammarGab.checkNumericWFF: invalid length for if grammar rule [" rule "]")))
          )) ; end ruleIf case
         ((= rule ruleFrac:) (goto UnaryCheck:))
         ((= rule ruleInt:) (goto UnaryCheck:))
         ((= rule ruleInv:) (goto UnaryCheck:))
         ((= rule ruleLog:) (goto UnaryCheck:))
         ((= rule ruleMax:) (goto MultiaryCheck:))
         ((= rule ruleMin:) (goto MultiaryCheck:))
         ((= rule ruleMod:) (goto BinaryCheck:))
         ((= rule ruleMul:) (goto BinaryCheck:))
         ((= rule ruleNeg:) (goto UnaryCheck:))
         ((= rule ruleNop:) (goto UnaryCheck:))
         ((= rule ruleProd:) (goto MultiaryCheck:))
         ((= rule ruleSigmoid:) (goto UnaryCheck:))
         ((= rule ruleSign:) (goto UnaryCheck:))
         ((= rule ruleSin:) (goto UnaryCheck:))
         ((= rule ruleSqrt:) (goto UnaryCheck:))
         ((= rule ruleSquare:) (goto UnaryCheck:))
         ((= rule ruleSub:) (goto BinaryCheck:))
         ((= rule ruleSum:) (goto MultiaryCheck:))
         ((= rule ruleTan:) (goto UnaryCheck:))
         ((= rule ruleVar:) (goto UnaryCheck:))
         (else (error (append "gsm.expressionGrammarGab.checkNumericWFF: unknown WFF grammar rule [" rule "]")))
         ) ; end cond
        wff) ; end checkNumericWFF    
    
    (defun concreteWFF(Lambda ...)
    ;; *******************************************************************
    ;; summary:   Converts the specified abstract Lambda's WFF into a concrete WFF.  
    ;;
    ;; args:     Lambda    The specified abstract Lambda whose WFF into a concrete WFF.
    ;;           wff      (Optional)The specified WFF to be converted into a concrete WFF.
    ;;           
    ;; Return:   wff      The new concrete WFF.
    ;;
    ;; *******************************************************************
        regs:(m M n N cn)
        vars:(rule wff temp genome newWff wffTerm)

        ;; Convert wff to a list grammar format.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (if (>= (argCount) 2) (setq wff (argFetch 1)) (setq wff (listWff Lambda.WFF)))

        ;; Check for abstract grammar rules which may need to be converted.
        (cond
         ((and (isSymbol wff) (= wff[0] #\v)) (setq wff (symbol (append "x" (integer Lambda.VV[(integer (mid wff 1 100000))])))))
         ((and (isSymbol wff) (= wff[0] #\c)) (setq wff (number Lambda.CC[(integer (mid wff 1 100000))])))
         ((isVector wff)
          (begin
             (setq N (length wff)) 
             (loop for n from 0 until N do 
               (if (isPair wff[n]) (concreteWFF Lambda wff[n]))
               (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq wff[n] (symbol (append "x" (integer Lambda.VV[(integer (mid wff[n] 1 100000))])))))
               (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq wff[n] (number Lambda.CC[(integer (mid wff[n] 1 100000))])))
          ))) ; end case: Vector
         ((isPair wff)
          (begin
             (setq rule wff[0])
             (cond
              ((and (= rule ruleMvl:) (isVector wff[1]) (not (isConcrete (setq genome wff[1]))))
               (begin              
                 ;; Determine the number of existing abstract real number constants in this mvlregress genome.             
                 (setq temp (compileEstimator (evalRule (list ruleReg: genome))))
                 (if (not (isLambda temp)) (setq cn -1) (setq cn (- temp.CCN 1)))
                 (setq newWff "")
                 (setq N (length genome)) 
                 ;; Create the final source from the genome.
                 (setq M (length genome))
                 (loop for m from 0 until M do
                   (if (<> genome[m] #void)
                       (begin
                         (setq wffTerm (append "(ruleMul " Lambda.CC[(++ cn)] " " (string (concreteWFF Lambda genome[m]) true) ")"))
                         (if (= newWff "") 
                             (setq newWff wffTerm)
                             (setq newWff (append newWff " " wffTerm))
                             ) ; end if
                       )) ; end if
                   ) ; end column loop  
	            ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	            (setq newWff (append "(ruleReg #(" newWff "))"))
                (setq wff (listWff newWff))
               )) ; end abstract ruleMvl case
              ((isVector wff[1]) (concreteWFF Lambda wff[1]))
              ((= rule ruleVar) (begin (setq wff[0] ruleName:) (setq wff[1] Lambda.VV[wff[1]])))
              ((= rule ruleCons) (begin (setq wff[0] ruleNum:) (setq wff[1] Lambda.CC[wff[1]])))
              (else 
                (begin 
                  (setq N (length wff)) 
                  (loop for n from 0 until N do 
                    (if (isPair wff[n]) (concreteWFF Lambda wff[n]))
                    (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq wff[n] (symbol (append "x" (integer Lambda.VV[(integer (mid wff[n] 1 100000))])))))
                    (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq wff[n] (number Lambda.CC[(integer (mid wff[n] 1 100000))])))
                ))) ; end else
              ))) ; end case: Pair
         ) ; end cond

        wff) ; end concreteWFF      
		
	(defun convertToAbstractWFF(wff ...)  (error "gsm.expressionGrammarGab: abstract expression conversion is not valid"))

	(defun cutoutNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly cutting out a  
	;;           sub-expression from a candidate Estimator WFF 
	;;           For example {"(x3/sin(x4))" ==> "sin(x4)"}. 
	;;
	;; args:     wff       The WFF from which the cutout is to be taken.
	;;           point     (Optional)The probability of cutting at this grammar rule.           
	;;           
	;; Return:   wff       The cut out sub-expression from a candidate Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (return wff))
		 ((isSymbol wff) (return wff))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the unary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument two.
	         ((and (= stopHereSW false) (isPair wff[2])) (return (cutoutNumericWFF wff[2] point)))
	         ;; Case: Cutout the binary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryCutout::
            (setq N (- (length wff) 1))
	        (cond
	         ;; Case: Pass the cutout request to the next level through the nth argument.
	         ((and (= stopHereSW false) (> (setq n (+ 1 (integer (* argPoint N)))) 0) (isPair wff[n])) (return (cutoutNumericWFF wff[n] point)))
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the multiary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (goto UnaryCutout:))
		 ((= rule ruleCos:) (goto UnaryCutout:))
		 ((= rule ruleCube:) (goto UnaryCutout:))
		 ((= rule ruleDiv:) (goto BinaryCutout:))
		 ((= rule ruleExp:) (goto UnaryCutout:))
		 ((= rule ruleExpression:) (goto UnaryCutout:))
		 ((= rule ruleExpt:) (goto BinaryCutout:))
		 ((= rule ruleTanh:) (goto UnaryCutout:))
		 ((= rule ruleIf:)
	      (begin
	        IfCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1]) (< argPoint .25)) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument three.
	         ((and (= stopHereSW false) (isPair wff[3]) (< argPoint .50)) (return (cutoutNumericWFF wff[3] point)))
	         ;; Case: Pass the cutout request to the next level through argument four.
	         ((and (= stopHereSW false) (isPair wff[4]) (< argPoint .75)) (return (cutoutNumericWFF wff[4] point)))
	         ;; Case: Pass the cutout request to the next level through argument five.
	         ((and (= stopHereSW false) (isPair wff[5]) (>= argPoint .75)) (return (cutoutNumericWFF wff[5] point)))
	         ;; Case: Cutout the if expression on this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryCutout:))
		 ((= rule ruleInt:) (goto UnaryCutout:))
		 ((= rule ruleInv:) (goto UnaryCutout:))
		 ((= rule ruleLog:) (goto UnaryCutout:))
		 ((= rule ruleMax:) (goto MultiaryCutout:))
		 ((= rule ruleMin:) (goto MultiaryCutout:))
		 ((= rule ruleMod:) (goto BinaryCutout:))
		 ((= rule ruleMul:) (goto BinaryCutout:))
		 ((= rule ruleName:) (return (ruleName wff[1])))
		 ((= rule ruleNeg:) (goto UnaryCutout:))
		 ((= rule ruleNop:) (goto UnaryCutout:))
		 ((= rule ruleProd:) (goto MultiaryCutout:))
		 ((= rule ruleSigmoid:) (goto UnaryCutout:))
		 ((= rule ruleSign:) (goto UnaryCutout:))
		 ((= rule ruleSin:) (goto UnaryCutout:))
		 ((= rule ruleSqrt:) (goto UnaryCutout:))
		 ((= rule ruleSquare:) (goto UnaryCutout:))
		 ((= rule ruleSub:) (goto BinaryCutout:))
		 ((= rule ruleSum:) (goto MultiaryCutout:))
		 ((= rule ruleTan:) (goto UnaryCutout:))
		 ((= rule ruleVar:) (return (ruleVar wff[1])))
	     (else (error (append "gsm.expressionGrammarGab.cutoutNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end cutoutNumericWFF    
	
	;; *******************************************************************
	;; summary:  Evaluate an GAB grammar production rule.
	;;
	;; args:     rule        Any GAB grammar rule to be evaluated.
	;;           
	;; Return:   expression  The result of evaluating the grammar rule as a String.
	;;
	;; *******************************************************************
    (defun evalRule(rule)
       vars:(ruleHdr)
       (onError (lambda(msg) "...error..."))
       (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
       (if (isString rule) (setq rule (listWff rule)))
       (if (isPair rule) (setq rule (apply (setq ruleHdr gsm.expressionGrammarGab[(car rule)]) (cdr rule))) (setq rule (string rule true)))
       rule) ; end evalRule

    (defun extractNumericWFF(inWff ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF from any Estimator WFF.
	;;           For instance: "regress (x3/x13);" ==> "(x3/x13)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     inWff       Any Estimator input WFF or Estimator Lambda.
	;;           sourceSW    (Optional) True iff the result expression is to be returned in source form.
	;;           
	;;           
	;; Return:   expression  The numeric WFF extracted from the specified Estimator WFF.
	;;
	;; *******************************************************************
		regs:(m M)
		vars:(sourceSW expression rule wff)
	    ;; If the wff argument is an Lambda, then convert it to a WFF.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (if (isLambda inWff) (setq wff inWff.WFF) (setq wff inWff))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    (setq sourceSW (if (>= (argCount) 2) (argFetch 1) false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (setq expression wff))
		 ((isSymbol wff) (setq expression wff))
		 ((= rule ruleAbs:) (setq expression wff))
		 ((= rule ruleAdd:) (setq expression wff))
		 ((= rule ruleAvg:) (setq expression wff))
		 ((= rule ruleCons:) (setq expression (ruleCons wff[1])))
		 ((= rule ruleCos:) (setq expression wff))
		 ((= rule ruleCube:) (setq expression wff))
		 ((= rule ruleDiv:) (setq expression wff))
		 ((= rule ruleExp:) (setq expression wff))
		 ((= rule ruleExpression:) (setq expression wff))
		 ((= rule ruleExpt:) (setq expression wff))
		 ((= rule ruleFrm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleIf:) (setq expression wff))
		 ((= rule ruleLog:) (setq expression wff))
		 ((= rule ruleFrac:) (setq expression wff))
		 ((= rule ruleInt:) (setq expression wff))
		 ((= rule ruleInv:) (setq expression wff))
		 ((= rule ruleMax:) (setq expression wff))
		 ((= rule ruleMdl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleMin:) (setq expression wff))
		 ((= rule ruleMod:) (setq expression wff))
		 ((= rule ruleMul:) (setq expression wff))
		 ((= rule ruleMvl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleName:) (setq expression (ruleName wff[1])))
		 ((= rule ruleNeg:) (setq expression wff))
		 ((= rule ruleNop:) (setq expression wff))
		 ((= rule ruleProd:) (setq expression wff))
		 ((= rule ruleReg:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleSigmoid:) (setq expression wff))
		 ((= rule ruleSign:) (setq expression wff))
		 ((= rule ruleSin:) (setq expression wff))
		 ((= rule ruleSqrt:) (setq expression wff))
		 ((= rule ruleSquare:) (setq expression wff))
		 ((= rule ruleSub:) (setq expression wff))
		 ((= rule ruleSum:) (setq expression wff))
		 ((= rule ruleSvm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleTan:) (setq expression wff))
		 ((= rule ruleTanh:) (setq expression wff))
		 ((= rule ruleVar:) (setq expression (ruleVar wff[1])))
	     (else (setq expression x1:))
	     ) ; end cond
	    ;; Return the numeric expression as a Estimator WFF or as a Estimator source string.
	    (if (= expression #void) (setq expression x1:))
	    (if (= sourceSW true) then (setq expression (evalRule expression))) 
		expression) ; end extractNumericWFF    
	    
    (defun growWFF(Symbol:rule Integer:level ...)
	;; *******************************************************************
	;; summary:  Returns a randomly grown Estimator WFF. 
	;;
	;; args:     rule      The grammar rule indicating the type of WFF is to be returned.
	;;                     Note: The values for the rule argument as as follows:
	;;                           binary:		Generates a random binary operator expression.	            
	;;                           condition:     Generates a random "if" expression.	            
	;;                           expression:    Generates a random numeric expression.	            
	;;                           number:		Generates a random number constant.	            
	;;                           unary:		    Generates a random unary operator expression.	            
	;;                           variable:      Generates a random GSVariable reference (v0 thru vK).	            
	;;           level     The count of the current level in the expression.
	;;           gsvCount  The count of the current GSVariables generated in the expression.
	;;           gscCount  The count of the current GSConstants generated in the expression.
	;;           
	;; Return:   result    The randomly grown Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:r (maxLevels 4))
        pvars:(gscCount gsvCount)
		vars:(wff newRule relop)
		vars:(commands expressions percents)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((expressionRules #(obj| binary condition unary variable)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Load the count of the current GSVariables generated in the expression.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (if (>= (argCount) 3) (setq gsvCount (argFetch 2)) (setq gsvCount 0))
        (if (>= (argCount) 4) (setq gscCount (argFetch 3)) (setq gscCount 0))
		;; Use the grammar rule to guide the type of Estimator WFF generated.
	    (cond
	     ;; Case binary:		Generates a random binary operator expression.	            
		 ((= rule binary:) 
	      (begin
	        (setq N (length binaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule binaryRules[n])
            (if (= newRule ruleExpt:)
                (begin
	              (if (< level maxLevels)
	                  (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount) (growWFF number: (+ level 1) gsvCount gscCount)))
	                  (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount) (growWFF number: (+ level 1) gsvCount gscCount))))
                ) ; then
            else
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1) gsvCount gscCount) (growWFF expression: (+ level 1) gsvCount gscCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount) (growWFF term: (+ level 1) gsvCount gscCount)))
	            )) ; end if
	      )) ; end case binary
	
	     ;; Case condition:    Generates a random "if" expression.	            
		 ((= rule condition:) 
	      (begin
	        (setq newRule ruleIf:)
	        (setq N (length relationalOperators))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq relop relationalOperators[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount) relop (growWFF expression: (+ level 1) gsvCount gscCount) (growWFF expression: (+ level 1) gsvCount gscCount) (growWFF expression: (+ level 1) gsvCount gscCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount) relop (growWFF term: (+ level 1) gsvCount gscCount) (growWFF term: (+ level 1) gsvCount gscCount) (growWFF term: (+ level 1) gsvCount gscCount)))
	            ) ; end if
	      )) ; end case condition
	
	     ;; Case expression:    Generates a random numeric expression.	            
		 ((= rule expression:) 
	      (begin
	        GrowExpression::
	        (setq N (length expressionRules))
	        (setq n (integer (gsm.myRandomFunction N)))
            (setq r (gsm.myRandomFunction 1.0))
	        (cond 
	         ((>= level maxLevels) (goto GrowTerm:))
	         ((<= r .40) (setq wff (growWFF (setq newRule unary:) (+ level 1) gsvCount gscCount)))
	         ((<= r .70) (setq wff (growWFF (setq newRule binary:) (+ level 1) gsvCount gscCount)))
	         ((<= r .95) (setq wff (growWFF (setq newRule variable:) (+ level 1) gsvCount gscCount)))
	         (else (setq wff (growWFF (setq newRule condition:) (+ level 1) gsvCount gscCount)))
	         ) ; end cond
	      )) ; end case expression
	
	     ;; Case number:    Generates a random number constant.	            
		 ((= rule number:) 
	      (begin
	        GrowNumber::
	        (setq wff (ruleCons gscCount))
	        (++ gscCount) 
	      )) ; end case number
	
	     ;; Case term:    Generates a random number constant or variable name.	            
		 ((= rule term:) 
	      (begin
	        GrowTerm::
	        (if (< (gsm.myRandomFunction 1.0) myNumberPct) (goto GrowNumber:) (goto GrowVariable:))
	      )) ; end case number
	
	     ;; Case unary:		Generates a random unary operator expression.	            
		 ((= rule unary:) 
	      (begin
	        (setq N (length unaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule unaryRules[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1) gsvCount gscCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount)))
	            ) ; end if
	      )) ; end case unary
	
	     ;; Case variable:		Generates a random variable reference (v0, v1 thru vK).	            
		 ((= rule variable:) 
	      (begin
	        GrowVariable::
	        (setq wff (ruleVar gsvCount))
	        (++ gsvCount) 
	      )) ; end case variable
	
	     ;; Case else
	     (else (error (append "gsm.expressionGrammarGab.growWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond

	    ;; Return the randomly grown Estimator WFF.
		wff) ; end growWFF    
	
	(defun growCTermWFF(...)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression conditional term
	;;           Estimator WFF based upon a chosen column, such as
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion including conditionals.           
	;;
	;; args:     none                                 
	;;           
	;; Return:   wff          The sequentially grown conditional term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N NN NO)
		vars:(wff choice)
		vars:((operators #("<" "<=" "==" "<>" ">=" ">")))
	
	    ;; Return the count of term Estimator term WFFs
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (setq NN (growTermWFF -1))
	    (setq NO (length operators))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	
	    (setq choice (gsm.myRandomFunction 1.0))
	    (if (>= choice 0.25)
	        ;; Generate a term Estimator term WFF
	        (setq wff (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN)))))
	        ;; Generate a Estimator conditional term WFF
	        (setq wff (list ruleIf: (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))
	                                (symbol operators[(integer (gsm.myRandomFunction NO))])  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))
	                                )) ; end list
	        ) ; end generate cterm only if
	
		wff) ; end growCTermWFF    

	(defun growRootWFF(Integer:rootChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown root Estimator WFF such as
	;;             v0, 
	;;             abs(v0) thru tanh(v0), 
	;;             (v0+v1) thru (v0-v1),
	;;                      ...
	;;             abs((abs(v0)) thru tanh(tanh(v0)), 
	;;             (abs(v0)+abs(v1)) thru (tanh(v0)-tanh(v1)),
	;;                      ...
	;;             abs(v0+v1) thru tanh(v0-v1), 
	;;           
	;;           The root Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice   The choice of the sequential root WFF expression to return.                        
	;;           Note: if rootChoice <= -2, then a random root WFF is to be generated and extended randomly.
	;;           Note: if rootChoice == -1, then the maximum number of root WFFs is to be returned.
	;;           Note: if rootChoice >=  0, then a random root WFF is to be generated and extended randomly.
	;;                 Otherwise, rootChoice must be the index of the chosen Estimator WFF root expression.
	;;           
	;; Return:   wff          The sequentially grown root Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(b B m M n N NN)
		vars:(wff newRule binRule Integer:choice)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator root WFF without extension.
	    ;; **********************************************************
	    
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate all of the single variable names
	          (setq N 1)
	          (if (< choice N)
	              (begin
	                 (setq wff (ruleVar 0))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the exponent functions with single variable names
	          (setq N 3)
	          (if (< choice N)
	              (begin
	                 (if (= choice 0) then (begin (setq wff (list ruleSqrt: (ruleVar 0))) (return wff)))
	                 (if (= choice 1) then (begin (setq wff (list ruleSquare: (ruleVar 0))) (return wff)))
	                 (if (= choice 2) then (begin (setq wff (list ruleCube: (ruleVar 0))) (return wff)))
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with single variable names
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule unaryRules[n])
	                 (setq wff (list newRule (ruleVar 0)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the binary functions with single variable names
	          (setq N (length binaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule binaryRules[n])
	                 (setq wff (list newRule (ruleVar 0) (ruleVar 1)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with binary root expression arguments
	          (setq M (length unaryRules))
	          (setq B (length binaryRules))
	          (setq N (muli M B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (divi choice B))
	                 (setq newRule unaryRules[n])
	                 (setq binRule binaryRules[b])
	                 (setq wff (list newRule (list binRule (ruleVar 0) (ruleVar 1))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Generate all of the binary functions with binary root expression arguments
	          (setq B (length binaryRules))
	          (setq N (muli B B B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (modi (divi choice B) B))
                     (setq m (divi choice (* B B)))
	                 (setq wff (list binaryRules[m] (list binaryRules[n] (ruleVar 0) (ruleVar 1)) (list binaryRules[b] (ruleVar 2) (ruleVar 3))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Return void wff showing that there are no more root Estimator WFFs available.
	          (return #void)
	          
	        )) ; end generate root only if
	
    ;; **********************************************************
    ;; Return the maximum number of root WFFs.
    ;; **********************************************************
    (setq NN 1)
    (setq N 3)(+= NN N)
    (setq N (length unaryRules))(+= NN N)
    (setq N (length binaryRules))(+= NN N)
    (setq N (* (length unaryRules) (length binaryRules)))(+= NN N)
    (setq N (* (length binaryRules) (length binaryRules) (length binaryRules)))(+= NN N)
    (if (= choice -1) (return NN))

    ;; **************************************************************
    ;; Generate a sequential Estimator root WFF with random extension.
    ;; **************************************************************
    (setq choice (integer (gsm.myRandomFunction NN)))
    (setq wff (growRootWFF choice))
    (setq wff (mutateNumericWFF wff))

    Last::
	wff) ; end growRootWFF    

	(defun growTermWFF(Integer:rootChoice ...)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression term Estimator WFF 
	;;           based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice     The choice of the sequential term WFF expression to return.                        
	;;                           Note: if rootChoice <  -1, then a random term WFF is to be generated.
	;;                           Note: if rootChoice == -1, then the maximum number of term WFFs is to be returned.
	;;                           Note: if rootChoice >=  0, then a sequential term WFF is to be generated, and the rootChoice must be the index of the chosen Estimator WFF.
	;;           
	;; Return:   wff          The sequentially grown term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(b B m M n N NN)
		vars:(wff newRule binRule Integer:choice)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	    
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate all of the single variable names
	          (setq N 1)
	          (if (< choice N)
	              (begin
	                 (setq wff (ruleVar 0))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the exponent functions with single variable names
	          (setq N 3)
	          (if (< choice N)
	              (begin
	                 (if (= choice 0) then (begin (setq wff (list ruleSqrt: (ruleVar 0))) (return wff)))
	                 (if (= choice 1) then (begin (setq wff (list ruleSquare: (ruleVar 0))) (return wff)))
	                 (if (= choice 2) then (begin (setq wff (list ruleCube: (ruleVar 0))) (return wff)))
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with single variable names
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule unaryRules[n])
	                 (setq wff (list newRule (ruleVar 0)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the binary functions with single variable names
	          (setq N (length binaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule binaryRules[n])
	                 (setq wff (list newRule (ruleVar 0) (ruleVar 1)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with binary term expression arguments
	          (setq M (length unaryRules))
	          (setq B (length binaryRules))
	          (setq N (muli M B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (divi choice B))
	                 (setq newRule unaryRules[n])
	                 (setq binRule binaryRules[b])
	                 (setq wff (list newRule (list binRule (ruleVar 0) (ruleVar 1))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Generate all of the binary functions with binary term expression arguments
	          (setq B (length binaryRules))
	          (setq N (muli B B B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (modi (divi choice B) B))
                     (setq m (divi choice (* B B)))
	                 (setq wff (list binaryRules[m] (list binaryRules[n] (ruleVar 0) (ruleVar 1)) (list binaryRules[b] (ruleVar 2) (ruleVar 3))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Return a random Estimator term WFF if there are no more term Estimator term WFFs available.
			  (setq choice (integer (gsm.myRandomFunction NN)))
			  (setq wff (growRootWFF choice))
			  (setq wff (mutateNumericWFF wff))
	          (return wff)
			          
	        )) ; end generate term only if
	
	    ;; **********************************************************
	    ;; Return the maximum number of term WFFs.
	    ;; **********************************************************
	    (setq NN 1)
	    (setq N 3)(+= NN N)
	    (setq N (length unaryRules))(+= NN N)
	    (setq N (length binaryRules))(+= NN N)
	    (setq N (* (length unaryRules) (length binaryRules)))(+= NN N)
	    (setq N (* (length binaryRules) (length binaryRules) (length binaryRules)))(+= NN N)
	    (if (= choice -1) (return NN))
	
	    ;; **************************************************************
	    ;; Generate a sequential Estimator term WFF with random extension.
	    ;; **************************************************************
	    (setq choice (integer (gsm.myRandomFunction NN)))
	    (setq wff (growRootWFF choice))
	    (setq wff (mutateNumericWFF wff))
	
		wff) ; end growTermWFF 

	(defun lengthWFF(wff)
	;; *******************************************************************
	;; summary:  Returns the left-depth-first length of any Estimator WFF. 
	;;
	;; args:     wff       The WFF whose length is to be returned.           
	;;           
	;; Return:   result    The left-depth-first length of the specified WFF.
	;;
	;; *******************************************************************
	    regs:(n N (result 0))
		vars:(rule)
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; The length of a Vector of WFFs is always the
	    ;; sum of the lengths of each WFF in the vector.
	    (if (isVector wff) 
	        then
	        (begin
	          (setq N (length wff))
	          (loop for n from 0 until N do
	            (+= result (lengthWFF wff[n]))
	            ) ; end loop 
	          (return result)
	        )) ; end if
	    ;; The length of an atomic WFF is always 1.
	    (if (isAtom wff) then (return 1))
		;; Use the grammar rule to guide the computation 
	    ;; of the specified Estimator WFF length.
	    (setq rule wff[0])
	    (cond
		 ((= rule ruleAbs:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleAdd:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleAvg:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleCons:) (setq result 1))
		 ((= rule ruleCos:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleCube:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleDiv:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleExp:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpression:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpt:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleFrm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleIf:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]) (lengthWFF wff[4]) (lengthWFF wff[5]))))
		 ((= rule ruleFrac:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInv:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleLog:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMax:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMdl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMin:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMod:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMul:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMvl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleName:) (setq result 1))
		 ((= rule ruleNeg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleNop:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleProd:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleReg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSigmoid:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSign:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSin:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSqrt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSquare:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSub:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleSum:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTan:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTanh:) (+= result (lengthWFF wff[1])))
	     (else (error (append "gsm.expressionGrammarGab.lengthWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		result) ; end lengthWFF    
	
	(defun marryNumericWFFs(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF by marrying two suitor 
	;;           Estimator WFFs.
	;;           For instance: "x3" , "x4" ==> "(x3/x4)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     wff1      The male WFF suitor for this marriage.           
	;;           wff2      The female WFF suitor for this marriage.           
	;;           operator  (Optional) The binary operator for this marriage.           
	;;           
	;; Return:   expression  The numeric WFF resulting from the marriage.
	;;
	;; *******************************************************************
	    vars:(expression newRule len1 len2)
		vars:((binaryOperators #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (if (= wff1 #void) (return false))
	    (if (= wff2 #void) (return false))
	    (if (isString wff1) (setq wff1 (listWff wff1)))
	    (if (isString wff2) (setq wff2 (listWff wff2)))
	    ;; Make sure we can marry these two WFFs without exceeding the WFF length limit.
	    (setq len1 (lengthWFF wff1))
	    (setq len2 (lengthWFF wff2))
	    (if (>= (+ len1 len2) myMaxColWFFLen) (return false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (if (= (argCount) 3) 
	        (setq newRule (argFetch 2))
	        (setq newRule binaryOperators[(integer (gsm.myRandomFunction (length binaryOperators)))])
	        ) ; end if
	    (setq expression (list newRule wff1 wff2))
		expression) ; end marryNumericWFFs    
		
	(defun mutateAbstractC0(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateAbstractC1(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4)"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((binaryRules #(obj| ruleAdd ruleDiv ruleExpt ruleMod ruleMul ruleSub)))
		vars:((multiaryRules #(obj| ruleAvg ruleMax ruleMin ruleProd ruleSum)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (setq wff (growWFF expression: 0)))
		 ((isSymbol wff) (setq wff (growWFF expression: 0)))
		 ((and (isString wff) (= wff[0] #\c)) (setq wff (growWFF expression: 0)))
		 ((and (isString wff) (= wff[0] #\v)) (setq wff (growWFF expression: 0)))
		 ((and (isString wff) (= wff[0] #\x)) (setq wff (growWFF expression: 0)))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Replace the unary argument of this level.
	         ((>= argPoint .50) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff unaryRules[(gsm.myRandomFunction (length unaryRules))]))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateNumericWFF wff[2] point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .6666) (if (isAtom wff[2]) (setCar (cddr wff) (mutateNumericWFF wff[2] point)) (setCar (cddr wff) (growWFF expression: 0))))
	         ;; Case: Replace binary argument one of this level.
	         ((> argPoint .3333) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCar wff binaryRules[(gsm.myRandomFunction (length binaryRules))]))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)))
	         ;; Case: Replace multiary argument two of this level.
	         ((> argPoint .6666) (if (isAtom nwff[2]) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)) (setCar (cddr nwff) (growWFF expression: 0))))
	         ;; Case: Replace multiary argument one of this level.
	         ((> argPoint .3333) (if (isAtom nwff[1]) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)) (setCar (cdr nwff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff multiaryRules[(gsm.myRandomFunction (length multiaryRules))]))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) false)
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleExpt:) (goto BinaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .80) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)) (setCar (cdr (cddddr wff)) (growWFF expression: 0))))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .60) (if (isAtom wff[4]) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)) (setCar (cddddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .40) (if (isAtom wff[3]) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)) (setCar (cdddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument two of this level.
	         ((>= argPoint .20) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Replace binary argument one of this level.
	         (else (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:) (setq wff (growWFF expression: 0)))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
		 ((= rule ruleVar:) (setq wff (growWFF expression: 0)))
	     (else (error (append "gsm.expressionGrammarGab.mutateNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateNumericWFF    
	
	(defun selectPairWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Pair objects. 
	;;
	;; args:     wff       The WFF whose Pair objects are to be returned.           
	;;           index     (Optional)The vector of Pair objects to be returned.           
	;;           
	;; Return:   index     The vector of Pair objects to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector: Object:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return index))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectPairWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleCons:) (selectPairWFF wff[1] index))
		 ((= rule ruleCos:) (selectPairWFF wff[1] index))
		 ((= rule ruleCube:) (selectPairWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleExp:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpression:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index) (selectPairWFF wff[3] index) (selectPairWFF wff[4] index) (selectPairWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectPairWFF wff[1] index))
		 ((= rule ruleInt:) (selectPairWFF wff[1] index))
		 ((= rule ruleInv:) (selectPairWFF wff[1] index))
		 ((= rule ruleLog:) (selectPairWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleName:) (selectPairWFF wff[1] index))
		 ((= rule ruleNeg:) (selectPairWFF wff[1] index))
		 ((= rule ruleNop:) (selectPairWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectPairWFF wff[1] index))
		 ((= rule ruleSign:) (selectPairWFF wff[1] index))
		 ((= rule ruleSin:) (selectPairWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectPairWFF wff[1] index))
		 ((= rule ruleSquare:) (selectPairWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleTan:) (selectPairWFF wff[1] index))
		 ((= rule ruleTanh:) (selectPairWFF wff[1] index))
		 ((= rule ruleVar:) (selectPairWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGab.selectPairWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectPairWFF    

	(defun selectSlotWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Slot items. 
	;;
	;; args:     wff       The WFF whose slot items are to be returned.           
	;;           index     (Optional)The vector of slot items to be returned.           
	;;           
	;; Return:   index     The vector of slot items to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return (setq index[(length index)] wff)))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectSlotWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleCons:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCos:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCube:) (selectSlotWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleExp:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpression:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index) (selectSlotWFF wff[3] index) (selectSlotWFF wff[4] index) (selectSlotWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInv:) (selectSlotWFF wff[1] index))
		 ((= rule ruleLog:) (selectSlotWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleName:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNeg:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNop:) (selectSlotWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSign:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSin:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSquare:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleTan:) (selectSlotWFF wff[1] index))
		 ((= rule ruleTanh:) (selectSlotWFF wff[1] index))
		 ((= rule ruleVar:) (selectSlotWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGab.selectSlotWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectSlotsWFF    

	(defun spliceImmediateWFF(wff swff index)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by immediately splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered (must be a Pair).
	;;           swff      The WFF which is to be spliced.
	;;           index     The index for splicing this grammar rule.
	;;           
	;; Return:   result    True iff the wff has been altered; otherwise, false.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
        (if (isAtom wff) (error "gsm.expressionGrammarGab.spliceImmediateWFF: the WFF argument must be a Pair object"))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (return false))
		 ((isSymbol wff) (return false))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (length wff))
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         ((and (= index 3) (> N 3)) (setCar (cdddr wff) swff))
	         ((and (= index 4) (> N 4)) (setCar (cddddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (return false))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (return false))
	         ((= index 3) (setCar (cdddr wff) swff))
	         ((= index 4) (setCar (cddddr wff) swff))
	         ((= index 5) (setCar (cdr (cddddr wff)) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (return false))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (return false))
	     (else (error (append "gsm.expressionGrammarGab.spliceImmediateWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		true) ; end spliceImmediateWFF    
	
	(defun spliceNumericWFF(wff swff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered.
	;;           swff      The WFF which is to be spliced.
	;;           point     (Optional) The probability of splicing this grammar rule.
    ;;                     Note: If omitted, the probability of splicing this node is 100%.           
	;;           
	;; Return:   wff       The new spliced WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGab) (error "gsm.expressionGrammarGab: this expression grammar is out of focus"))
	    (if (= (argCount) 2) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 2)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (setq wff swff))
		 ((isSymbol wff) (setq wff swff))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level.
	         ((= stopHereSW false) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Replace unary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom wff[2]) (setCar (cddr wff) swff) (spliceNumericWFF wff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom nwff[1]) (setCar (cdr nwff) swff) (spliceNumericWFF nwff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom nwff[2]) (setCar (cddr nwff) swff) (spliceNumericWFF nwff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr nwff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr nwff) swff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (setq wff swff))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .25)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[3]) (setCar (cdddr wff) swff) (spliceNumericWFF wff[3] swff point)))
	         ;; Case: Pass the splice request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .75)) (if (isAtom wff[4]) (setCar (cddddr wff) swff) (spliceNumericWFF wff[4] swff point)))
	         ;; Case: Pass the splice request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .75)) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) swff) (spliceNumericWFF wff[5] swff point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .75) (setCar (cdr (cddddr wff)) swff))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .50) (setCar (cddddr wff) swff))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .25) (setCar (cdddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (setq wff  swff))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (setq wff swff))
	     (else (error (append "gsm.expressionGrammarGab.spliceNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end spliceNumericWFF    
	
    ;; *******************************************************************************
    ;; Define Expression grammar production Rules 
    ;; *******************************************************************************

	(defun ruleAbs(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric absolute function such as "abs(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(" (evalRule wff1) ")"))
	    source) ; end ruleAbs    
	
	(defun ruleAdd(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric addition such as "x1 + xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " + " (evalRule wff2) ")"))
	    source) ; end ruleAdd    
	    
	(defun ruleAvg(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric average such as "avg(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "avg(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleAvg    
	    
	(defun ruleCons(Integer:constantID)
	;; *******************************************************************
	;; summary:  Return an constant name c0 thru cK only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     constantID  An Integer in the range 0 thru K.
	;;           
	;; Return:   name        A constant name c0 thru cK.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an constant name.
	    (setq name (append "c" constantID))
	    (symbol name)) ; end ruleCons  
	    
	(defun ruleCos(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cosine function such as "cos(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "cos(" (evalRule wff1) ")"))
	    source) ; end ruleCos    
	    
	(defun ruleCube(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cube function such as "(x1*x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleCube    
	    
	(defun ruleDiv(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric protected division such as "(x1/xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " / " (evalRule wff2) ")"))
	    source) ; end ruleDiv    
	    
	(defun ruleExpression(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric exp function such as "exp(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (evalRule wff1))
	    source) ; end ruleExpression    
	    
	(defun ruleExp(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator exponential function such as "exp(x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff      The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "exp(" (evalRule wff) ")"))
	    source) ; end ruleExp    
	    
	(defun ruleExpt(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator exponent function such as "expt(abs(x1),x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "expt(abs(" (evalRule wff1) ") ," (evalRule wff2) ")"))
	    source) ; end ruleExpt    
	    
	   
	(defun ruleFrac(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric fraction function such as "fraction(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "fraction(" (evalRule wff1) ")"))
	    source) ; end ruleFrac    

	(defun ruleFrm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple factor regression statement 
    ;;           such as 
    ;;                     "frmregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple factor regression statement such as "frmregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleFrm.wffSource genome))
	    source) ; end ruleFrm    
	    
	(defun ruleIf(wff1 relop wff2 wff3 wff4)
	;; *******************************************************************
	;; summary:  Return a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           relop    The relational operator (< <= == <> >= >).
	;;           wff2     The second expression.
	;;           wff3     The then expression.
	;;           wff4     The else expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(if (" (evalRule wff1) " " (string relop) " " (evalRule wff2) ") {" (evalRule wff3)  "} else {" (evalRule wff4) "})"))
	    source) ; end ruleIf    
	    
	
	(defun ruleInt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "number(integer(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "ninteger(" (evalRule wff1) ")"))
	    source) ; end ruleInt    
	    
	(defun ruleInv(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator inverted numeric WFF, such as (1.0 / x4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The inverion of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (/ wff))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGab.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGab.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGab.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGab.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGab.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     (else (setq expression (append "(1.0 / " (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleInv    
	
	(defun ruleLog(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric log function such as "log(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "log(" (evalRule wff1) ")"))
	    source) ; end ruleLog    
	    
	(defun ruleMax(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric maximum such as "max(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "max(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMax    
	
	(defun ruleMdl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator model statement such as "model x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the model statement.
	;;           
	;; Return:   result      A Estimator model statement such as "model x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMdl.wffSource genome))
	    source) ; end ruleMdl   
	    
	(defun ruleMin(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric minimum such as "min(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "min(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMin    
	    
	(defun ruleMod(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric modulus such as "(x1%xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    ;; Return the modulus of the specified arguments.
	    (setq source (append "(" (evalRule wff1) " % " (evalRule wff2) ")"))
	    source) ; end ruleMod    
	    
	(defun ruleMul(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric multiplication such as "x1 * xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " * " (evalRule wff2) ")"))
	    source) ; end ruleMul    
	    
	(defun ruleMvl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple linear regression statement 
    ;;           such as 
    ;;                     "mvlregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple linear regression statement such as "mvlregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMvl.wffSource genome))
        source) ; end ruleMvl    
	    
	(defun ruleName(elementID)
	;; *******************************************************************
	;; summary:  Return an element name xtime, xid, x1 thru xm only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru M.
	;;           
	;; Return:   name        An element name xtime, xid, or x1 thru xm.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name WGE.
	    (setq name (append "x" elementID))
	    (symbol name)) ; end ruleName    
	    
	(defun ruleNeg(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator negative numeric WFF, such as -x1 or -(x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The negation of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (- wff))))
	     ((= rule ruleAdd:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleAvg:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleDiv:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGab.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleIf:) (setq expression (evalRule (list rule wff[1] wff[2] wff[3] (list ruleNeg: wff[4])  (list ruleNeg: wff[5])))))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGab.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleMul:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGab.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleNeg:) (setq expression (evalRule wff[1])))
	     ((= rule ruleSign:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])))))
	     ((= rule ruleSub:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGab.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGab.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     (else (setq expression (append "(-" (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleNeg    
	
	(defun ruleNop(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator no operation numeric WFF, such as x1 or (x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The specified wff.
	;;
	;; *******************************************************************
	    ;; Return the specified WFF.
	    (evalRule wff)) ; end ruleNop    
	    
	(defun ruleProd(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "product(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "product(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleProd    
	    
	(defun ruleReg(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator regress statement such as "regress x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "regress x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleReg.wffSource genome))
	    source) ; end ruleReg    
	    
	(defun ruleSigmoid(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "sigmoid(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(fraction(" (evalRule wff1) "))"))
	    source) ; end ruleSigmoid    
	    
	(defun ruleSign(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sign function such as "sign(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sign(" (evalRule wff1) ")"))
	    source) ; end ruleSign    
	
	
	(defun ruleSin(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sine function such as "sin(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sin(" (evalRule wff1) ")"))
	    source) ; end ruleSin    
	
	(defun ruleSqrt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sqrt function such as "sqrt(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sqrt(" (evalRule wff1) ")"))
	    source) ; end ruleSqrt    
	    
	(defun ruleSquare(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric square function such as "(x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleSquare    
	    
	(defun ruleSub(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric subtraction such as "x1 - xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " - " (evalRule wff2) ")"))
	    source) ; end ruleSub    
	    
	(defun ruleSum(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "sum(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "sum(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleSum    
	    
	(defun ruleSvm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator SVM statement such as "svmregress(x1,x2,x3);". 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the svmregress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "svmregress(x3,x5);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleSvm.wffSource genome))
	    source) ; end ruleSvm    

	    
	(defun ruleTan(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric tangent function such as "tan(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tan(" (evalRule wff1) ")"))
	    source) ; end ruleTan    
	    
	(defun ruleTanh(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric hyper tangent function such as "tanh(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tanh(" (evalRule wff1) ")"))
	    source) ; end ruleTanh    
	    
	(defun ruleVar(elementID)
	;; *******************************************************************
	;; summary:  Return an element variable reference v0, v1 thru vK as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru K.
	;;           
	;; Return:   name        An element variable reference v0, v1 thru vK.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name vk.
	    (setq name (append "v" elementID))
	    (symbol name)) ; end ruleVar    
	    
	;; *******************************************************************
    ;; Begin main logic
	;; *******************************************************************
    vars:(wffHdr sourceWff)
    (if (isString wff) then (setq wff (listWff wff)))
    (if (isPair wff) 
        (setq sourceWff (apply (setq wffHdr gsm.expressionGrammarGab[(car wff)]) (cdr wff))) 
        (setq sourceWff (string wff true))
        ) ; end if
    sourceWff) ; end expressionGrammarGab









































































































































































;;**EXPORTKEY**:gsm.expressionGrammarGen
(defriend gsm:expressionGrammarGen(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all generating training model
;;           genetic programming numeric expressions. 
;;
;; Main:     Return a training model genetic programming numeric expression, 
;;           in source format, such as 
;;
;;                    "((x2*(x3-35.7))/x1)"
;; 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the numeric expression.
;;           
;; Return:   result      A Estimator genetic programming numeric 
;;                       expression such as "((x2*(x3-35.7))/x1)".
;;
;; Notes:    GEP expressions support the following self-learning references
;;
;;           Constants:             -45.261  +319.23 .0345 .192765 
;;
;;           Variables:             x0 thru xM 
;;
;;           Relational Operators:  < <= == <> >= > 
;;
;;           binary Rules:          ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub 
;;
;;           unary Rules:           ruleAbs ruleCos ruleCube ruleExpression ruleInt ruleInv ruleLog ruleNeg ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh  
;;
;;           conditional Rules:     ruleIf  
;; *******************************************************************
  pvars:(;; Public Variables
         ;; Expression operators
		 checkNumericWFF   		    ;; Checks a numeric Estimator WFF for validity.
         concreteWFF                ;; Converts the specified abstract Lambda's WFF into a concrete WFF.  
		 convertToAbstractWFF  	    ;; Converts a concrete/abstract Estimator WFF to an abstract WFF {x4 ==> v0 and -2.345 ==> c0}.
		 cutoutNumericWFF   		;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
         extractNumericWFF		    ;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
         growWFF                    ;; Returns a randomly grown Estimator WFF. 
         growCTermWFF               ;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
         growRootWFF                ;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
         growTermWFF                ;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column.
	  	 lengthWFF   		        ;; Returns the left-depth-first length of any Estimator WFF.
         marryNumericWFFs		    ;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}.
		 mutateAbstractC0   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v0*c0))"}.
		 mutateAbstractC1   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v1*c1))"}.
		 mutateNumericWFF   	    ;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}.
		 selectPairWFF    	        ;; Returns the specified WFF as a vector of Pair objects. 
		 selectSlotWFF    	        ;; Returns the specified WFF as a vector of Slot items. 
		 spliceImmediateWFF    	    ;; Returns a numeric Estimator WFF by immediately splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
		 spliceNumericWFF    	    ;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
         ;; Expression grammar production Rules
         ruleAbs             		;; Produce a Estimator numeric absolute function such as "abs(x1)". 
         ruleAdd                   	;; Produce a Estimator numeric addition such as x1 + xm. 
         ruleAvg                   	;; Produce a Estimator numeric average such as avg(x1,x2,...,xm). 
         ruleCos                   	;; Produce a Estimator numeric cosine function such as "cos(x1)". 
         ruleCube                  	;; Produce a Estimator numeric cube function such as "(x1*x1*x1)". 
         ruleDiv                   	;; Produce a Estimator numeric protected division such as pdiv(x1,xm). (x3 == 0 ? x4 : x4 / x3) 
         ruleExpression             ;; Produce a Estimator genetic programming numeric expressions such as "((x1-x6)*cos(x2))". 
         ruleExp                   	;; Produce a Estimator exponential function such as "exp(x2)".
         ruleFrac                  	;; Produce a Estimator numeric fraction function such as "fraction(x1)". 
         ruleFrm                   	;; Produce a Estimator multiple factor regression statement such as "frmregress (.23*x3,34.5*x4);". 
         ruleIf                    	;; Produce a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})".
         ruleInt                   	;; Produce a Estimator numeric integer function such as "number(integer(x1))". 
         ruleInv                   	;; Produce a Estimator inversion function such as "(1.0 /x1)". 
         ruleLog                   	;; Produce a Estimator numeric log function such as "log(abs(x1))". 
         ruleMax                   	;; Produce a Estimator numeric maximum such as max(x1,x2,...,xm). 
         ruleMdl                   	;; Produce a Estimator model statement such as "model x3*x4;". 
         ruleMin                   	;; Produce a Estimator numeric minimum such as min(x1,x2,...,xm). 
         ruleMod                   	;; Produce a Estimator numeric mod such as mod(x1,xm). 
         ruleMul                   	;; Produce a Estimator numeric multiplication such as x1 * xm. 
         ruleMvl                   	;; Produce a Estimator multiple linear regression statement such as "mvlregress (.23*x3,34.5*x4);". 
         ruleName                  	;; Produce a Estimator element name such as xtime, or x1 thru xm.
         ruleNeg                   	;; Produce a Estimator numeric negation such as -(x1 * xm). 
         ruleNop                   	;; Produce a Estimator no operation.
         ruleProd                  	;; Produce a Estimator numeric product such as (x1*x2*...*xm). 
         ruleReg                   	;; Produce a Estimator regress statement such as "regress x3*x4;". 
         ruleSigmoid               	;; Produce a Estimator numeric sigmoid function such as "sigmoid(x1)". 
         ruleSign                  	;; Produce a Estimator numeric sign function such as "sign(x1)". 
         ruleSin                   	;; Produce a Estimator numeric sine function such as "sin(x1)". 
         ruleSqrt                  	;; Produce a Estimator numeric square root function such as "sqrt(abs(x1))". 
         ruleSquare                	;; Produce a Estimator numeric square function such as "(x1*x1)". 
         ruleSub                   	;; Produce a Estimator numeric subtraction such as x1 - xm. 
         ruleSum                   	;; Produce a Estimator numeric sum such as sum(x1,x2,...,xm). 
         ruleSvm                   	;; Produce a Estimator support vector regression statement such as "svmregress (.23*x3,34.5*x4);". 
         ruleTan                   	;; Produce a Estimator numeric tangent function such as "tan(x1)". 
         ruleTanh                  	;; Produce a Estimator numeric hyper tangent function such as "tanh(x1)". 
         ) ; end public variables
    ;; *******************************************************************************
    ;; Define Public Child Lambdas 
    ;; *******************************************************************************

    ;; *******************************************************************************
    ;; Define Expression operators 
    ;; *******************************************************************************
   
    (defun checkNumericWFF(wff)
    ;; *******************************************************************
    ;; summary:  Checks a numeric Estimator WFF for validity.  
    ;;
    ;; args:     wff       The WFF which is to be verified.
    ;;           
    ;; Return:   wff       The new verified WFF.
    ;;
    ;; *******************************************************************
        vars:(rule)
        ;; Check to make sure the Estimator WFF is valid.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
        (setq rule wff[0])
        (cond
         ((isNumber wff) true)
         ((isSymbol wff) true)
         ((= rule ruleAbs:)
          (begin
            UnaryCheck::
            (if (<> (length wff) 2) (error (append "gsm.expressionGrammarGen.checkNumericWFF: invalid length for unary grammar rule [" rule "]")))
          )) ; end ruleAbs case
         ((= rule ruleAdd:)
          (begin
            BinaryCheck::
            (if (<> (length wff) 3) (error (append "gsm.expressionGrammarGen.checkNumericWFF: invalid length for binary grammar rule [" rule "]")))
          )) ; end ruleAdd case
         ((= rule ruleAvg:)
          (begin
            MultiaryCheck::
            (if (< (length wff) 2) (error (append "gsm.expressionGrammarGen.checkNumericWFF: invalid length for Multiary grammar rule [" rule "]")))
          )) ; end ruleAvg case
         ((= rule ruleCos:) (goto UnaryCheck:))
         ((= rule ruleCube:) (goto UnaryCheck:))
         ((= rule ruleDiv:) (goto BinaryCheck:))
         ((= rule ruleExp:) (goto UnaryCheck:))
         ((= rule ruleName:) (goto UnaryCheck:))
         ((= rule ruleNum:) (goto UnaryCheck:))
         ((= rule ruleExpression:) (goto UnaryCheck:))
         ((= rule ruleTanh:) (goto UnaryCheck:))
         ((= rule ruleIf:)
          (begin
            IfCheck::
            (if (<> (length wff) 6) (error (append "gsm.expressionGrammarGen.checkNumericWFF: invalid length for if grammar rule [" rule "]")))
          )) ; end ruleIf case
         ((= rule ruleFrac:) (goto UnaryCheck:))
         ((= rule ruleInt:) (goto UnaryCheck:))
         ((= rule ruleInv:) (goto UnaryCheck:))
         ((= rule ruleLog:) (goto UnaryCheck:))
         ((= rule ruleMax:) (goto MultiaryCheck:))
         ((= rule ruleMin:) (goto MultiaryCheck:))
         ((= rule ruleMod:) (goto BinaryCheck:))
         ((= rule ruleMul:) (goto BinaryCheck:))
         ((= rule ruleNeg:) (goto UnaryCheck:))
         ((= rule ruleProd:) (goto MultiaryCheck:))
         ((= rule ruleSigmoid:) (goto UnaryCheck:))
         ((= rule ruleSign:) (goto UnaryCheck:))
         ((= rule ruleSin:) (goto UnaryCheck:))
         ((= rule ruleSqrt:) (goto UnaryCheck:))
         ((= rule ruleSquare:) (goto UnaryCheck:))
         ((= rule ruleSub:) (goto BinaryCheck:))
         ((= rule ruleSum:) (goto MultiaryCheck:))
         ((= rule ruleTan:) (goto UnaryCheck:))
         (else (error (append "gsm.expressionGrammarGen.checkNumericWFF: unknown WFF grammar rule [" rule "]")))
         ) ; end cond
        wff) ; end checkNumericWFF    
    
    (defun concreteWFF(Lambda ...)
    ;; *******************************************************************
    ;; summary:   Converts the specified abstract Lambda's WFF into a concrete WFF.  
    ;;
    ;; args:     Lambda    The specified abstract Lambda whose WFF into a concrete WFF.
    ;;           wff      (Optional)The specified WFF to be converted into a concrete WFF.
    ;;           
    ;; Return:   wff      The new concrete WFF.
    ;;
    ;; *******************************************************************
        regs:(n N)
        vars:(rule wff)

        ;; Convert wff to a list grammar format.
        (if (>= (argCount) 2) (setq wff (argFetch 1)) (setq wff (listWff Lambda.WFF)))

        wff) ; end concreteWFF    
		
	(defun convertToAbstractWFF(wff ...)  (error "gsm.expressionGrammarGen: abstract expression conversion is not valid"))

	(defun cutoutNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly cutting out a  
	;;           sub-expression from a candidate Estimator WFF 
	;;           For example {"(x3/sin(x4))" ==> "sin(x4)"}. 
	;;
	;; args:     wff       The WFF from which the cutout is to be taken.
	;;           point     (Optional)The probability of cutting at this grammar rule.           
	;;           
	;; Return:   wff       The cut out sub-expression from a candidate Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (return wff))
		 ((isSymbol wff) (return wff))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the unary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument two.
	         ((and (= stopHereSW false) (isPair wff[2])) (return (cutoutNumericWFF wff[2] point)))
	         ;; Case: Cutout the binary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryCutout::
            (setq N (- (length wff) 1))
	        (cond
	         ;; Case: Pass the cutout request to the next level through the nth argument.
	         ((and (= stopHereSW false) (> (setq n (+ 1 (integer (* argPoint N)))) 0) (isPair wff[n])) (return (cutoutNumericWFF wff[n] point)))
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the multiary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnaryCutout:))
		 ((= rule ruleCube:) (goto UnaryCutout:))
		 ((= rule ruleDiv:) (goto BinaryCutout:))
         ((= rule ruleExp:) (goto UnaryCutout:))
		 ((= rule ruleExpression:) (goto UnaryCutout:))
		 ((= rule ruleTanh:) (goto UnaryCutout:))
		 ((= rule ruleIf:)
	      (begin
	        IfCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1]) (< argPoint .25)) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument three.
	         ((and (= stopHereSW false) (isPair wff[3]) (< argPoint .50)) (return (cutoutNumericWFF wff[3] point)))
	         ;; Case: Pass the cutout request to the next level through argument four.
	         ((and (= stopHereSW false) (isPair wff[4]) (< argPoint .75)) (return (cutoutNumericWFF wff[4] point)))
	         ;; Case: Pass the cutout request to the next level through argument five.
	         ((and (= stopHereSW false) (isPair wff[5]) (>= argPoint .75)) (return (cutoutNumericWFF wff[5] point)))
	         ;; Case: Cutout the if expression on this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryCutout:))
		 ((= rule ruleInt:) (goto UnaryCutout:))
		 ((= rule ruleInv:) (goto UnaryCutout:))
		 ((= rule ruleLog:) (goto UnaryCutout:))
		 ((= rule ruleMax:) (goto MultiaryCutout:))
		 ((= rule ruleMin:) (goto MultiaryCutout:))
		 ((= rule ruleMod:) (goto BinaryCutout:))
		 ((= rule ruleMul:) (goto BinaryCutout:))
		 ((= rule ruleName:) (return (ruleName wff[1])))
		 ((= rule ruleNeg:) (goto UnaryCutout:))
		 ((= rule ruleNop:) (goto UnaryCutout:))
		 ((= rule ruleProd:) (goto MultiaryCutout:))
		 ((= rule ruleSigmoid:) (goto UnaryCutout:))
		 ((= rule ruleSign:) (goto UnaryCutout:))
		 ((= rule ruleSin:) (goto UnaryCutout:))
		 ((= rule ruleSqrt:) (goto UnaryCutout:))
		 ((= rule ruleSquare:) (goto UnaryCutout:))
		 ((= rule ruleSub:) (goto BinaryCutout:))
		 ((= rule ruleSum:) (goto MultiaryCutout:))
		 ((= rule ruleTan:) (goto UnaryCutout:))
	     (else (error (append "gsm.expressionGrammarGen.cutoutNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end cutoutNumericWFF    
	
	;; *******************************************************************
	;; summary:  Evaluate an GEP grammar production rule.
	;;
	;; args:     rule        Any GEP grammar rule to be evaluated.
	;;           
	;; Return:   expression  The result of evaluating the grammar rule as a String.
	;;
	;; *******************************************************************
    (defun evalRule(rule)
       vars:(ruleHdr)
       (onError (lambda(msg) "...error..."))
       (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
       (if (isString rule) (setq rule (listWff rule)))
       (if (isPair rule) (setq rule (apply (setq ruleHdr gsm.expressionGrammarGen[(car rule)]) (cdr rule))) (setq rule (string rule true)))
       rule) ; end evalRule

    (defun extractNumericWFF(inWff ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF from any Estimator WFF.
	;;           For instance: "regress (x3/x13);" ==> "(x3/x13)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     inWff       Any Estimator input WFF or Estimator Lambda.
	;;           sourceSW    (Optional) True iff the result expression is to be returned in source form.
	;;           
	;;           
	;; Return:   expression  The numeric WFF extracted from the specified Estimator WFF.
	;;
	;; *******************************************************************
		regs:(m M)
		vars:(sourceSW expression rule wff)
	    ;; If the wff argument is an Lambda, then convert it to a WFF.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (isLambda inWff) (setq wff inWff.WFF) (setq wff inWff))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    (setq sourceSW (if (>= (argCount) 2) (argFetch 1) false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (setq expression wff))
		 ((isSymbol wff) (setq expression wff))
		 ((= rule ruleAbs:) (setq expression wff))
		 ((= rule ruleAdd:) (setq expression wff))
		 ((= rule ruleAvg:) (setq expression wff))
		 ((= rule ruleCos:) (setq expression wff))
		 ((= rule ruleCube:) (setq expression wff))
		 ((= rule ruleDiv:) (setq expression wff))
		 ((= rule ruleExp:) (setq expression wff))
		 ((= rule ruleExpression:) (setq expression wff))
		 ((= rule ruleFrm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleIf:) (setq expression wff))
		 ((= rule ruleLog:) (setq expression wff))
		 ((= rule ruleFrac:) (setq expression wff))
		 ((= rule ruleInt:) (setq expression wff))
		 ((= rule ruleInv:) (setq expression wff))
		 ((= rule ruleMax:) (setq expression wff))
		 ((= rule ruleMdl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleMin:) (setq expression wff))
		 ((= rule ruleMod:) (setq expression wff))
		 ((= rule ruleMul:) (setq expression wff))
		 ((= rule ruleMvl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleName:) (setq expression (ruleName wff[1])))
		 ((= rule ruleNeg:) (setq expression wff))
		 ((= rule ruleNop:) (setq expression wff))
		 ((= rule ruleProd:) (setq expression wff))
		 ((= rule ruleReg:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleSigmoid:) (setq expression wff))
		 ((= rule ruleSign:) (setq expression wff))
		 ((= rule ruleSin:) (setq expression wff))
		 ((= rule ruleSqrt:) (setq expression wff))
		 ((= rule ruleSquare:) (setq expression wff))
		 ((= rule ruleSub:) (setq expression wff))
		 ((= rule ruleSum:) (setq expression wff))
		 ((= rule ruleSvm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleTan:) (setq expression wff))
		 ((= rule ruleTanh:) (setq expression wff))
	     (else (setq expression x1:))
	     ) ; end cond
	    ;; Return the numeric expression as a Estimator WFF or as a Estimator source string.
	    (if (= expression #void) (setq expression x1:))
	    (if (= sourceSW true) then (setq expression (evalRule expression))) 
		expression) ; end extractNumericWFF    
	
    (defun growWFF(Symbol:rule Integer:level)
	;; *******************************************************************
	;; summary:  Returns a randomly grown Estimator WFF. 
	;;
	;; args:     rule      The grammar rule indicating the type of WFF is to be returned.
	;;                     Note: The values for the rule argument as as follows:
	;;                           binary:		Generates a random binary operator expression.	            
	;;                           condition:     Generates a random "if" expression.	            
	;;                           expression:    Generates a random numeric expression.	            
	;;                           number:		Generates a random number constant.	            
	;;                           unary:		    Generates a random unary operator expression.	            
	;;                           variable:      Generates a random element name (xtime, xid, x1 thru xm).	            
	;;           level     The count of the current level in the expression.
	;;           
	;; Return:   result    The randomly grown Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:r (maxLevels 10))
		vars:(wff newRule relop)
		vars:(commands expressions percents)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((expressionRules #(obj| binary condition unary variable)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the type of Estimator WFF generated.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
		;; Apply the specified rule to generate the Estimator WFF.
	    (cond
	     ;; Case binary:		Generates a random binary operator expression.	            
		 ((= rule binary:) 
	      (begin
	        (setq N (length binaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule binaryRules[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1)) (growWFF term: (+ level 1))))
	            ) ; end if
	      )) ; end case binary
	
	     ;; Case condition:    Generates a random "if" expression.	            
		 ((= rule condition:) 
	      (begin
	        (setq newRule ruleIf:)
	        (setq N (length relationalOperators))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq relop relationalOperators[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF variable: (+ level 1)) relop (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1)) relop (growWFF term: (+ level 1)) (growWFF term: (+ level 1)) (growWFF term: (+ level 1))))
	            ) ; end if
	      )) ; end case condition
	
	     ;; Case expression:    Generates a random numeric expression.	            
		 ((= rule expression:) 
	      (begin
	        GrowExpression::
	        (setq N (length expressionRules))
	        (setq n (integer (gsm.myRandomFunction N)))
            (setq r (gsm.myRandomFunction 1.0))
	        (cond 
	         ((>= level maxLevels) (goto GrowTerm:))
	         ((<= r .40) (setq wff (growWFF (setq newRule unary:) (+ level 1))))
	         ((<= r .70) (setq wff (growWFF (setq newRule binary:) (+ level 1))))
	         ((<= r .95) (setq wff (growWFF (setq newRule variable:) (+ level 1))))
	         (else (setq wff (growWFF (setq newRule condition:) (+ level 1))))
	         ) ; end cond
	      )) ; end case expression
	
	     ;; Case number:    Generates a random number constant.	            
		 ((= rule number:) 
	      (begin
	        GrowNumber::
	        (setq r (- (gsm.myRandomFunction 10.0) 5.0))
	        (setq wff r)
	      )) ; end case number
	
	     ;; Case term:    Generates a random number constant or variable name.	            
		 ((= rule term:) 
	      (begin
	        GrowTerm::
	        (if (< (gsm.myRandomFunction 1.0) myNumberPct) (goto GrowNumber:) (goto GrowVariable:))
	      )) ; end case number
	
	     ;; Case unary:		Generates a random unary operator expression.	            
		 ((= rule unary:) 
	      (begin
	        (setq N (length unaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule unaryRules[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1))))
	            ) ; end if
	      )) ; end case unary
	
	     ;; Case variable:		Generates a random element name (xtime, xid, x1 thru xm).	            
		 ((= rule variable:) 
	      (begin
	        GrowVariable::
	        (setq n (integer (gsm.myRandomFunction myM))) 
	        (setq wff (ruleName n))
	      )) ; end case variable
	
	     ;; Case else
	     (else (error (append "gsm.expressionGrammarGen.growWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
	    ;; Return the randomly grown Estimator WFF.
		wff) ; end growWFF    
	
	(defun growCTermWFF(Integer:columnChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression conditional term
	;;           Estimator WFF based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;                      ...
	;;             if (xc+xtime) {xm-xm}, etc.
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion including conditionals.           
	;;
	;; args:     columnChoice   The choice of the regression column for this Estimator WFF expression.                        
	;;           
	;; Return:   wff          The sequentially grown conditional term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N NN NO)
		vars:(wff choice)
		vars:((operators #("<" "<=" "==" "<>" ">=" ">")))
	
	    ;; Return the count of basic Estimator term WFFs
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (setq NN (growTermWFF -1 columnChoice))
	    (setq NO (length operators))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	
	    (setq choice (gsm.myRandomFunction 1.0))
	    (if (>= choice 0.20)
	        ;; Generate a Estimator term WFF
	        (setq wff (growTermWFF (integer (gsm.myRandomFunction NN)) columnChoice))
	        ;; Generate a Estimator conditional term WFF
	        (setq wff (list ruleIf: (growTermWFF (integer (gsm.myRandomFunction NN))  columnChoice)
	                                (symbol operators[(integer (gsm.myRandomFunction NO))])  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))
	                                )) ; end list
	        ) ; end generate cterm only if
	
		wff) ; end growCTermWFF    
	
	(defun growRootWFF(Integer:rootChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown root Estimator WFF such as
	;;             xtime, thru xm, 
	;;             abs(xtime) thru abs(xm), 
	;;             cos(xtime) thru cos(xm),
	;;                      ...
	;;             tan(xtime) thru tan(xm),
	;;             (xtime+xtime) thru (xm+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The root Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice   The choice of the sequential root WFF expression to return.                        
	;;           Note: if rootChoice <= -2, then a random root WFF is to be generated and extended randomly.
	;;           Note: if rootChoice == -1, then the maximum number of root WFFs is to be returned.
	;;           Note: if rootChoice >=  0, then a random root WFF is to be generated and extended randomly.
	;;                 Otherwise, rootChoice must be the index of the chosen Estimator WFF root expression.
	;;           
	;; Return:   wff          The sequentially grown root Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(B m M n N NN)
		vars:(wff newRule Integer:choice)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator root WFF without extension.
	    ;; **********************************************************
	    
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate all of the single variable names
	          (if (< choice myM)
	              (begin
	                 (setq wff (ruleName choice))
	                 (return wff)
	              )) ; end variable names
	          (-= choice myM)
	          
	          ;; Generate all of the exponent functions with single variable names
	          (setq N 3)
	          (if (< choice N)
	              (begin
	                 (if (= choice 0) then (begin (setq wff (list ruleSqrt: (ruleName m))) (return wff)))
	                 (if (= choice 1) then (begin (setq wff (list ruleSquare: (ruleName m))) (return wff)))
	                 (if (= choice 2) then (begin (setq wff (list ruleCube: (ruleName m))) (return wff)))
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with single variable names
	          (setq N (muli (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule unaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName m)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the binary functions with single variable names
	          (setq B (length binaryRules))
	          (setq M (muli myM myM))
	          (setq N (muli B myM myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice M))
	                 (setq newRule binaryRules[n])
	                 (setq n (modi choice M))
	                 (setq m (/ n myM))
	                 (setq n (modi n myM))
	                 (setq wff (list newRule (ruleName m) (ruleName n)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Return void wff showing that there are no more root Estimator WFFs available.
	          (return #void)
	          
	        )) ; end generate root only if
	
    ;; **********************************************************
    ;; Return the maximum number of root WFFs.
    ;; **********************************************************
    (setq NN myM)
    (setq N 3)(+= NN N)
    (setq N (muli (length unaryRules) myM))(+= NN N)
    (setq N (muli (length binaryRules) myM myM))(+= NN N)
    (if (= choice -1) (return NN))

    ;; **************************************************************
    ;; Generate a sequential Estimator root WFF with random extension.
    ;; **************************************************************
    (setq choice (integer (gsm.myRandomFunction NN)))
    (setq wff (growRootWFF choice))
    (setq wff (mutateNumericWFF wff))

	wff) ; end growRootWFF    


	(defun growTermWFF(Integer:rootChoice Integer:columnChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression term Estimator WFF 
	;;           based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice     The choice of the sequential term WFF expression to return.                        
	;;                           Note: if rootChoice <  -1, then a random term WFF is to be generated.
	;;                           Note: if rootChoice == -1, then the maximum number of term WFFs is to be returned.
	;;                           Note: if rootChoice >=  0, then a sequential term WFF is to be generated, and the rootChoice must be the index of the chosen Estimator WFF.
	;;           columnChoice   The choice of the regression column for this Estimator WFF expression.                        
	;;                           Note: if columnChoice <  0, then a random column choice is to be generated.
	;;           
	;; Return:   wff          The sequentially grown term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(B m M mm MM n N nn NN)
		vars:(wff newRule Integer:choice)
		vars:((binaryRules #(obj| ruleAvg ruleAdd ruleDiv ruleMax ruleMod ruleMin ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; Generate a random column choice (if necessary).
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (< columnChoice 0) (setq columnChoice (integer (gsm.myRandomFunction myM))))
	    
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	    
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate the chosen column variable name
	          (if (= choice 0)
	              (begin
	                 (setq wff (ruleName columnChoice))
	                 (return wff)
	              )) ; end column variable names
	          (-= choice 1)
	
	          ;; Generate all of the term unary functions
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq newRule unaryRules[choice])
	                 (setq wff (list newRule (ruleName columnChoice)))
	                 (return wff)
	              )) ; end term unary functions names
	          (-= choice N)
	          
	          ;; Generate all of the left term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName columnChoice) (ruleName m)))
	                 (return wff)
	              )) ; end left term binary functions
	          (-= choice N)        
	          
	          ;; Generate all of the right term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName m) (ruleName columnChoice)))
	                 (return wff)
	              )) ; end right term binary functions
	          (-= choice N) 
	          
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (ruleName columnChoice) (list unaryRules[nn] (ruleName m))))
	                 (return wff)
	              )) ; end right binary unary functions
	          (-= choice N)        
	                            
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the left binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (list unaryRules[mm] (ruleName m))))
	                 (return wff)
	              )) ; end left binary unary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName m)) (list unaryRules[mm] (ruleName columnChoice))))
	                 (return wff)
	              )) ; end right binary unary unary functions
	          (-= choice N)        
	
	          ;; Return a random Estimator term WFF if there are no more term Estimator term WFFs available.
	          (return (growTermWFF -2 columnChoice))
	          
	        )) ; end generate term only if
	
	    ;; **********************************************************
	    ;; Return the maximum number of term WFFs.
	    ;; **********************************************************
	    (setq NN (+ 1 (length unaryRules) (* 2.0 (muli (length binaryRules) myM)) (* 3.0 (muli (length binaryRules) (length unaryRules) myM)) (* 2.0 (muli (length binaryRules) (length binaryRules) (length unaryRules) myM)) ))
	    (if (= choice -1) (return NN))
	
	    ;; **************************************************************
	    ;; Generate a random Estimator term WFF.
	    ;; **************************************************************
	    TryAgain::
	    (setq choice (integer (gsm.myRandomFunction NN)))
	    (setq wff (growTermWFF choice columnChoice))
	    (if (= wff #void) (begin (writeln "gsm.expressionGrammarGen.growTermWff: void WFF at [" choice "]") (goto TryAgain:)))
	
		wff) ; end growTermWFF    
	
	(defun lengthWFF(wff)
	;; *******************************************************************
	;; summary:  Returns the left-depth-first length of any Estimator WFF. 
	;;
	;; args:     wff       The WFF whose length is to be returned.           
	;;           
	;; Return:   result    The left-depth-first length of the specified WFF.
	;;
	;; *******************************************************************
	    regs:(n N (result 0))
		vars:(rule)
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; The length of a Vector of WFFs is always the
	    ;; sum of the lengths of each WFF in the vector.
	    (if (isVector wff) 
	        then
	        (begin
	          (setq N (length wff))
	          (loop for n from 0 until N do
	            (+= result (lengthWFF wff[n]))
	            ) ; end loop 
	          (return result)
	        )) ; end if
	    ;; The length of an atomic WFF is always 1.
	    (if (isAtom wff) then (return 1))
		;; Use the grammar rule to guide the computation 
	    ;; of the specified Estimator WFF length.
	    (setq rule wff[0])
	    (cond
		 ((= rule ruleAbs:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleAdd:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleAvg:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleCos:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleCube:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleDiv:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleExp:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpression:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleFrm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleIf:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]) (lengthWFF wff[4]) (lengthWFF wff[5]))))
		 ((= rule ruleFrac:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInv:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleLog:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMax:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMdl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMin:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMod:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMul:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMvl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleName:) (setq result 1))
		 ((= rule ruleNeg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleNop:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleProd:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleReg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSigmoid:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSign:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSin:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSqrt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSquare:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSub:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleSum:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTan:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTanh:) (+= result (lengthWFF wff[1])))
	     (else (error (append "gsm.expressionGrammarGen.lengthWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		result) ; end lengthWFF    
	
	(defun marryNumericWFFs(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF by marrying two suitor 
	;;           Estimator WFFs.
	;;           For instance: "x3" , "x4" ==> "(x3/x4)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     wff1      The male WFF suitor for this marriage.           
	;;           wff2      The female WFF suitor for this marriage.           
	;;           operator  (Optional) The binary operator for this marriage.           
	;;           
	;; Return:   expression  The numeric WFF resulting from the marriage.
	;;
	;; *******************************************************************
	    vars:(expression newRule len1 len2)
		vars:((binaryOperators #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (= wff1 #void) (return false))
	    (if (= wff2 #void) (return false))
	    (if (isString wff1) (setq wff1 (listWff wff1)))
	    (if (isString wff2) (setq wff2 (listWff wff2)))
	    ;; Make sure we can marry these two WFFs without exceeding the WFF length limit.
	    (setq len1 (lengthWFF wff1))
	    (setq len2 (lengthWFF wff2))
	    (if (>= (+ len1 len2) myMaxColWFFLen) (return false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (if (= (argCount) 3) 
	        (setq newRule (argFetch 2))
	        (setq newRule binaryOperators[(integer (gsm.myRandomFunction (length binaryOperators)))])
	        ) ; end if
	    (setq expression (list newRule wff1 wff2))
		expression) ; end marryNumericWFFs    
		
	(defun mutateAbstractC0(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateAbstractC1(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4)"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((binaryRules #(obj| ruleAdd ruleDiv ruleMod ruleMul ruleSub)))
		vars:((multiaryRules #(obj| ruleAvg ruleMax ruleMin ruleProd ruleSum)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (if (< argPoint .80) (setq wff (* wff (- (gsm.myRandomFunction 10.0) 5.0))) (setq wff (growWFF expression: 0))))
		 ((isSymbol wff) (if (< argPoint .80) (setq wff (ruleName (integer (gsm.myRandomFunction myM)))) (setq wff (growWFF expression: 0))))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Replace the unary argument of this level.
	         ((>= argPoint .50) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff unaryRules[(gsm.myRandomFunction (length unaryRules))]))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateNumericWFF wff[2] point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .6666) (if (isAtom wff[2]) (setCar (cddr wff) (mutateNumericWFF wff[2] point)) (setCar (cddr wff) (growWFF expression: 0))))
	         ;; Case: Replace binary argument one of this level.
	         ((> argPoint .3333) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCar wff binaryRules[(gsm.myRandomFunction (length binaryRules))]))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)))
	         ;; Case: Replace multiary argument two of this level.
	         ((> argPoint .6666) (if (isAtom nwff[2]) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)) (setCar (cddr nwff) (growWFF expression: 0))))
	         ;; Case: Replace multiary argument one of this level.
	         ((> argPoint .3333) (if (isAtom nwff[1]) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)) (setCar (cdr nwff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff multiaryRules[(gsm.myRandomFunction (length multiaryRules))]))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .80) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)) (setCar (cdr (cddddr wff)) (growWFF expression: 0))))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .60) (if (isAtom wff[4]) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)) (setCar (cddddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .40) (if (isAtom wff[3]) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)) (setCar (cdddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument two of this level.
	         ((>= argPoint .20) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Replace binary argument one of this level.
	         (else (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:) (setq wff (ruleName (integer (gsm.myRandomFunction myM)))))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
	     (else (error (append "gsm.expressionGrammarGen.mutateNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateNumericWFF    
	
	(defun selectPairWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Pair objects. 
	;;
	;; args:     wff       The WFF whose Pair objects are to be returned.           
	;;           index     (Optional)The vector of Pair objects to be returned.           
	;;           
	;; Return:   index     The vector of Pair objects to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector: Object:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return index))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectPairWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleCos:) (selectPairWFF wff[1] index))
		 ((= rule ruleCube:) (selectPairWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleExp:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpression:) (selectPairWFF wff[1] index))
		 ((= rule ruleIf:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index) (selectPairWFF wff[3] index) (selectPairWFF wff[4] index) (selectPairWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectPairWFF wff[1] index))
		 ((= rule ruleInt:) (selectPairWFF wff[1] index))
		 ((= rule ruleInv:) (selectPairWFF wff[1] index))
		 ((= rule ruleLog:) (selectPairWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleName:) (selectPairWFF wff[1] index))
		 ((= rule ruleNeg:) (selectPairWFF wff[1] index))
		 ((= rule ruleNop:) (selectPairWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectPairWFF wff[1] index))
		 ((= rule ruleSign:) (selectPairWFF wff[1] index))
		 ((= rule ruleSin:) (selectPairWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectPairWFF wff[1] index))
		 ((= rule ruleSquare:) (selectPairWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleTan:) (selectPairWFF wff[1] index))
		 ((= rule ruleTanh:) (selectPairWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGen.selectPairWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectPairWFF    

	(defun selectSlotWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Slot items. 
	;;
	;; args:     wff       The WFF whose slot items are to be returned.           
	;;           index     (Optional)The vector of slot items to be returned.           
	;;           
	;; Return:   index     The vector of slot items to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return (setq index[(length index)] wff)))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectSlotWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleCos:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCube:) (selectSlotWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleExp:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpression:) (selectSlotWFF wff[1] index))
		 ((= rule ruleIf:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index) (selectSlotWFF wff[3] index) (selectSlotWFF wff[4] index) (selectSlotWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInv:) (selectSlotWFF wff[1] index))
		 ((= rule ruleLog:) (selectSlotWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleName:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNeg:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNop:) (selectSlotWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSign:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSin:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSquare:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleTan:) (selectSlotWFF wff[1] index))
		 ((= rule ruleTanh:) (selectSlotWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGen.selectSlotWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectSlotsWFF    

	(defun spliceImmediateWFF(wff swff index)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by immediately splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered (must be a Pair).
	;;           swff      The WFF which is to be spliced.
	;;           index     The index for splicing this grammar rule.
	;;           
	;; Return:   result    True iff the wff has been altered; otherwise, false.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
        (if (isAtom wff) (error "gsm.expressionGrammarGen.spliceImmediateWFF: the WFF argument must be a Pair object"))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (return false))
		 ((isSymbol wff) (return false))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (length wff))
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         ((and (= index 3) (> N 3)) (setCar (cdddr wff) swff))
	         ((and (= index 4) (> N 4)) (setCar (cddddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (return false))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (return false))
	         ((= index 3) (setCar (cdddr wff) swff))
	         ((= index 4) (setCar (cddddr wff) swff))
	         ((= index 5) (setCar (cdr (cddddr wff)) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (return false))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (return false))
	     (else (error (append "gsm.expressionGrammarGen.spliceImmediateWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		true) ; end spliceImmediateWFF    
	
	(defun spliceNumericWFF(wff swff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered.
	;;           swff      The WFF which is to be spliced.
	;;           point     (Optional) The probability of splicing this grammar rule.
    ;;                     Note: If omitted, the probability of splicing this node is 100%.           
	;;           
	;; Return:   wff       The new spliced WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGen) (error "gsm.expressionGrammarGen: this expression grammar is out of focus"))
	    (if (= (argCount) 2) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 2)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (setq wff swff))
		 ((isSymbol wff) (setq wff swff))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level.
	         ((= stopHereSW false) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Replace unary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom wff[2]) (setCar (cddr wff) swff) (spliceNumericWFF wff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom nwff[1]) (setCar (cdr nwff) swff) (spliceNumericWFF nwff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom nwff[2]) (setCar (cddr nwff) swff) (spliceNumericWFF nwff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr nwff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr nwff) swff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .25)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[3]) (setCar (cdddr wff) swff) (spliceNumericWFF wff[3] swff point)))
	         ;; Case: Pass the splice request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .75)) (if (isAtom wff[4]) (setCar (cddddr wff) swff) (spliceNumericWFF wff[4] swff point)))
	         ;; Case: Pass the splice request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .75)) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) swff) (spliceNumericWFF wff[5] swff point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .75) (setCar (cdr (cddddr wff)) swff))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .50) (setCar (cddddr wff) swff))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .25) (setCar (cdddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (setq wff  swff))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
	     (else (error (append "gsm.expressionGrammarGen.spliceNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end spliceNumericWFF    
	
    ;; *******************************************************************************
    ;; Define Expression grammar production Rules 
    ;; *******************************************************************************

	(defun ruleAbs(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric absolute function such as "abs(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(" (evalRule wff1) ")"))
	    source) ; end ruleAbs    
	
	(defun ruleAdd(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric addition such as "x1 + xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " + " (evalRule wff2) ")"))
	    source) ; end ruleAdd    
	    
	(defun ruleAvg(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric average such as "avg(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "avg(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleAvg    
	    
	(defun ruleCos(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cosine function such as "cos(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "cos(" (evalRule wff1) ")"))
	    source) ; end ruleCos    
	    
	(defun ruleCube(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cube function such as "(x1*x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleCube    
	    
	(defun ruleDiv(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric protected division such as "(x1/xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " / " (evalRule wff2) ")"))
	    source) ; end ruleDiv    
	    
	(defun ruleExpression(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric exp function such as "exp(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (evalRule wff1))
	    source) ; end ruleExpression    
	    
	(defun ruleExp(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator exponential function such as "exp(x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff      The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "exp(" (evalRule wff) ")"))
	    source) ; end ruleExp    
	    
	   
	(defun ruleFrac(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric fraction function such as "fraction(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "fraction(" (evalRule wff1) ")"))
	    source) ; end ruleFrac    

	(defun ruleFrm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple factor regression statement 
    ;;           such as 
    ;;                     "frmregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple factor regression statement such as "frmregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleFrm.wffSource genome))
	    source) ; end ruleFrm    
	    
	(defun ruleIf(wff1 relop wff2 wff3 wff4)
	;; *******************************************************************
	;; summary:  Return a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           relop    The relational operator (< <= == <> >= >).
	;;           wff2     The second expression.
	;;           wff3     The then expression.
	;;           wff4     The else expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(if (" (evalRule wff1) " " (string relop) " " (evalRule wff2) ") {" (evalRule wff3)  "} else {" (evalRule wff4) "})"))
	    source) ; end ruleIf    
	    
	
	(defun ruleInt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "number(integer(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "ninteger(" (evalRule wff1) ")"))
	    source) ; end ruleInt    
	    
	(defun ruleInv(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator inverted numeric WFF, such as (1.0 / x4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The inverion of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (/ wff))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGen.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGen.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGen.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGen.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGen.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     (else (setq expression (append "(1.0 / " (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleInv    
	
	(defun ruleLog(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric log function such as "log(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "log(" (evalRule wff1) ")"))
	    source) ; end ruleLog    
	    
	(defun ruleMax(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric maximum such as "max(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "max(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMax    
	
	(defun ruleMdl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator model statement such as "model x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the model statement.
	;;           
	;; Return:   result      A Estimator model statement such as "model x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMdl.wffSource genome))
	    source) ; end ruleMdl    
	    
	(defun ruleMin(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric minimum such as "min(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "min(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMin    
	    
	(defun ruleMod(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric modulus such as "(x1%xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    ;; Return the modulus of the specified arguments.
	    (setq source (append "(" (evalRule wff1) " % " (evalRule wff2) ")"))
	    source) ; end ruleMod    
	    
	(defun ruleMul(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric multiplication such as "x1 * xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " * " (evalRule wff2) ")"))
	    source) ; end ruleMul    
	    
	(defun ruleMvl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple linear regression statement 
    ;;           such as 
    ;;                     "mvlregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple linear regression statement such as "mvlregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMvl.wffSource genome))
        source) ; end ruleMvl    
	    
	(defun ruleName(elementID)
	;; *******************************************************************
	;; summary:  Return an element name xtime, xid, x1 thru xm only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru M.
	;;           
	;; Return:   name        An element name xtime, xid, or x1 thru xm.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name WGE.
	    (setq name (append "x" elementID))
	    (symbol name)) ; end ruleName    
	    
	(defun ruleNeg(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator negative numeric WFF, such as -x1 or -(x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The negation of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (- wff))))
	     ((= rule ruleAdd:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleAvg:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleDiv:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGen.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleIf:) (setq expression (evalRule (list rule wff[1] wff[2] wff[3] (list ruleNeg: wff[4])  (list ruleNeg: wff[5])))))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGen.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleMul:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGen.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleNeg:) (setq expression (evalRule wff[1])))
	     ((= rule ruleSign:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])))))
	     ((= rule ruleSub:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGen.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGen.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     (else (setq expression (append "(-" (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleNeg    
	
	(defun ruleNop(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator no operation numeric WFF, such as x1 or (x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The specified wff.
	;;
	;; *******************************************************************
	    ;; Return the specified WFF.
	    (evalRule wff)) ; end ruleNop    
	
	(defun ruleNum(Number:constant)
	;; *******************************************************************
	;; summary:  Return a numeric constant as an ASCI string in 
	;;           grammatically correct estimator.
	;;
	;; args:     constant    A numeric constant.
	;;           
	;; Return:   number      A numeric constant.
	;;
	;; *******************************************************************
	    ;; Return a numeric constant.
	    constant) ; end ruleNum    
	    
	(defun ruleProd(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "product(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "product(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleProd    
	    
	(defun ruleReg(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator regress statement such as "regress x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "regress x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleReg.wffSource genome))
	    source) ; end ruleReg    
	    
	(defun ruleSigmoid(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "sigmoid(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(fraction(" (evalRule wff1) "))"))
	    source) ; end ruleSigmoid    
	    
	(defun ruleSign(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sign function such as "sign(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sign(" (evalRule wff1) ")"))
	    source) ; end ruleSign    
	
	
	(defun ruleSin(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sine function such as "sin(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sin(" (evalRule wff1) ")"))
	    source) ; end ruleSin    
	
	(defun ruleSqrt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sqrt function such as "sqrt(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sqrt(" (evalRule wff1) ")"))
	    source) ; end ruleSqrt    
	    
	(defun ruleSquare(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric square function such as "(x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleSquare    
	    
	(defun ruleSub(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric subtraction such as "x1 - xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " - " (evalRule wff2) ")"))
	    source) ; end ruleSub    
	    
	(defun ruleSum(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "sum(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "sum(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleSum    
	    
	(defun ruleSvm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator SVM statement such as "svmregress(x1,x2,x3);". 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the svmregress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "svmregress(x3,x5);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleSvm.wffSource genome))
	    source) ; end ruleSvm    

	    
	(defun ruleTan(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric tangent function such as "tan(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tan(" (evalRule wff1) ")"))
	    source) ; end ruleTan    
	    
	(defun ruleTanh(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric hyper tangent function such as "tanh(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tanh(" (evalRule wff1) ")"))
	    source) ; end ruleTanh    
	    
	;; *******************************************************************
    ;; Begin main logic
	;; *******************************************************************
    vars:(wffHdr sourceWff)
    (if (isString wff) then (setq wff (listWff wff)))
    (if (isPair wff) 
        (setq sourceWff (apply (setq wffHdr gsm.expressionGrammarGen[(car wff)]) (cdr wff))) 
        (setq sourceWff (string wff true))
        ) ; end if
    sourceWff) ; end expressionGrammarGen









































































































































































;;**EXPORTKEY**:gsm.expressionGrammarGep
(defriend gsm:expressionGrammarGep(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator genetic programming
;;           numeric expressions. 
;;
;; Main:     Return a Estimator genetic programming numeric expression, 
;;           in source format, such as 
;;
;;                    "((x2*(x3-35.7))/x1)"
;; 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the numeric expression.
;;           
;; Return:   result      A Estimator genetic programming numeric 
;;                       expression such as "((x2*(x3-35.7))/x1)".
;;
;; Notes:    GEP expressions support the following self-learning references
;;
;;           Constants:             -45.261  +319.23 .0345 .192765 
;;
;;           Variables:             x0 thru xM 
;;
;;           Relational Operators:  < <= == <> >= > 
;;
;;           binary Rules:          ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub 
;;
;;           unary Rules:           ruleAbs ruleCos ruleCube ruleExpression ruleInt ruleInv ruleLog ruleNeg ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh  
;;
;;           conditional Rules:     ruleIf  
;; *******************************************************************
  pvars:(;; Public Variables
         ;; Expression operators
		 checkNumericWFF   		    ;; Checks a numeric Estimator WFF for validity.
         concreteWFF                ;; Converts the specified abstract Lambda's WFF into a concrete WFF.  
		 convertToAbstractWFF  	    ;; Converts a concrete/abstract Estimator WFF to an abstract WFF {x4 ==> v0 and -2.345 ==> c0}.
		 cutoutNumericWFF   		;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
         extractNumericWFF		    ;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
         growWFF                    ;; Returns a randomly grown Estimator WFF. 
         growCTermWFF               ;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
         growRootWFF                ;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
         growTermWFF                ;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column.
	  	 lengthWFF   		        ;; Returns the left-depth-first length of any Estimator WFF.
         marryNumericWFFs		    ;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}.
		 mutateAbstractC0   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v0*c0))"}.
		 mutateAbstractC1   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v1*c1))"}.
		 mutateNumericWFF   	    ;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}.
		 selectPairWFF    	        ;; Returns the specified WFF as a vector of Pair objects. 
		 selectSlotWFF    	        ;; Returns the specified WFF as a vector of Slot items. 
		 spliceImmediateWFF    	    ;; Returns a numeric Estimator WFF by immediately splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
		 spliceNumericWFF    	    ;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
         ;; Expression grammar production Rules
         ruleAbs             		;; Produce a Estimator numeric absolute function such as "abs(x1)". 
         ruleAdd                   	;; Produce a Estimator numeric addition such as x1 + xm. 
         ruleAvg                   	;; Produce a Estimator numeric average such as avg(x1,x2,...,xm). 
         ruleCos                   	;; Produce a Estimator numeric cosine function such as "cos(x1)". 
         ruleCube                  	;; Produce a Estimator numeric cube function such as "(x1*x1*x1)". 
         ruleDiv                   	;; Produce a Estimator numeric protected division such as pdiv(x1,xm). (x3 == 0 ? x4 : x4 / x3) 
         ruleExpression             ;; Produce a Estimator genetic programming numeric expressions such as "((x1-x6)*cos(x2))". 
         ruleExp                   	;; Produce a Estimator exponential function such as "exp(x2)".
         ruleExpt                  	;; Produce a Estimator exponent function such as "expt(abs(x1),x2)".
         ruleFrac                   ;; Produce a Estimator numeric fraction function such as "fraction(x1)". 
         ruleFrm                   	;; Produce a Estimator multiple factor regression statement such as "frmregress (.23*x3,34.5*x4);". 
         ruleIf                    	;; Produce a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})".
         ruleInt                   	;; Produce a Estimator numeric integer function such as "number(integer(x1))". 
         ruleInv                   	;; Produce a Estimator inversion function such as "(1.0 /x1)". 
         ruleLog                   	;; Produce a Estimator numeric log function such as "log(abs(x1))". 
         ruleMax                   	;; Produce a Estimator numeric maximum such as max(x1,x2,...,xm). 
         ruleMdl                   	;; Produce a Estimator model statement such as "model x3*x4;". 
         ruleMin                   	;; Produce a Estimator numeric minimum such as min(x1,x2,...,xm). 
         ruleMod                   	;; Produce a Estimator numeric mod such as mod(x1,xm). 
         ruleMul                   	;; Produce a Estimator numeric multiplication such as x1 * xm. 
         ruleMvl                   	;; Produce a Estimator multiple linear regression statement such as "mvlregress (.23*x3,34.5*x4);". 
         ruleName                  	;; Produce a Estimator element name such as xtime, or x1 thru xm.
         ruleNeg                   	;; Produce a Estimator numeric negation such as -(x1 * xm). 
         ruleNop                   	;; Produce a Estimator no operation.
         ruleProd                  	;; Produce a Estimator numeric product such as (x1*x2*...*xm). 
         ruleReg                   	;; Produce a Estimator regress statement such as "regress x3*x4;". 
         ruleSigmoid                ;; Produce a Estimator numeric sigmoid function such as "sigmoid(x1)". 
         ruleSign                  	;; Produce a Estimator numeric sign function such as "sign(x1)". 
         ruleSin                   	;; Produce a Estimator numeric sine function such as "sin(x1)". 
         ruleSqrt                  	;; Produce a Estimator numeric square root function such as "sqrt(abs(x1))". 
         ruleSquare                	;; Produce a Estimator numeric square function such as "(x1*x1)". 
         ruleSub                   	;; Produce a Estimator numeric subtraction such as x1 - xm. 
         ruleSum                   	;; Produce a Estimator numeric sum such as sum(x1,x2,...,xm). 
         ruleSvm                   	;; Produce a Estimator support vector regression statement such as "svmregress (.23*x3,34.5*x4);". 
         ruleTan                   	;; Produce a Estimator numeric tangent function such as "tan(x1)". 
         ruleTanh                  	;; Produce a Estimator numeric hyper tangent function such as "tanh(x1)". 
         ) ; end public variables
    ;; *******************************************************************************
    ;; Define Public Child Lambdas 
    ;; *******************************************************************************

    ;; *******************************************************************************
    ;; Define Expression operators 
    ;; *******************************************************************************
   
    (defun checkNumericWFF(wff)
    ;; *******************************************************************
    ;; summary:  Checks a numeric Estimator WFF for validity.  
    ;;
    ;; args:     wff       The WFF which is to be verified.
    ;;           
    ;; Return:   wff       The new verified WFF.
    ;;
    ;; *******************************************************************
        vars:(rule)
        ;; Check to make sure the Estimator WFF is valid.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
        (setq rule wff[0])
        (cond
         ((isNumber wff) true)
         ((isSymbol wff) true)
         ((= rule ruleAbs:)
          (begin
            UnaryCheck::
            (if (<> (length wff) 2) (error (append "gsm.expressionGrammarGep.checkNumericWFF: invalid length for unary grammar rule [" rule "]")))
          )) ; end ruleAbs case
         ((= rule ruleAdd:)
          (begin
            BinaryCheck::
            (if (<> (length wff) 3) (error (append "gsm.expressionGrammarGep.checkNumericWFF: invalid length for binary grammar rule [" rule "]")))
          )) ; end ruleAdd case
         ((= rule ruleAvg:)
          (begin
            MultiaryCheck::
            (if (< (length wff) 2) (error (append "gsm.expressionGrammarGep.checkNumericWFF: invalid length for Multiary grammar rule [" rule "]")))
          )) ; end ruleAvg case
         ((= rule ruleCos:) (goto UnaryCheck:))
         ((= rule ruleCube:) (goto UnaryCheck:))
         ((= rule ruleDiv:) (goto BinaryCheck:))
         ((= rule ruleExp:) (goto UnaryCheck:))
         ((= rule ruleName:) (goto UnaryCheck:))
         ((= rule ruleNum:) (goto UnaryCheck:))
         ((= rule ruleExpression:) (goto UnaryCheck:))
         ((= rule ruleExpt:) (goto BinaryCheck:))
         ((= rule ruleTanh:) (goto UnaryCheck:))
         ((= rule ruleIf:)
          (begin
            IfCheck::
            (if (<> (length wff) 6) (error (append "gsm.expressionGrammarGep.checkNumericWFF: invalid length for if grammar rule [" rule "]")))
          )) ; end ruleIf case
         ((= rule ruleFrac:) (goto UnaryCheck:))
         ((= rule ruleInt:) (goto UnaryCheck:))
         ((= rule ruleInv:) (goto UnaryCheck:))
         ((= rule ruleLog:) (goto UnaryCheck:))
         ((= rule ruleMax:) (goto MultiaryCheck:))
         ((= rule ruleMin:) (goto MultiaryCheck:))
         ((= rule ruleMod:) (goto BinaryCheck:))
         ((= rule ruleMul:) (goto BinaryCheck:))
         ((= rule ruleNeg:) (goto UnaryCheck:))
         ((= rule ruleProd:) (goto MultiaryCheck:))
         ((= rule ruleSigmoid:) (goto UnaryCheck:))
         ((= rule ruleSign:) (goto UnaryCheck:))
         ((= rule ruleSin:) (goto UnaryCheck:))
         ((= rule ruleSqrt:) (goto UnaryCheck:))
         ((= rule ruleSquare:) (goto UnaryCheck:))
         ((= rule ruleSub:) (goto BinaryCheck:))
         ((= rule ruleSum:) (goto MultiaryCheck:))
         ((= rule ruleTan:) (goto UnaryCheck:))
         (else (error (append "gsm.expressionGrammarGep.checkNumericWFF: unknown WFF grammar rule [" rule "]")))
         ) ; end cond
        wff) ; end checkNumericWFF    
    
    (defun concreteWFF(Lambda ...)
    ;; *******************************************************************
    ;; summary:   Converts the specified abstract Lambda's WFF into a concrete WFF.  
    ;;
    ;; args:     Lambda    The specified abstract Lambda whose WFF into a concrete WFF.
    ;;           wff      (Optional)The specified WFF to be converted into a concrete WFF.
    ;;           
    ;; Return:   wff      The new concrete WFF.
    ;;
    ;; *******************************************************************
        regs:(n N)
        vars:(rule wff)

        ;; Convert wff to a list grammar format.
        (if (>= (argCount) 2) (setq wff (argFetch 1)) (setq wff (listWff Lambda.WFF)))

        wff) ; end concreteWFF    
		
	(defun convertToAbstractWFF(wff ...)  (error "gsm.expressionGrammarGep: abstract expression conversion is not valid"))

	(defun cutoutNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly cutting out a  
	;;           sub-expression from a candidate Estimator WFF 
	;;           For example {"(x3/sin(x4))" ==> "sin(x4)"}. 
	;;
	;; args:     wff       The WFF from which the cutout is to be taken.
	;;           point     (Optional)The probability of cutting at this grammar rule.           
	;;           
	;; Return:   wff       The cut out sub-expression from a candidate Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (return wff))
		 ((isSymbol wff) (return wff))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the unary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument two.
	         ((and (= stopHereSW false) (isPair wff[2])) (return (cutoutNumericWFF wff[2] point)))
	         ;; Case: Cutout the binary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryCutout::
            (setq N (- (length wff) 1))
	        (cond
	         ;; Case: Pass the cutout request to the next level through the nth argument.
	         ((and (= stopHereSW false) (> (setq n (+ 1 (integer (* argPoint N)))) 0) (isPair wff[n])) (return (cutoutNumericWFF wff[n] point)))
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the multiary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnaryCutout:))
		 ((= rule ruleCube:) (goto UnaryCutout:))
		 ((= rule ruleDiv:) (goto BinaryCutout:))
         ((= rule ruleExp:) (goto UnaryCutout:))
		 ((= rule ruleExpression:) (goto UnaryCutout:))
		 ((= rule ruleExpt:) (goto BinaryCutout:))
		 ((= rule ruleTanh:) (goto UnaryCutout:))
		 ((= rule ruleIf:)
	      (begin
	        IfCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1]) (< argPoint .25)) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument three.
	         ((and (= stopHereSW false) (isPair wff[3]) (< argPoint .50)) (return (cutoutNumericWFF wff[3] point)))
	         ;; Case: Pass the cutout request to the next level through argument four.
	         ((and (= stopHereSW false) (isPair wff[4]) (< argPoint .75)) (return (cutoutNumericWFF wff[4] point)))
	         ;; Case: Pass the cutout request to the next level through argument five.
	         ((and (= stopHereSW false) (isPair wff[5]) (>= argPoint .75)) (return (cutoutNumericWFF wff[5] point)))
	         ;; Case: Cutout the if expression on this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryCutout:))
		 ((= rule ruleInt:) (goto UnaryCutout:))
		 ((= rule ruleInv:) (goto UnaryCutout:))
		 ((= rule ruleLog:) (goto UnaryCutout:))
		 ((= rule ruleMax:) (goto MultiaryCutout:))
		 ((= rule ruleMin:) (goto MultiaryCutout:))
		 ((= rule ruleMod:) (goto BinaryCutout:))
		 ((= rule ruleMul:) (goto BinaryCutout:))
		 ((= rule ruleName:) (return (ruleName wff[1])))
		 ((= rule ruleNeg:) (goto UnaryCutout:))
		 ((= rule ruleNop:) (goto UnaryCutout:))
		 ((= rule ruleProd:) (goto MultiaryCutout:))
		 ((= rule ruleSigmoid:) (goto UnaryCutout:))
		 ((= rule ruleSign:) (goto UnaryCutout:))
		 ((= rule ruleSin:) (goto UnaryCutout:))
		 ((= rule ruleSqrt:) (goto UnaryCutout:))
		 ((= rule ruleSquare:) (goto UnaryCutout:))
		 ((= rule ruleSub:) (goto BinaryCutout:))
		 ((= rule ruleSum:) (goto MultiaryCutout:))
		 ((= rule ruleTan:) (goto UnaryCutout:))
	     (else (error (append "gsm.expressionGrammarGep.cutoutNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end cutoutNumericWFF    
	
	;; *******************************************************************
	;; summary:  Evaluate an GEP grammar production rule.
	;;
	;; args:     rule        Any GEP grammar rule to be evaluated.
	;;           
	;; Return:   expression  The result of evaluating the grammar rule as a String.
	;;
	;; *******************************************************************
    (defun evalRule(rule)
       vars:(ruleHdr)
       (onError (lambda(msg) "...error..."))
       (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
       (if (isString rule) (setq rule (listWff rule)))
       (if (isPair rule) (setq rule (apply (setq ruleHdr gsm.expressionGrammarGep[(car rule)]) (cdr rule))) (setq rule (string rule true)))
       rule) ; end evalRule

    (defun extractNumericWFF(inWff ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF from any Estimator WFF.
	;;           For instance: "regress (x3/x13);" ==> "(x3/x13)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     inWff       Any Estimator input WFF or Estimator Lambda.
	;;           sourceSW    (Optional) True iff the result expression is to be returned in source form.
	;;           
	;;           
	;; Return:   expression  The numeric WFF extracted from the specified Estimator WFF.
	;;
	;; *******************************************************************
		regs:(m M)
		vars:(sourceSW expression rule wff)
	    ;; If the wff argument is an Lambda, then convert it to a WFF.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (isLambda inWff) (setq wff inWff.WFF) (setq wff inWff))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    (setq sourceSW (if (>= (argCount) 2) (argFetch 1) false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (setq expression wff))
		 ((isSymbol wff) (setq expression wff))
		 ((= rule ruleAbs:) (setq expression wff))
		 ((= rule ruleAdd:) (setq expression wff))
		 ((= rule ruleAvg:) (setq expression wff))
		 ((= rule ruleCos:) (setq expression wff))
		 ((= rule ruleCube:) (setq expression wff))
		 ((= rule ruleDiv:) (setq expression wff))
		 ((= rule ruleExp:) (setq expression wff))
		 ((= rule ruleExpression:) (setq expression wff))
		 ((= rule ruleExpt:) (setq expression wff))
		 ((= rule ruleFrac:) (setq expression wff))
		 ((= rule ruleFrm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleIf:) (setq expression wff))
		 ((= rule ruleLog:) (setq expression wff))
		 ((= rule ruleInt:) (setq expression wff))
		 ((= rule ruleInv:) (setq expression wff))
		 ((= rule ruleMax:) (setq expression wff))
		 ((= rule ruleMdl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleMin:) (setq expression wff))
		 ((= rule ruleMod:) (setq expression wff))
		 ((= rule ruleMul:) (setq expression wff))
		 ((= rule ruleMvl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleName:) (setq expression (ruleName wff[1])))
		 ((= rule ruleNeg:) (setq expression wff))
		 ((= rule ruleNop:) (setq expression wff))
		 ((= rule ruleProd:) (setq expression wff))
		 ((= rule ruleReg:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleSigmoid:) (setq expression wff))
		 ((= rule ruleSign:) (setq expression wff))
		 ((= rule ruleSin:) (setq expression wff))
		 ((= rule ruleSqrt:) (setq expression wff))
		 ((= rule ruleSquare:) (setq expression wff))
		 ((= rule ruleSub:) (setq expression wff))
		 ((= rule ruleSum:) (setq expression wff))
		 ((= rule ruleSvm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleTan:) (setq expression wff))
		 ((= rule ruleTanh:) (setq expression wff))
	     (else (setq expression x1:))
	     ) ; end cond
	    ;; Return the numeric expression as a Estimator WFF or as a Estimator source string.
	    (if (= expression #void) (setq expression x1:))
	    (if (= sourceSW true) then (setq expression (evalRule expression))) 
		expression) ; end extractNumericWFF    
	
    (defun growWFF(Symbol:rule Integer:level)
	;; *******************************************************************
	;; summary:  Returns a randomly grown Estimator WFF. 
	;;
	;; args:     rule      The grammar rule indicating the type of WFF is to be returned.
	;;                     Note: The values for the rule argument as as follows:
	;;                           binary:		Generates a random binary operator expression.	            
	;;                           condition:     Generates a random "if" expression.	            
	;;                           expression:    Generates a random numeric expression.	            
	;;                           number:		Generates a random number constant.	            
	;;                           unary:		    Generates a random unary operator expression.	            
	;;                           variable:      Generates a random element name (xtime, xid, x1 thru xm).	            
	;;           level     The count of the current level in the expression.
	;;           
	;; Return:   result    The randomly grown Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:r (maxLevels 10))
		vars:(wff newRule relop)
		vars:(commands expressions percents)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((expressionRules #(obj| binary condition unary variable)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the type of Estimator WFF generated.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
		;; Apply the specified rule to generate the Estimator WFF.
	    (cond
	     ;; Case binary:		Generates a random binary operator expression.	            
		 ((= rule binary:) 
	      (begin
	        (setq N (length binaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule binaryRules[n])
            (if (= newRule ruleExpt:)
                (begin
	              (if (< level maxLevels)
	                  (setq wff (list newRule (growWFF variable: (+ level 1)) (growWFF number: (+ level 1))))
	                  (setq wff (list newRule (growWFF variable: (+ level 1)) (growWFF number: (+ level 1)))))
                ) ; then
            else
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1)) (growWFF term: (+ level 1))))
	            )) ; end if
	      )) ; end case binary
	
	     ;; Case condition:    Generates a random "if" expression.	            
		 ((= rule condition:) 
	      (begin
	        (setq newRule ruleIf:)
	        (setq N (length relationalOperators))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq relop relationalOperators[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF variable: (+ level 1)) relop (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1)) (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1)) relop (growWFF term: (+ level 1)) (growWFF term: (+ level 1)) (growWFF term: (+ level 1))))
	            ) ; end if
	      )) ; end case condition
	
	     ;; Case expression:    Generates a random numeric expression.	            
		 ((= rule expression:) 
	      (begin
	        GrowExpression::
	        (setq N (length expressionRules))
	        (setq n (integer (gsm.myRandomFunction N)))
            (setq r (gsm.myRandomFunction 1.0))
	        (cond 
	         ((>= level maxLevels) (goto GrowTerm:))
	         ((<= r .40) (setq wff (growWFF (setq newRule unary:) (+ level 1))))
	         ((<= r .70) (setq wff (growWFF (setq newRule binary:) (+ level 1))))
	         ((<= r .95) (setq wff (growWFF (setq newRule variable:) (+ level 1))))
	         (else (setq wff (growWFF (setq newRule condition:) (+ level 1))))
	         ) ; end cond
	      )) ; end case expression
	
	     ;; Case number:    Generates a random number constant.	            
		 ((= rule number:) 
	      (begin
	        GrowNumber::
	        (setq r (- (gsm.myRandomFunction 10.0) 5.0))
	        (setq wff r)
	      )) ; end case number
	
	     ;; Case term:    Generates a random number constant or variable name.	            
		 ((= rule term:) 
	      (begin
	        GrowTerm::
	        (if (< (gsm.myRandomFunction 1.0) myNumberPct) (goto GrowNumber:) (goto GrowVariable:))
	      )) ; end case number
	
	     ;; Case unary:		Generates a random unary operator expression.	            
		 ((= rule unary:) 
	      (begin
	        (setq N (length unaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule unaryRules[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1))))
	            (setq wff (list newRule (growWFF variable: (+ level 1))))
	            ) ; end if
	      )) ; end case unary
	
	     ;; Case variable:		Generates a random element name (xtime, xid, x1 thru xm).	            
		 ((= rule variable:) 
	      (begin
	        GrowVariable::
	        (setq n (integer (gsm.myRandomFunction myM))) 
	        (setq wff (ruleName n))
	      )) ; end case variable
	
	     ;; Case else
	     (else (error (append "gsm.expressionGrammarGep.growWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
	    ;; Return the randomly grown Estimator WFF.
		wff) ; end growWFF    
	
	(defun growCTermWFF(Integer:columnChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression conditional term
	;;           Estimator WFF based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;                      ...
	;;             if (xc+xtime) {xm-xm}, etc.
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion including conditionals.           
	;;
	;; args:     columnChoice   The choice of the regression column for this Estimator WFF expression.                        
	;;           
	;; Return:   wff          The sequentially grown conditional term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N NN NO)
		vars:(wff choice)
		vars:((operators #("<" "<=" "==" "<>" ">=" ">")))
	
	    ;; Return the count of basic Estimator term WFFs
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (setq NN (growTermWFF -1 columnChoice))
	    (setq NO (length operators))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	
	    (setq choice (gsm.myRandomFunction 1.0))
	    (if (>= choice 0.20)
	        ;; Generate a Estimator term WFF
	        (setq wff (growTermWFF (integer (gsm.myRandomFunction NN)) columnChoice))
	        ;; Generate a Estimator conditional term WFF
	        (setq wff (list ruleIf: (growTermWFF (integer (gsm.myRandomFunction NN))  columnChoice)
	                                (symbol operators[(integer (gsm.myRandomFunction NO))])  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))  
	                                (growTermWFF (integer (gsm.myRandomFunction NN))  (integer (gsm.myRandomFunction myM)))
	                                )) ; end list
	        ) ; end generate cterm only if
	
		wff) ; end growCTermWFF    
	
	(defun growRootWFF(Integer:rootChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown root Estimator WFF such as
	;;             xtime, thru xm, 
	;;             abs(xtime) thru abs(xm), 
	;;             cos(xtime) thru cos(xm),
	;;                      ...
	;;             tan(xtime) thru tan(xm),
	;;             (xtime+xtime) thru (xm+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The root Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice   The choice of the sequential root WFF expression to return.                        
	;;           Note: if rootChoice <= -2, then a random root WFF is to be generated and extended randomly.
	;;           Note: if rootChoice == -1, then the maximum number of root WFFs is to be returned.
	;;           Note: if rootChoice >=  0, then a random root WFF is to be generated and extended randomly.
	;;                 Otherwise, rootChoice must be the index of the chosen Estimator WFF root expression.
	;;           
	;; Return:   wff          The sequentially grown root Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(B m M n N NN)
		vars:(wff newRule Integer:choice)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator root WFF without extension.
	    ;; **********************************************************
	    
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate all of the single variable names
	          (if (< choice myM)
	              (begin
	                 (setq wff (ruleName choice))
	                 (return wff)
	              )) ; end variable names
	          (-= choice myM)
	          
	          ;; Generate all of the exponent functions with single variable names
	          (setq N 3)
	          (if (< choice N)
	              (begin
	                 (if (= choice 0) then (begin (setq wff (list ruleSqrt: (ruleName m))) (return wff)))
	                 (if (= choice 1) then (begin (setq wff (list ruleSquare: (ruleName m))) (return wff)))
	                 (if (= choice 2) then (begin (setq wff (list ruleCube: (ruleName m))) (return wff)))
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with single variable names
	          (setq N (muli (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule unaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName m)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the binary functions with single variable names
	          (setq B (length binaryRules))
	          (setq M (muli myM myM))
	          (setq N (muli B myM myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice M))
	                 (setq newRule binaryRules[n])
	                 (setq n (modi choice M))
	                 (setq m (/ n myM))
	                 (setq n (modi n myM))
	                 (setq wff (list newRule (ruleName m) (ruleName n)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Return void wff showing that there are no more root Estimator WFFs available.
	          (return #void)
	          
	        )) ; end generate root only if
	
    ;; **********************************************************
    ;; Return the maximum number of root WFFs.
    ;; **********************************************************
    (setq NN myM)
    (setq N 3)(+= NN N)
    (setq N (muli (length unaryRules) myM))(+= NN N)
    (setq N (muli (length binaryRules) myM myM))(+= NN N)
    (if (= choice -1) (return NN))

    ;; **************************************************************
    ;; Generate a sequential Estimator root WFF with random extension.
    ;; **************************************************************
    (setq choice (integer (gsm.myRandomFunction NN)))
    (setq wff (growRootWFF choice))
    (setq wff (mutateNumericWFF wff))

	wff) ; end growRootWFF    


	(defun growTermWFF(Integer:rootChoice Integer:columnChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression term Estimator WFF 
	;;           based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice     The choice of the sequential term WFF expression to return.                        
	;;                           Note: if rootChoice <  -1, then a random term WFF is to be generated.
	;;                           Note: if rootChoice == -1, then the maximum number of term WFFs is to be returned.
	;;                           Note: if rootChoice >=  0, then a sequential term WFF is to be generated, and the rootChoice must be the index of the chosen Estimator WFF.
	;;           columnChoice   The choice of the regression column for this Estimator WFF expression.                        
	;;                           Note: if columnChoice <  0, then a random column choice is to be generated.
	;;           
	;; Return:   wff          The sequentially grown term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(B m M mm MM n N nn NN)
		vars:(wff newRule Integer:choice)
		vars:((binaryRules #(obj| ruleAvg ruleAdd ruleDiv ruleExpt ruleMax ruleMod ruleMin ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; Generate a random column choice (if necessary).
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (< columnChoice 0) (setq columnChoice (integer (gsm.myRandomFunction myM))))
	    
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	    
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate the chosen column variable name
	          (if (= choice 0)
	              (begin
	                 (setq wff (ruleName columnChoice))
	                 (return wff)
	              )) ; end column variable names
	          (-= choice 1)
	
	          ;; Generate all of the term unary functions
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq newRule unaryRules[choice])
	                 (setq wff (list newRule (ruleName columnChoice)))
	                 (return wff)
	              )) ; end term unary functions names
	          (-= choice N)
	          
	          ;; Generate all of the left term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName columnChoice) (ruleName m)))
	                 (return wff)
	              )) ; end left term binary functions
	          (-= choice N)        
	          
	          ;; Generate all of the right term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (setq wff (list newRule (ruleName m) (ruleName columnChoice)))
	                 (return wff)
	              )) ; end right term binary functions
	          (-= choice N) 
	          
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (ruleName columnChoice) (list unaryRules[nn] (ruleName m))))
	                 (return wff)
	              )) ; end right binary unary functions
	          (-= choice N)        
	                            
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the left binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (list unaryRules[mm] (ruleName m))))
	                 (return wff)
	              )) ; end left binary unary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName m)) (list unaryRules[mm] (ruleName columnChoice))))
	                 (return wff)
	              )) ; end right binary unary unary functions
	          (-= choice N)        
	
	          ;; Return a random Estimator term WFF if there are no more term Estimator term WFFs available.
	          (return (growTermWFF -2 columnChoice))
	          
	        )) ; end generate term only if
	
	    ;; **********************************************************
	    ;; Return the maximum number of term WFFs.
	    ;; **********************************************************
	    (setq NN (+ 1 (length unaryRules) (* 2.0 (muli (length binaryRules) myM)) (* 3.0 (muli (length binaryRules) (length unaryRules) myM)) (* 2.0 (muli (length binaryRules) (length binaryRules) (length unaryRules) myM)) ))
	    (if (= choice -1) (return NN))
	
	    ;; **************************************************************
	    ;; Generate a random Estimator term WFF.
	    ;; **************************************************************
	    TryAgain::
	    (setq choice (integer (gsm.myRandomFunction NN)))
	    (setq wff (growTermWFF choice columnChoice))
	    (if (= wff #void) (begin (writeln "gsm.expressionGrammarGep.growTermWff: void WFF at [" choice "]") (goto TryAgain:)))
	
		wff) ; end growTermWFF    
	
	(defun lengthWFF(wff)
	;; *******************************************************************
	;; summary:  Returns the left-depth-first length of any Estimator WFF. 
	;;
	;; args:     wff       The WFF whose length is to be returned.           
	;;           
	;; Return:   result    The left-depth-first length of the specified WFF.
	;;
	;; *******************************************************************
	    regs:(n N (result 0))
		vars:(rule)
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; The length of a Vector of WFFs is always the
	    ;; sum of the lengths of each WFF in the vector.
	    (if (isVector wff) 
	        then
	        (begin
	          (setq N (length wff))
	          (loop for n from 0 until N do
	            (+= result (lengthWFF wff[n]))
	            ) ; end loop 
	          (return result)
	        )) ; end if
	    ;; The length of an atomic WFF is always 1.
	    (if (isAtom wff) then (return 1))
		;; Use the grammar rule to guide the computation 
	    ;; of the specified Estimator WFF length.
	    (setq rule wff[0])
	    (cond
		 ((= rule ruleAbs:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleAdd:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleAvg:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleCos:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleCube:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleDiv:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleExp:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpression:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpt:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleFrm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleIf:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]) (lengthWFF wff[4]) (lengthWFF wff[5]))))
		 ((= rule ruleInt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleFrac:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInv:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleLog:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMax:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMdl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMin:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMod:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMul:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMvl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleName:) (setq result 1))
		 ((= rule ruleNeg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleNop:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleProd:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleReg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSigmoid:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSign:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSin:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSqrt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSquare:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSub:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleSum:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTan:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTanh:) (+= result (lengthWFF wff[1])))
	     (else (error (append "gsm.expressionGrammarGep.lengthWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		result) ; end lengthWFF    
	
	(defun marryNumericWFFs(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF by marrying two suitor 
	;;           Estimator WFFs.
	;;           For instance: "x3" , "x4" ==> "(x3/x4)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     wff1      The male WFF suitor for this marriage.           
	;;           wff2      The female WFF suitor for this marriage.           
	;;           operator  (Optional) The binary operator for this marriage.           
	;;           
	;; Return:   expression  The numeric WFF resulting from the marriage.
	;;
	;; *******************************************************************
	    vars:(expression newRule len1 len2)
		vars:((binaryOperators #(obj| ruleAdd ruleAvg ruleDiv ruleExpt ruleMax ruleMin ruleMod ruleMul ruleSub)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (= wff1 #void) (return false))
	    (if (= wff2 #void) (return false))
	    (if (isString wff1) (setq wff1 (listWff wff1)))
	    (if (isString wff2) (setq wff2 (listWff wff2)))
	    ;; Make sure we can marry these two WFFs without exceeding the WFF length limit.
	    (setq len1 (lengthWFF wff1))
	    (setq len2 (lengthWFF wff2))
	    (if (>= (+ len1 len2) myMaxColWFFLen) (return false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (if (= (argCount) 3) 
	        (setq newRule (argFetch 2))
	        (setq newRule binaryOperators[(integer (gsm.myRandomFunction (length binaryOperators)))])
	        ) ; end if
	    (setq expression (list newRule wff1 wff2))
		expression) ; end marryNumericWFFs    
		
	(defun mutateAbstractC0(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateAbstractC1(wff ...)  (error "gsm.expressionGrammarGab: abstract expression mutation is not valid"))

	(defun mutateNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4)"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((binaryRules #(obj| ruleAdd ruleDiv ruleExpt ruleMod ruleMul ruleSub)))
		vars:((multiaryRules #(obj| ruleAvg ruleMax ruleMin ruleProd ruleSum)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg fuleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (if (< argPoint .80) (setq wff (* wff (- (gsm.myRandomFunction 10.0) 5.0))) (setq wff (growWFF expression: 0))))
		 ((isSymbol wff) (if (< argPoint .80) (setq wff (ruleName (integer (gsm.myRandomFunction myM)))) (setq wff (growWFF expression: 0))))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Replace the unary argument of this level.
	         ((>= argPoint .50) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff unaryRules[(gsm.myRandomFunction (length unaryRules))]))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateNumericWFF wff[2] point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .6666) (if (isAtom wff[2]) (setCar (cddr wff) (mutateNumericWFF wff[2] point)) (setCar (cddr wff) (growWFF expression: 0))))
	         ;; Case: Replace binary argument one of this level.
	         ((> argPoint .3333) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCar wff binaryRules[(gsm.myRandomFunction (length binaryRules))]))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)))
	         ;; Case: Replace multiary argument two of this level.
	         ((> argPoint .6666) (if (isAtom nwff[2]) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)) (setCar (cddr nwff) (growWFF expression: 0))))
	         ;; Case: Replace multiary argument one of this level.
	         ((> argPoint .3333) (if (isAtom nwff[1]) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)) (setCar (cdr nwff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff multiaryRules[(gsm.myRandomFunction (length multiaryRules))]))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleExpt:) (goto BinaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .80) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)) (setCar (cdr (cddddr wff)) (growWFF expression: 0))))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .60) (if (isAtom wff[4]) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)) (setCar (cddddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .40) (if (isAtom wff[3]) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)) (setCar (cdddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument two of this level.
	         ((>= argPoint .20) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Replace binary argument one of this level.
	         (else (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:) (setq wff (ruleName (integer (gsm.myRandomFunction myM)))))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
	     (else (error (append "gsm.expressionGrammarGep.mutateNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateNumericWFF    
	
	(defun selectPairWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Pair objects. 
	;;
	;; args:     wff       The WFF whose Pair objects are to be returned.           
	;;           index     (Optional)The vector of Pair objects to be returned.           
	;;           
	;; Return:   index     The vector of Pair objects to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector: Object:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return index))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectPairWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleCos:) (selectPairWFF wff[1] index))
		 ((= rule ruleCube:) (selectPairWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleExp:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpression:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index) (selectPairWFF wff[3] index) (selectPairWFF wff[4] index) (selectPairWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectPairWFF wff[1] index))
		 ((= rule ruleInt:) (selectPairWFF wff[1] index))
		 ((= rule ruleInv:) (selectPairWFF wff[1] index))
		 ((= rule ruleLog:) (selectPairWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleName:) (selectPairWFF wff[1] index))
		 ((= rule ruleNeg:) (selectPairWFF wff[1] index))
		 ((= rule ruleNop:) (selectPairWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectPairWFF wff[1] index))
		 ((= rule ruleSign:) (selectPairWFF wff[1] index))
		 ((= rule ruleSin:) (selectPairWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectPairWFF wff[1] index))
		 ((= rule ruleSquare:) (selectPairWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleTan:) (selectPairWFF wff[1] index))
		 ((= rule ruleTanh:) (selectPairWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGep.selectPairWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectPairWFF    

	(defun selectSlotWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Slot items. 
	;;
	;; args:     wff       The WFF whose slot items are to be returned.           
	;;           index     (Optional)The vector of slot items to be returned.           
	;;           
	;; Return:   index     The vector of slot items to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return (setq index[(length index)] wff)))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectSlotWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleCos:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCube:) (selectSlotWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleExp:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpression:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index) (selectSlotWFF wff[3] index) (selectSlotWFF wff[4] index) (selectSlotWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInv:) (selectSlotWFF wff[1] index))
		 ((= rule ruleLog:) (selectSlotWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleName:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNeg:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNop:) (selectSlotWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSign:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSin:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSquare:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleTan:) (selectSlotWFF wff[1] index))
		 ((= rule ruleTanh:) (selectSlotWFF wff[1] index))
	     (else (error (append "gsm.expressionGrammarGep.selectSlotWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectSlotsWFF    

	(defun spliceImmediateWFF(wff swff index)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by immediately splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered (must be a Pair).
	;;           swff      The WFF which is to be spliced.
	;;           index     The index for splicing this grammar rule.
	;;           
	;; Return:   result    True iff the wff has been altered; otherwise, false.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
        (if (isAtom wff) (error "gsm.expressionGrammarGep.spliceImmediateWFF: the WFF argument must be a Pair object"))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (return false))
		 ((isSymbol wff) (return false))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (length wff))
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         ((and (= index 3) (> N 3)) (setCar (cdddr wff) swff))
	         ((and (= index 4) (> N 4)) (setCar (cddddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (return false))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (return false))
	         ((= index 3) (setCar (cdddr wff) swff))
	         ((= index 4) (setCar (cddddr wff) swff))
	         ((= index 5) (setCar (cdr (cddddr wff)) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (return false))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (return false))
	     (else (error (append "gsm.expressionGrammarGep.spliceImmediateWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		true) ; end spliceImmediateWFF    
	
	(defun spliceNumericWFF(wff swff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered.
	;;           swff      The WFF which is to be spliced.
	;;           point     (Optional) The probability of splicing this grammar rule.
    ;;                     Note: If omitted, the probability of splicing this node is 100%.           
	;;           
	;; Return:   wff       The new spliced WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGep) (error "gsm.expressionGrammarGep: this expression grammar is out of focus"))
	    (if (= (argCount) 2) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 2)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (setq wff swff))
		 ((isSymbol wff) (setq wff swff))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level.
	         ((= stopHereSW false) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Replace unary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom wff[2]) (setCar (cddr wff) swff) (spliceNumericWFF wff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom nwff[1]) (setCar (cdr nwff) swff) (spliceNumericWFF nwff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom nwff[2]) (setCar (cddr nwff) swff) (spliceNumericWFF nwff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr nwff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr nwff) swff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .25)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[3]) (setCar (cdddr wff) swff) (spliceNumericWFF wff[3] swff point)))
	         ;; Case: Pass the splice request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .75)) (if (isAtom wff[4]) (setCar (cddddr wff) swff) (spliceNumericWFF wff[4] swff point)))
	         ;; Case: Pass the splice request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .75)) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) swff) (spliceNumericWFF wff[5] swff point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .75) (setCar (cdr (cddddr wff)) swff))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .50) (setCar (cddddr wff) swff))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .25) (setCar (cdddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (setq wff  swff))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
	     (else (error (append "gsm.expressionGrammarGep.spliceNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end spliceNumericWFF    
	
    ;; *******************************************************************************
    ;; Define Expression grammar production Rules 
    ;; *******************************************************************************

	(defun ruleAbs(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric absolute function such as "abs(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(" (evalRule wff1) ")"))
	    source) ; end ruleAbs    
	
	(defun ruleAdd(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric addition such as "x1 + xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " + " (evalRule wff2) ")"))
	    source) ; end ruleAdd    
	    
	(defun ruleAvg(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric average such as "avg(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "avg(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleAvg    
	    
	(defun ruleCos(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cosine function such as "cos(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "cos(" (evalRule wff1) ")"))
	    source) ; end ruleCos    
	    
	(defun ruleCube(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cube function such as "(x1*x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleCube    
	    
	(defun ruleDiv(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric protected division such as "(x1/xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " / " (evalRule wff2) ")"))
	    source) ; end ruleDiv    
	    
	(defun ruleExpression(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric exp function such as "exp(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (evalRule wff1))
	    source) ; end ruleExpression    
	    
	(defun ruleExp(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator exponential function such as "exp(x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff      The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "exp(" (evalRule wff) ")"))
	    source) ; end ruleExp    
	    
	(defun ruleExpt(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator exponent function such as "expt(abs(x1),x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "expt(abs(" (evalRule wff1) ") ," (evalRule wff2) ")"))
	    source) ; end ruleExpt    
	    
	(defun ruleFrac(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric fraction function such as "fraction(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "fraction(" (evalRule wff1) ")"))
	    source) ; end ruleFrac    
	    
	(defun ruleFrm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple factor regression statement 
    ;;           such as 
    ;;                     "frmregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple factor regression statement such as "frmregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleFrm.wffSource genome))
	    source) ; end ruleFrm    
	    
	(defun ruleIf(wff1 relop wff2 wff3 wff4)
	;; *******************************************************************
	;; summary:  Return a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           relop    The relational operator (< <= == <> >= >).
	;;           wff2     The second expression.
	;;           wff3     The then expression.
	;;           wff4     The else expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(if (" (evalRule wff1) " " (string relop) " " (evalRule wff2) ") {" (evalRule wff3)  "} else {" (evalRule wff4) "})"))
	    source) ; end ruleIf    
	    
	
	(defun ruleInt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "number(integer(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "ninteger(" (evalRule wff1) ")"))
	    source) ; end ruleInt    
	    
	(defun ruleInv(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator inverted numeric WFF, such as (1.0 / x4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The inverion of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (/ wff))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGep.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGep.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGep.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGep.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGep.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     (else (setq expression (append "(1.0 / " (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleInv    
	
	(defun ruleLog(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric log function such as "log(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "log(" (evalRule wff1) ")"))
	    source) ; end ruleLog    
	    
	(defun ruleMax(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric maximum such as "max(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "max(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMax    
	
	(defun ruleMin(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric minimum such as "min(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "min(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMin    
	    
	(defun ruleMod(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric modulus such as "(x1%xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    ;; Return the modulus of the specified arguments.
	    (setq source (append "(" (evalRule wff1) " % " (evalRule wff2) ")"))
	    source) ; end ruleMod    
	    
	(defun ruleMul(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric multiplication such as "x1 * xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " * " (evalRule wff2) ")"))
	    source) ; end ruleMul    
	    
	(defun ruleMvl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple linear regression statement 
    ;;           such as 
    ;;                     "mvlregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple linear regression statement such as "mvlregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMvl.wffSource genome))
        source) ; end ruleMvl    
	    
	(defun ruleName(elementID)
	;; *******************************************************************
	;; summary:  Return an element name xtime, xid, x1 thru xm only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru M.
	;;           
	;; Return:   name        An element name xtime, xid, or x1 thru xm.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name WGE.
	    (setq name (append "x" elementID))
	    (symbol name)) ; end ruleName    
	    
	(defun ruleMdl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator model statement such as "model x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the model statement.
	;;           
	;; Return:   result      A Estimator model statement such as "model x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMdl.wffSource genome))
	    source) ; end ruleMdl    
	    
	(defun ruleNeg(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator negative numeric WFF, such as -x1 or -(x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The negation of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (- wff))))
	     ((= rule ruleAdd:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleAvg:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleDiv:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGep.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleIf:) (setq expression (evalRule (list rule wff[1] wff[2] wff[3] (list ruleNeg: wff[4])  (list ruleNeg: wff[5])))))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGep.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleMul:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGep.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleNeg:) (setq expression (evalRule wff[1])))
	     ((= rule ruleSign:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])))))
	     ((= rule ruleSub:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGep.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGep.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     (else (setq expression (append "(-" (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleNeg    
	
	(defun ruleNop(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator no operation numeric WFF, such as x1 or (x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The specified wff.
	;;
	;; *******************************************************************
	    ;; Return the specified WFF.
	    (evalRule wff)) ; end ruleNop    
	
	(defun ruleNum(Number:constant)
	;; *******************************************************************
	;; summary:  Return a numeric constant as an ASCI string in 
	;;           grammatically correct estimator.
	;;
	;; args:     constant    A numeric constant.
	;;           
	;; Return:   number      A numeric constant.
	;;
	;; *******************************************************************
	    ;; Return a numeric constant.
	    constant) ; end ruleNum    
	    
	(defun ruleProd(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "product(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "product(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleProd    
	    
	(defun ruleReg(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator regress statement such as "regress x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "regress x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleReg.wffSource genome))
	    source) ; end ruleReg    
	    
	(defun ruleSigmoid(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sigmoid function such as "sigmoid(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(fraction(" (evalRule wff1) "))"))
	    source) ; end ruleSigmoid    
	    
	(defun ruleSign(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sign function such as "sign(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sign(" (evalRule wff1) ")"))
	    source) ; end ruleSign    
	
	
	(defun ruleSin(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sine function such as "sin(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sin(" (evalRule wff1) ")"))
	    source) ; end ruleSin    
	
	(defun ruleSqrt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sqrt function such as "sqrt(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sqrt(" (evalRule wff1) ")"))
	    source) ; end ruleSqrt    
	    
	(defun ruleSquare(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric square function such as "(x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleSquare    
	    
	(defun ruleSub(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric subtraction such as "x1 - xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " - " (evalRule wff2) ")"))
	    source) ; end ruleSub    
	    
	(defun ruleSum(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "sum(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "sum(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleSum    
	    
	(defun ruleSvm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator SVM statement such as "svmregress(x1,x2,x3);". 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the svmregress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "svmregress(x3,x5);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleSvm.wffSource genome))
	    source) ; end ruleSvm    

	    
	(defun ruleTan(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric tangent function such as "tan(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tan(" (evalRule wff1) ")"))
	    source) ; end ruleTan    
	    
	(defun ruleTanh(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric hyper tangent function such as "tanh(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tanh(" (evalRule wff1) ")"))
	    source) ; end ruleTanh    
	    
	;; *******************************************************************
    ;; Begin main logic
	;; *******************************************************************
    vars:(wffHdr sourceWff)
    (if (isString wff) then (setq wff (listWff wff)))
    (if (isPair wff) 
        (setq sourceWff (apply (setq wffHdr gsm.expressionGrammarGep[(car wff)]) (cdr wff))) 
        (setq sourceWff (string wff true))
        ) ; end if
    sourceWff) ; end expressionGrammarGep









































































































































































;;**EXPORTKEY**:gsm.expressionGrammarGso
(defriend gsm:expressionGrammarGso(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator grammar with mixed 
;;           Concrete/Abstract Estimator genetic programming numeric expressions. 
;;
;; Main:     Return an Estimator grammar swarm variable numeric expression, 
;;           in source format, such as 
;;
;;                    "((x2*(x2-c1))/v0)"
;; 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the numeric expression.
;;           
;; Return:   result      A Estimator grammar swarm variable numeric 
;;                       expression such as "((x2*(x2-c1))/v0)".
;;
;; Notes:    GSO expressions support the following self-learning references
;;
;;           Gso Constants:         c0 thru cI - Each of these references creates a 
;;                                   NumVector constant vector in which the PSO and 
;;                                   DE algorithms search the solution space for 
;;                                   optimal Number constant values.
;;
;;           Gso Variables:         v0 thru vK - Each of these references creates an 
;;                                   IntVector variable vector, which indirectly refers
;;                                   to the variables (x0 thru xM) in which learning 
;;                                   algorithms search the solution space for optimal 
;;                                   variable references.
;;
;;           Constants:             -45.261  +319.23 .0345 .192765 
;;
;;           Variables:             x0 thru xM 
;;
;;           Relational Operators:  < <= == <> >= > 
;;
;;           binary Operators:      ruleAdd ruleDiv ruleMul ruleSub 
;;
;;           unary Rules:           ruleAbs ruleCos ruleExp ruleInv ruleLog ruleNeg ruleSin ruleSqrt ruleSquare ruleTan  
;;
;;           conditional Operators: ruleIf  
;; *******************************************************************
  pvars:(;; Public Variables
		 myAbstractLambda   	        ;; Contains the current abstract Lambda whose WFF is being converted into a concrete WFF.
         ;; Expression operators
		 checkNumericWFF   		    ;; Checks a numeric Estimator WFF for validity.
		 concreteWFF     		    ;; Converts the specified abstract Lambda's WFF into a concrete WFF.
		 convertToAbstractWFF  	    ;; Converts a concrete/abstract Estimator WFF to an abstract WFF {x4 ==> v0 and -2.345 ==> c0}.
		 cutoutNumericWFF   		;; Returns a numeric Estimator WFF by randomly cutting out a sub-expression from a candidate Estimator WFF {"(x3/sin(x4))" ==> "sin(x4)"}.
         extractNumericWFF		    ;; Return a numeric Estimator WFF from any Estimator WFF {"regress (x3/x13);" ==> "(x3/x13)"}.
         growWFF                    ;; Returns a randomly grown Estimator WFF. 
         growCTermWFF               ;; Returns a sequentially grown regression conditional term Estimator WFF based upon a chosen column.
         growRootWFF                ;; Returns a sequentially grown root Estimator WFF xtime, thru xm, abs(xtime) thru abs(xm), cos(xtime) thru cos(xm), etc. 
         growTermWFF                ;; Returns a sequentially grown regression basic term Estimator WFF based upon a chosen column.
	  	 lengthWFF   		        ;; Returns the left-depth-first length of any Estimator WFF.
         marryNumericWFFs		    ;; Return a numeric Estimator WFF by marrying two suitor Estimator WFFs {"x3" , "x4" ==> "(x3/x4)"}.
		 mutateAbstractC0   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v0*c0))"}.
		 mutateAbstractC1   	    ;; Returns a abstract Estimator WFF by randomly mutating a candidate Estimator WFF using abstract expressions {"(x3/sin(x4))" ==> "(x3/sin(v1*c1))"}.
		 mutateNumericWFF   	    ;; Returns a numeric Estimator WFF by randomly mutating a candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4))"}.
		 selectPairWFF    	        ;; Returns the specified WFF as a vector of Pair objects. 
		 selectSlotWFF    	        ;; Returns the specified WFF as a vector of Slot items. 
		 spliceImmediateWFF    	    ;; Returns a numeric Estimator WFF by immediately splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
		 spliceNumericWFF    	    ;; Returns a numeric Estimator WFF by randomly splicing one WFF into a candidate Estimator WFF {"(x3/sin(x4))" , "log(x10)" ==> "(log(x10)/sin(x4))"}.
         ;; Expression grammar production Rules
         ruleAbs             		;; Produce a Estimator numeric absolute function such as "abs(x1)". 
         ruleAdd                   	;; Produce a Estimator numeric addition such as x1 + xm. 
         ruleAvg                   	;; Produce a Estimator numeric average such as avg(x1,x2,...,xm). 
         ruleCons                   ;; Produce a Estimator abstract numeric constant.
         ruleCos                   	;; Produce a Estimator numeric cosine function such as "cos(x1)". 
         ruleCube                  	;; Produce a Estimator numeric cube function such as "(x1*x1*x1)". 
         ruleDiv                   	;; Produce a Estimator numeric protected division such as pdiv(x1,xm). (x3 == 0 ? x4 : x4 / x3) 
         ruleExp                   	;; Produce a Estimator exponential function such as "exp(x2)".
         ruleExpression             ;; Produce a Estimator genetic programming numeric expressions such as "((x1-x6)*cos(x2))". 
         ruleExpt                  	;; Produce a Estimator exponent function such as "expt(abs(x1),x2)".
         ruleFrac                  	;; Produce a Estimator numeric fraction function such as "fraction(x1)". 
         ruleFrm                   	;; Produce a Estimator multiple factor regression statement such as "frmregress (.23*x3,34.5*x4);". 
         ruleIf                    	;; Produce a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})".
         ruleInt                   	;; Produce a Estimator numeric integer function such as "number(integer(x1))". 
         ruleInv                   	;; Produce a Estimator inversion function such as "(1.0 /x1)". 
         ruleLog                   	;; Produce a Estimator numeric log function such as "log(abs(x1))". 
         ruleMax                   	;; Produce a Estimator numeric maximum such as max(x1,x2,...,xm). 
         ruleMdl                   	;; Produce a Estimator model statement such as "model x3*x4;". 
         ruleMin                   	;; Produce a Estimator numeric minimum such as min(x1,x2,...,xm). 
         ruleMod                   	;; Produce a Estimator numeric mod such as mod(x1,xm). 
         ruleMul                   	;; Produce a Estimator numeric multiplication such as x1 * xm. 
         ruleMvl                   	;; Produce a Estimator multiple linear regression statement such as "mvlregress (.23*x3,34.5*x4);". 
         ruleName                  	;; Produce a Estimator element name such as xtime, or x1 thru xM.
         ruleNeg                   	;; Produce a Estimator numeric negation such as -(x1 * xm). 
         ruleNoise                  ;; Produce a Estimator abstract random noise reference such as e0, or e1.
         ruleNop                   	;; Produce a Estimator no operation.
         ruleProd                  	;; Produce a Estimator numeric product such as sum(x1*x2*...*xm). 
         ruleReg                   	;; Produce a Estimator regress statement such as "regress x3*x4;". 
         ruleSigmoid               	;; Produce a Estimator numeric sigmoid function such as "sigmoid(x1)". 
         ruleSign                  	;; Produce a Estimator numeric sign function such as "sign(x1)". 
         ruleSin                   	;; Produce a Estimator numeric sine function such as "sin(x1)". 
         ruleSqrt                  	;; Produce a Estimator numeric square root function such as "sqrt(abs(x1))". 
         ruleSquare                	;; Produce a Estimator numeric square function such as "(x1*x1)". 
         ruleSub                   	;; Produce a Estimator numeric subtraction such as x1 - xm. 
         ruleSum                   	;; Produce a Estimator numeric sum such as sum(x1,x2,...,xm). 
         ruleSvm                   	;; Produce a Estimator support vector regression statement such as "svmregress (.23*x3,34.5*x4);". 
         ruleTan                   	;; Produce a Estimator numeric tangent function such as "tan(x1)". 
         ruleTanh                  	;; Produce a Estimator numeric hyper tangent function such as "tanh(x1)". 
         ruleVar                    ;; Produce a Estimator abstract variable reference such as v0, or v1 thru vK.
         ruleVop                    ;; Produce a Estimator abstract operator reference such as f0(x1), or f1(c0,x2) thru fK(v1,v2).
         ;; Abstract operators for this expression grammar.
         ;; WARNING: These operators in their number and order must match %COMPILER_USERFUNCTIONS:templateRegressReg and %COMPILER_USERFUNCTIONS:templateRegressMdl exactly!
         (myAbstractOperators #(obj| ruleAdd ruleSub ruleMul ruleDiv ruleCos ruleSin ruleTan ruleTanh ruleLog ruleSqrt ruleSquare ruleCube ruleNop))
         (myAbstractOperNames #(obj| _fadd   _fsub   _fmul   _fdiv   _fcos   _fsin   _ftan   _ftanh   _flog   _fsqrt   _fsquare   _fcube   _fnop))
         ) ; end public variables

    ;; *******************************************************************************
    ;; Define Public Child Lambdas 
    ;; *******************************************************************************

    ;; *******************************************************************************
    ;; Define Expression operators 
    ;; *******************************************************************************
   
    (defun checkNumericWFF(wff)
    ;; *******************************************************************
    ;; summary:  Checks a numeric Estimator WFF for validity.  
    ;;
    ;; args:     wff       The WFF which is to be verified.
    ;;           
    ;; Return:   wff       The new verified WFF.
    ;;
    ;; *******************************************************************
        vars:(rule)
        ;; Check to make sure the Estimator WFF is valid.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (setq rule wff[0])
        (cond
         ((isNumber wff) true)
         ((isSymbol wff) true)
         ((= rule ruleAbs:)
          (begin
            UnaryCheck::
            (if (<> (length wff) 2) (error (append "gsm.expressionGrammarGso.checkNumericWFF: invalid length for unary grammar rule [" rule "]")))
          )) ; end ruleAbs case
         ((= rule ruleAdd:)
          (begin
            BinaryCheck::
            (if (<> (length wff) 3) (error (append "gsm.expressionGrammarGso.checkNumericWFF: invalid length for binary grammar rule [" rule "]")))
          )) ; end ruleAdd case
         ((= rule ruleAvg:)
          (begin
            MultiaryCheck::
            (if (< (length wff) 2) (error (append "gsm.expressionGrammarGso.checkNumericWFF: invalid length for Multiary grammar rule [" rule "]")))
          )) ; end ruleAvg case
         ((= rule ruleCons:) (goto UnaryCheck:))
         ((= rule ruleCos:) (goto UnaryCheck:))
         ((= rule ruleCube:) (goto UnaryCheck:))
         ((= rule ruleDiv:) (goto BinaryCheck:))
         ((= rule ruleExp:) (goto UnaryCheck:))
         ((= rule ruleName:) (goto UnaryCheck:))
         ((= rule eGrammar:) (goto UnaryCheck:))
         ((= rule ruleExpt:) (goto BinaryCheck:))
         ((= rule ruleTanh:) (goto UnaryCheck:))
         ((= rule ruleIf:)
          (begin
            IfCheck::
            (if (<> (length wff) 6) (error (append "gsm.expressionGrammarGso.checkNumericWFF: invalid length for if grammar rule [" rule "]")))
          )) ; end ruleIf case
         ((= rule ruleFrac:) (goto UnaryCheck:))
         ((= rule ruleInt:) (goto UnaryCheck:))
         ((= rule ruleInv:) (goto UnaryCheck:))
         ((= rule ruleLog:) (goto UnaryCheck:))
         ((= rule ruleMax:) (goto MultiaryCheck:))
         ((= rule ruleMin:) (goto MultiaryCheck:))
         ((= rule ruleMod:) (goto BinaryCheck:))
         ((= rule ruleMul:) (goto BinaryCheck:))
         ((= rule ruleNeg:) (goto UnaryCheck:))
         ((= rule ruleNoise:) (goto UnaryCheck:))
         ((= rule ruleNop:) (goto UnaryCheck:))
         ((= rule ruleProd:) (goto MultiaryCheck:))
         ((= rule ruleSigmoid:) (goto UnaryCheck:))
         ((= rule ruleSign:) (goto UnaryCheck:))
         ((= rule ruleSin:) (goto UnaryCheck:))
         ((= rule ruleSqrt:) (goto UnaryCheck:))
         ((= rule ruleSquare:) (goto UnaryCheck:))
         ((= rule ruleSub:) (goto BinaryCheck:))
         ((= rule ruleSum:) (goto MultiaryCheck:))
         ((= rule ruleTan:) (goto UnaryCheck:))
         ((= rule ruleVar:) (goto UnaryCheck:))
         ((= rule ruleVop:)
          (begin
            NaryCheck::
            ;; (ruleVop findex arg1 arg2)
            (if (<> (length wff) 4) (error (append "gsm.expressionGrammarGso.checkNumericWFF: invalid length for abstract operator grammar rule [" rule "]")))
          )) ; end ruleVop case
         (else (error (append "gsm.expressionGrammarGso.checkNumericWFF: unknown WFF grammar rule [" rule "]")))
         ) ; end cond
        wff) ; end checkNumericWFF    
    
    (defun concreteWFF(Lambda ...)
    ;; *******************************************************************
    ;; summary:   Converts the specified abstract Lambda's WFF into a concrete WFF.  
    ;;
    ;; args:     Lambda    The specified abstract Lambda whose WFF into a concrete WFF.
    ;;           wff      (Optional)The specified WFF to be converted into a concrete WFF.
    ;;           
    ;; Return:   wff      The new concrete WFF.
    ;;
    ;; *******************************************************************
        regs:(m M n N cn)
        vars:(rule wff temp genome newWff wffTerm)

        ;; Convert wff to a list grammar format.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (>= (argCount) 2) (setq wff (argFetch 1)) (setq wff (listWff Lambda.WFF)))

        ;; Check for abstract grammar rules which may need to be converted.
        (cond
         ((and (isSymbol wff) (= wff[0] #\v)) (setq wff (symbol (append "x" (integer Lambda.VV[(integer (mid wff 1 100000))])))))
         ((and (isSymbol wff) (= wff[0] #\c)) (setq wff (number Lambda.CC[(integer (mid wff 1 100000))])))
         ((isVector wff)
          (begin
             (setq N (length wff)) 
             (loop for n from 0 until N do 
               (if (isPair wff[n]) (concreteWFF Lambda wff[n]))
               (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq wff[n] (symbol (append "x" (integer Lambda.VV[(integer (mid wff[n] 1 100000))])))))
               (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq wff[n] (number Lambda.CC[(integer (mid wff[n] 1 100000))])))
          ))) ; end case: Vector
         ((isPair wff)
          (begin
             (setq rule wff[0])
             (cond
              ((and (= rule ruleMvl:) (isVector wff[1]) (not (isConcrete (setq genome wff[1]))))
               (begin              
                 ;; Determine the number of existing abstract real number constants in this mvlregress genome.             
                 (setq temp (compileEstimator (evalRule (list ruleReg: genome))))
                 (if (not (isLambda temp)) (setq cn -1) (setq cn (- temp.CCN 1)))
                 (setq newWff "")
                 (setq N (length genome)) 
                 ;; Create the final source from the genome.
                 (setq M (length genome))
                 (loop for m from 0 until M do
                   (if (<> genome[m] #void)
                       (begin
                         (setq wffTerm (append "(ruleMul " Lambda.CC[(++ cn)] " " (string (concreteWFF Lambda genome[m]) true) ")"))
                         (if (= newWff "") 
                             (setq newWff wffTerm)
                             (setq newWff (append newWff " " wffTerm))
                             ) ; end if
                       )) ; end if
                   ) ; end column loop  
	            ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	            (setq newWff (append "(ruleReg #(" newWff "))"))
                (setq wff (listWff newWff))
               )) ; end abstract ruleMvl case
              ((isVector wff[1]) (concreteWFF Lambda wff[1]))
              ((or (= rule ruleNoise:) (= rule ruleNoise)) (begin (setq wff[0] ruleNum:) (setq wff[1] 0.0)))
              ((or (= rule ruleVar:) (= rule ruleVar)) (begin (setq wff[0] ruleName:) (setq wff[1] Lambda.VV[wff[1]])))
              ((or (= rule ruleVop:) (= rule ruleVop)) 
               (begin  ;; (ruleVop findex arg1 arg2)
                  (setq cn Lambda.FF[wff[1]])
                  (setq rule myAbstractOperators[cn])
                  ;; Support all abstract operators for this expression grammar.
                  ;; WARNING: These operators in their number and order must match expressionGrammarGso.myAbstractOperators vector exactly!
                  ;;(myAbstractOperators #(obj| ruleAdd ruleSub ruleMul ruleDiv ruleCos ruleSin ruleTan ruleTanh ruleAvg ruleMax ruleMin ruleMod ruleNop 
                  ;;                            ruleExpt ruleAbs ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleSigmoid ruleSign ruleSqrt ruleSquare))
                  (cond 
                   ((= rule ruleAdd:) 
                    (begin
                      BinaryOperator::
                      (setq wff[0] rule)
                      (setq wff[1] (concreteWFF Lambda wff[2]))
                      (setq wff[2] (concreteWFF Lambda wff[3]))
                      (setCdr (cddr wff) #void) ;; Drop last argument 
                    )) ; end ruleAdd case 
                   ((= rule ruleAvg:) (goto BinaryOperator:))
                   ((= rule ruleDiv:) (goto BinaryOperator:))
                   ((= rule ruleExpt:) (goto BinaryOperator:))
                   ((= rule ruleMax:) (goto BinaryOperator:))
                   ((= rule ruleMin:) (goto BinaryOperator:))
                   ((= rule ruleMod:) (goto BinaryOperator:))
                   ((= rule ruleMul:) (goto BinaryOperator:))
                   ((= rule ruleSub:) (goto BinaryOperator:))
                   ((= rule ruleAbs:) 
                    (begin
                      UnaryOperator::
                      (setq wff[0] rule)
                      (setq wff[1] (concreteWFF Lambda wff[2]))
                      (setCdr (cdr wff) #void) ;; Drop last two arguments 
                    )) ; end ruleAbs case 
                   ((= rule ruleCos:) (goto UnaryOperator:))
                   ((= rule ruleCube:) (goto UnaryOperator:))
                   ((= rule ruleExp:) (goto UnaryOperator:))
                   ((= rule ruleFrac:) (goto UnaryOperator:))
                   ((= rule ruleInt:) (goto UnaryOperator:))
                   ((= rule ruleInv:) (goto UnaryOperator:))
                   ((= rule ruleLog:) (goto UnaryOperator:))
                   ((= rule ruleNop:) (setq wff (concreteWFF Lambda wff[2])))
                   ((= rule ruleSigmoid:) (goto UnaryOperator:))
                   ((= rule ruleSign:) (goto UnaryOperator:))
                   ((= rule ruleSin:) (goto UnaryOperator:))
                   ((= rule ruleSqrt:) (goto UnaryOperator:))
                   ((= rule ruleSquare:) (goto UnaryOperator:))
                   ((= rule ruleTan:) (goto UnaryOperator:))
                   ((= rule ruleTanh:) (goto UnaryOperator:))
                   (else (error (append "gsm.expressionGrammarGso.concreteWFF: unknown WFF abstract operator [" rule "]")))
                   ) ; end cond
               )) ; end ruleVop case
              ((or (= rule ruleCons:) (= rule ruleCons)) 
               (begin 
                 (setq wff[0] ruleNum:) 
                 (setq wff[1] Lambda.CC[wff[1]])
               )) ; end ruleCons case
              (else 
                (begin 
                  (setq N (length wff)) 
                  (loop for n from 0 until N do 
                    (if (isPair wff[n]) (concreteWFF Lambda wff[n]))
                    (if (and (isSymbol wff[n]) (= wff[n][0] #\v) (isCharNumeric wff[n][1])) (setq wff[n] (symbol (append "x" (integer Lambda.VV[(integer (mid wff[n] 1 100000))])))))
                    (if (and (isSymbol wff[n]) (= wff[n][0] #\c) (isCharNumeric wff[n][1])) (setq wff[n] (number Lambda.CC[(integer (mid wff[n] 1 100000))])))
                ))) ; end else
              ))) ; end case: Pair
         ) ; end cond

        wff) ; end concreteWFF    
    
    (defun convertToAbstractWFF(wff ...)
    ;; *******************************************************************
    ;; summary:  Converts a concrete/abstract Estimator WFF to an abstract WFF, 
    ;;           for example: {x4 ==> v0 and -2.345 ==> c0}.  
    ;;
    ;; args:     wff      The specified WFF to be converted into an abstract WFF.
    ;;           state    (Optional)The state of the conversion counters #{CC: 0 VV: 0}.
    ;;           
    ;; Return:   wff      The new abstract WFF.
    ;;
    ;; *******************************************************************
        regs:(m M n N cn)
        vars:(state rule wff temp genome newWff wffTerm)

        ;; Convert wff to a list grammar format.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (not (isPair wff)) (setq wff (listWff wff)))
        (if (> (argCount) 1) then (setq state (argFetch 1)) else (setq state (new Structure: CC: 0 VV: 0)))

        ;; Check for concrete grammar rules which may need to be converted.
        (cond
         ((and (isSymbol wff) (= wff[0] #\x) (isCharNumeric wff[1])) (begin (setq wff (symbol (append "v" state.VV))) (++ state.VV)))
         ((isNumber wff) (begin (setq wff (symbol (append "c" state.CC))) (++ state.CC)))
         ((isVector wff)
          (begin
             (setq N (length wff)) 
             (loop for n from 0 until N do 
               (if (isPair wff[n]) (setq wff[n] (convertToAbstractWFF wff[n] state)))
               (if (and (isSymbol wff[n]) (= wff[n][0] #\x) (isCharNumeric wff[n][1])) (begin (setq wff[n] (symbol (append "v" state.VV))) (++ state.VV)))
               (if (isNumber wff[n]) (begin (setq wff[n] (symbol (append "c" state.CC))) (++ state.CC)))
          ))) ; end case: Vector
         ((isPair wff)
          (begin
             (setq rule wff[0])
             (cond
              ((and (= rule ruleFrm:) (isVector wff[1])) (setq wff[1] (convertToAbstractWFF wff[1] state)))
              ((and (= rule ruleMdl:) (isVector wff[1])) (setq wff[1] (convertToAbstractWFF wff[1] state)))
              ((and (= rule ruleMvl:) (isVector wff[1])) (setq wff[1] (convertToAbstractWFF wff[1] state)))
              ((and (= rule ruleReg:) (isVector wff[1])) (setq wff[1] (convertToAbstractWFF wff[1] state)))
              ((and (= rule ruleSvm:) (isVector wff[1])) (setq wff[1] (convertToAbstractWFF wff[1] state)))
              ((= rule ruleVop:) (begin (setq wff[2] (convertToAbstractWFF wff[2] state)) (setq wff[3] (convertToAbstractWFF wff[3] state)))) 
              ((= rule ruleAdd:) 
               (begin
                 BinaryOperator::
                 (setq wff[0] rule)
                 (setq wff[1] (convertToAbstractWFF wff[1] state))
                 (setq wff[2] (convertToAbstractWFF wff[2] state))
               )) ; end ruleAdd case 
              ((= rule ruleAvg:) (goto BinaryOperator:))
              ((= rule ruleDiv:) (goto BinaryOperator:))
              ((= rule ruleExpt:) (goto BinaryOperator:))
              ((= rule ruleMax:) (goto BinaryOperator:))
              ((= rule ruleMin:) (goto BinaryOperator:))
              ((= rule ruleMod:) (goto BinaryOperator:))
              ((= rule ruleMul:) (goto BinaryOperator:))
              ((= rule ruleProd:) (goto BinaryOperator:))
              ((= rule ruleSub:) (goto BinaryOperator:))
              ((= rule ruleSum:) (goto BinaryOperator:))
              ((= rule ruleAbs:) 
               (begin
                 UnaryOperator::
                 (setq wff[0] rule)
                 (setq wff[1] (convertToAbstractWFF wff[1] state))
               )) ; end ruleAbs case 
              ((= rule ruleCos:) (goto UnaryOperator:))
              ((= rule ruleCube:) (goto UnaryOperator:))
              ((= rule ruleExp:) (goto UnaryOperator:))
              ((= rule ruleExpression:) (goto UnaryOperator:))
              ((= rule ruleFrac:) (goto UnaryOperator:))
              ((= rule ruleInt:) (goto UnaryOperator:))
              ((= rule ruleInv:) (goto UnaryOperator:))
              ((= rule ruleLog:) (goto UnaryOperator:))
              ((= rule ruleNeg:) (goto UnaryOperator:))
              ((= rule ruleSigmoid:) (goto UnaryOperator:))
              ((= rule ruleSign:) (goto UnaryOperator:))
              ((= rule ruleSin:) (goto UnaryOperator:))
              ((= rule ruleSqrt:) (goto UnaryOperator:))
              ((= rule ruleSquare:) (goto UnaryOperator:))
              ((= rule ruleTan:) (goto UnaryOperator:))
              ((= rule ruleTanh:) (goto UnaryOperator:))
              ((= rule ruleNum:)
               (begin 
                 (setq wff[0] ruleCons:) 
                 (setq wff[1] state.CC) 
                 (++ state.CC)
               )) ; end ruleNum case
              ((= rule ruleName:)
               (begin 
                 (setq wff[0] ruleVar:) 
                 (setq wff[1] state.VV)
                 (++ state.VV)
               )) ; end ruleName case
              ((= rule ruleIf:) 
               (begin
                 ConditionalOperator::
                 (setq wff[0] rule)
                 (setq wff[1] (convertToAbstractWFF wff[1] state))
                 (setq wff[3] (convertToAbstractWFF wff[3] state))
                 (setq wff[4] (convertToAbstractWFF wff[4] state))
                 (setq wff[5] (convertToAbstractWFF wff[5] state))
               )) ; end ruleIf case 
              ))) ; end case: Pair
         ) ; end cond

        wff) ; end convertToAbstractWFF    


	(defun cutoutNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly cutting out a  
	;;           sub-expression from a candidate Estimator WFF 
	;;           For example {"(x3/sin(x4))" ==> "sin(x4)"}. 
	;;
	;; args:     wff       The WFF from which the cutout is to be taken.
	;;           point     (Optional)The probability of cutting at this grammar rule.           
	;;           
	;; Return:   wff       The cut out sub-expression from a candidate Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (return wff))
		 ((isSymbol wff) (return wff))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the unary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument two.
	         ((and (= stopHereSW false) (isPair wff[2])) (return (cutoutNumericWFF wff[2] point)))
	         ;; Case: Cutout the binary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryCutout::
            (setq N (- (length wff) 1))
	        (cond
	         ;; Case: Pass the cutout request to the next level through the nth argument.
	         ((and (= stopHereSW false) (> (setq n (+ 1 (integer (* argPoint N)))) 0) (isPair wff[n])) (return (cutoutNumericWFF wff[n] point)))
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1])) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Cutout the multiary grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (goto UnaryCutout:))
		 ((= rule ruleCos:) (goto UnaryCutout:))
		 ((= rule ruleCube:) (goto UnaryCutout:))
		 ((= rule ruleDiv:) (goto BinaryCutout:))
		 ((= rule ruleExp:) (goto UnaryCutout:))
		 ((= rule ruleExpression:) (goto UnaryCutout:))
		 ((= rule ruleExpt:) (goto BinaryCutout:))
		 ((= rule ruleTanh:) (goto UnaryCutout:))
		 ((= rule ruleIf:)
	      (begin
	        IfCutout::
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (isPair wff[1]) (< argPoint .25)) (return (cutoutNumericWFF wff[1] point)))
	         ;; Case: Pass the cutout request to the next level through argument three.
	         ((and (= stopHereSW false) (isPair wff[3]) (< argPoint .50)) (return (cutoutNumericWFF wff[3] point)))
	         ;; Case: Pass the cutout request to the next level through argument four.
	         ((and (= stopHereSW false) (isPair wff[4]) (< argPoint .75)) (return (cutoutNumericWFF wff[4] point)))
	         ;; Case: Pass the cutout request to the next level through argument five.
	         ((and (= stopHereSW false) (isPair wff[5]) (>= argPoint .75)) (return (cutoutNumericWFF wff[5] point)))
	         ;; Case: Cutout the if expression on this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryCutout:))
		 ((= rule ruleInt:) (goto UnaryCutout:))
		 ((= rule ruleInv:) (goto UnaryCutout:))
		 ((= rule ruleLog:) (goto UnaryCutout:))
		 ((= rule ruleMax:) (goto MultiaryCutout:))
		 ((= rule ruleMin:) (goto MultiaryCutout:))
		 ((= rule ruleMod:) (goto BinaryCutout:))
		 ((= rule ruleMul:) (goto BinaryCutout:))
		 ((= rule ruleName:) (return (ruleName wff[1])))
		 ((= rule ruleNeg:) (goto UnaryCutout:))
		 ((= rule ruleNoise:) (return (ruleNoise wff[1])))
		 ((= rule ruleNop:) (goto UnaryCutout:))
		 ((= rule ruleProd:) (goto MultiaryCutout:))
		 ((= rule ruleSigmoid:) (goto UnaryCutout:))
		 ((= rule ruleSign:) (goto UnaryCutout:))
		 ((= rule ruleSin:) (goto UnaryCutout:))
		 ((= rule ruleSqrt:) (goto UnaryCutout:))
		 ((= rule ruleSquare:) (goto UnaryCutout:))
		 ((= rule ruleSub:) (goto BinaryCutout:))
		 ((= rule ruleSum:) (goto MultiaryCutout:))
		 ((= rule ruleTan:) (goto UnaryCutout:))
		 ((= rule ruleVar:) (return (ruleVar wff[1])))
		 ((= rule ruleVop:)
	      (begin
	        (cond
	         ;; Case: Pass the cutout request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50) (isPair wff[2])) (return (cutoutNumericWFF wff[2] point)))
	         ;; Case: Pass the cutout request to the next level through argument two.
	         ((and (= stopHereSW false) (isPair wff[3])) (return (cutoutNumericWFF wff[3] point)))
	         ;; Case: Cutout the abstract operator grammar rule of this level.
	         (else (return wff))
	         ) ; end cond
	      )) ; end ruleVop case
	     (else (error (append "gsm.expressionGrammarGso.cutoutNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end cutoutNumericWFF    
	
	;; *******************************************************************
	;; summary:  Evaluate an GSO grammar production rule.
	;;
	;; args:     rule        Any GSO grammar rule to be evaluated.
	;;           
	;; Return:   expression  The result of evaluating the grammar rule as a String.
	;;
	;; *******************************************************************
    (defun evalRule(rule)
       vars:(ruleHdr)
       (onError (lambda(msg) "...error..."))
       (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
       (if (isString rule) (setq rule (listWff rule)))
       (if (isPair rule) (setq rule (apply (setq ruleHdr gsm.expressionGrammarGso[(car rule)]) (cdr rule))) (setq rule (string rule true)))
       rule) ; end evalRule

    (defun extractNumericWFF(inWff ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF from any Estimator WFF.
	;;           For instance: "regress (x3/x13);" ==> "(x3/x13)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     inWff       Any Estimator input WFF or Estimator Lambda.
	;;           sourceSW    (Optional) True iff the result expression is to be returned in source form.
	;;           
	;;           
	;; Return:   expression  The numeric WFF extracted from the specified Estimator WFF.
	;;
	;; *******************************************************************
		regs:(m M)
		vars:(sourceSW expression rule wff)
	    ;; If the wff argument is an Lambda, then convert it to a WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (isLambda inWff) (setq wff inWff.WFF) (setq wff inWff))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    (setq sourceSW (if (>= (argCount) 2) (argFetch 1) false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (setq rule wff[0])
	    (cond
		 ((isNumber wff) (setq expression wff))
		 ((isSymbol wff) (setq expression wff))
		 ((= rule ruleAbs:) (setq expression wff))
		 ((= rule ruleAdd:) (setq expression wff))
		 ((= rule ruleAvg:) (setq expression wff))
		 ((= rule ruleCons:) (setq expression (ruleCons wff[1])))
		 ((= rule ruleCos:) (setq expression wff))
		 ((= rule ruleCube:) (setq expression wff))
		 ((= rule ruleDiv:) (setq expression wff))
		 ((= rule ruleExp:) (setq expression wff))
		 ((= rule ruleExpression:) (setq expression wff))
		 ((= rule ruleExpt:) (setq expression wff))
		 ((= rule ruleFrm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleIf:) (setq expression wff))
		 ((= rule ruleLog:) (setq expression wff))
		 ((= rule ruleFrac:) (setq expression wff))
		 ((= rule ruleInt:) (setq expression wff))
		 ((= rule ruleInv:) (setq expression wff))
		 ((= rule ruleMax:) (setq expression wff))
		 ((= rule ruleMdl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleMin:) (setq expression wff))
		 ((= rule ruleMod:) (setq expression wff))
		 ((= rule ruleMul:) (setq expression wff))
		 ((= rule ruleMvl:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleName:) (setq expression (ruleName wff[1])))
		 ((= rule ruleNeg:) (setq expression wff))
		 ((= rule ruleNoise:) (setq expression (ruleNoise wff[1])))
		 ((= rule ruleNop:) (setq expression wff))
		 ((= rule ruleProd:) (setq expression wff))
		 ((= rule ruleReg:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleSigmoid:) (setq expression wff))
		 ((= rule ruleSign:) (setq expression wff))
		 ((= rule ruleSin:) (setq expression wff))
		 ((= rule ruleSqrt:) (setq expression wff))
		 ((= rule ruleSquare:) (setq expression wff))
		 ((= rule ruleSub:) (setq expression wff))
		 ((= rule ruleSum:) (setq expression wff))
		 ((= rule ruleSvm:) (begin (setq M wff[1]) (setq m 0) (while (and (= expression #void) (= wff[1][m] #void)) do (++ m)) (setq expression wff[1][m])))
		 ((= rule ruleTan:) (setq expression wff))
		 ((= rule ruleTanh:) (setq expression wff))
		 ((= rule ruleVar:) (setq expression (ruleVar wff[1])))
		 ((= rule ruleVop:) (setq expression (ruleVop wff[0] wff[1] wff[2] wff[3])))
	     (else (setq expression x1:))
	     ) ; end cond
	    ;; Return the numeric expression as a Estimator WFF or as a Estimator source string.
	    (if (= expression #void) (setq expression x1:))
	    (if (= sourceSW true) then (setq expression (evalRule expression))) 
		expression) ; end extractNumericWFF    
	    
    (defun growWFF(Symbol:rule Integer:level ...)
	;; *******************************************************************
	;; summary:  Returns a randomly grown Estimator WFF. 
	;;
	;; args:     rule      The grammar rule indicating the type of WFF is to be returned.
	;;                     Note: The values for the rule argument as as follows:
	;;                           binary:		Generates a random binary operator expression.	            
	;;                           condition:     Generates a random "if" expression.	            
	;;                           expression:    Generates a random numeric expression.	            
	;;                           number:		Generates a random number constant.	            
	;;                           unary:		    Generates a random unary operator expression.	            
	;;                           variable:      Generates a random GSVariable reference (v0 thru vK).	            
	;;           level     The count of the current level in the expression.
	;;           gsvCount  The count of the current GSVariables generated in the expression.
	;;           gscCount  The count of the current GSConstants generated in the expression.
	;;           gsnCount  The count of the current GSNoise terms generated in the expression.
	;;           
	;; Return:   result    The randomly grown Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:r (maxLevels 4))
        pvars:(gscCount gsvCount gseCount gsnCount)
		vars:(wff newRule relop)
		vars:(commands expressions percents)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((expressionRules #(obj| binary condition unary variable)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Load the count of the current GSVariables generated in the expression.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (>= (argCount) 3) (setq gsvCount (argFetch 2)) (setq gsvCount 0))
        (if (>= (argCount) 4) (setq gscCount (argFetch 3)) (setq gscCount 0))
        (if (>= (argCount) 5) (setq gsnCount (argFetch 4)) (setq gsnCount 0))
		;; Use the grammar rule to guide the type of Estimator WFF generated.
	    (cond
	     ;; Case binary:		Generates a random binary operator expression.	            
		 ((= rule binary:) 
	      (begin
	        (setq N (length binaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule binaryRules[n])
            (if (= newRule ruleExpt:)
                (begin
	              (if (< level maxLevels)
	                  (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount) (growWFF number: (+ level 1) gsvCount gscCount gsnCount)))
	                  (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount) (growWFF number: (+ level 1) gsvCount gscCount gsnCount))))
                ) ; then
            else
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1) gsvCount gscCount gsnCount) (growWFF expression: (+ level 1) gsvCount gscCount gsnCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount) (growWFF term: (+ level 1) gsvCount gscCount gsnCount)))
	            )) ; end if
	      )) ; end case binary
	
	     ;; Case condition:    Generates a random "if" expression.	            
		 ((= rule condition:) 
	      (begin
	        (setq newRule ruleIf:)
	        (setq N (length relationalOperators))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq relop relationalOperators[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount) relop (growWFF expression: (+ level 1) gsvCount gscCount gsnCount) (growWFF expression: (+ level 1) gsvCount gscCount gsnCount) (growWFF expression: (+ level 1) gsvCount gscCount gsnCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount) relop (growWFF term: (+ level 1) gsvCount gscCount gsnCount) (growWFF term: (+ level 1) gsvCount gscCount gsnCount) (growWFF term: (+ level 1) gsvCount gscCount gsnCount)))
	            ) ; end if
	      )) ; end case condition
	
	     ;; Case expression:    Generates a random numeric expression.	            
		 ((= rule expression:) 
	      (begin
	        GrowExpression::
	        (setq N (length expressionRules))
	        (setq n (integer (gsm.myRandomFunction N)))
            (setq r (gsm.myRandomFunction 1.0))
	        (cond 
	         ((>= level maxLevels) (goto GrowTerm:))
	         ((<= r .40) (setq wff (growWFF (setq newRule unary:) (+ level 1) gsvCount gscCount gsnCount)))
	         ((<= r .70) (setq wff (growWFF (setq newRule binary:) (+ level 1) gsvCount gscCount gsnCount)))
	         ((<= r .95) (setq wff (growWFF (setq newRule variable:) (+ level 1) gsvCount gscCount gsnCount)))
	         (else (setq wff (growWFF (setq newRule condition:) (+ level 1) gsvCount gscCount gsnCount)))
	         ) ; end cond
	      )) ; end case expression
	
	     ;; Case number:    Generates a random number constant.	            
		 ((= rule number:) 
	      (begin
	        GrowNumber::
            (if (<= (gsm.myRandomFunction 1.0) myAbstractConsPct)
	            (begin (setq wff (ruleCons gscCount)) (++ gscCount))	            
	            (setq wff (- (gsm.myRandomFunction 10.0) 5.0))
                ) ; end if
	      )) ; end case number
	
	     ;; Case term:    Generates a random number constant or variable name.	            
		 ((= rule term:) 
	      (begin
	        GrowTerm::
	        (if (< (gsm.myRandomFunction 1.0) myNumberPct) (goto GrowNumber:) (goto GrowVariable:))
	      )) ; end case number
	
	     ;; Case unary:		Generates a random unary operator expression.	            
		 ((= rule unary:) 
	      (begin
	        (setq N (length unaryRules))
	        (setq n (integer (gsm.myRandomFunction N))) 
	        (setq newRule unaryRules[n])
	        (if (< level maxLevels)
	            (setq wff (list newRule (growWFF expression: (+ level 1) gsvCount gscCount gsnCount)))
	            (setq wff (list newRule (growWFF variable: (+ level 1) gsvCount gscCount gsnCount)))
	            ) ; end if
	      )) ; end case unary
	
	     ;; Case variable:		Generates a random variable reference (v0, v1 thru vK).	            
		 ((= rule variable:) 
	      (begin
	        GrowVariable::
            (if (<= (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                then
	            (if (<= (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                    (begin (setq wff (ruleVar gsvCount)) (++ gsvCount))
                    (begin (setq wff (ruleNoise gsnCount)) (++ gsnCount)))
                else
	            (begin (setq n (integer (gsm.myRandomFunction myM))) (setq wff (ruleName n)))
                ) ; end if
	      )) ; end case variable
	
	     ;; Case else
	     (else (error (append "gsm.expressionGrammarGso.growWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond

	    ;; Return the randomly grown Estimator WFF.
		wff) ; end growWFF    
	
	(defun growCTermWFF(...)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression conditional term
	;;           Estimator WFF based upon a chosen column, such as
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion including conditionals.           
	;;
	;; args:     none                                 
	;;           
	;; Return:   wff          The sequentially grown conditional term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(n N NN NO)
		vars:(wff choice)
		vars:((operators #("<" "<=" "==" "<>" ">=" ">")))
	
	    ;; Return the count of term Estimator term WFFs
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (setq NN (growTermWFF -1))
	    (setq NO (length operators))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	
	    (setq choice (gsm.myRandomFunction 1.0))
	    (if (>= choice 0.25)
	        ;; Generate a term Estimator term WFF
	        (setq wff (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN)))))
	        ;; Generate a Estimator conditional term WFF
	        (setq wff (list ruleIf: (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))
	                                (symbol operators[(integer (gsm.myRandomFunction NO))])  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))  
	                                (growTermWFF (integer (* 2.0 (gsm.myRandomFunction NN))))
	                                )) ; end list
	        ) ; end generate cterm only if
	
		wff) ; end growCTermWFF    

	(defun growRootWFF(Integer:rootChoice)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown root Estimator WFF such as
	;;             v0, 
	;;             abs(v0) thru tanh(v0), 
	;;             (v0+v1) thru (v0-v1),
	;;                      ...
	;;             abs((abs(v0)) thru tanh(tanh(v0)), 
	;;             (abs(v0)+abs(v1)) thru (tanh(v0)-tanh(v1)),
	;;                      ...
	;;             abs(v0+v1) thru tanh(v0-v1), 
	;;           
	;;           The root Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice   The choice of the sequential root WFF expression to return.                        
	;;           Note: if rootChoice <= -2, then a random root WFF is to be generated and extended randomly.
	;;           Note: if rootChoice == -1, then the maximum number of root WFFs is to be returned.
	;;           Note: if rootChoice >=  0, then a random root WFF is to be generated and extended randomly.
	;;                 Otherwise, rootChoice must be the index of the chosen Estimator WFF root expression.
	;;           
	;; Return:   wff          The sequentially grown root Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(b B m M n N NN)
		vars:(wff newRule binRule Integer:choice)
		vars:((binaryRules #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; **********************************************************
	    ;; Generate a sequential Estimator root WFF without extension.
	    ;; **********************************************************
	    
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate all of the single variable names
	          (setq N 1)
	          (if (< choice N)
	              (begin
	                 (setq wff (ruleVar 0))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the exponent functions with single variable names
	          (setq N 3)
	          (if (< choice N)
	              (begin
	                 (if (= choice 0) then (begin (setq wff (list ruleSqrt: (ruleVar 0))) (return wff)))
	                 (if (= choice 1) then (begin (setq wff (list ruleSquare: (ruleVar 0))) (return wff)))
	                 (if (= choice 2) then (begin (setq wff (list ruleCube: (ruleVar 0))) (return wff)))
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with single variable names
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule unaryRules[n])
	                 (setq wff (list newRule (ruleVar 0)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the binary functions with single variable names
	          (setq N (length binaryRules))
	          (if (< choice N)
	              (begin
	                 (setq n choice)
	                 (setq newRule binaryRules[n])
	                 (setq wff (list newRule (ruleVar 0) (ruleVar 1)))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          
	          ;; Generate all of the unary functions with binary root expression arguments
	          (setq M (length unaryRules))
	          (setq B (length binaryRules))
	          (setq N (muli M B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (divi choice B))
	                 (setq newRule unaryRules[n])
	                 (setq binRule binaryRules[b])
	                 (setq wff (list newRule (list binRule (ruleVar 0) (ruleVar 1))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Generate all of the binary functions with binary root expression arguments
	          (setq B (length binaryRules))
	          (setq N (muli B B B))
	          (if (< choice N)
	              (begin
                     (setq b (modi choice B))
                     (setq n (modi (divi choice B) B))
                     (setq m (divi choice (* B B)))
	                 (setq wff (list binaryRules[m] (list binaryRules[n] (ruleVar 0) (ruleVar 1)) (list binaryRules[b] (ruleVar 2) (ruleVar 3))))
	                 (return wff)
	              )) ; end variable names
	          (-= choice N)
	          	          
	          ;; Return void wff showing that there are no more root Estimator WFFs available.
	          (return #void)
	          
	        )) ; end generate root only if
	
    ;; **********************************************************
    ;; Return the maximum number of root WFFs.
    ;; **********************************************************
    (setq NN 1)
    (setq N 3)(+= NN N)
    (setq N (length unaryRules))(+= NN N)
    (setq N (length binaryRules))(+= NN N)
    (setq N (* (length unaryRules) (length binaryRules)))(+= NN N)
    (setq N (* (length binaryRules) (length binaryRules) (length binaryRules)))(+= NN N)
    (if (= choice -1) (return NN))

    ;; **************************************************************
    ;; Generate a sequential Estimator root WFF with random extension.
    ;; **************************************************************
    (setq choice (integer (gsm.myRandomFunction NN)))
    (setq wff (growRootWFF choice))
    (setq wff (mutateNumericWFF wff))

    Last::
	wff) ; end growRootWFF    

	(defun growTermWFF(Integer:rootChoice ...)
	;; *******************************************************************
	;; summary:  Returns a sequentially grown regression term Estimator WFF 
	;;           based upon a chosen column, such as
	;;             xc 
	;;             xtime, thru xm, 
	;;             abs(ac) thru tan(xc), 
	;;                      ...
	;;             (xc+xtime) thru (xc+xm),
	;;                      ...
	;;             (xtime-xtime) thru (xm-xm),
	;;           
	;;           The term Estimator numeric expressions cover the starting
	;;           forms of ALL possible gramatically correct Estimator WFFs
	;;           down to the first level of recursion.           
	;;
	;; args:     rootChoice     The choice of the sequential term WFF expression to return.                        
	;;                           Note: if rootChoice <  -1, then a random term WFF is to be generated.
	;;                           Note: if rootChoice == -1, then the maximum number of term WFFs is to be returned.
	;;                           Note: if rootChoice >=  0, then a sequential term WFF is to be generated, and the rootChoice must be the index of the chosen Estimator WFF.
	;;           columnChoice   The choice of the regression column for this Estimator WFF expression.                        
	;;                           Note: if columnChoice <  0, then a random column choice is to be generated.
	;;           
	;; Return:   wff          The sequentially grown term Estimator WFF.
	;;
	;; *******************************************************************
	    regs:(B m M mm MM n N nn NN)
		vars:(wff newRule Integer:choice (Integer:columnChoice -1) (Integer:maxVars 2) (Integer:maxNoise 2))
		vars:((binaryRules #(obj| ruleAvg ruleAdd ruleDiv ruleMax ruleMod ruleMin ruleMul ruleSub)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
	
	    ;; Generate a random column choice (if necessary).
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (>= (argCount) 2) (setq columnChoice (argFetch 1)))
	    (if (< columnChoice 0) (setq columnChoice (integer (gsm.myRandomFunction myM))))
	    
	    ;; **********************************************************
	    ;; Generate a sequential Estimator term WFF without extension.
	    ;; **********************************************************
	    
	    (setq choice rootChoice)
	    (if (>= choice 0)
	        (begin         
	
	          ;; Generate the chosen column variable name
	          (if (= choice 0)
	              (begin
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct) 
                             (setq wff (ruleNoise (integer (gsm.myRandomFunction maxNoise))))
                             (setq wff (ruleVar (integer (gsm.myRandomFunction maxVars)))))
                         else 
                         (setq wff (ruleName columnChoice)))
	                 (return wff)
	              )) ; end column variable names
	          (-= choice 1)
	
	          ;; Generate all of the term unary functions
	          (setq N (length unaryRules))
	          (if (< choice N)
	              (begin
	                 (setq newRule unaryRules[choice])
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct) 
                             (setq wff (list newRule (ruleNoise (integer (gsm.myRandomFunction maxVars)))))
                             (setq wff (list newRule (ruleVar (integer (gsm.myRandomFunction maxVars))))))
                         else 
                         (setq wff (list newRule (ruleName columnChoice))))
	                 (return wff)
	              )) ; end term unary functions names
	          (-= choice N)
	          
	          ;; Generate all of the left term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                             (setq wff (list newRule (ruleNoise (integer (gsm.myRandomFunction maxNoise))) (ruleName m)))
                             (setq wff (list newRule (ruleVar (integer (gsm.myRandomFunction maxVars))) (ruleName m))))
                         else 
                         (setq wff (list newRule (ruleName columnChoice) (ruleName m))))
	                 (return wff)
	              )) ; end left term binary functions
	          (-= choice N)        
	          
	          ;; Generate all of the right term binary functions
	          (setq N (muli (length binaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice myM))
	                 (setq newRule binaryRules[n])
	                 (setq m (modi choice myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct) 
                         then
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct) 
                             (setq wff (list newRule (ruleName m) (ruleNoise (integer (gsm.myRandomFunction maxNoise))))) 
                             (setq wff (list newRule (ruleName m) (ruleVar (integer (gsm.myRandomFunction maxVars)))))) 
                         else
                         (setq wff (list newRule (ruleName m) (ruleName columnChoice))))
	                 (return wff)
	              )) ; end right term binary functions
	          (-= choice N) 
	          
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleNoise (integer (gsm.myRandomFunction maxNoise)))) (ruleName m))) 
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleVar (integer (gsm.myRandomFunction maxVars)))) (ruleName m)))) 
                         else
                         (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
                         ) ; end if
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                             (setq wff (list binaryRules[n] (ruleNoise (integer (gsm.myRandomFunction maxNoise))) (list unaryRules[nn] (ruleName m)))) 
                             (setq wff (list binaryRules[n] (ruleVar (integer (gsm.myRandomFunction maxVars))) (list unaryRules[nn] (ruleName m))))) 
                         else
                         (setq wff (list binaryRules[n] (ruleName columnChoice) (list unaryRules[nn] (ruleName m))))
                         ) ; end if
	                 (return wff)
	              )) ; end right binary unary functions
	          (-= choice N)        
	                            
	          ;; Generate all of the left binary unary functions
	          (setq N (muli (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length unaryRules) myM)))
	                 (setq nn (/ m myM))
	                 (setq m (modi m myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct) 
                         then
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct) 
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleNoise (integer (gsm.myRandomFunction maxNoise)))) (ruleName m))) 
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleVar (integer (gsm.myRandomFunction maxVars)))) (ruleName m)))) 
                         else
                         (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (ruleName m)))
                         ) ; end if
	                 (return wff)
	              )) ; end left binary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the left binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleNoise (integer (gsm.myRandomFunction maxNoise)))) (list unaryRules[mm] (ruleName m)))) 
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleVar (integer (gsm.myRandomFunction maxVars)))) (list unaryRules[mm] (ruleName m))))) 
                         else 
                         (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName columnChoice)) (list unaryRules[mm] (ruleName m))))
                         ) ; end if
	                 (return wff)
	              )) ; end left binary unary unary functions
	          (-= choice N)        
	
	          ;; Generate all of the right binary unary unary functions
	          (setq N (muli (length binaryRules) (length binaryRules) (length unaryRules) myM))
	          (if (< choice N)
	              (begin
	                 (setq n (/ choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq m (modi choice (muli (length binaryRules) (length unaryRules) myM)))
	                 (setq nn (/ m (muli (length unaryRules) myM)))
	                 (setq m (modi m (muli (length unaryRules) myM)))
	                 (setq mm (/ m myM))
	                 (setq m (modi m myM))
	                 (if (< (gsm.myRandomFunction 1.0) myAbstractVarsPct)
                         then 
	                     (if (< (gsm.myRandomFunction 1.0) myAbstractNoisePct)
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName m)) (list unaryRules[mm] (ruleNoise (integer (gsm.myRandomFunction maxNoise)))))) 
                             (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName m)) (list unaryRules[mm] (ruleVar (integer (gsm.myRandomFunction maxVars))))))) 
                         else 
                         (setq wff (list binaryRules[n] (list unaryRules[nn] (ruleName m)) (list unaryRules[mm] (ruleName columnChoice))))
                         ) ; end if
	                 (return wff)
	              )) ; end right binary unary unary functions
	          (-= choice N)        
	
	          ;; Return a random Estimator term WFF if there are no more term Estimator term WFFs available.
	          (return (growTermWFF -2 columnChoice))
	          
	        )) ; end generate term only if
	
	    ;; **********************************************************
	    ;; Return the maximum number of term WFFs.
	    ;; **********************************************************
	    (setq NN (+ 1 (length unaryRules) (* 2.0 (muli (length binaryRules) myM)) (* 3.0 (muli (length binaryRules) (length unaryRules) myM)) (* 2.0 (muli (length binaryRules) (length binaryRules) (length unaryRules) myM)) ))
	    (if (= choice -1) (return NN))
	
	    ;; **************************************************************
	    ;; Generate a random Estimator term WFF.
	    ;; **************************************************************
	    TryAgain::
	    (setq choice (integer (gsm.myRandomFunction NN)))
	    (setq wff (growTermWFF choice columnChoice))
	    (if (= wff #void) (begin (writeln "gsm.expressionGrammarGso.growTermWff: void WFF at [" choice "]") (goto TryAgain:)))
	
		wff) ; end growTermWFF    

	(defun lengthWFF(wff)
	;; *******************************************************************
	;; summary:  Returns the left-depth-first length of any Estimator WFF. 
	;;
	;; args:     wff       The WFF whose length is to be returned.           
	;;           
	;; Return:   result    The left-depth-first length of the specified WFF.
	;;
	;; *******************************************************************
	    regs:(n N (result 0))
		vars:(rule)
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; The length of a Vector of WFFs is always the
	    ;; sum of the lengths of each WFF in the vector.
	    (if (isVector wff) 
	        then
	        (begin
	          (setq N (length wff))
	          (loop for n from 0 until N do
	            (+= result (lengthWFF wff[n]))
	            ) ; end loop 
	          (return result)
	        )) ; end if
	    ;; The length of an atomic WFF is always 1.
	    (if (isAtom wff) then (return 1))
		;; Use the grammar rule to guide the computation 
	    ;; of the specified Estimator WFF length.
	    (setq rule wff[0])
	    (cond
		 ((= rule ruleAbs:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleAdd:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleAvg:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleCons:) (setq result 1))
		 ((= rule ruleCos:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleCube:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleDiv:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleExp:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpression:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleExpt:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleFrm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleIf:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]) (lengthWFF wff[4]) (lengthWFF wff[5]))))
		 ((= rule ruleFrac:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleInv:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleLog:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMax:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMdl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleMin:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleMod:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMul:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleMvl:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleName:) (setq result 1))
		 ((= rule ruleNeg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleNop:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleProd:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleReg:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSigmoid:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSign:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSin:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSqrt:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSquare:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleSub:) (+= result (+ (lengthWFF wff[1]) (lengthWFF wff[2]))))
		 ((= rule ruleSum:) (begin (setq N (length wff)) (loop for n from 1 until N do (+= result (lengthWFF wff[n]))) result))
		 ((= rule ruleSvm:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTan:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleTanh:) (+= result (lengthWFF wff[1])))
		 ((= rule ruleVar:) (setq result 1))
		 ((= rule ruleVop:) (+= result (+ (lengthWFF wff[2]) (lengthWFF wff[3]))))
	     (else (error (append "gsm.expressionGrammarGso.lengthWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		result) ; end lengthWFF    
	
	(defun marryNumericWFFs(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a numeric Estimator WFF by marrying two suitor 
	;;           Estimator WFFs.
	;;           For instance: "x3" , "x4" ==> "(x3/x4)".
	;;
	;; Note:     If the wff argument is a string, then it is returned "as is".
	;;
	;; args:     wff1      The male WFF suitor for this marriage.           
	;;           wff2      The female WFF suitor for this marriage.           
	;;           operator  (Optional) The binary operator for this marriage.           
	;;           
	;; Return:   expression  The numeric WFF resulting from the marriage.
	;;
	;; *******************************************************************
	    vars:(expression newRule len1 len2)
		vars:((binaryOperators #(obj| ruleAdd ruleAvg ruleDiv ruleMax ruleMin ruleMod ruleMul ruleSub)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (= wff1 #void) (return false))
	    (if (= wff2 #void) (return false))
	    (if (isString wff1) (setq wff1 (listWff wff1)))
	    (if (isString wff2) (setq wff2 (listWff wff2)))
	    ;; Make sure we can marry these two WFFs without exceeding the WFF length limit.
	    (setq len1 (lengthWFF wff1))
	    (setq len2 (lengthWFF wff2))
	    (if (>= (+ len1 len2) myMaxColWFFLen) (return false)) 
		;; Use the grammar rule to guide the extraction 
	    ;; of a numeric expression WFF from the specified 
	    ;; Estimator WFF.
	    (if (= (argCount) 3) 
	        (setq newRule (argFetch 2))
	        (setq newRule binaryOperators[(integer (gsm.myRandomFunction (length binaryOperators)))])
	        ) ; end if
	    (setq expression (list newRule wff1 wff2))
		expression) ; end marryNumericWFFs    
		
	(defun mutateAbstractC0(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF using abstract expressions 
    ;;           {"(x3/sin(x4))" ==> "(x3/sin(v0*c0))"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (= wff #void) (return wff))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (setq wff c0:))
		 ((isSymbol wff) (cond ((= wff[0] #\x) (setq wff v0:)) (else (setq wff wff))))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateAbstractC0 wff[1] point)))
	         ;; Case: Mutate the unary grammar rule of this level into an abstract function.
	         (else (setCdr (setCar wff ruleVop:) (list 0 wff[1] c0:)))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateAbstractC0 wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateAbstractC0 wff[2] point)))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 0 wff[1] wff[2])))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateAbstractC0 nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateAbstractC0 nwff[2] point)))
	         ;; Case: Replace the multiary grammar rule of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 0 nwff[1] nwff[2])))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (setCdr (setCar wff ruleVop:) (list 0 v0: c0:)))
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleExpt:) (goto BinaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateAbstractC0 wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateAbstractC0 wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateAbstractC0 wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateAbstractC0 wff[5] point)))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 0 wff[4] wff[5])))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:)  (setCdr (setCar wff ruleVar:) (list 0)))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNoise:) (setCdr (setCar wff ruleVop:) (list 0 v0: c0:)))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
		 ((= rule ruleVar:) (setCdr (setCar wff ruleVop:) (list 0 v0: c0:)))
		 ((= rule ruleVop:) (setCdr (setCar wff ruleVar:) (list 0)))
	     (else (error (append "gsm.expressionGrammarGso.mutateAbstractC0: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateAbstractC0    

	(defun mutateAbstractC1(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF using abstract expressions 
    ;;           {"(x3/sin(x4))" ==> "(x3/sin(v1*c1))"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (= wff #void) (return wff))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (setq wff c1:))
		 ((isSymbol wff) (cond ((= wff[0] #\x) (setq wff v1:)) (else (setq wff wff))))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateAbstractC1 wff[1] point)))
	         ;; Case: Mutate the unary grammar rule of this level into an abstract function.
	         (else (setCdr (setCar wff ruleVop:) (list 1 wff[1] c1:)))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateAbstractC1 wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateAbstractC1 wff[2] point)))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 0 wff[1] wff[2])))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateAbstractC1 nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateAbstractC1 nwff[2] point)))
	         ;; Case: Replace the multiary grammar rule of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 1 nwff[1] nwff[2])))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (setCdr (setCar wff ruleVop:) (list 1 v1: c1:)))
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleExpt:) (goto BinaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateAbstractC1 wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateAbstractC1 wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateAbstractC1 wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateAbstractC1 wff[5] point)))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCdr (setCar wff ruleVop:) (list 1 wff[4] wff[5])))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:)  (setCdr (setCar wff ruleVar:) (list 1)))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNoise:) (setCdr (setCar wff ruleVop:) (list 1 v1: c1:)))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
		 ((= rule ruleVar:) (setCdr (setCar wff ruleVop:) (list 1 v1: c1:)))
		 ((= rule ruleVop:) (setCdr (setCar wff ruleVar:) (list 1)))
	     (else (error (append "gsm.expressionGrammarGso.mutateAbstractC1: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateAbstractC1    

	(defun mutateNumericWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly mutating a 
	;;           candidate Estimator WFF {"(x3/x4)" ==> "(x3/sin(x4)"}. 
	;;
	;; args:     wff       The WFF which is to be mutated.
	;;           point     (Optional)The probability of mutating this grammar rule.           
	;;           
	;; Return:   wff       The new mutated WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((binaryRules #(obj| ruleAdd ruleDiv ruleMod ruleMul ruleSub)))
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		vars:((multiaryRules #(obj| ruleAvg ruleMax ruleMin ruleProd ruleSum)))
		vars:((unaryRules #(obj| ruleAbs ruleCos ruleCube ruleExp ruleFrac ruleInt ruleInv ruleLog ruleNeg ruleSigmoid ruleSign ruleSin ruleSqrt ruleSquare ruleTan ruleTanh)))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (= (argCount) 1) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 1)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
	    (if (isString wff) 
	        (if (isNumber (parse wff)) (setq wff (parse wff)) (setq wff (symbol wff)))
	        ); end if
	    (setq rule wff[0])
	    (cond
		 ((= wff #void) (setq wff (growWFF expression: 0)))
		 ((isNumber wff) (if (< argPoint .80) (setq wff (* wff (- (gsm.myRandomFunction 10.0) 5.0))) (setq wff (growWFF expression: 0))))
		 ((isSymbol wff) (if (< argPoint .80) (setq wff (ruleName (integer (gsm.myRandomFunction myM)))) (setq wff (growWFF expression: 0))))
		 ((= rule ruleAbs:)
	      (begin
	        UnaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level.
	         ((= stopHereSW false) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Replace the unary argument of this level.
	         ((>= argPoint .50) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the unary grammar rule of this level.
	         (else (setCar wff unaryRules[(gsm.myRandomFunction (length unaryRules))]))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinaryMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr wff) (mutateNumericWFF wff[2] point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .6666) (if (isAtom wff[2]) (setCar (cddr wff) (mutateNumericWFF wff[2] point)) (setCar (cddr wff) (growWFF expression: 0))))
	         ;; Case: Replace binary argument one of this level.
	         ((> argPoint .3333) (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ;; Case: Replace the binary grammar rule of this level.
	         (else (setCar wff binaryRules[(gsm.myRandomFunction (length binaryRules))]))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiaryMutate::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((= stopHereSW false) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)))
	         ;; Case: Replace multiary argument two of this level.
	         ((> argPoint .6666) (if (isAtom nwff[2]) (setCar (cddr nwff) (mutateNumericWFF nwff[2] point)) (setCar (cddr nwff) (growWFF expression: 0))))
	         ;; Case: Replace multiary argument one of this level.
	         ((> argPoint .3333) (if (isAtom nwff[1]) (setCar (cdr nwff) (mutateNumericWFF nwff[1] point)) (setCar (cdr nwff) (growWFF expression: 0))))
	         ;; Case: Replace the multiary grammar rule of this level.
	         (else (setCar wff multiaryRules[(gsm.myRandomFunction (length multiaryRules))]))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) false)
		 ((= rule ruleCos:) (goto UnaryMutate:))
		 ((= rule ruleCube:) (goto UnaryMutate:))
		 ((= rule ruleDiv:) (goto BinaryMutate:))
		 ((= rule ruleExp:) (goto UnaryMutate:))
		 ((= rule ruleExpression:) (goto UnaryMutate:))
		 ((= rule ruleExpt:) (goto BinaryMutate:))
		 ((= rule ruleIf:)
	      (begin
	        IfMutate::
	        (cond
	         ;; Case: Pass the mutation request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .20)) (setCar (cdr wff) (mutateNumericWFF wff[1] point)))
	         ;; Case: Pass the mutation request to the next level through argument two.
	         ((and (= stopHereSW false) (< argPoint .40)) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Pass the mutation request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .60)) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)))
	         ;; Case: Pass the mutation request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .80)) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)))
	         ;; Case: Pass the mutation request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .80)) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .80) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) (mutateNumericWFF wff[5] point)) (setCar (cdr (cddddr wff)) (growWFF expression: 0))))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .60) (if (isAtom wff[4]) (setCar (cddddr wff) (mutateNumericWFF wff[4] point)) (setCar (cddddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .40) (if (isAtom wff[3]) (setCar (cdddr wff) (mutateNumericWFF wff[3] point)) (setCar (cdddr wff) (growWFF expression: 0))))
	         ;; Case: Replace argument two of this level.
	         ((>= argPoint .20) (setCar (cddr wff) relationalOperators[(gsm.myRandomFunction (length relationalOperators))]))
	         ;; Case: Replace binary argument one of this level.
	         (else (if (isAtom wff[1]) (setCar (cdr wff) (mutateNumericWFF wff[1] point)) (setCar (cdr wff) (growWFF expression: 0))))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnaryMutate:))
		 ((= rule ruleInt:) (goto UnaryMutate:))
		 ((= rule ruleInv:) (goto UnaryMutate:))
		 ((= rule ruleLog:) (goto UnaryMutate:))
		 ((= rule ruleMax:) (goto MultiaryMutate:))
		 ((= rule ruleMin:) (goto MultiaryMutate:))
		 ((= rule ruleMod:) (goto BinaryMutate:))
		 ((= rule ruleMul:) (goto BinaryMutate:))
		 ((= rule ruleName:) (setq wff (growWFF expression: 0)))
		 ((= rule ruleNeg:) (goto UnaryMutate:))
		 ((= rule ruleNoise:) (setq wff (growWFF expression: 0)))
		 ((= rule ruleNop:) (goto UnaryMutate:))
		 ((= rule ruleProd:) (goto MultiaryMutate:))
		 ((= rule ruleSigmoid:) (goto UnaryMutate:))
		 ((= rule ruleSign:) (goto UnaryMutate:))
		 ((= rule ruleSin:) (goto UnaryMutate:))
		 ((= rule ruleSqrt:) (goto UnaryMutate:))
		 ((= rule ruleSquare:) (goto UnaryMutate:))
		 ((= rule ruleSub:) (goto BinaryMutate:))
		 ((= rule ruleSum:) (goto MultiaryMutate:))
		 ((= rule ruleTan:) (goto UnaryMutate:))
		 ((= rule ruleTanh:) (goto UnaryMutate:))
		 ((= rule ruleVar:) (setq wff (growWFF expression: 0)))
		 ((= rule ruleVop:) (setq wff (growWFF expression: 0)))
	     (else (error (append "gsm.expressionGrammarGso.mutateNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end mutateNumericWFF    
	
	(defun selectPairWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Pair objects. 
	;;
	;; args:     wff       The WFF whose Pair objects are to be returned.           
	;;           index     (Optional)The vector of Pair objects to be returned.           
	;;           
	;; Return:   index     The vector of Pair objects to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector: Object:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return index))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectPairWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleCons:) (selectPairWFF wff[1] index))
		 ((= rule ruleCos:) (selectPairWFF wff[1] index))
		 ((= rule ruleCube:) (selectPairWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleExp:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpression:) (selectPairWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index) (selectPairWFF wff[3] index) (selectPairWFF wff[4] index) (selectPairWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectPairWFF wff[1] index))
		 ((= rule ruleInt:) (selectPairWFF wff[1] index))
		 ((= rule ruleInv:) (selectPairWFF wff[1] index))
		 ((= rule ruleLog:) (selectPairWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleName:) (selectPairWFF wff[1] index))
		 ((= rule ruleNeg:) (selectPairWFF wff[1] index))
		 ((= rule ruleNoise:) (selectPairWFF wff[1] index))
		 ((= rule ruleNop:) (selectPairWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectPairWFF wff[1] index))
		 ((= rule ruleSign:) (selectPairWFF wff[1] index))
		 ((= rule ruleSin:) (selectPairWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectPairWFF wff[1] index))
		 ((= rule ruleSquare:) (selectPairWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectPairWFF wff[1] index) (selectPairWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectPairWFF wff[n] index))))
		 ((= rule ruleTan:) (selectPairWFF wff[1] index))
		 ((= rule ruleTanh:) (selectPairWFF wff[1] index))
		 ((= rule ruleVar:) (selectPairWFF wff[1] index))
		 ((= rule ruleVop:) (begin (selectPairWFF wff[2] index) (selectPairWFF wff[3] index)))
	     (else (error (append "gsm.expressionGrammarGso.selectPairWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectPairWFF    

	(defun selectSlotWFF(wff ...)
	;; *******************************************************************
	;; summary:  Returns the specified WFF as a vector of Slot items. 
	;;
	;; args:     wff       The WFF whose slot items are to be returned.           
	;;           index     (Optional)The vector of slot items to be returned.           
	;;           
	;; Return:   index     The vector of slot items to be returned.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule index)
	    ;; Retrieve the optional index argument.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (> (argCount) 1) then (setq index (argFetch 1))) 
        (if (not (isVector index)) (setq index (new Vector:)))
	    ;; If the wff argument is a string, then convert it to a list of Pair objects.
	    (if (isString wff) (setq wff (listWff wff)))
	    ;; Return the original argument if it is not a Pair or if the selection index is zero.
	    (if (isAtom wff) then (return (setq index[(length index)] wff)))
		;; Use the grammar rule to guide the computation of the specified Estimator WFF length.
	    ;; Note: We are at a Pair object (the head of this list) so we always add it to the index vector.
	    (setq rule wff[0])
        (setq index[(length index)] wff)
	    (cond
		 ((= rule ruleAbs:) (selectSlotWFF wff[1] index))
		 ((= rule ruleAdd:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleAvg:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleCons:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCos:) (selectSlotWFF wff[1] index))
		 ((= rule ruleCube:) (selectSlotWFF wff[1] index))
		 ((= rule ruleDiv:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleExp:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpression:) (selectSlotWFF wff[1] index))
		 ((= rule ruleExpt:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleIf:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index) (selectSlotWFF wff[3] index) (selectSlotWFF wff[4] index) (selectSlotWFF wff[5] index)))
		 ((= rule ruleFrac:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleInv:) (selectSlotWFF wff[1] index))
		 ((= rule ruleLog:) (selectSlotWFF wff[1] index))
		 ((= rule ruleMax:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMin:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleMod:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleMul:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleName:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNeg:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNoise:) (selectSlotWFF wff[1] index))
		 ((= rule ruleNop:) (selectSlotWFF wff[1] index))
		 ((= rule ruleProd:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleSigmoid:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSign:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSin:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSqrt:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSquare:) (selectSlotWFF wff[1] index))
		 ((= rule ruleSub:) (begin (selectSlotWFF wff[1] index) (selectSlotWFF wff[2] index)))
		 ((= rule ruleSum:) (begin (setq N (length wff))(loop for n from 1 until N do (selectSlotWFF wff[n] index))))
		 ((= rule ruleTan:) (selectSlotWFF wff[1] index))
		 ((= rule ruleTanh:) (selectSlotWFF wff[1] index))
		 ((= rule ruleVar:) (selectSlotWFF wff[1] index))
		 ((= rule ruleVop:) (begin (selectSlotWFF wff[2] index) (selectSlotWFF wff[3] index)))
	     (else (error (append "gsm.expressionGrammarGso.selectSlotWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		index) ; end selectSlotsWFF    

	(defun spliceImmediateWFF(wff swff index)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by immediately splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered (must be a Pair).
	;;           swff      The WFF which is to be spliced.
	;;           index     The index for splicing this grammar rule.
	;;           
	;; Return:   result    True iff the wff has been altered; otherwise, false.
	;;
	;; *******************************************************************
	    regs:(n N)
		vars:(rule)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
        (if (isAtom wff) (error "gsm.expressionGrammarGso.spliceImmediateWFF: the WFF argument must be a Pair object"))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (return false))
		 ((isSymbol wff) (return false))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (length wff))
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (setCar (cddr wff) swff))
	         ((and (= index 3) (> N 3)) (setCar (cdddr wff) swff))
	         ((and (= index 4) (> N 4)) (setCar (cddddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (return false))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cdr wff) swff))
	         ((= index 2) (return false))
	         ((= index 3) (setCar (cdddr wff) swff))
	         ((= index 4) (setCar (cddddr wff) swff))
	         ((= index 5) (setCar (cdr (cddddr wff)) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (return false))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNoise:) (return false))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (return false))
		 ((= rule ruleVop:)
	      (begin
	        (cond
	         ((= index 0) (return false))
	         ((= index 1) (setCar (cddr wff) swff))
	         ((= index 2) (setCar (cdddr wff) swff))
	         (else (return false))
	         ) ; end cond
	      )) ; end ruleVop case
	     (else (error (append "gsm.expressionGrammarGso.spliceImmediateWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		true) ; end spliceImmediateWFF    
	
	(defun spliceNumericWFF(wff swff ...)
	;; *******************************************************************
	;; summary:  Returns a numeric Estimator WFF by randomly splicing one WFF 
	;;           into a candidate Estimator WFF.  
	;;           For example {"(x3/sin(x4))" , "(log(x10)" ==> "(log(x10)/sin(x4))"}. 
	;;
	;; args:     wff       The WFF which is to be altered.
	;;           swff      The WFF which is to be spliced.
	;;           point     (Optional) The probability of splicing this grammar rule.
    ;;                     Note: If omitted, the probability of splicing this node is 100%.           
	;;           
	;; Return:   wff       The new spliced WFF.
	;;
	;; *******************************************************************
	    regs:(n N Number:point Number:argPoint Number:swPoint)
		vars:(rule nwff stopHereSW)
		vars:((relationalOperators #("<" "<=" "==" "<>" ">=" ">")))
		;; Use the grammar rule to guide the mutation of the candidate Estimator WFF.
        (if (<> eGrammar expressionGrammarGso) (error "gsm.expressionGrammarGso: this expression grammar is out of focus"))
	    (if (= (argCount) 2) (setq point (gsm.myRandomFunction 1.0)) (setq point (argFetch 2)))
	    (if (<= (setq swPoint (gsm.myRandomFunction 1.0)) point) (setq stopHereSW true) (setq stopHereSW false))
	    (setq argPoint (gsm.myRandomFunction 1.0))
        ;; Conditionally splice the swff into the wff 
	    (setq rule wff[0])
	    (cond
		 ((isMember swff relationalOperators) (return false))
		 ((isNumber wff) (setq wff swff))
		 ((isSymbol wff) (setq wff swff))
		 ((= rule ruleAbs:)
	      (begin
	        UnarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level.
	         ((= stopHereSW false) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Replace unary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAbs case
		 ((= rule ruleAdd:)
	      (begin
	        BinarySplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom wff[2]) (setCar (cddr wff) swff) (spliceNumericWFF wff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleAdd case
		 ((= rule ruleAvg:)
	      (begin
	        MultiarySplice::
            (setq N (- (length wff) 2))
            (setq N (integer (* (gsm.myRandomFunction 1.0) N)))
            (setq nwff wff)(loop for n from 0 until N do (setq nwff (cdr nwff)))
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom nwff[1]) (setCar (cdr nwff) swff) (spliceNumericWFF nwff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom nwff[2]) (setCar (cddr nwff) swff) (spliceNumericWFF nwff[2] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cddr nwff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr nwff) swff))
	         ) ; end cond
	      )) ; end ruleAvg case
		 ((= rule ruleCons:) (setq wff swff))
		 ((= rule ruleCos:) (goto UnarySplice:))
		 ((= rule ruleCube:) (goto UnarySplice:))
		 ((= rule ruleDiv:) (goto BinarySplice:))
		 ((= rule ruleExp:) (goto UnarySplice:))
		 ((= rule ruleExpression:) (goto UnarySplice:))
		 ((= rule ruleExpt:) (goto BinarySplice:))
		 ((= rule ruleIf:)
	      (begin
	        IfSplice::
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .25)) (if (isAtom wff[1]) (setCar (cdr wff) swff) (spliceNumericWFF wff[1] swff point)))
	         ;; Case: Pass the splice request to the next level through argument three.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[3]) (setCar (cdddr wff) swff) (spliceNumericWFF wff[3] swff point)))
	         ;; Case: Pass the splice request to the next level through argument four.
	         ((and (= stopHereSW false) (< argPoint .75)) (if (isAtom wff[4]) (setCar (cddddr wff) swff) (spliceNumericWFF wff[4] swff point)))
	         ;; Case: Pass the splice request to the next level through argument five.
	         ((and (= stopHereSW false) (>= argPoint .75)) (if (isAtom wff[5]) (setCar (cdr (cddddr wff)) swff) (spliceNumericWFF wff[5] swff point)))
	         ;; Case: Replace argument five of this level.
	         ((>= argPoint .75) (setCar (cdr (cddddr wff)) swff))
	         ;; Case: Replace argument four of this level.
	         ((>= argPoint .50) (setCar (cddddr wff) swff))
	         ;; Case: Replace argument three of this level.
	         ((>= argPoint .25) (setCar (cdddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cdr wff) swff))
	         ) ; end cond
	      )) ; end ruleIf case
		 ((= rule ruleFrac:) (goto UnarySplice:))
		 ((= rule ruleInt:) (goto UnarySplice:))
		 ((= rule ruleInv:) (goto UnarySplice:))
		 ((= rule ruleLog:) (goto UnarySplice:))
		 ((= rule ruleMax:) (goto MultiarySplice:))
		 ((= rule ruleMin:) (goto MultiarySplice:))
		 ((= rule ruleMod:) (goto BinarySplice:))
		 ((= rule ruleMul:) (goto BinarySplice:))
		 ((= rule ruleName:) (setq wff  swff))
		 ((= rule ruleNeg:) (goto UnarySplice:))
		 ((= rule ruleNoise:) (setq wff swff))
		 ((= rule ruleNop:) (goto UnarySplice:))
		 ((= rule ruleProd:) (goto MultiarySplice:))
		 ((= rule ruleSigmoid:) (goto UnarySplice:))
		 ((= rule ruleSign:) (goto UnarySplice:))
		 ((= rule ruleSin:) (goto UnarySplice:))
		 ((= rule ruleSqrt:) (goto UnarySplice:))
		 ((= rule ruleSquare:) (goto UnarySplice:))
		 ((= rule ruleSub:) (goto BinarySplice:))
		 ((= rule ruleSum:) (goto MultiarySplice:))
		 ((= rule ruleTan:) (goto UnarySplice:))
		 ((= rule ruleTanh:) (goto UnarySplice:))
		 ((= rule ruleVar:) (setq wff swff))
		 ((= rule ruleVop:)
	      (begin
	        (cond
	         ;; Case: Pass the splice request to the next level through argument one.
	         ((and (= stopHereSW false) (< argPoint .50)) (if (isAtom wff[2]) (setCar (cddr wff) swff) (spliceNumericWFF wff[2] swff point)))
	         ;; Case: Pass the splice request to the next level through argument two.
	         ((= stopHereSW false) (if (isAtom wff[3]) (setCar (cdddr wff) swff) (spliceNumericWFF wff[3] swff point)))
	         ;; Case: Replace binary argument two of this level.
	         ((> argPoint .50) (setCar (cdddr wff) swff))
	         ;; Case: Replace binary argument one of this level.
	         (else (setCar (cddr wff) swff))
	         ) ; end cond
	      )) ; end ruleVop case
	     (else (error (append "gsm.expressionGrammarGso.spliceNumericWFF: unknown WFF grammar rule [" rule "]")))
	     ) ; end cond
		wff) ; end spliceNumericWFF    
	
    ;; *******************************************************************************
    ;; Define Expression grammar production Rules 
    ;; *******************************************************************************

	(defun ruleAbs(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric absolute function such as "abs(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(" (evalRule wff1) ")"))
	    source) ; end ruleAbs    
	
	(defun ruleAdd(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric addition such as "x1 + xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " + " (evalRule wff2) ")"))
	    source) ; end ruleAdd    
	    
	(defun ruleAvg(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric average such as "avg(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "avg(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleAvg    
	    
	(defun ruleCons(Integer:constantID)
	;; *******************************************************************
	;; summary:  Return an constant name c0 thru cK only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     constantID  An Integer in the range 0 thru K.
	;;           
	;; Return:   name        A constant name c0 thru cK.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an constant name.
	    (setq name (append "c" constantID))
	    (symbol name)) ; end ruleCons  
	    
	(defun ruleCos(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cosine function such as "cos(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "cos(" (evalRule wff1) ")"))
	    source) ; end ruleCos    
	    
	(defun ruleCube(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric cube function such as "(x1*x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleCube    
	    
	(defun ruleDiv(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric protected division such as "(x1/xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " / " (evalRule wff2) ")"))
	    source) ; end ruleDiv    
	    
	(defun ruleExpression(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric exp function such as "exp(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (evalRule wff1))
	    source) ; end ruleExpression    
	    
	(defun ruleExp(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator exponential function such as "exp(x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff      The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "exp(" (evalRule wff) ")"))
	    source) ; end ruleExp    
	    
	(defun ruleExpt(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator exponent function such as "expt(abs(x1),x2)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "expt(abs(" (evalRule wff1) ") ," (evalRule wff2) ")"))
	    source) ; end ruleExpt    
	   
	(defun ruleFrac(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric fraction function such as "fraction(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "fraction(" (evalRule wff1) ")"))
	    source) ; end ruleFrac    

	(defun ruleFrm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple factor regression statement 
    ;;           such as 
    ;;                     "frmregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple factor regression statement such as "frmregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleFrm.wffSource genome))
	    source) ; end ruleFrm    
	    
	(defun ruleIf(wff1 relop wff2 wff3 wff4)
	;; *******************************************************************
	;; summary:  Return a Estimator if expression such as "(if (x1 == x2) {5.0} else {1.0})", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           relop    The relational operator (< <= == <> >= >).
	;;           wff2     The second expression.
	;;           wff3     The then expression.
	;;           wff4     The else expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(if (" (evalRule wff1) " " (string relop) " " (evalRule wff2) ") {" (evalRule wff3)  "} else {" (evalRule wff4) "})"))
	    source) ; end ruleIf    
	    
	
	(defun ruleInt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "number(integer(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "ninteger(" (evalRule wff1) ")"))
	    source) ; end ruleInt    
	    
	(defun ruleInv(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator inverted numeric WFF, such as (1.0 / x4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The inverion of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (/ wff))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGso.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGso.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGso.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGso.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGso.ruleInv: invalid WFF grammar rule for inversion [" rule "]")))
	     (else (setq expression (append "(1.0 / " (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleInv    
	
	(defun ruleLog(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric log function such as "log(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "log(" (evalRule wff1) ")"))
	    source) ; end ruleLog    
	    
	(defun ruleMax(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric maximum such as "max(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "max(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMax    
	
	(defun ruleMdl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator model statement such as "model x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the model statement.
	;;           
	;; Return:   result      A Estimator model statement such as "model x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMdl.wffSource genome))
	    source) ; end ruleMdl    
	    
	(defun ruleMin(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric minimum such as "min(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "min(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleMin    
	    
	(defun ruleMod(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric modulus such as "(x1%xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    ;; Return the modulus of the specified arguments.
	    (setq source (append "(" (evalRule wff1) " % " (evalRule wff2) ")"))
	    source) ; end ruleMod    
	    
	(defun ruleMul(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric multiplication such as "x1 * xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " * " (evalRule wff2) ")"))
	    source) ; end ruleMul    
	    
	(defun ruleMvl(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multiple linear regression statement 
    ;;           such as 
    ;;                     "mvlregress (23.4*x3,2.1*x10);"
    ;;  
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator multiple linear regression statement such as "mvlregress (23.4*x3,2.1*x10);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleMvl.wffSource genome))
        source) ; end ruleMvl    
	    
	(defun ruleName(elementID)
	;; *******************************************************************
	;; summary:  Return an element name xtime, xid, x1 thru xm only as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru M.
	;;           
	;; Return:   name        An element name xtime, xid, or x1 thru xm.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name WGE.
	    (setq name (append "x" elementID))
	    (symbol name)) ; end ruleName    
	    
	(defun ruleNeg(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator negative numeric WFF, such as -x1 or -(x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The negation of the specified wff.
	;;
	;; *******************************************************************
	    vars:(expression rule)
	    ;; Return the negative of the specified WFF.
	    (setq rule wff[0])
	    (cond
	     ((isNumber wff) (return (string (- wff))))
	     ((= rule ruleAdd:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleAvg:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleDiv:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleFrm:) (error (append "gsm.expressionGrammarGso.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleIf:) (setq expression (evalRule (list rule wff[1] wff[2] wff[3] (list ruleNeg: wff[4])  (list ruleNeg: wff[5])))))
	     ((= rule ruleMdl:) (error (append "gsm.expressionGrammarGso.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleMul:) (setq expression (if (isNumber wff[2]) (evalRule (list rule wff[1] (list ruleNeg: wff[2]))) (evalRule (list rule (list ruleNeg: wff[1]) wff[2])))))
	     ((= rule ruleMvl:) (error (append "gsm.expressionGrammarGso.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleNeg:) (setq expression (evalRule wff[1])))
	     ((= rule ruleSign:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])))))
	     ((= rule ruleSub:) (setq expression (evalRule (list rule (list ruleNeg: wff[1])  (list ruleNeg: wff[2])))))
	     ((= rule ruleReg:) (error (append "gsm.expressionGrammarGso.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     ((= rule ruleSvm:) (error (append "gsm.expressionGrammarGso.ruleNeg: invalid WFF grammar rule for negation [" rule "]")))
	     (else (setq expression (append "(-" (evalRule wff) ")")))
	     ) ; end cond
	    expression) ; end ruleNeg    
	
	(defun ruleNoise(elementID)
	;; *******************************************************************
	;; summary:  Return an element random noise reference e0 or e1 as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru K.
	;;           
	;; Return:   name        An element random noise reference e0 or e1.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name ek.
	    (setq name (append "e" elementID))
	    (symbol name)) ; end ruleNoise    
	    
	(defun ruleNop(wff)
	;; *******************************************************************
	;; summary:  Return a Estimator no operation numeric WFF, such as x1 or (x2 / 4), 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff         A Estimator numeric WFF.
	;;           
	;; Return:   expression  The specified wff.
	;;
	;; *******************************************************************
	    ;; Return the specified WFF.
	    (evalRule wff)) ; end ruleNop    
	    
	(defun ruleProd(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "product(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "product(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleProd    
	    
	(defun ruleReg(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator regress statement such as "regress x3;" 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "regress x3*x5;"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleReg.wffSource genome))
	    source) ; end ruleReg    
	    
	(defun ruleSigmoid(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric integer function such as "sigmoid(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "abs(fraction(" (evalRule wff1) "))"))
	    source) ; end ruleSigmoid    
	    
	(defun ruleSign(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sign function such as "sign(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sign(" (evalRule wff1) ")"))
	    source) ; end ruleSign    
	
	
	(defun ruleSin(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sine function such as "sin(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sin(" (evalRule wff1) ")"))
	    source) ; end ruleSin    
	
	(defun ruleSqrt(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sqrt function such as "sqrt(abs(x1))", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "sqrt(" (evalRule wff1) ")"))
	    source) ; end ruleSqrt    
	    
	(defun ruleSquare(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric square function such as "(x1*x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) "*" (evalRule wff1) ")"))
	    source) ; end ruleSquare    
	    
	(defun ruleSub(wff1 wff2)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric subtraction such as "x1 - xm", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "(" (evalRule wff1) " - " (evalRule wff2) ")"))
	    source) ; end ruleSub    
	    
	(defun ruleSum(wff1 wff2 ...)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric sum such as "sum(x1,xm)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           wff2     The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
        regs:(n N)
	    vars:(source wff)
        (setq N (argCount))
	    (setq source (append "sum(" (evalRule wff1) " , " (evalRule wff2)))
        (loop for n from 2 until N do (setq wff (argFetch n)) (setq source (append source " , " (evalRule wff))))
	    (setq source (append source ")"))
	    source) ; end ruleSum    
	    
	(defun ruleSvm(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator SVM statement such as "svmregress(x1,x2,x3);". 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     genome      The sparse vector of numeric expressions for the svmregress statement.
	;;           
	;; Return:   result      A Estimator regress statement such as "svmregress(x3,x5);"
	;;
	;; *******************************************************************
	    vars:(source)
        (setq source (gsm.ruleSvm.wffSource genome))
	    source) ; end ruleSvm    

	    
	(defun ruleTan(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric tangent function such as "tan(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tan(" (evalRule wff1) ")"))
	    source) ; end ruleTan    
	    
	(defun ruleTanh(wff1)
	;; *******************************************************************
	;; summary:  Return a Estimator numeric hyper tangent function such as "tanh(x1)", 
	;;           as an ASCI string in grammatically correct estimator.
	;;
	;; args:     wff1     The first expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(source)
	    (setq source (append "tanh(" (evalRule wff1) ")"))
	    source) ; end ruleTanh    
	    
	(defun ruleVar(elementID)
	;; *******************************************************************
	;; summary:  Return an element variable reference v0, v1 thru vK as 
	;;           an ASCI string in grammatically correct estimator.
	;;
	;; args:     elementID   An Integer in the range 0 thru K.
	;;           
	;; Return:   name        An element variable reference v0, v1 thru vK.
	;;
	;; *******************************************************************
	    vars:(name)
	    ;; Return an element name vk.
	    (setq name (append "v" elementID))
	    (symbol name)) ; end ruleVar    
	    
	(defun ruleVop(functionID wff1 wff2)
	;; *******************************************************************
	;; summary:  Return an Estimator numeric abstract operator such as 
    ;;           "f0(x1,x2)", as an ASCI string in grammatically correct 
    ;;           estimator.
	;;
	;; args: 	 functionID	The first expression.
	;;           wff1     	The first expression.
	;;           wff2     	The second expression.
	;;           
	;; Return:   source   The resulting numeric Estimator WFF expression
	;;
	;; *******************************************************************
	    vars:(fname source name)
	    ;; Return the modulus of the specified arguments.
	    (setq name (symbol (append "f" functionID)))
	    (setq source (append name "(" (evalRule wff1) "," (evalRule wff2) ")"))
	    source) ; end ruleVop    
	
	;; *******************************************************************
    ;; Begin main logic
	;; *******************************************************************
    vars:(wffHdr sourceWff)
    (if (isString wff) then (setq wff (listWff wff)))
    (if (isPair wff) 
        (setq sourceWff (apply (setq wffHdr gsm.expressionGrammarGso[(car wff)]) (cdr wff))) 
        (setq sourceWff (string wff true))
        ) ; end if
    sourceWff) ; end expressionGrammarGso




































































































































;;**EXPORTKEY**:gsm.frmRegress
(deforphan gsm:frmRegress(X Y)
;; *******************************************************************
;; name:     frmRegress
;; 
;; summary:  Trains a factor model regression Lambda, using a factor model 
;;           algorithm and returns the trained regression Lambda.
;;
;;           Factor model learning machines are regression machines which learn
;;           and make regression estimates on XY vector arrays such as:
;;
;;               XY:  An N by M+1 array representing the original observations
;;                    in the form of:    x x x ...  y
;;                                       x x x ...  y
;;                                           ... 
;;                                       x x x ...  y
;;
;;           Factor Model Machines normalize the X Y training data by converting each
;;           X column and the Y column into unit quantities which reflect the number
;;           units of standard deviation they are away from the mean of the specified
;;           column. For example, if x1 contain a value equal to the mean of x1, then
;;           that value will be converted to zero. Whereas if x1 contains a value which
;;           lies exactly one unit of standard deviation above from the mean of x1, then
;;           such a value would be converted to 1.0.
;;
;;           The FRM regression is essentially a sequencing operation which attempts to
;;           predictively order the X examples in terms of the relative size of their
;;           corresponding Y value. 
;;
;;           The FRM is a normalized learning algorithm, therefore each x variable is
;;           first normalized before learning. Since, relative normalized value, not
;;           absolute value, is important, the FRM should be rescaled before estimates
;;           are made on a new data set. 
;;
;;
;; Parms:    X:         The N by M vector array representing the original observations
;;                      in the form of:    x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;           Y   		The N vector of dependent variables.
;;
;; Return:   Rf:     A new factor model machine Lambda ready for regression.
;; *******************************************************************
    pvars:(;; Public variables
           Number:NLSE                  ;; The current absolute error for the FRM regression model (in percent of target). 
           myFRMParent                  ;; The parent Lambda of this FRM regression Lambda community. 
           NumVector:myColumnAVGs		;; The vector of average values in each of the training columns (independent variables). 
           NumVector:myColumnSTDs		;; The vector of low values in each of the training columns (independent variables). 
           Number:myYAVG                ;; The average Y value for the FRM regression model.
           Number:myYSTD                ;; The standard deviation of Y value for the FRM regression model.
           Integer:myM					;; The number of elements in each training example (all variables). 
           myVerboseSW      			;; True iff we are to display progress on the console. 
           NumVector:myW                ;; The weight coefficient vector for the FRM regression model.
           ;; Public child methods
           clear			       		;; Clear the current factor model machine.
           frmLambda			       		;; Return an Lambda ready to compute the frm output for specified input vector.
	       multipleRegression           ;; Performs a Gaussian multiple regression on the X Y training data
           train    		       		;; Train the frm machine on the specified training examples.
           rescale   		       		;; Reset the frm machines column highs, lows, and ranges on the specified training examples.
           ;; Private maintenance child methods
           selfTest                		;; The self test method for this Lambda. 
           ) ;; end of persistent variables
    ;; ***************************
    ;; Define Public Child Lambdas.
    ;; ***************************
    ;; Clear the current factor model machine.
    (defun clear()
       (setq NLSE 0.0)
       (setq myM 0)
       (setq myW #void)
       true) ; end clear
    ; Return an Lambda ready to compute the frm output for specified input points.
    (defun frmLambda()
       regs:(n m NW)
       vars:(NumVector:hW Vector:hKX ObjVector:hWX)
       vars:(Lambda HRecord)
       (setq Lambda (eval 
        {(lambda(NumVector:xv) 
         pvars:(Strategy Number:NLSE NumVector:myColumnAVGs NumVector:myColumnSTDs Integer:myM NumVector:myW rescale) 
	     (defun rescale(X)
	        regs:(k K m M n N nn)
	        regs:(Number:wx Number:wn Number:wxn Number:ax Number:ey Number:y Number:RN)
	        vars:(result NumVector:x)
		    (setq N (length X))
		    (setq M (length X[0]))
		    (if (<> myM M) (error "frmRegress.rescale: must be at least one column."))
	        (setq myColumnAVGs (new Vector: Number: myM)) 
	        (setq myColumnSTDs (new Vector: Number: myM)) 
			;; Compute the column highs, lows, and ranges.
	        (vmregRunInHardware start:)
	        (setq RN (/ 1.0 N))
	        (loop for m from 0 until M do (setq myColumnAVGs[m] 0.0) (setq myColumnSTDs[m] 0.0))
	        (loop for n from 0 until N do
	           (setq x X[n])
	           (loop for m from 0 until M do 
	              (setq wx x[m]) 
	              (setq wn (* wx RN)) 
	              (setq wxn (* wx wx RN)) 
	              (setq ax myColumnAVGs[m]) 
	              (+= ax wn) 
	              (setq myColumnAVGs[m] ax)
	              (setq ax myColumnSTDs[m]) 
	              (+= ax wxn) 
	              (setq myColumnSTDs[m] ax)
	              ) ; end M loop 
	           ) ; end N loop
	        (loop for m from 0 until M do 
	           (setq wx myColumnSTDs[m]) 
	           (setq ax myColumnAVGs[m]) 
	           (-= wx (* ax ax)) 
	           (setq wx (* (+ (sqrt (abs wx)) .000000000001) 1.000000000001))
	           (setq myColumnSTDs[m] wx)
	           ) ; end M loop 
	        (vmregRunInHardware stop:)
	        true)
         regs:(m Number:wx Number:wn Number:ax Number:sx Number:ey) 
         (setq ey 0.0)
         (loop for m from 0 until myM do
            (setq ax myColumnAVGs[m]) 
            (setq sx myColumnSTDs[m]) 
            (setq wx xv[m]) 
            (-= wx ax)
            (/= wx sx) 
            (setq wn myW[m]) 
            (*= wx wn) 
            (+= ey wx)  
            )
          ey)
        }))
       ;; Move all important knowledge structures into the trained regression Lambda.
       (setq Lambda.Strategy FRM:)
       (setq Lambda.NLSE 1.0e+300)
       (setq Lambda.myColumnAVGs myColumnAVGs)
       (setq Lambda.myColumnSTDs myColumnSTDs)
       (setq Lambda.myM myM)
       (setq Lambda.myW myW)
       Lambda) ; end frmLambda
    ;; summary:  Performs a Gaussian multiple regression on the X Y training data
    ;; Return:   myW:    The weight coefficient vector for the regression model.
    ;; Note1:    Average error statistics are computed as a percent of the target (dependent variable).
    ;; Note2:    See Sedgewick[2] chap 37.
    (defun multipleRegression(ObjVector:X NumVector:Y)
       regs:(m M n N MY NumPointer:pmxy Number:wx Number:y)
       vars:(NumMatrix:Xt NumVector:x NumVector:C NumMatrix:MXY)
       ;; Convert X Y vector input to a Matrix format.
       (setq N (length X))
       (setq M (length X[0]))
       (setq MY (+ M 1))
       (if (<> N (length Y)) (error "frmRegress.multipleRegression: X and Y vectors must be same length"))
       (setq MXY (new Matrix: number: 2 N MY))
       (vmregRunInHardware start:)
       (setq pmxy MXY)
       (loop for n from 0 until N do
          (setq x X[n])
          (loop for m from 0 until M do
            (setq wx x[m])
            (setq wx (/ (- wx myColumnAVGs[m]) myColumnSTDs[m]))
            (setq pmxy[0] wx)
            (++ pmxy)
            ) ; end n loop
          (setq y Y[n])
          (setq y (/ (- y myYAVG) myYSTD))
          (setq pmxy[0] y)
          (++ pmxy)
          ) ; end m loop
       (vmregRunInHardware stop:)
       ;; Perform a least squares regression on all the factors.
       (setq Xt (|Gv:makeGaussianMatrix| MXY))
       (setq Xt (|Gv:matrixGaussianEliminate| Xt true))
       (setq myW (|Gv:matrixGaussianSubstitute| Xt))
       ;; Return the weight coefficient vector for the regression model.
       myW) ; end multipleRegression
    ;; Train the frm machine on the specified inputs and model.
	;; Parms:    X:         The N by M vector array representing the original observations
	;;                      in the form of:    x x ... x
	;;                                         x x ... x
	;;                                             ... 
	;;                                         x x ... x
	;;           Y   		The N vector of dependent variables.
    ;;
    ;; Return:   Rf:        A new factor model machine Lambda ready for regression.
    (defun train(X NumVector:Y)
        regs:(k K m M n N nn)
        regs:(Number:wx Number:wn Number:wxn Number:ax Number:ey Number:y Number:RN)
        vars:(result NumVector:x)
	    ;; Clear factor model machine for retraining.
	    (clear)
		;; Initialize the persistent variables before proceeding with training.
	    (if (or (<> (isVector X) true) (<> (isVector X[0]) true)) (error "frmRegress.train: X argument must be a Vector Array of rank 2"))
	    (setq N (length X))
	    (if (or (<> (isVector Y) true) (<> (length Y) N)) (error "frmRegress.train: Y argument must be a Vector of length the same as X"))
	    (setq myM (length X[0]))
	    (setq M myM)
	    (if (<= myM 0) (error "frmRegress.train: must be at least one column."))
		(setq NLSE 1.0e300)
        (setq myColumnAVGs (new Vector: Number: myM)) 
        (setq myColumnSTDs (new Vector: Number: myM)) 
        (setq myYAVG (avg Y)) 
        (setq myYSTD (stdev Y)) 
		;; Compute the column highs, lows, and ranges.
        (vmregRunInHardware start:)
        (setq RN (/ 1.0 N))
        (loop for m from 0 until M do (setq myColumnAVGs[m] 0.0) (setq myColumnSTDs[m] 0.0))
        (loop for n from 0 until N do
           (setq x X[n])
           (loop for m from 0 until M do 
              (setq wx x[m]) 
              (setq wn (* wx RN)) 
              (setq wxn (* wx wx RN)) 
              (setq ax myColumnAVGs[m]) 
              (+= ax wn) 
              (setq myColumnAVGs[m] ax)
              (setq ax myColumnSTDs[m]) 
              (+= ax wxn) 
              (setq myColumnSTDs[m] ax)
              ) ; end M loop 
           ) ; end N loop
        (loop for m from 0 until M do 
           (setq wx myColumnSTDs[m]) 
           (setq ax myColumnAVGs[m]) 
           (-= wx (* ax ax)) 
           (setq wx (* (+ (sqrt (abs wx)) .000000000001) 1.000000000001))
           (setq myColumnSTDs[m] wx)
           ) ; end M loop 
        (vmregRunInHardware stop:)
		;; Perform a multiple linear regression for training.
        (setq myW (multipleRegression X Y))
		;; Return a factor model regression Lambda.
        (setq result (frmLambda))
        result) ; end train
    ;; Reset the frm machines column highs, lows, and ranges on the specified training examples.
    ;; Note: This happens when the FRM has been trained on one data set and is to be tested on another data set.
    ;;       The FRM is a ranked learning machine, so rescaling may be necessary for each test data set.
    (defun rescale(X)
        regs:(k K m M n N)
        regs:(Number:RM)
        regs:(Number:wx Number:ax Number:ey Number:y Number:RN)
        vars:(result NumVector:x NumVector:GYcount)
	    ;; Initialize the untrained FRM model.
	    (if (or (<> (isVector X) true) (<> (isVector X[0]) true)) (error "frmRegress.rescale: X argument must be a Vector Array of rank 2"))
	    (setq M (length X[0]))
	    (setq N (length X))
	    (if (< M myM) (error "frmRegress.rescale: number of columns must match training data set."))
		;; Initialize the persistent variables before proceeding with training.
        (setq myColumnAVGs (new Vector: Number: myM)) 
        (setq myColumnSTDs (new Vector: Number: myM)) 
		;; Compute the column highs, lows, and ranges.
        (vmregRunInHardware start:)
        (setq RN (/ 1.0 N))
        (loop for m from 0 until M do (setq myColumnAVGs[m] 0.0) (setq myColumnSTDs[m] 0.0))
        (loop for n from 0 until N do
           (setq x X[n])
           (loop for m from 0 until M do (setq wx x[m]) (+= myColumnAVGs[m] (* wx RN)))
           ) ; end N loop
        (loop for n from 0 until N do
           (setq x X[n])
           (loop for m from 0 until M do (setq wx x[m]) (setq ax myColumnAVGs[m]) (+= myColumnAVGs[m] (* (- wx ax) (- wx ax) RN)))
           ) ; end N loop
        (loop for m from 0 until M do (setq myColumnSTDs[m] (* (+ (sqrt myColumnSTDs[m]) .000000000001) 1.000000000001)))
        (vmregRunInHardware stop:)
        true) ; end rescale
    ;; ****************************************
    ;; Define Private Maintenance Child Lambdas.
    ;; ****************************************
    ;; The self test method for this Lambda.
    (defun selfTest(Test Ns Ms Es)
       vars:(k m M n N g G y ey C c X Y Yv avgY avgTopEy topEyCnt
             Lambda err Net pct sortedY 
             eyGrid eyGridCount eyGridSize errScore 
             startTime endTime startTimeT endTimeT
             (checkResults true)
             (tol 0.0) (errStop 0.01) (Cs 1.0)
             ) ; end temporary variables
       (clear)
       (setq startTimeT (getTickCount 0))
       (gsm.setRandomSeed 8192.0)
       (setq eyGridSize Es)
       ;; Select the requested test case
       ;; Test Case srandom 
       (if (or (= Test all:) (= Test linear:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] + C[3]*X[3] + C[4]*X[4] ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: linear")
		       (setq Lambda (setq Lambda (gsm.frmRegress.train X Y)))
		       (writeln "frmRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (Lambda.rescale X)
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "frmRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], Cols=[" myM "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case linear
       ;; Test Case mixedRandom 
       (if (or (= Test all:) (= Test mixed:))
           (begin
		       ;; Create a test polynomial linear model where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] ...
		       ;; Create a test polynomial square model where y = C[0]*X[0]*X[0] + C[1]*X[1]*X[1] + C[2]*X[2]*X[2] ...
		       ;; Create a test polynomial sin model where y = C[0]*sin(X[0]) + C[1]*sin(X[1]) + C[2]*sin(X[2]) ...
		       ;; Create a test polynomial log model where y = C[0]*log(abs(X[0])+.000001) + C[1]*log(abs(X[1])+.000001) + C[1]*log(abs(X[2])+.000001) ...
               ;; These four models are mixed together and random noise is added.
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
                     (cond
                        ;; Linear model
                        ((= k 0) (setq y (+ y (* X[n][m] C[m]))))
                        ;; Square model
                        ((= k 1) (setq y (+ y (* X[n][m] X[n][m] C[m]))))
                        ;; Sine model
                        ((= k 2) (setq y (+ y (* (|Gv:sin| X[n][m]) C[m]))))
                        ;; Log model
                        (else (setq y (+ y (* (|Gv:log| (+ .000001 (|Gv:abs| X[n][m]))) C[m]))))
                        ) ; end cond
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: mixed")
		       (setq Lambda (setq Lambda (gsm.frmRegress.train X Y)))
		       (writeln "frmRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (cond
                        ;; Linear model
                        ((= k 0) (setq y (+ y (* X[n][m] C[m]))))
                        ;; Square model
                        ((= k 1) (setq y (+ y (* X[n][m] X[n][m] C[m]))))
                        ;; Sine model
                        ((= k 2) (setq y (+ y (* (|Gv:sin| X[n][m]) C[m]))))
                        ;; Log model
                        (else (setq y (+ y (* (|Gv:log| (+ .000001 (|Gv:abs| X[n][m]))) C[m]))))
                        ) ; end cond
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (Lambda.rescale X)
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "frmRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], Cols=[" myM "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case mixed
       ;; Test Case sigmoid 
       (if (or (= Test all:) (= Test sigmoid:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] + C[3]*X[3] + C[4]*X[4] ...
		       ;; Note1: The inputs, X, are restricted to the sigmoid domain.
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 1.0) .50))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (gsm.myRandomFunction 1.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: sigmoid")
		       (setq Lambda (setq Lambda (gsm.frmRegress.train X Y)))
		       (writeln "frmRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (gsm.myRandomFunction 1.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (Lambda.rescale X)
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "frmRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], Cols=[" myM "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case sigmoid
       ;; Test Case square 
       (if (or (= Test all:) (= Test square:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*(X[1]**2) + C[2]*X[2] + C[3]*(X[3]**2) ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* X[n][m] X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: square")
		       (setq Lambda (setq Lambda (gsm.frmRegress.train X Y)))
		       (writeln "frmRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* X[n][m] X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (Lambda.rescale X)
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "frmRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], Cols=[" myM "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case square
       ;; Test Case tan 
       (if (or (= Test all:) (= Test tan:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*tan(X[0]) + C[1]*tan(X[1]) + C[2]*tan(X[2]) ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* (tan X[n][m]) C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: tan")
		       (setq Lambda (setq Lambda (gsm.frmRegress.train X Y)))
		       (writeln "frmRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* (tan X[n][m]) C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (Lambda.rescale X)
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "frmRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], Cols=[" myM "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case tan
       (writeln "frmRegress.selfTest: completed in [" (/ (setq endTimeT (getTickCount startTimeT)) 60.0) "] minutes.")       
       Lambda) ; end selfTest
    ;; *****************
    ;; Begin main logic.
    ;; ***************** 
    vars:(Lambda frmLambda)

    ;; Train a new factor model machine Lambda.
    (setq frmLambda (new (myself)))
    (setq frmLambda.myFRMParent frmLambda)
    (setq Lambda (frmLambda.train X Y))
    Lambda) ; end frmRegress

















































































































































































;;**EXPORTKEY**:gsm.infoTheory
(defriend gsm:infoTheory()
;; ************************************************************************************
;; Summary:  This Lambda library implements utility functions inspired
;;           by information theory.
;;
;; Reference: [1] "Towards an Information Theoretic Framework for Genetic Programming",
;;                Genetic Programming Theory & Practive VI, Springer Verlag, 2008
;; ************************************************************************************
   pvars:(placeHolder			;; This is just a place holder variable
         ) ;; end of persistent variables
   regs:(n N)
   vars:(outExplain)
   ;; ***************************************************
   ;; Define the child Lambdas which belong to this parent
   ;; ***************************************************
   
   true) ;; end of infoTheory
























































































































;;**EXPORTKEY**:gsm.linearRegress
(defriend gsm:linearRegress(NumVector:X NumVector:Y)
;; *******************************************************************
;; name:     linearRegress
;; 
;; summary:  Returns a vector containing the coefficients resulting
;;           from a linear regression on two variables. If x and y 
;;           are two variables, then (regression w) is: #(a  b  error).
;;           where a + bx = y represents the least squares best fit.
;;           The term, error, is the least squares error = sqr(y - (a + bx)).
;;
;; Parms:    X:       The N Number Vector representing the original observations.
;;           Y        The N Number Vector representing the dependent variables.
;; Return:   C:       The coefficient vector #(num| a b error)
;; *******************************************************************
	regs:(M n N Number:InvN)
	regs:(Number:numerator Number:denominator Number:a Number:b Number:err)
	regs:(Number:xmean Number:xsum Number:x)
	regs:(Number:ymean Number:ysum Number:y)
	regs:(Number:xxdot Number:yydot Number:xydot)
	regs:(NumPointer:pX NumPointer:pY)
	vars:(NumVector:C NumVector:X NumVector:Y)
	(setq C (|Gv:new| Vector: Number: 3))
    (setq N (length X))
    (setq InvN (/ 1.0 (number N)))
    (setq pX X)
    (setq pY Y)
    (loop for n from 0 until N do
       (setq x pX[n])
       (setq y pY[n])
       (+= xsum x)
       (+= ysum y)
       (+= xxdot (* x x))
       (+= xydot (* x y))
       (+= yydot (* y y))
       ) ; end main loop
    (setq xmean (/ xsum N)) 
    (setq ymean (/ ysum N)) 
   	(setq numerator (- xydot (* ysum xmean)))
    (setq denominator (- xxdot (/ (* xsum xsum) N)))
   	(if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator)))
   	(setq a (- ymean (* b xmean)))
    (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) ))
   	(setq C[0] a)
   	(setq C[1] b)
    (setq C[2] (* InvN err))
	C) ; linearRegress






























































































































































;;**EXPORTKEY**:gsm.memoryCursor
(deforphan gsm:memoryCursor(tableName colNames)
;; *******************************************************************
;; Summary:  gsm generic table cursor which manages a 
;;           generic table in memory. This table cursor is built 
;;           on principles similar to relational cursors, but
;;           loads a complete copy of the table in memory.
;; Notes:    Each element in the table is called a record.
;;           The index of a table record is called its row (rows begin with zero).
;; Depends:  gsm
;; args:     tableName      The name for this new in memory table.
;;           colNames       The column name vector for this new in memory table.
;; Return:   self           This newly initialized table cursor.
;; *******************************************************************
    ;; Persistent Variables
    pvars:(;; Public variables
           fileID              ;; The file id used during import and export.
           myCursorName        ;; The unique name of this investor colony table cursor.
           myCursorNotes       ;; The notes Dictionary of this investor colony table cursor.
           myCursorScore       ;; The score of this investor colony table cursor.
           myCursorType        ;; The type of this investor colony table cursor.
           myCursorTable       ;; The investor colony table underlying this cursor.
           myDataMine          ;; The investor colony owner of this cursor.
           myIndex             ;; The schema repository for investor colony tables.
           myParent            ;; This parent cursor Lambda.
           myTableCursor       ;; The cursor for the table of this view (views only).
           showLimit           ;; The maximum number of records to display with the show function.
           bckVectorKey        ;; The repository key of the backup record view vector (bckVector).
           colCount            ;; The number of columns in the table.
           colVector           ;; The table's vector of column names.
           myMemoPad           ;; The table's memo pad (always a Dictionary).
           myObjectName        ;; The name of the table object (#void if cursor is inactive).
           myPathInFileName    ;; The input path and file name of the table object (#void if cursor is inactive).
           myPathOutFileName   ;; The output path and file name of the table object (#void if cursor is inactive).
           qtrVector           ;; The quarterly record view vector.
           recordCount         ;; The table's current total record count.
           recordStructure     ;; The table's record structure.
           validFields         ;; The table's valid fields and types (necessary for query compilation).
           rowVector           ;; The current record view vector.
           bckVector           ;; The backup record view vector.
           viewDirectory       ;; The the Directory of saved table record view vectors.
           UPDIamDirty         ;; Update has occurred switch.
           ;; Public Child Lambdas
           average             ;; Averages a lambda value on each record of a table.
           averageForAll       ;; Averages a lambda value on ALL records of a table.
           checkin             ;; Checks in an ascii tab delimited table file.
           close               ;; Terminate an update transaction on the table object.
           delete              ;; Delete the specified row from the table object.
           delimitedCells      ;; Returns a block of cells as a tab delimited string.
           deviation           ;; Returns the standard deviation of a lambda value on each record of a table.
           drop                ;; Drop all records from a table object.
           dropView            ;; Drops the specified record view.
           exportTab           ;; Exports ascii tab delimited records from the table.
           fillFromDirectory   ;; Fills a table cursor with records from a unique directory index.
           getColumnHeaders    ;; Returns the table headers as a tab delimited string.
           getNewRecord        ;; Returns a blank new record.
           importTab           ;; Imports ascii tab delimited records into the table.
           importTabIFF        ;; Imports ascii tab delimited records into the table (if and only if they exit).
           insert              ;; Insert a table row.
           insertColumn        ;; Insert a table column.
           isView              ;; Returns true iff the specified key is a saved view of this cursor.
           maximum             ;; Returns the max of a lambda value on each record of a table.
           minimum             ;; Returns the min of a lambda value on each record of a table.
           newIndex            ;; Creates unique index of each record in a table.
           newMemoPadIndex     ;; Creates unique memoPad index of each record in a table.
           omit                ;; Deletes those records from a table for which a lambda predicate is true.
           read                ;; Read a table row for later update.
           readByKey           ;; Read a table row for later update (using the specified index key).
           readLast            ;; Read the last table row for later update.
           refExport           ;; Returns a record, for export, to the exportTab function.
           refImport           ;; Returns an empty record to the importTab function.
           reset               ;; Resets the backup copy and views of the investor colony table.
           restore             ;; Restores the backup copy of the investor colony table.
           restoreView         ;; Restore the specified record view.
           run                 ;; Run the specified javaFilter Lambda against this cursor.
           save                ;; Save the contents of the table cursor back to disk.
           saveView            ;; Save the current record view for later retrieval.
           search              ;; Returns the row index for the first record for which a lambda predicate is true.
           setImport           ;; Receives a single record from the importTab function.
           sharpe              ;; Returns the sharpe ratio of a lambda value on each record of a table.
           show                ;; Shows a group of records starting from the specified row.
           sort                ;; Sort the table rows using a lambda sort function.
           total               ;; Totals a lambda value on each record of a table.
           totalForAll         ;; Totals a lambda value on ALL records of a table.
           truncate            ;; Truncates a table to those records for which a lambda predicate is true.
           updateView          ;; Updates each record in the current view and restores the altered backup view.
           write               ;; Write a table row, perhaps previously read, for update.
           writeByKey          ;; Write a table row (using the specified index key).
           writeLast           ;; Write a new table row, to the end of the table, for update.
           ;; Private Child Lambdas
           __clear             ;; Clears the memory cursor.
           __errorStop         ;; Handles error conditions during sensitive operations.
           __open              ;; Begin an update transaction on a table object.
           __truncateEnds      ;; Truncate records from both ends of a table.
           __truncateMid       ;; Truncate records from the center of a table.
          ) ;; end of persistent variables
    ;; Temporary Variables
    vars:(myCopy)
    ;; Initialize the inline child Lambdas.
    ;; *******************************************************************
    ;; Summary:  Averages a lambda value on each record of a table.
    ;; *******************************************************************
    (defun average(valueLambda)
       vars:(result) 
       (setq result (total valueLambda))
       (if (isPositive recordCount) 
           (/= result recordCount)
           (setq result #void)
           ) ; end if
       result) ; end average
    ;; *******************************************************************
    ;; Summary:  Averages a lambda value on ALL records of a table.
    ;; *******************************************************************
    (defun averageForAll(valueLambda)
       vars:(result) 
       (setq result (totalForAll valueLambda))
       (if (isPositive (length bckVector)) 
           (/= result (length bckVector))
           (setq result #void)
           ) ; end if
       result) ; end averageForAll
    (defun checkin()
    ;; *******************************************************************
    ;; Summary:  Checks in an ascii tab delimited table file.
    ;; *******************************************************************
       (exportTab myPathOutFileName)) ;; end of checkin
    (defun close()
    ;; *******************************************************************
    ;; Summary:  Terminates an update transaction on the table cursor.
    ;; *******************************************************************
       (__clear)
       (setq myObjectName #void)
       (setq myIndex #void)
       (setq colVector #void)
       (setq colCount #void)
       (setq validFields #void)
       (setq colVector #void)
       (setq recordStructure #void)
       (setq myCursorType #void)
       (setq showLimit #void)
       (setq myParent #void)
       (setq myTableCursor #void)
       (setq myCursorNotes #void)
       (setq viewDirectory #void)
       (setq myMemoPad #void)
       (setq colCount #void)
       true) ;; end of close
    (defun delete(row)
    ;; *******************************************************************
    ;; Summary:  Delete the specified row from the table object.
    ;; Args:     row      Row number of row to be deleted.
    ;; Return:   true     Always return true. 
    ;; *******************************************************************
       ;; Make sure the row number is valid.
       (if (or (< row 0) (>= row recordCount))
           (error (append "badRowIndex" 
                          "memoryCursor:delete:" myObjectName " - " row
                          ":An attempt was made to delete with a bad row number.")))
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       (^delete rowVector row)
       (setq recordCount (length rowVector))
       true) ;; end of delete
    (defun delimitedCells(startRow endRow startCol endCol)
    ;; *******************************************************************
    ;; Summary:  Returns a block of cells as a tab delimited string.
    ;; *******************************************************************
       vars:(rowIndex colIndex dls tab cellValue record) 
       ;; Return a tab delimited string of cell values for
       ;; all cells between the following rows and columns.
       (setq dls "")
       (setq tab (append "" (char 09)))
       (if (> startRow endRow) (return dls))
       (loop for rowIndex from startRow to endRow do
          (if (< rowIndex recordCount)
              (setq record (read rowIndex))
              (setq record #void)
              ) ; end if
          (loop for colIndex from startCol to endCol do
              (setq cellValue record[colIndex])
              (if (isString cellValue) (setq cellValue (substitute cellValue tab " ")))
              (if (= cellValue #void) (setq cellValue ""))
              (if (isVector cellValue) (setq cellValue (string cellValue true)))
              (setq cellValue (append "" cellValue)) 
              (setq cellValue (substitute cellValue (char 09)  " "))
              (setq cellValue (substitute cellValue (char 13)  " "))
              (if (<> colIndex endCol) 
                  (setq dls (append dls cellValue (char 09)))
                  (setq dls (append dls cellValue))
                  ) ; end if
              ) ;;end column loop
          (if (<> rowIndex endRow) 
              (setq dls (append dls (char 13)))
              ) ; end if
          ) ;;end row loop
       (append dls "")) ;; end of delimitedCells
    (defun deviation(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Returns the standard deviation of a lambda value on each 
    ;;           record of a table.
    ;; *******************************************************************
       vars:(rowIndex (result 0) score aSum aSsq anAvg)
       (if (<= recordCount 0) (return 0))
       ;; Compute the stadard devisation lambda value for each record in the table.
       (loop for rowIndex from 0 until recordCount do
           (setq score (totalLambda rowVector[rowIndex]))
           (setq aSum (+ aSum score))
           (setq aSsq (+ aSsq (* score score)))
           ) ;; end loop
       (setq anAvg (/ aSum recordCount))
       (setq result (sqrt (- (/ aSsq recordCount) (* anAvg anAvg))))
       result) ;; end deviation
    (defun drop()
    ;; *******************************************************************
    ;; Summary:  Drops all records from the table.
    ;; *******************************************************************
       (__clear)) ;; end of drop
    (defun dropView(key)
    ;; *******************************************************************
    ;; Summary: Drops the current record view as specified.
    ;; *******************************************************************
       (setq viewDirectory[key] 1)
       (delete viewDirectory key)
       true) ;; end of dropView
    (defun exportTab(fileName)
    ;; *******************************************************************
    ;; Summary:  Exports ascii tab delimited records from the table.
    ;; *******************************************************************
       ;; Make sure we catch all errors which might occur.
       (onError __errorStop)
       ;; Open the specified .tab file and export.
       (setq fileID (fileOpen fileName 1 0))
       (^exportTab fileID myParent recordVectors:)
       (fileClose fileID 1)
       (setq fileID #void)
       recordCount) ;; end exportTab
    (defun fillFromDirectory(theDirectory)
    ;; *******************************************************************
    ;; Summary:  Fills a table cursor with records from a unique directory index.
    ;; *******************************************************************
       vars:(record rowIndex numRecords colIndex)
       ;; Make sure the backup records are used to create the index.
       (__clear)
       (setq numRecords (length theDirectory))
       (setq myMemoPad theDirectory)
       (if (<= numRecords 0) (return numRecords))
       ;; Place all records in the index.
       (loop for rowIndex from 0 until numRecords do
           (setq record theDirectory[rowIndex 1])
           (write rowIndex record)
           ) ;; end loop
       recordCount) ;; end fillFromDirectory
    (defun getColumnHeaders(startCol endCol) 
    ;; *******************************************************************
    ;; Summary:  Returns the table headers as a tab delimited string.
    ;; *******************************************************************
       vars:(colIndex dls colName)  
       (setq dls "")
       (loop for colIndex from startCol to endCol do
           (setq colName (string colVector[colIndex]))
           (if (= colName "#void") (setq colName ""))
           (if (= (left colName 1) "|") (setq colName (mid colName 1 (subi (length colName) 2))))
           (if (<> colIndex endCol) 
               (setq dls (append dls colName (char 09)))
               (setq dls (append dls colName))
               ) ; end if
           ) ;;end column loop
       (append dls "")) ;; end getColumnHeaders
    ;; Summary:  Returns a blank new record.
    (defun getNewRecord() (copy recordStructure))
    (defun importTab(fileName)
    ;; *******************************************************************
    ;; Summary:  Performs an import tab transaction on the table cursor.
    ;; *******************************************************************
       ;; Make sure we catch all errors which might occur.
       (onError __errorStop)
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       ;; Open the specified .tab file and import.
       (setq fileID (fileOpen fileName 0 0))
       (|Gv:importTab| fileID myParent recordVectors:)
       (fileClose fileID 1)
       (setq fileID #void)
       recordCount) ;; end importTab
    (defun importTabIFF(fileName)
    ;; *******************************************************************
    ;; Summary:  Imports ascii tab delimited records into the table (if and only if they exit).
    ;; *******************************************************************
       ;; Make sure we return zero records imported if there are errors.
       (onError (lambda(err) 0))
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       ;; Open the specified .tab file and import.
       ;; Note: If the specified tab delimited ascii file
       ;;       does not exist, then this will cause an error
       ;;       which will be trapped and return zero records imported.
       (setq fileID (fileOpen fileName 0 0))
       (|Gv:importTab| fileID myParent recordVectors:)
       (fileClose fileID 1)
       (setq fileID #void)
       recordCount) ;; end importTabIFF
    (defun insert(row record)
    ;; *******************************************************************
    ;; Summary:  Insert a record into the table for update.
    ;; Args:     row      Row number of row to be inserted (before).
    ;;           record   Row to be written to the table database.
    ;; Return:   record   The row just written. 
    ;; *******************************************************************
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       ;; Make sure the row number is valid.
       (if (or (< row 0) (>= row recordCount))
           (error (append "badRowIndex" 
                          "memoryCursor:insert:" myObjectName " - " row
                          ":An attempt was made to insert with a bad row number.")))
       (setq recordCount (addi recordCount 1))
       (setq record (copy record))
       (setAttributes record colVector)
       (^insert rowVector row record)
       ;; Return the record just inserted.
       record) ;; end of insert
    (defun insertColumn(colName position)
    ;; *******************************************************************
    ;; Summary:  Insert a column into the table.
    ;; Args:     colName    The name of the column to be inserted.
    ;;           position   The position of the column to be inserted (before).
    ;; Return:   true       Always return true iff no error occurs. 
    ;; *******************************************************************
       vars:(n N record)
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq colCount (length colVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       ;; Make sure the position number is valid.
       (if (or (< position 0) (> position colCount))
           (error (append "badColumnIndex" 
                          "memoryCursor:insertColumn:" myObjectName " - " position
                          ":An attempt was made to insert with a bad column number.")))
       ;; Insert the column in the column vector.
       (setq colName (symbol colName))
       (^insert colVector position colName)
       (setq colCount (length colVector))
       (setq recordStructure (new Vector: colCount))
       (setAttributes recordStructure colVector)
       ;; Insert the column into each record.
       (loop for n from 0 until recordCount do
          (setq record bckVector[n])
          (setAttributes record #void)
          (^insert record position #void)
          (setAttributes record colVector)
          ) ; end loop
       true) ;; end of insertColumn
    ;; Returns true iff the specified key is a saved view of this cursor.
    (defun isView(key) (<> viewDirectory[key] #void)) 
    (defun maximum(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Returns the max of a lambda value on each record of a table.
    ;; *******************************************************************
       vars:(rowIndex result)
       (if (<= recordCount 0) (return 0))
       (setq result (totalLambda rowVector[0]))
       ;; Compute the min lambda value for each record in the table.
       (loop for rowIndex from 1 until recordCount do
           (setq result (max result (totalLambda rowVector[rowIndex])))
           ) ;; end loop
       result) ;; end maximum
    (defun minimum(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Returns the min of a lambda value on each record of a table.
    ;; *******************************************************************
       vars:(rowIndex result)
       (if (<= recordCount 0) (return 0))
       (setq result (totalLambda rowVector[0]))
       ;; Compute the min lambda value for each record in the table.
       (loop for rowIndex from 1 until recordCount do
           (setq result (min result (totalLambda rowVector[rowIndex])))
           ) ;; end loop
       result) ;; end minimum
    (defun newIndex(colName)
    ;; *******************************************************************
    ;; Summary:  Creates unique index of each record in a table.
    ;; *******************************************************************
       vars:(record rowIndex numRecords colIndex)
       ;; Make sure the backup records are used to create the index.
       (setq colIndex (member (symbol colName) colVector))
       (if (= colIndex false) (error (append "memoryCursor: unknown index field name[" colName "]")))
       (setq numRecords (length bckVector))
       (setq myIndex (new Directory:))
       (if (<= numRecords 0) (return numRecords))
       ;; Place all records in the index.
       (loop for rowIndex from 0 until numRecords do
           (setq record bckVector[rowIndex])
           (setq myIndex[record[colIndex]] rowIndex)
           ) ;; end loop
       numRecords) ;; end newIndex
    (defun newMemoPadIndex(colName)
    ;; *******************************************************************
    ;; Summary:  Creates unique memoPad index of each record in a table.
    ;; *******************************************************************
       vars:(record rowIndex numRecords colIndex)
       ;; Make sure the backup records are used to create the index.
       (setq colIndex (member (symbol colName) colVector))
       (if (= colIndex false) (error (append "memoryCursor: unknown index field name[" colName "]")))
       (setq numRecords (length bckVector))
       (setq myMemoPad (new Directory:))
       (if (<= numRecords 0) (return numRecords))
       ;; Place all records in the index.
       (loop for rowIndex from 0 until numRecords do
           (setq record bckVector[rowIndex])
           (if (= myMemoPad[record[colIndex]] #void)
               (setq myMemoPad[record[colIndex]] record)
               (error (append "gsm.memoryCursor: duplicate memoPad index key [" colName "," record[colIndex] "," rowIndex "]"))
               ) ; end if
           ) ;; end loop
       numRecords) ;; end newMemoPadIndex
    (defun omit(findLambda)
    ;; *******************************************************************
    ;; Summary:  Deletes those records from a table for which a lambda predicate is true.
    ;; *******************************************************************
       vars:(rowIndex)
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       (if (<= recordCount 0) (return recordCount))
       ;; Omit those rows for which the find Lambda returns true.
       (loop for rowIndex from 0 until (length rowVector) do
           (if (findLambda rowVector[rowIndex])
               (begin 
                  (delete rowIndex)
                  (-- rowIndex)
               )) ; end if
           ) ;; end loop
       (setq recordCount (length rowVector))
       recordCount) ;; end omit
    (defun read(row)
    ;; *******************************************************************
    ;; Summary:  Reads a record from the table.
    ;; Args:     row      Row number of row to be read.
    ;; Return:   record   The row just read. 
    ;; *******************************************************************
       (if (= row #void) (setq row 0))
       (if (or (< row 0) (> row recordCount))
           (error (append "badRowIndex" 
                          "memoryCursor:read:" myObjectName " - " row
                          ":An attempt was made to read with a bad row number.")))
       rowVector[row]) ;; end of read
    (defun readByKey(key)
    ;; *******************************************************************
    ;; Summary:  Reads a record from the table (using the specified key).
    ;; Args:     key      Key of row to be read (found in index).
    ;; Return:   record   The row just read. 
    ;; *******************************************************************
       vars:(row)
       (setq row myIndex[key])
       (if (= row #void) (return #void))
       (if (or (< row 0) (> row recordCount))
           (error (append "badRowKey" 
                          "memoryCursor:readByKey:" myObjectName "[" key
                          "] :An attempt was made to read with a bad index key.")))
       rowVector[row]) ;; end of readByKey
    (defun readLast()
    ;; *******************************************************************
    ;; Summary:  Reads the last record from the table.
    ;; Args:     none     
    ;; Return:   record   The row just read. 
    ;; *******************************************************************
       (if (<= recordCount 0) (return #void))
       rowVector[(subi recordCount 1)]) ;; end of readLast
    (defun refExport(row)
    ;; *******************************************************************
    ;; Summary:  Returns a record, for export, to the exportTab function.
    ;; *******************************************************************
       ;; If the row is zero, return the column names for the header record.
       (if (= row 0) (return colVector))
       ;; Adjust the record index for the header record.
       (setq row (subi row 1))
       ;; If there are no more records, tell exportTab to stop exporting.
       (if (>= row recordCount) (return false))
       ;; Otherwise return the next record for export.
       (read row)) ;; end of refExport 
    (defun refImport(row)
    ;; *******************************************************************
    ;; Summary:  Returns an empty record to the importTab function.
    ;; *******************************************************************
       ;; If the row is zero, return an empty vector to hold the column names,
       ;; Otherwise, return an empty record (use the recordStructure as a template).
       (if (= row 0)
           (return (^new Vector: 0))
           (return (copy recordStructure)))) ;; end of refImport
    (defun reset()
    ;; *******************************************************************
    ;; Summary:  Resets the backup copy and views of the investor colony table. 
    ;; *******************************************************************
       ;; Make sure the backup records and views are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       (setq UPDIamDirty true)
       true) ;; end of reset
    (defun restore()
    ;; *******************************************************************
    ;; Summary: Restores the backup copy of the investor colony table.
    ;; *******************************************************************
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       true) ;; end of restore
    (defun restoreView(key)
    ;; *******************************************************************
    ;; Summary: Restores the current record view as specified.
    ;; *******************************************************************
       (setq rowVector viewDirectory[key])
       (if (= rowVector #void) (setq rowVector bckVector)) 
       (setq rowVector (copy rowVector))
       (setq recordCount (length rowVector))
       true) ;; end of restoreView
    ;; Run the specified javaFilter Lambda against this cursor.
    (defun run(filterString)
       vars:(filterLambda)
       (setq filterLambda (compile (morph (javaScript filterString))))
       (setq filterLambda (filterLambda))
       (filterLambda myParent)) ;; end of run
    (defun save(tableName)
    ;; *******************************************************************
    ;; Summary:  Save the contents of the table cursor back to disk.
    ;; *******************************************************************
       true) ;; end of save
    (defun saveView(key)
    ;; *******************************************************************
    ;; Summary: Saves the current record view as specified.
    ;; *******************************************************************
       (setq viewDirectory[key] (copy rowVector))
       true) ;; end of saveView
    (defun search(findLambda ...)
    ;; *******************************************************************
    ;; Summary:  Returns the row index for the first record for which a lambda predicate is true.
    ;; *******************************************************************
       vars:(startIndex rowIndex n colName colValue (argc 2))
       ;; Define the temporary search lambda.
       (defun __searchLambda(x) vars:(colName colValue) (= x[colName] colValue))
       ;; If the findLambda is a columnName, we must make our own lambda predicate.
       (if (not (isLambda findLambda))
           (begin
              (setq colName findLambda)
              (setq colValue (argFetch 1))
              (++ argc)
              (setq findLambda __searchLambda)
              (setq findLambda.Tv.colName colName)
              (setq findLambda.Tv.colValue colValue)
           )) ; end if
       ;; Make sure we capture the startIndex argument (if any).
       (if (= (argCount) argc)
           (setq startIndex (argFetch (sub1 argc)))
           (setq startIndex 0)
           ) ; end if
       (if (<= recordCount 0) (return false))
       ;; Select the first row for which the find Lambda returns true.
       (setq n (length rowVector))
       (loop for rowIndex from startIndex until n do
           (if (findLambda rowVector[rowIndex]) (return rowIndex))
           ) ;; end loop
       false) ;; end search
    (defun setImport(row recordVector)
    ;; *******************************************************************
    ;; Summary:  Receives a single record from the importTab function.
    ;; *******************************************************************
       regs:(n N)
       ;; Import the .tab column header record (if necessary).
       (if (= row 0)
           (if (= recordCount 0)
               (begin
                  (setq N (length recordVector))(loop for n from 0 until N do (setq recordVector[n] (symbol (string recordVector[n])))) 
                  (setq validFields (objectToStructure recordVector #(#void)))
                  (setq colVector (refAttributes validFields))
                  (setq recordStructure (new Vector: (length colVector)))
                  (setAttributes recordStructure colVector)
                  (setq colCount (length colVector))
                  (return true)) ;; end setting new column names.
               (begin 
                 (setq recordVector (objectToStructure recordVector #(#void)))
                 (setq recordVector (refAttributes recordVector))
                 (if (<> colVector recordVector)
                      (error 
                         (append "importTab: An attempt was made to import a file with mismatched column names: "
                                 myObjectName)))
                  (return true)) ;; end checking new column names against old column names.
           )) ;; end if
       ;; Import all other .tab records at the end of the table.
       (write recordCount recordVector)
       true) ;; end of setImport
    (defun sharpe(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Returns the sharpe ratio of a lambda value on each 
    ;;           record of a table.
    ;; *******************************************************************
       vars:(rowIndex (result 0) score aSum aSsq anAvg aStd)
       (if (<= recordCount 0) (return 0))
       ;; Compute the stadard devisation lambda value for each record in the table.
       (loop for rowIndex from 0 until recordCount do
           (setq score (totalLambda rowVector[rowIndex]))
           (setq aSum (+ aSum score))
           (setq aSsq (+ aSsq (* score score)))
           ) ;; end loop
       (setq anAvg (/ aSum recordCount))
       (setq aStd (sqrt (- (/ aSsq recordCount) (* anAvg anAvg))))
       (setq result (/ anAvg aStd))
       result) ;; end sharpe
    (defun show(startIndex) 
    ;; *******************************************************************
    ;; Summary:  Shows a group of records starting from the specified row.
    ;; *******************************************************************
       vars:(i n) 
       (setq n (integer (min recordCount (addi startIndex showLimit))))
       (writeln "[" n "] " colVector)
       (loop for i from startIndex until n do
           (writeln "[" i "] " (read i))
           ) ;; end loop
       true) ;; end show
    (defun sort(sortLambda ...)
    ;; *******************************************************************
    ;; Summary:  Sorts each record in the table cursor.
    ;; *******************************************************************
       vars:(backupSW)
       ;; Are we sorting the backup view as well as the current view?
       (if (and (= (argCount) 2) (= (argFetch 1) backup:))
           then ;; Sort the backup view as well as the current view.
           (begin
              (setq backupSW true)
              (setq viewDirectory (new Directory:))
              (setq myIndex (new Directory:))
              (setq rowVector bckVector)
              (setq recordCount (length rowVector))
              ) ; end then
           else ;; Sort only the current view.
           (begin
              (setq backupSW false)
              (setq rowVector (copy rowVector))
              )) ; end if
       (if (<= recordCount 0) (return recordCount))       
       (^sort rowVector sortLambda)
       (setq UPDIamDirty true)
       recordCount) ;; end sort
    (defun total(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Totals a lambda value on each record of a table.
    ;; *******************************************************************
       vars:(rowIndex result)
       (if (<= recordCount 0) (return 0))
       ;; Compute the total lambda value for each record in the table.
       (loop for rowIndex from 0 until recordCount do
           (+= result (totalLambda rowVector[rowIndex]))
           ) ;; end loop
       result) ;; end total
    (defun totalForAll(totalLambda)
    ;; *******************************************************************
    ;; Summary:  Totals a lambda value on ALL records of a table.
    ;; *******************************************************************
       vars:(rowIndex (result 0))
       (if (<= (length bckVector) 0) (return 0))
       ;; Compute the total lambda value for each record in the table.
       (loop for rowIndex from 0 until (length bckVector) do
           (+= result (totalLambda bckVector[rowIndex]))
           ) ;; end loop
       result) ;; end totalForAll
    (defun truncate(findLambda)
    ;; *******************************************************************
    ;; Summary:  Truncates a table to those records for which a lambda predicate is true.
    ;; *******************************************************************
       vars:(rowIndex newIndex n vec maxRecords)
       (if (<= recordCount 0) (return recordCount))
       (setq rowVector (copy rowVector))
       (setq recordCount (length rowVector))
       ;; If the selectLambda is a number, then keep only the first N records.
       (if (isNumber findLambda)
           (begin
              (setq maxRecords (min recordCount findLambda))
              (setq rowVector (resize rowVector maxRecords))
              (setq recordCount (length rowVector))
              (return recordCount)
           )) ; end if
       ;; Select only those rows for which the find Lambda returns true.
       (setq n (length rowVector))
       (setq vec (^new Vector: object: 0))
       (setq newIndex -1)
       (loop for rowIndex from 0 until n do
           (if (findLambda rowVector[rowIndex]) (setq vec[(++ newIndex)] rowVector[rowIndex]))
           ) ;; end loop
       (setq rowVector vec)
       (setq recordCount (length rowVector))
       recordCount) ;; end truncate
    (defun updateView(updateLambda ...)
    ;; *******************************************************************
    ;; Summary:  Updates each record in the current view and restores the altered backup view.
    ;; *******************************************************************
       vars:(_rowVector rowIndex n resetSW)
       ;; Check for a no reset request.
       (setq resetSW true)
       (if (and (= (argCount) 2) (= (argFetch 1) noreset:)) (setq resetSW false))
       ;; Update each row in the current view.
       (setq _rowVector (copy rowVector))
       (setq n (length _rowVector))
       (loop for rowIndex from 0 until n do
           (updateLambda _rowVector[rowIndex])
           ) ;; end loop
       (if (= resetSW true) (restore) true)) ;; end updateView
    (defun write(row record)
    ;; *******************************************************************
    ;; Summary:  Write a record to the table for update.
    ;; Args:     row      Row number of row to be written.
    ;;           record   Row to be written to the table.
    ;; Return:   record   The row just written. 
    ;; *******************************************************************
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       ;; Make sure the row number is valid.
       (if (or (< row 0) (> row recordCount))
           (error (append "badRowIndex" 
                          "memoryCursor:write:" myObjectName " - " row
                          ":An attempt was made to write with a bad row number.")))
       (if (= row recordCount) (setq recordCount (addi recordCount 1)))
       (setq record (copy record))
       (setAttributes record colVector)
       (setq rowVector[row] record)
       ;; Return the record just written.
       record) ;; end of write
    (defun writeByKey(key record)
    ;; *******************************************************************
    ;; Summary:  Write a record to the table for update (using the specified key).
    ;; Args:     key      Index key of row to be written.
    ;;           record   Row to be written to the table.
    ;; Return:   record   The row just written. 
    ;; *******************************************************************
       vars:(row)
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (if (not (isDirectory myIndex)) (setq myIndex (new Directory:)))
       (setq row myIndex[key])
       (if (= row #void) (begin (setq row recordCount) (setq myIndex[key] row)))
       ;; Make sure the row number is valid.
       (if (or (< row 0) (> row recordCount))
           (error (append "badRowKey" 
                          "memoryCursor:writeByKey:" myObjectName "[" key
                          "] :An attempt was made to write with a bad record key.")))
       (if (= row recordCount) (setq recordCount (addi recordCount 1)))
       (setq record (copy record))
       (setAttributes record colVector)
       (setq rowVector[row] record)
       ;; Return the record just written.
       record) ;; end of writeByKey
    (defun writeLast(record)
    ;; *******************************************************************
    ;; Summary:  Write a record to the end of the table for update.
    ;; Args:     record   Row to be written to the end of the table.
    ;; Return:   record   The row just written. 
    ;; *******************************************************************
       ;; Make sure the backup records are restored.
       (setq rowVector bckVector)
       (setq recordCount (length rowVector))
       (setq viewDirectory (new Directory:))
       (setq myIndex (new Directory:))
       (setq record (copy record))
       (setAttributes record colVector)
       (setq rowVector[recordCount] record)
       (setq recordCount (addi recordCount 1))
       ;; Return the record just written.
       record) ;; end of write
    ;; -------------------------------------
    ;; Private methods (not for public use).
    ;; -------------------------------------
    (defun __clear()
       (setq rowVector (new Vector: object: 0))
       (setq bckVector rowVector)
       (setq viewDirectory (new Directory:))
       (setq myIndex #void)
       (setq recordCount 0)
       (setq fileID #void)
       true) ;; end of __clear
    (defun __open(tableName colNames)
    ;; *******************************************************************
    ;; Summary:  Begins an update transaction on the table cursor.
    ;; *******************************************************************
       ;; Search for the specified table in the reference and blackboard areas.
       vars:(indexOf record)
       (__clear)
       (setq myObjectName (symbol tableName))
       (setq colVector (copy colNames))
       (setq colCount (length colVector))
       (setq validFields (objectToStructure colVector #(#void)))
       (setq colVector (refAttributes validFields))
       (setq recordStructure (new Vector: colCount))
       (setAttributes recordStructure colVector)
       ;; Load the memo pad Dictionary into the cursor memory.
       (setq myCursorType memory:)
       (setq showLimit 10)
       (setq myIndex #void)
       (setq myObjectName (symbol tableName))
       (setq myTableCursor #void)
       (setq myCursorNotes (new Dictionary:))
       (setq viewDirectory (new Directory:))
       (setq myMemoPad (new Dictionary:))
       (setq colCount 0)
       true) ;; end of __open
    (defun __errorStop(errMsg)
       (if (isNumber fileID) (fileClose fileID 1))
       (setq fileID #void)
       (error (mid errMsg 1 (subi (length errMsg) 2)))) ;; end __errorStop
    (defun __truncateEnds(begRowLimit endRowLimit)
    ;; *******************************************************************
    ;; Summary:  Truncate records from both ends of a table.
    ;; *******************************************************************
       vars:(rowIndex newIndex n vec endRowIndex)
       (if (<= recordCount 0) (return recordCount))
       ;; Select only those rows in between the begin and end row limits.
       (setq n (length rowVector))
       (setq endRowIndex (subi n endRowLimit))
       (setq vec (^new Vector: object: 0))
       (setq newIndex -1)
       (loop for rowIndex from (addi begRowLimit 1) until endRowIndex do
           (setq vec[(++ newIndex)] rowVector[rowIndex])
           ) ;; end loop
       (setq rowVector vec)
       (setq recordCount (length rowVector))
       recordCount) ;; end truncateEnds
    (defun __truncateMid(begRowLimit endRowLimit)
    ;; *******************************************************************
    ;; Summary:  Truncate records from the center of a table.
    ;; *******************************************************************
       vars:(rowIndex newIndex n vec endRowIndex)
       (if (<= recordCount 0) (return recordCount))
       ;; Delete those rows in between the begin and end row limits.
       (setq n (length rowVector))
       (setq endRowIndex (subi n endRowLimit))
       (setq vec (^new Vector: object: 0))
       (setq newIndex -1)
       (loop for rowIndex from 0 until begRowLimit do
           (setq vec[(++ newIndex)] rowVector[rowIndex])
           ) ;; end loop
       (loop for rowIndex from endRowIndex until n do
           (setq vec[(++ newIndex)] rowVector[rowIndex])
           ) ;; end loop
       (setq rowVector vec)
       (setq recordCount (length rowVector))
       recordCount) ;; end truncateMid
    ;; *******************************************************************
    ;; Begin MAIN logic section.
    ;; Note: Initialize this memory table cursor.
    ;; *******************************************************************
    Continue::
    (setq myCopy (copy (myself)))
    (setq myCopy.myParent myCopy)
    (myCopy.__open tableName colNames)
    myCopy) ;; end of memoryCursor





























































































































;;**EXPORTKEY**:gsm.mvlRegress
(deforphan gsm:mvlRegress(X Y)
;; *******************************************************************
;; name:     mvlRegress
;; 
;; summary:  Trains a multiple linear regression Lambda, using a the 
;;           gaussian algorithm and returns the trained regression Lambda.
;;
;;           Multivariable regression machines are regression machines which learn
;;           and make regression estimates on XY vector arrays such as:
;;
;;               XY:  An N by M+1 array representing the original observations
;;                    in the form of:    x x x ...  y
;;                                       x x x ...  y
;;                                           ... 
;;                                       x x x ...  y
;;
;; Parms:    X:         The N by M vector array representing the original observations
;;                      in the form of:    x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;           Y   		The N vector of dependent variables.
;;
;; Return:   Rf:     A new learning machine Lambda ready for regression.
;; *******************************************************************
    pvars:(;; Public variables
           Number:NLSE                  ;; The current absolute error for the MVL regression model (in percent of target). 
           Integer:myM					;; The number of elements in each training example (independent variables). 
           Integer:myN					;; The number of training examples. 
           myMVLParent                  ;; The parent Lambda of this MVL regression Lambda community. 
           myVerboseSW      			;; True iff we are to display progress on the console. 
           NumVector:myW                ;; The weight coefficient vector for the MVL regression model.
           myX                          ;; The vector of training examples (independent variables).
           NumVector:myY                ;; The vector of training example scores (dependent variable).
           ;; Public child methods
           clear			       		;; Clear the current percentile grid machine.
           mvlLambda			       		;; Return an Lambda ready to compute the mvl output for specified input vector.
           mvlTraining		       		;; Train the mvl machine on the specified training examples.
	       multipleRegression           ;; Performs a Gaussian multiple regression on the X Y training data
           ;; Private maintenance child methods
           selfTest                		;; The self test method for this Lambda. 
           ) ;; end of persistent variables
    ;; ***************************
    ;; Define Public Child Lambdas.
    ;; ***************************
    ;; Clear the current percentile grid machine.
    (defun clear()
       (setq NLSE BIGPOSNUM)
       (setq myM 0)
       (setq myN 0)
       (setq myW #void)
       (setq myX #void)
       (setq myY #void)
       true) ; end clear
    ; Return an Lambda ready to compute the mvl output for specified input points.
    (defun mvlLambda()
       regs:(n m NW)
       vars:(NumVector:hW Vector:hKX ObjVector:hWX)
       vars:(Lambda HRecord)
       (setq Lambda (eval 
        {(lambda(NumVector:X) 
         pvars:(Strategy Number:NLSE Integer:myM NumVector:myW) 
         regs:(k m M Number:x Number:wn Number:dy Number:ey NumPointer:pW NumPointer:pX) 
         (setq M myM) 
         (setq pW myW) 
         (setq pX X) 
         (loop for m from 0 until M do 
            (setq x pX[m]) 
            (setq wn pW[m]) 
            (*= x wn) 
            (+= ey x)  
            )
          ey)
        }))
       ;; Move all important knowledge structures into the trained regression Lambda.
       (setq Lambda.Strategy MVL:)
       (setq Lambda.NLSE BIGPOSNUM)
       (setq Lambda.myM myM)
       (setq Lambda.myW myW)
       Lambda) ; end mvlLambda
   ;; summary:  Performs a Gaussian multiple regression on the X Y training data
   ;; Return:   C:     The weight coefficient vector for the regression model.
   ;; Note1:    Average error statistics are computed as a percent of the target (dependent variable).
   ;; Note2:    See Sedgewick[2] chap 37.
   (defun multipleRegression(ObjVector:X NumVector:Y)
       regs:(m M n N MY NumPointer:pmxy Number:wx Number:y)
       vars:(NumMatrix:Xt NumVector:x NumVector:C NumMatrix:MXY)
       ;; Convert X Y vector input to a Matrix format.
       (setq N (length X))
       (setq M (length X[0]))
       (setq MY (+ M 1))
       (if (<> N (length Y)) (error "mvlRegress.multipleRegression: X and Y vectors must be same length"))
       (setq MXY (new Matrix: number: 2 N MY))
       (vmregRunInHardware start:)
       (setq pmxy MXY)
       (loop for n from 0 until N do
          (setq x X[n])
          (loop for m from 0 until M do
            (setq wx x[m])
            (setq pmxy[0] wx)
            (++ pmxy)
            ) ; end n loop
          (setq y Y[n])
          (setq pmxy[0] y)
          (++ pmxy)
          ) ; end m loop
       (vmregRunInHardware stop:)
       ;; Perform a least squares regression on all the factors.
       (setq Xt (|Gv:makeGaussianMatrix| MXY))
       (setq Xt (|Gv:matrixGaussianEliminate| Xt true))
       (setq myW (|Gv:matrixGaussianSubstitute| Xt))
       ;; Return the weight coefficient vector for the regression model.
       myW) ; end multipleRegression
    ;; Train the mvl machine on the specified inputs and model.
	;; Parms:    x:         The N by M vector array representing the original observations
	;;                      in the form of:    x x ... x
	;;                                         x x ... x
	;;                                             ... 
	;;                                         x x ... x
	;;           y   		The N vector of dependent variables.
    ;;
    ;; Return:   Rf:        A new percentile grid machine Lambda ready for regression.
    (defun mvlTraining(X Y)
        regs:(k K m M n N)
        regs:(Number:RGrid Number:RM Number:w Number:tw)
        regs:(Number:wx Number:ey Number:y)
        vars:(result NumVector:GYcount)
	    ;; Clear percentile grid machine for retraining.
	    (clear)
	    ;; Initialize the untrained MVL model.
	    (if (or (<> (isVector X) true) (<> (isVector X[0]) true)) (error "mvlRegress: X argument must be a Vector Array of rank 2"))
	    (setq myM (length X[0]))
	    (setq myN (length X))
	    (if (or (<> (isVector Y) true) (<> (length Y) myN)) (error "mvlRegress: Y argument must be a Vector of length the same as X"))
	    (setq myX X)
	    (setq myY Y)
		;; Initialize the persistent variables before proceeding with training.
		(setq NLSE BIGPOSNUM)
        (setq myW (new Vector: Number: myM))
		;; Compute the MVL model column weights.
        (setq myW (multipleRegression X Y))
		;; Return a multivariable regression Lambda.
	    (setq myX #void)
	    (setq myY #void)
        (setq result (mvlLambda))
        result) ; end mvlTraining
    ;; ****************************************
    ;; Define Private Maintenance Child Lambdas.
    ;; ****************************************
    ;; The self test method for this Lambda.
    (defun selfTest(Test Ns Ms Gs Es)
       vars:(k m M n N g G y ey C c X Y Yv avgY avgTopEy topEyCnt
             Lambda err Net pct sortedY 
             eyGrid eyGridCount eyGridSize errScore 
             startTime endTime startTimeT endTimeT
             (checkResults true)
             (tol 0.0) (errStop 0.01) (Cs 1.0)
             ) ; end temporary variables
       (clear)
       (setq startTimeT (getTickCount 0))
       (gsm.setRandomSeed 8192.0)
       (setq eyGridSize Es)
       ;; Select the requested test case
       ;; Test Case srandom 
       (if (or (= Test all:) (= Test linear:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] + C[3]*X[3] + C[4]*X[4] ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: linear")
		       (setq Lambda (setq Lambda (gsm.mvlRegress.mvlTraining X Y)))
		       (writeln "mvlRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "mvlRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case linear
       ;; Test Case mixedRandom 
       (if (or (= Test all:) (= Test mixed:))
           (begin
		       ;; Create a test polynomial linear model where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] ...
		       ;; Create a test polynomial square model where y = C[0]*X[0]*X[0] + C[1]*X[1]*X[1] + C[2]*X[2]*X[2] ...
		       ;; Create a test polynomial sin model where y = C[0]*sin(X[0]) + C[1]*sin(X[1]) + C[2]*sin(X[2]) ...
		       ;; Create a test polynomial log model where y = C[0]*log(abs(X[0])+.000001) + C[1]*log(abs(X[1])+.000001) + C[1]*log(abs(X[2])+.000001) ...
               ;; These four models are mixed together and random noise is added.
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
 		          (setq X[n][1] (number k))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
                     (cond
                        ;; Linear model
                        ((= k 0) (setq y (+ y (* X[n][m] C[m]))))
                        ;; Square model
                        ((= k 1) (setq y (+ y (* X[n][m] X[n][m] C[m]))))
                        ;; Sine model
                        ((= k 2) (setq y (+ y (* (|Gv:sin| X[n][m]) C[m]))))
                        ;; Log model
                        (else (setq y (+ y (* (|Gv:log| (+ .000001 (|Gv:abs| X[n][m]))) C[m]))))
                        ) ; end cond
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: mixed")
		       (setq Lambda (setq Lambda (gsm.mvlRegress.mvlTraining X Y)))
		       (writeln "mvlRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
 		          (setq X[n][1] (number k))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (cond
                        ;; Linear model
                        ((= k 0) (setq y (+ y (* X[n][m] C[m]))))
                        ;; Square model
                        ((= k 1) (setq y (+ y (* X[n][m] X[n][m] C[m]))))
                        ;; Sine model
                        ((= k 2) (setq y (+ y (* (|Gv:sin| X[n][m]) C[m]))))
                        ;; Log model
                        (else (setq y (+ y (* (|Gv:log| (+ .000001 (|Gv:abs| X[n][m]))) C[m]))))
                        ) ; end cond
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "mvlRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case mixed
       ;; Test Case sigmoid 
       (if (or (= Test all:) (= Test sigmoid:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] + C[3]*X[3] + C[4]*X[4] ...
		       ;; Note1: The inputs, X, are restricted to the sigmoid domain.
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 1.0) .50))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (gsm.myRandomFunction 1.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: sigmoid")
		       (setq Lambda (setq Lambda (gsm.mvlRegress.mvlTraining X Y)))
		       (writeln "mvlRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (gsm.myRandomFunction 1.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "mvlRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case sigmoid
       ;; Test Case square 
       (if (or (= Test all:) (= Test square:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*(X[1]**2) + C[2]*X[2] + C[3]*(X[3]**2) ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 01 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* X[n][m] X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: square")
		       (setq Lambda (setq Lambda (gsm.mvlRegress.mvlTraining X Y)))
		       (writeln "mvlRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
 		          (setq X[n][1] (number k))
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* X[n][m] X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "mvlRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case square
       ;; Test Case tan 
       (if (or (= Test all:) (= Test tan:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*tan(X[0]) + C[1]*tan(X[1]) + C[2]*tan(X[2]) ...
		       (setq M Ms)
		       (setq N Ns)
		       (setq eyGrid (new Vector: Number: eyGridSize))
		       (setq eyGridCount (new Vector: Number: eyGridSize))
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 10.0) 5.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
		          (loop for m from 01 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* (tan X[n][m]) C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the training data.
		       (writeln _eol "Starting test case: tan")
		       (setq Lambda (setq Lambda (gsm.mvlRegress.mvlTraining X Y)))
		       (writeln "mvlRegress: N = [" Ns "], M = [" Ms "]")
		       ;; Score on the test case.
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq y 0.0)
                  (setq k (modi n 4)) 
 		          (setq X[n][1] (number k))
		          (loop for m from 0 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     (setq y (+ y (* (tan X[n][m]) C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
               (setq err 0.0)
               (setq errScore 0.0)
               (setq avgTopEy 0.0)
               (setq topEyCnt 0)
               (setq avgY (avg Y))
               (setq G (/ N eyGridSize))
               (setq sortedY (|Gv:sort| Y < true)) 
               (loop for n from 0 until N do
                  (setq k sortedY[n])                  
                  (setq ey (Lambda X[k]))
                  (setq y Y[k])
                  (setq g (divi n G))
                  (setq eyGrid[g] (+ eyGrid[g] ey))
                  (setq eyGridCount[g] (+ eyGridCount[g] 1.0))
                  (setq pct (/ (abs (- ey y)) (+ (abs ey) .000000001)))
                  (+= err pct)
                  (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" (- ey y) "] err%=[" pct "]"))
                  ) ; end N loop
               (/= err N)
               (loop for g from 0 until eyGridSize do (setq eyGrid[g] (/ eyGrid[g] eyGridCount[g]))) 
               (loop for g from 1 until eyGridSize do (if (<= eyGrid[g] eyGrid[(- g 1)]) (++ errScore)))
               (setq errScore (/ (- eyGridSize errScore 1) (- eyGridSize 1)))
               (writeln "mvlRegress: err=[" err "], avgY=[" avgY "], errScore=[" errScore "], eyGrid=[" (string eyGrid true) "]")
          )) ; end Test Case tan
       (writeln "mvlRegress.selfTest: completed in [" (/ (setq endTimeT (getTickCount startTimeT)) 60.0) "] minutes.")       
       Lambda) ; end selfTest
    ;; *****************
    ;; Begin main logic.
    ;; ***************** 
    vars:(Lambda mvlLambda)

    ;; Train a new percentile grid machine Lambda.
    (setq mvlLambda (new (myself)))
    (setq mvlLambda.myMVLParent mvlLambda)
    (setq Lambda (mvlLambda.mvlTraining X Y))
    Lambda) ; end mvlRegress
























































































































































































;;**EXPORTKEY**:gsm.ruleFrm
(defriend gsm:ruleFrm(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator multivariate 
;;           factor regression Lambdas. 
;;
;; Main:     Return a Estimator multivariate factor regression statement,
;;           in source format, such as 
;;                    "frmregress(x2,(x2-x10));" 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the multivariate factor regression statement.
;;           
;; Return:   result      A Estimator multivariate factor regression statement such as "frmregress(x2,(x2-x10));".
;; *******************************************************************
  	pvars:(;; Public Variables
           (genomeType EXP)         ;; This regression rule uses an expression based genome.
           (lengthExempt false)     ;; This regression rule is NOT exempt from genome length restrictions.
           ;; Public Methods
           chromosomeLength         ;; Return the number of non-empty left-most chromosomes in the genome.
           crossOver                ;; Create two new Estimator multivariate factor regression WFFs by splicing two parent WFFs together using genetic crossover.
           crossOverAware    		;; Create all possible new Estimator WFFs by splicing two parent WFFs together using context aware crossover.
           growWFF                  ;; Create a new Estimator multivariate factor regression wff to the current population.
           mutate                   ;; Create a new Estimator multivariate factor regression WFF using genetic mutation.
           wffList                  ;; Convert a Estimator multivariate factor regression wff to a list format.
           wffSource				;; Convert a Estimator multivariate factor regression wff to a source statement such as "frmregress(x0-x5,abs(x1));". 
           wffString                ;; Convert a Estimator multivariate factor regression wff to a string format such as "(ruleFrm #(obj| (ruleSub x0 x5) (ruleAbs x1)));"
           ) ; end persistant variables
   	;; *******************************************************************************
   	;; Define Public Child Lambdas 
   	;; *******************************************************************************

	(defun chromosomeLength(genome)
	;; *******************************************************************
	;; summary:  Return the number of non-empty left-most chromosomes in the genome. 
	;;
	;; args:     genome     The genome whose chromosome length is to be returned.           
	;;           
	;; Return:   length     The number of non-empty left-most chromosomes in the genome.
	;;
	;; *******************************************************************
	   regs:(m M len)
	
       (setq M (length genome))
	   (loop for m from 0 until M do
          (if (<> genome[m] #void) (++ len))
          ) ; end loop

	   len) ; end chromosomeLength


	(defun crossOver(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator multivariate factor regression WFFs, 
    ;;           by splicing two parent WFFs together using genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome genome)
	   vars:(dadWff momWff newWff (passOne true) chromosome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))

       ;; Implement the user select cross over strategy 
       (cond
        ;; Manage "Genetic" cross over?
        ;; Note: We use chromosomes in a "genetic algorithm" inspired cross over operation.
        ((and (= myCrossOverStrategy genetic:) (= myREGMultiple true))
         (begin
             ;; Select chromosomes from each genome.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (loop for m from 0 until M do
               (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m]))
               ) ; end column loop  	
         )) ; end genetic cross over strategy
        ;; Manage "Aggressive" cross over?
        ;; Note: We use chromosomes from multiple crossed genome columns during cross over operations.
        ((= myCrossOverStrategy aggressive:)
         (begin
             ;; Reorder the chromosomes in the candidate genomes occasionally.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
      
             ;; Select chromosomes from each genome.
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (setq chromosomeCrossPct 1.5)
             (loop for m from 0 until M do
               (if (>= chromosomeCrossPct .50) (-= chromosomeCrossPct .50))
               (cond
                 ((> (gsm.myRandomFunction 1.0) chromosomeCrossPct) (setq genome[m] genome[m]))
                 ((= genome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m])))
                 ((= momGenome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] (eGrammar.mutateNumericWFF genome[m] (gsm.myRandomFunction 1.0)))))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs genome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 (else 
                  (begin
                     (setq dadWff genome[m])                    
                     (setq momSlot (setq momIndex (eGrammar.selectSlotWFF momGenome[m]))[(integer (gsm.myRandomFunction (length momIndex)))])
                     (setq dadPair (setq dadIndex (eGrammar.selectPairWFF dadWff))[(integer (gsm.myRandomFunction (length dadIndex)))])
                     (cond
                      ((isAtom dadPair) (setq genome[m] momSlot))
                      ((and (isPair momSlot) (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs (listWff dadPair) (listWff momSlot))) false))
                       (begin (setCar dadPair (car newWff))  (setCdr dadPair (cdr newWff))))
                      ((isPair momSlot) (begin (setCar dadPair (car momSlot))  (setCdr dadPair (cdr momSlot))))
                      (else (eGrammar.spliceNumericWFF dadPair momSlot 1.0))
                      ) ; end splice cond
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end aggressive cross over strategy
        ;; Manage "Normal" cross over?
        ;; Note: We use chromosomes from only single matched genome columns during cross over operations.
        ((= myCrossOverStrategy normal:)
         (begin
	         ;; Reorder the chromosomes in the candidate genomes occasionally.
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq dadGenome (copy dadGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome dadGenome[m])
	               (setq dadGenome[m] dadGenome[n])
	               (setq dadGenome[n] chromosome)
	             )) ; end if
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq momGenome (copy momGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome momGenome[m])
	               (setq momGenome[m] momGenome[n])
	               (setq momGenome[n] chromosome)
	             )) ; end if

	         ;; Splice the chromosomes in the candidate genomes to form the progeny.
             (setq genome (new Vector: myM))
             (setq M myM)
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (cond 
                 ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
                 ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
                 (else 
                  (begin
                     (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                         ) ; end if
                     (setq genome[m] newWff)
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end normal cross over strategy
        (else (error (append "gsm.ruleFrm.crossOver: unknown user specified cross over strategy [" myCrossOverStrategy "]")))
        ) ; end cross over strategy cond

	   ;; Make a Estimator multivariate factor regression wff and add it to the current population.
       Grow::
       (growWFF genome dadGenome)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOver
	
	(defun crossOverAware(father mother)
	;; *******************************************************************
	;; summary:  Create all possible new Estimator WFFs by splicing two  
    ;;           parent WFFs together using context aware crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(k K m M n N ns NS np NP)
	   vars:(dadGenome momGenome dadWff momWff newWff (passOne true))
	   vars:(chromosome dadRule momRule newGenome genome)
       vars:(dadPairVector dadPair momSlotVector momSlot)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))
       (setq M (chromosomeLength dadGenome))
       (setq N (chromosomeLength momGenome))

       ;; Reorder the chromosomes in the candidate genomes occasionally.
       ;; Note: we use a linear genome during cross over operations.
       (if (= myREGMultiple true)
           (begin
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
           )) ; end if
      
       ;; Select chromosomes from each genome.
       (setq genome (copy dadGenome))           
       (setq M (min M N))
       (loop for m from 0 until M do
          (if (and (<> dadGenome[m] #void) (<> momGenome[m] #void))
              (begin
                (setq dadPairVector (eGrammar.selectPairWFF dadGenome[m]))
                (setq momSlotVector (eGrammar.selectSlotWFF momGenome[m]))
                (setq NP (length dadPairVector))
                (setq NS (length momSlotVector))
                (loop for np from 0 until NP do
                   (loop for ns from 0 until NS do
                      (setq K (length dadPairVector[np]))
                      (loop for k from 1 until K do 
                         (setq dadPair (eGrammar.selectPairWFF (setq dadWff (listWff dadGenome[m])))[np])
                         (setq momSlot (eGrammar.selectSlotWFF (setq momWff (listWff momGenome[m])))[ns])
                         (if (= (eGrammar.spliceImmediateWFF dadPair momSlot k) true)
                             (begin     
	            			    ;; Make a new wff and add it to the current population.                               
                                (setq (setq newGenome (copy dadGenome))[m] dadWff)
                                ;(writeln "[" m "," np "," ns "," k "]:" "new=" newGenome ", dad=" dadGenome ", mom=" momGenome)
                                (growWFF newGenome)
                             )) ; end if
                         ) ; end K loop
                      ) ; end NS loop
                   ) ; end NP loop

              )) ; end if

         ) ; end column loop  	

	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAware
	
	(defun growWFF(command ...)
	;; *******************************************************************
	;; summary:  Grow a new Estimator multivariate factor regression WFF and
	;;           add it to the current population.
	;;
	;; args:     command 	The command to determine the type of WFF to grow.
	;;           
	;; Return:   Lambda      A scored Estimator multivariate factor regression Lambda.
	;;
	;; *******************************************************************
	   regs:(k m M mm n N maxChromosomes cntChromosomes)
	   vars:(Lambda genome newGenome)
	   vars:(Rf wff)
	   vars:(IntVector:chromosomeIndices IntVector:chromosomeLimits)
	
       ;; Use the command to determine the type of WFF to grow.
       (setq maxChromosomes gsm.myFRMMaximum)
       (cond
         ;; Command is a genome vector.
         ((isVector command)
          (begin
            (setq genome command) 
          )) ; end case genome vector
         ;; Command requires growth of an mvl using term expressions.
         ((= command term:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random term expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growCTermWFF m))
		          (setq genome[m] (eGrammar.growTermWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case term command
         ;; Command requires growth of an mvl using full expressions.
         ((= command full:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random full expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growWFF expression: 0))
		          (setq genome[m] (eGrammar.growRootWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case full command
         ;; All other commands return an error.
         (else (error (append "gsm.ruleFrm.growWFF: invalid command [" command "]")))
         ) ; end command cond
	
	   ;; Create the multivariate factor regression Estimator from the final WFF.
	   Last::
       (if (isLambda genome) 
           (begin 
             (setq Lambda genome)
             (if (isVector Lambda.Genome) (setq genome genome.Genome) (setq genome genome.WFF[1]))
           )) ; end if
       (if (= genome #void) (error "ruleFrm.growWFF: encountered a void genome")) 
       (setq wff (wffList (list ruleFrm: genome)))
       (setq genome wff[1])
       (setq cntChromosomes 0)
       (setq M (length genome))
       (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntChromosomes)))
       (cond
        ;; We have less than the maximum number of chromosomes
	    ((>= maxChromosomes cntChromosomes) (setq Rf (createGrammarEstimator wff)))
        ;; We have more than the maximum number of chromosomes
        ;; Note: We must be an exhaustive search of all possible
        ;;       combinations of the chromosomes in this genome
        ;;       taken 'maxChromosomes' at a time.
	    (else 
         (begin
           (setq chromosomeIndices (new Vector: Integer: maxChromosomes))
           (setq chromosomeLimits (new Vector: Integer: maxChromosomes))
           (loop for mm from 0 until maxChromosomes do (setq chromosomeIndices[mm] mm) (setq chromosomeLimits[mm] (+ (- cntChromosomes maxChromosomes) mm)))
           (while (<= chromosomeIndices[0] chromosomeLimits[0]) do
             (setq newGenome (new Vector: M))
             (loop for mm from 0 until maxChromosomes do (setq k chromosomeIndices[mm]) (setq newGenome[mm] genome[k]))
             (setq Rf (createGrammarEstimator (list ruleFrm: newGenome)))
             ;; Increment the chromosome combinatatorial indices.
             (loop for mm from (- maxChromosomes 1) to 0 by -1 do (++ chromosomeIndices[mm]) (if (<= chromosomeIndices[mm] chromosomeLimits[mm]) (setq mm -1))) 
             (loop for mm from 1 until maxChromosomes do (if (> chromosomeIndices[mm] chromosomeLimits[mm]) (setq chromosomeIndices[mm] (+ chromosomeIndices[(- mm 1)] 1)))) 
             ) ; end while
         )) ; end else
        ) ; end cond
	   Rf) ; end growWFF

	(defun mutate(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator multivariate factor regression WFF 
    ;;           using genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff chromosome (Number:deathPct .10))
	
	   ;; Extract numeric WFFs from the candidate Estimator Lambda (where necessary).
	   (if (= wff #void) (return false))
	   (if (isLambda wff) (setq wff wff.Genome))
	   (if (isPair wff) (setq wff wff[1]))
	   (setq genome wff)
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the user selected mutation strategy 
       (cond
        ;; Do we use chromosomes from multiple genome columns during cross over operations?
        ((= myMutateStrategy normal:)
         (begin
           ;; Reorder the chromosomes in the candidate genome ocasionally.
           (if (<= (gsm.myRandomFunction 1.0) .50)
               then
               (begin 
                 (setq m (integer (gsm.myRandomFunction myM)))
                 (setq n (integer (gsm.myRandomFunction myM)))
                 (setq chromosome genome[m])
                 (setq genome[m] genome[n])
                 (setq genome[n] chromosome)
               )) ; end if
           (setq m (integer (gsm.myRandomFunction myM))) 
           (setq newWff (eGrammar.mutateNumericWFF genome[m]))
           (setq n 0)(while (and (< (++ n) 20) (> (lengthWFF newWff) myMaxColWFFLen)) do (setq newWff (eGrammar.mutateNumericWFF genome[m])))
           (if (> (lengthWFF newWff) myMaxColWFFLen) (return false))
           (if (<= (gsm.myRandomFunction 1.0) deathPct) (setq genome[m] #void) (setq genome[m] newWff))
         )) ;; end normal case
        (else (error (append "gsm.ruleFrm.mutate: unknown user specified mutation strategy [" myMutateStrategy "]")))
        ) ; end mutation strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (growWFF genome)
	
	   true) ; end mutate
		
    (defun wffList(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator multivariate factor regression wff to a 
    ;;           list format. 
	;;
	;; args:     wff         The multivariate factor regression wff.
	;;           
	;; Return:   result      A Estimator multivariate factor regression WFF such as '(ruleFrm #(obj| (x0-x5) abs(x1)))
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffListFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff wff) (setq wff (string wff true)))
       (setq wff (Lisp wff)[0])
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleFrm:)) (error "gsm.ruleFrm.wffList: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating frmregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffListFormat (list rule genome))
       wffListFormat) ; end wffList


	(defun wffSource(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multivariate factor regression statement 
    ;;           such as 
    ;;                     "frmregress(x0-x5,abs(x1));"
    ;;  
	;;           as an ASCI string in grammatically correct Estimator.
	;;
	;; args:     genome      The sparse vector of chromosome numeric expressions for the frmregress statement.
	;;           
	;; Return:   result      A Estimator multivariate factor regression statement such as "frmregress(x0-x5,abs(x1));"
	;;
	;; *******************************************************************
       regs:(m M (cn -1))
       vars:((wffSourceFormat "") wffTerm rule genome cntGenomes)
       vars:(Lambda chromosome0 chromosome1)
       ;; Eliminate all collisions before generating frmregress genome.
       (if (isConcrete genome)
           then
           (begin
             ;; Count the final number of non duplicate chromosomes.
             (setq M (length genome))
             (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntGenomes)))
             ;; Create the final source from an empty chromosome.
             (if (= cntGenomes 0) (return (setq wffSourceFormat "regress();")))
             ;; Create the final source from a single chromosome.
             (if (= cntGenomes 1) (return (setq wffSourceFormat (append "frmregress(" (eGrammar genome[0]) ");"))))
             ;; Create the final source from the multiple chromosomes.
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (if (<> genome[m] #void)
                   (begin
                     (setq wffTerm (eGrammar genome[m]))
                     (if (= wffSourceFormat "") 
                         (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                         (setq wffSourceFormat (append wffSourceFormat "," wffTerm))
                         ) ; end if
                   )) ; end if
               ) ; end column loop  
	           ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	           (setq wffSourceFormat (append "frmregress(" wffSourceFormat ");"))
           ) else
           (begin
              ;; Determine the number of existing abstract real number constants in this mvlregress genome.
              (setq Lambda (compileEstimator (evalRule (list ruleReg: genome))))
              (if (not (isLambda Lambda)) (setq cn -1) (setq cn (- Lambda.CCN 1)))
              ;; Eliminate all collisions before generating abstract mvlregress source expression.
              ;; Create the final source from the genome.
              (setq M (length genome))
              (loop for m from 0 until M do
                (if (<> genome[m] #void)
                    (begin
                      (setq wffTerm (append "(c" (++ cn) "*" (eGrammar genome[m]) ")"))
                      (if (= wffSourceFormat "") 
                          (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                          (setq wffSourceFormat (append wffSourceFormat "+" wffTerm))
                          ) ; end if
                    )) ; end if
                ) ; end column loop  
	          ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	          (setq wffSourceFormat (append "regress(" wffSourceFormat ");"))
              )) ; end if
	   wffSourceFormat) ; end wffSource    

   (defun wffString(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator multivariate factor regression wff to a 
    ;;           string format. 
	;;
	;; args:     wff         The multivariate factor regression wff.
	;;           
	;; Return:   result      A Estimator multivariate factor regression WFF such as "(ruleFrm #(obj| (x0-x5) abs(x1)))"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffStringFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff (Lisp wff)[0]))
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleFrm:)) (error "gsm.ruleFrm.wffString: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating frmregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffStringFormat (string (list rule genome) true))
       wffStringFormat) ; end stringWff

   	;; *******************************************************************************
   	;; Begin main logic 
   	;; *******************************************************************************
	vars:(wffSourceFormat)
    
    (setq wffSourceFormat (wffSource wff[1]))
    wffSourceFormat) ; end ruleFrm









































































































































































;;**EXPORTKEY**:gsm.ruleMdl
(defriend gsm:ruleMdl(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator model Lambdas. 
;;
;; Main:     Return a Estimator model statement,
;;           in source format, such as 
;;                    "model(x2*(x2-x10));" 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the model statement.
;;           
;; Return:   result      A Estimator model statement such as "model(x2*(x2-x10));".
;; *******************************************************************
  	pvars:(;; Public Variables
           (genomeType EXP)         ;; This regression rule uses an expression based genome.
           (lengthExempt false)     ;; This regression rule is NOT exempt from genome length restrictions.
           ;; Public Methods
           chromosomeLength         ;; Return the number of non-empty left-most chromosomes in the genome.
           crossOver                ;; Create two new Estimator linear regression WFFs by splicing two parent WFFs together using genetic crossover.
           crossOverAbstract        ;; Create two new Estimator linear regression WFFs by splicing two parent WFFs together using anstract expression genetic crossover.
           crossOverAware    		;; Create all possible new Estimator WFFs by splicing two parent WFFs together using context aware crossover.
           growWFF                  ;; Create a new Estimator linear regression wff to the current population.
           mutateAbstract           ;; Create a new Estimator multivariate linear regression WFF using abstract expression genetic mutation.
           mutate                   ;; Create a new Estimator linear regression WFF using genetic mutation.
           wffList                  ;; Convert a Estimator linear regression wff to a list format.
           wffSource				;; Convert a Estimator linear regression wff to a source statement such as "model(x0-x5*abs(x1));". 
           wffString                ;; Convert a Estimator linear regression wff to a string format such as "(ruleMdl #(obj| (ruleSub x0 x5) (ruleAbs x1)));"
           ) ; end persistant variables
   	;; *******************************************************************************
   	;; Define Public Child Lambdas 
   	;; *******************************************************************************

	(defun chromosomeLength(genome)
	;; *******************************************************************
	;; summary:  Return the number of non-empty left-most chromosomes in the genome. 
	;;
	;; args:     genome     The genome whose chromosome length is to be returned.           
	;;           
	;; Return:   length     The number of non-empty left-most chromosomes in the genome.
	;;
	;; *******************************************************************
	   regs:(m M len)
	
       (setq M (length genome))
	   (loop for m from 0 until M do
          (if (<> genome[m] #void) (++ len))
          ) ; end loop

	   len) ; end chromosomeLength

	(defun crossOver(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator linear regression WFFs, 
    ;;           by splicing two parent WFFs together using genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))

       ;; Implement the user select cross over strategy 
       (cond
        ;; Manage "Genetic" cross over?
        ;; Note: We use chromosomes in a "genetic algorithm" inspired cross over operation.
        ((and (= myCrossOverStrategy genetic:) (= myREGMultiple true))
         (begin
             ;; Select chromosomes from each genome.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (loop for m from 0 until M do
               (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m]))
               ) ; end column loop  	
         )) ; end genetic cross over strategy
        ;; Manage "Aggressive" cross over?
        ;; Note: We use chromosomes from multiple crossed genome columns during cross over operations.
        ((and (= myCrossOverStrategy aggressive:) (= myREGMultiple true))
         (begin
             ;; Reorder the chromosomes in the candidate genomes occasionally.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
      
             ;; Select chromosomes from each genome.
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (setq chromosomeCrossPct 1.5)
             (loop for m from 0 until M do
               (if (>= chromosomeCrossPct .50) (-= chromosomeCrossPct .50))
               (cond
                 ((> (gsm.myRandomFunction 1.0) chromosomeCrossPct) (setq genome[m] genome[m]))
                 ((= genome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m])))
                 ((= momGenome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] (eGrammar.mutateNumericWFF genome[m] (gsm.myRandomFunction 1.0)))))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs genome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 (else 
                  (begin
                     (setq dadWff genome[m])                    
                     (setq momSlot (setq momIndex (eGrammar.selectSlotWFF momGenome[m]))[(integer (gsm.myRandomFunction (length momIndex)))])
                     (setq dadPair (setq dadIndex (eGrammar.selectPairWFF dadWff))[(integer (gsm.myRandomFunction (length dadIndex)))])
                     (cond
                      ((isAtom dadPair) (setq genome[m] momSlot))
                      ((and (isPair momSlot) (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs (listWff dadPair) (listWff momSlot))) false))
                       (begin (setCar dadPair (car newWff))  (setCdr dadPair (cdr newWff))))
                      ((isPair momSlot) (begin (setCar dadPair (car momSlot))  (setCdr dadPair (cdr momSlot))))
                      (else (eGrammar.spliceNumericWFF dadPair momSlot 1.0))
                      ) ; end splice cond
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end aggressive cross over strategy
        ;; Manage "Normal" cross over?
        ;; Note: We use chromosomes from only single matched genome columns during cross over operations.
        ((= myCrossOverStrategy normal:)
         (begin
	         ;; Reorder the chromosomes in the candidate genomes occasionally.
	         (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	             then
	             (begin 
	               (setq dadGenome (copy dadGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome dadGenome[m])
	               (setq dadGenome[m] dadGenome[n])
	               (setq dadGenome[n] chromosome)
	             )) ; end if
	         (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	             then
	             (begin 
	               (setq momGenome (copy momGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome momGenome[m])
	               (setq momGenome[m] momGenome[n])
	               (setq momGenome[n] chromosome)
	             )) ; end if

	         ;; Splice the chromosomes in the candidate genomes to form the progeny.
             (setq genome (new Vector: myM))
             (if (= myREGMultiple true) (setq M myM) (setq M 0))
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (cond 
                 ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
                 ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
                 (else 
                  (begin
                     (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                         ) ; end if
                     (setq genome[m] newWff)
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end normal cross over strategy
        (else (error (append "gsm.ruleMdl.crossOver: unknown user specified cross over strategy [" myCrossOverStrategy "]")))
        ) ; end cross over strategy cond

	   ;; Make a Estimator linear regression wff and add it to the current population.
       Grow::
       (growWFF genome)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOver
	
	(defun crossOverAbstract(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator linear regression WFFs, 
    ;;           by splicing two parent WFFs together using abstract expression
    ;;           genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))


	   ;; Reorder the chromosomes in the candidate genomes occasionally.
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq dadGenome (copy dadGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome dadGenome[m])
	         (setq dadGenome[m] dadGenome[n])
	         (setq dadGenome[n] chromosome)
	       )) ; end if
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq momGenome (copy momGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome momGenome[m])
	         (setq momGenome[m] momGenome[n])
	         (setq momGenome[n] chromosome)
	       )) ; end if

	   ;; Splice the chromosomes in the candidate genomes to form the progeny.
       (setq genome (new Vector: myM))
       (if (= myREGMultiple true) (setq M myM) (setq M 0))
       (loop for m from 0 until M do
         ;; Select chromosomes from each genome.
         (cond 
           ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
           ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
           ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] (eGrammar.convertToAbstractWFF momGenome[m]))) false)) (setq genome[m] newWff))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
           (else 
            (begin
               (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                   ) ; end if
               (setq genome[m] newWff)
            )) ; end case
           ) ; end chromosome cond           
         ) ; end column loop  	

	   ;; Make a Estimator linear regression wff and add it to the current population.
       Grow::
       (createGrammarEstimator (list ruleMdl: genome) concrete:)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAbstract
	
	(defun crossOverAware(father mother)
	;; *******************************************************************
	;; summary:  Create all possible new Estimator WFFs by splicing two  
    ;;           parent WFFs together using context aware crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(k K m M n N ns NS np NP)
	   vars:(dadGenome momGenome dadWff momWff newWff (passOne true))
	   vars:(chromosome dadRule momRule newGenome genome)
       vars:(dadPairVector dadPair momSlotVector momSlot)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)
       ;(writeln "start context aware crossover: dad=" dadGenome ", mom=" momGenome)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))
       (setq M (chromosomeLength dadGenome))
       (setq N (chromosomeLength momGenome))

       ;; Reorder the chromosomes in the candidate genomes occasionally.
       ;; Note: we use a linear genome during cross over operations.
       (if (= myREGMultiple true)
           (begin
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
           )) ; end if
      
       ;; Select chromosomes from each genome.
       (setq genome (copy dadGenome))           
       (setq M (min M N))
       (loop for m from 0 until M do
          (if (and (<> dadGenome[m] #void) (<> momGenome[m] #void))
              (begin
                (setq dadPairVector (eGrammar.selectPairWFF dadGenome[m]))
                (setq momSlotVector (eGrammar.selectSlotWFF momGenome[m]))
                (setq NP (length dadPairVector))
                (setq NS (length momSlotVector))
                (loop for np from 0 until NP do
                   (loop for ns from 0 until NS do
                      (setq K (length dadPairVector[np]))
                      (loop for k from 1 until K do 
                         (setq dadPair (eGrammar.selectPairWFF (setq dadWff (listWff dadGenome[m])))[np])
                         (setq momSlot (eGrammar.selectSlotWFF (setq momWff (listWff momGenome[m])))[ns])
                         (if (= (eGrammar.spliceImmediateWFF dadPair momSlot k) true)
                             (begin     
	            			    ;; Make a new wff and add it to the current population.                               
                                (setq (setq newGenome (copy dadGenome))[m] dadWff)
                                ;(writeln "[" m "," np "," ns "," k "]:" "new=" newGenome ", dad=" dadGenome ", mom=" momGenome)
                                (growWFF newGenome)
                             )) ; end if
                         ) ; end K loop
                      ) ; end NS loop
                   ) ; end NP loop

              )) ; end if

         ) ; end column loop  	

	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAware
	
	(defun growWFF(command ...)
	;; *******************************************************************
	;; summary:  Grow a new Estimator linear regression WFF and
	;;           add it to the current population.
	;;
	;; args:     command 	The command to determine the type of WFF to grow..
	;;           choice     (Optional)The choice of term column OR the choice of sequential term WFF.
	;;           
	;; Return:   Lambda      A scored Estimator linear regression Lambda.
	;;
	;; *******************************************************************
	   regs:(k m M mm n N maxChromosomes cntChromosomes)
	   vars:(Lambda genome newGenome choice)
	   vars:(Rf wff)
	   vars:(IntVector:chromosomeIndices IntVector:chromosomeLimits)
	
       ;; Use the command to determine the type of WFF to grow.
       (setq maxChromosomes gsm.myREGMaximum)
       (if (>= (argCount) 2) (setq choice (argFetch 1)))
       (if (isNumber choice) (setq choice (integer choice)) (setq choice -2))
       (cond
         ;; Command is a genome vector.
         ((isVector command)
          (begin 
            (setq genome command) 
          )) ; end case genome vector
         ;; Command requires growth of an mvl using root expressions.
         ((= command root:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random root expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random root expressions for each chromosome in the genome.
                    (setq genome[m] (eGrammar.growRootWFF -2))
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random root expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (setq genome[0] (eGrammar.growRootWFF -2))
                )) ; end multiple columns if
          )) ; end case root command
         ;; Command requires growth of an mvl using term expressions.
         ((= command seqroot:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random term expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random term expressions for each chromosome in the genome.
                    (setq genome[m] (eGrammar.growTermWFF choice m))
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random term expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (setq genome[0] (eGrammar.growTermWFF choice))
                )) ; end multiple columns if
          )) ; end case seqroot command
         ;; Command requires growth of an mvl using term expressions.
         ((= command term:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random term expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random term expressions for each chromosome in the genome.
                    (if (= myGrowWFFStyle full:)
		                (setq genome[m] (eGrammar.growCTermWFF m))
		                (setq genome[m] (eGrammar.growTermWFF -2 m))
                        ) ; end if
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random term expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (if (= myGrowWFFStyle full:)
		              (setq genome[0] (eGrammar.growCTermWFF choice))
		              (setq genome[0] (eGrammar.growTermWFF -2 0))
                      ) ; end if
                )) ; end multiple columns if
          )) ; end case term command
         ;; Command requires growth of an mvl using full expressions.
         ((= command full:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random full expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
                    (if (= myGrowWFFStyle full:)
		                (setq genome[m] (eGrammar.growWFF expression: 0))
		                (setq genome[m] (eGrammar.growRootWFF -2 m))
                        ) ; end if
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random full expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
		          ;; Select random full expressions for each chromosome in the genome.
                  (if (= myGrowWFFStyle full:)
		              (setq genome[0] (eGrammar.growWFF expression: 0))
		              (setq genome[0] (eGrammar.growRootWFF choice))
                      ) ; end if
                )) ; end multiple columns if
          )) ; end case full command
         ;; All other commands return an error.
         (else (error (append "gsm.ruleMdl.growWFF: invalid command [" command "]")))
         ) ; end command cond
	
	   ;; Create the linear regression Estimator from the final WFF.
	   Last::
       (if (isLambda genome) 
           (begin 
             (setq Lambda genome)
             (if (isVector Lambda.Genome) (setq genome genome.Genome) (setq genome genome.WFF[1]))
           )) ; end if
       (if (= genome #void) (error "ruleMdl.growWFF: encountered a void genome")) 
       (setq wff (wffList (list ruleReg: genome)))
       (setq genome wff[1])
       (setq cntChromosomes 0)
       (setq M (length genome))
       (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntChromosomes)))
       (cond
        ;; We have less than the maximum number of chromosomes
	    ((>= maxChromosomes cntChromosomes) (setq Rf (createGrammarEstimator wff)))
        ;; We have more than the maximum number of chromosomes
        ;; Note: We must be an exhaustive search of all possible
        ;;       combinations of the chromosomes in this genome
        ;;       taken 'maxChromosomes' at a time.
	    (else 
         (begin
           (setq chromosomeIndices (new Vector: Integer: maxChromosomes))
           (setq chromosomeLimits (new Vector: Integer: maxChromosomes))
           (loop for mm from 0 until maxChromosomes do (setq chromosomeIndices[mm] mm) (setq chromosomeLimits[mm] (+ (- cntChromosomes maxChromosomes) mm)))
           (while (<= chromosomeIndices[0] chromosomeLimits[0]) do
             (setq newGenome (new Vector: M))
             (loop for mm from 0 until maxChromosomes do (setq k chromosomeIndices[mm]) (setq newGenome[mm] genome[k]))
             (setq Rf (createGrammarEstimator (list ruleReg: newGenome)))
             ;; Increment the chromosome combinatatorial indices.
             (loop for mm from (- maxChromosomes 1) to 0 by -1 do (++ chromosomeIndices[mm]) (if (<= chromosomeIndices[mm] chromosomeLimits[mm]) (setq mm -1))) 
             (loop for mm from 1 until maxChromosomes do (if (> chromosomeIndices[mm] chromosomeLimits[mm]) (setq chromosomeIndices[mm] (+ chromosomeIndices[(- mm 1)] 1)))) 
             ) ; end while
         )) ; end else
        ) ; end cond
	   Rf) ; end growWFF

	(defun mutateAbstract(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator multivariate linear regression WFF 
    ;;           using abstract expression genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff Lambda)
	
	   ;; Collect the WFFs rule and genome (only mutate properly formed WFFs with rules of type ruleReg or ruleMvl).
	   (if (isLambda wff) (setq wff wff.WFF))
	   (if (= wff #void) (return false))
       (setq wff (listWff wff))
	   (setq rule wff[0])
	   (setq genome wff[1])
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the abstract expression mutation strategy         
       (setq genome[m] (eGrammar.mutateAbstractC0 genome[(setq m (integer (gsm.myRandomFunction myM)))]))
       (if (<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] (eGrammar.mutateAbstractC1 genome[(setq m (integer (gsm.myRandomFunction myM)))])))

	   ;; Make an abstract Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (setq wff (wffList (list ruleMdl: genome)))
       (createGrammarEstimator wff concrete:)
	   true) ; end mutateAbstract

	(defun mutate(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator linear regression WFF 
    ;;           using genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff chromosome (Number:deathPct .10))
	
       ;; Mutate using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myMutateAbsPct) (return (mutateAbstract wff)))

	   ;; Extract numeric WFFs from the candidate Estimator Lambda (where necessary).
	   (if (= wff #void) (return false))
	   (if (isLambda wff) (setq wff wff.Genome))
	   (if (isPair wff) (setq wff wff[1]))
	   (setq genome wff)
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the user selected mutation strategy 
       (cond
        ;; Do we use chromosomes from multiple genome columns during cross over operations?
        ((= myMutateStrategy normal:)
         (begin
           ;; Reorder the chromosomes in the candidate genome ocasionally.
           (if (<= (gsm.myRandomFunction 1.0) .50)
               then
               (begin 
                 (setq m (integer (gsm.myRandomFunction myM)))
                 (setq n (integer (gsm.myRandomFunction myM)))
                 (setq chromosome genome[m])
                 (setq genome[m] genome[n])
                 (setq genome[n] chromosome)
               )) ; end if
           (if (= myREGMultiple true) (setq m (integer (gsm.myRandomFunction myM))) (setq m 0)) 
           (setq newWff (eGrammar.mutateNumericWFF genome[m]))
           (setq n 0)(while (and (< (++ n) 20) (> (lengthWFF newWff) myMaxColWFFLen)) do (setq newWff (eGrammar.mutateNumericWFF genome[m])))
           (if (> (lengthWFF newWff) myMaxColWFFLen) (return false))
           (if (<= (gsm.myRandomFunction 1.0) deathPct) (setq genome[m] #void) (setq genome[m] newWff))
         )) ;; end normal case
        (else (error (append "gsm.ruleMdl.mutate: unknown user specified mutation strategy [" myMutateStrategy "]")))
        ) ; end mutation strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (growWFF genome)
	
	   true) ; end mutate
		
    (defun wffList(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator linear regression wff to a 
    ;;           list format. 
	;;
	;; args:     wff         The linear regression wff.
	;;           
	;; Return:   result      A Estimator linear regression WFF such as '(ruleReg #(obj| (x0-x5) abs(x1)))
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffListFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff wff) (setq wff (string wff true)))
       (setq wff (Lisp wff)[0])
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleMdl:)) (error "gsm.ruleMdl.wffList: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       (setq wffListFormat (list rule genome))
       wffListFormat) ; end wffList


	(defun wffSource(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator model statement 
    ;;           such as 
    ;;                     "model(x0-x5*abs(x1));"
    ;;  
	;;           as an ASCI string in grammatically correct Estimator.
	;;
	;; args:     genome      The sparse vector of chromosome numeric expressions for the model statement.
	;;           
	;; Return:   result      A Estimator model statement such as "model(x0-x5*abs(x1));"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:((wffSourceFormat "") rule genome)
       vars:(chromosome0 chromosome1)
       ;; Create the final source from the genome.
       (setq M (length genome))
       (loop for m from 0 until M do
         ;; Select chromosomes from each genome.
         (cond 
           ((and (= wffSourceFormat "") (<> genome[m] #void)) (setq wffSourceFormat (eGrammar genome[m])))
           ((and (<> wffSourceFormat "") (<> genome[m] #void)) (setq wffSourceFormat (append wffSourceFormat "+" (eGrammar genome[m]))))
           ) ; end chromosome cond
         ) ; end column loop  
	    ;; Generate a gramatically correct Estimator linear regression statement in source format.
	   (setq wffSourceFormat (append "model(" wffSourceFormat ");"))
	   wffSourceFormat) ; end wffSource    

    (defun wffString(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator model wff to a 
    ;;           string format. 
	;;
	;; args:     wff         The model wff.
	;;           
	;; Return:   result      A Estimator model WFF such as "(ruleMdl #(obj| (x0-x5) abs(x1)))"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffStringFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff (Lisp wff)[0]))
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleReg:)) (error "gsm.ruleMdl.wffString: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       (setq wffStringFormat (string (list rule genome) true))
       wffStringFormat) ; end stringWff


   	;; *******************************************************************************
   	;; Begin main logic 
   	;; *******************************************************************************
	vars:(wffSourceFormat)
    
    (setq wffSourceFormat (wffSource wff[1]))
    wffSourceFormat) ; end ruleMdl








































































































































































;;**EXPORTKEY**:gsm.ruleMvl
(defriend gsm:ruleMvl(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator multivariate 
;;           linear regression Lambdas. 
;;
;; Main:     Return a Estimator multivariate linear regression statement,
;;           in source format, such as 
;;                    "mvlregress(x2,(x2-x10));" 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the multivariate linear regression statement.
;;           
;; Return:   result      A Estimator multivariate linear regression statement such as "mvlregress(x2,(x2-x10));".
;; *******************************************************************
  	pvars:(;; Public Variables
           (genomeType EXP)         ;; This regression rule uses an expression based genome.
           (lengthExempt false)     ;; This regression rule is NOT exempt from genome length restrictions.
           ;; Public Methods
           chromosomeLength         ;; Return the number of non-empty left-most chromosomes in the genome.
           crossOver                ;; Create two new Estimator multivariate linear regression WFFs by splicing two parent WFFs together using genetic crossover.
           crossOverAbstract        ;; Create two new Estimator linear regression WFFs by splicing two parent WFFs together using anstract expression genetic crossover.
           crossOverAware    		;; Create all possible new Estimator WFFs by splicing two parent WFFs together using context aware crossover.
           growWFF                  ;; Create a new Estimator multivariate linear regression wff to the current population.
           mutate                   ;; Create a new Estimator multivariate linear regression WFF using genetic mutation.
           mutateAbstract           ;; Create a new Estimator multivariate linear regression WFF using abstract expression genetic mutation.
           wffList                  ;; Convert a Estimator multivariate linear regression wff to a list format.
           wffSource				;; Convert a Estimator multivariate linear regression wff to a source statement such as "mvlregress(x0-x5,abs(x1));". 
           wffString                ;; Convert a Estimator multivariate linear regression wff to a string format such as "(ruleMvl #(obj| (ruleSub x0 x5) (ruleAbs x1)));"
           ) ; end persistant variables
   	;; *******************************************************************************
   	;; Define Public Child Lambdas 
   	;; *******************************************************************************

	(defun chromosomeLength(genome)
	;; *******************************************************************
	;; summary:  Return the number of non-empty left-most chromosomes in the genome. 
	;;
	;; args:     genome     The genome whose chromosome length is to be returned.           
	;;           
	;; Return:   length     The number of non-empty left-most chromosomes in the genome.
	;;
	;; *******************************************************************
	   regs:(m M len)
	
       (setq M (length genome))
	   (loop for m from 0 until M do
          (if (<> genome[m] #void) (++ len))
          ) ; end loop

	   len) ; end chromosomeLength


	(defun crossOver(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator multivariate linear regression WFFs, 
    ;;           by splicing two parent WFFs together using genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))

       ;; Implement the user select cross over strategy 
       (cond
        ;; Manage "Genetic" cross over?
        ;; Note: We use chromosomes in a "genetic algorithm" inspired cross over operation.
        ((and (= myCrossOverStrategy genetic:) (= myREGMultiple true))
         (begin
             ;; Select chromosomes from each genome.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (loop for m from 0 until M do
               (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m]))
               ) ; end column loop  	
         )) ; end genetic cross over strategy
        ;; Manage "Aggressive" cross over?
        ;; Note: We use chromosomes from multiple crossed genome columns during cross over operations.
        ((= myCrossOverStrategy aggressive:)
         (begin
             ;; Reorder the chromosomes in the candidate genomes occasionally.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
      
             ;; Select chromosomes from each genome.
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (setq chromosomeCrossPct 1.5)
             (loop for m from 0 until M do
               (if (>= chromosomeCrossPct .50) (-= chromosomeCrossPct .50))
               (cond
                 ((> (gsm.myRandomFunction 1.0) chromosomeCrossPct) (setq genome[m] genome[m]))
                 ((= genome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m])))
                 ((= momGenome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] (eGrammar.mutateNumericWFF genome[m] (gsm.myRandomFunction 1.0)))))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs genome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 (else 
                  (begin
                     (setq dadWff genome[m])                    
                     (setq momSlot (setq momIndex (eGrammar.selectSlotWFF momGenome[m]))[(integer (gsm.myRandomFunction (length momIndex)))])
                     (setq dadPair (setq dadIndex (eGrammar.selectPairWFF dadWff))[(integer (gsm.myRandomFunction (length dadIndex)))])
                     (cond
                      ((isAtom dadPair) (setq genome[m] momSlot))
                      ((and (isPair momSlot) (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs (listWff dadPair) (listWff momSlot))) false))
                       (begin (setCar dadPair (car newWff))  (setCdr dadPair (cdr newWff))))
                      ((isPair momSlot) (begin (setCar dadPair (car momSlot))  (setCdr dadPair (cdr momSlot))))
                      (else (eGrammar.spliceNumericWFF dadPair momSlot 1.0))
                      ) ; end splice cond
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end aggressive cross over strategy
        ;; Manage "Normal" cross over?
        ;; Note: We use chromosomes from only single matched genome columns during cross over operations.
        ((= myCrossOverStrategy normal:)
         (begin
	         ;; Reorder the chromosomes in the candidate genomes occasionally.
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq dadGenome (copy dadGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome dadGenome[m])
	               (setq dadGenome[m] dadGenome[n])
	               (setq dadGenome[n] chromosome)
	             )) ; end if
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq momGenome (copy momGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome momGenome[m])
	               (setq momGenome[m] momGenome[n])
	               (setq momGenome[n] chromosome)
	             )) ; end if

	         ;; Splice the chromosomes in the candidate genomes to form the progeny.
             (setq genome (new Vector: myM))
             (setq M myM)
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (cond 
                 ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
                 ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
                 (else 
                  (begin
                     (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                         ) ; end if
                     (setq genome[m] newWff)
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end normal cross over strategy
        (else (error (append "gsm.ruleMvl.crossOver: unknown user specified cross over strategy [" myCrossOverStrategy "]")))
        ) ; end cross over strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Grow::
       (growWFF genome dadGenome)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOver
	
	(defun crossOverAbstract(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator linear regression WFFs, 
    ;;           by splicing two parent WFFs together using abstract expression
    ;;           genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff wff Lambda (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))


	   ;; Reorder the chromosomes in the candidate genomes occasionally.
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq dadGenome (copy dadGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome dadGenome[m])
	         (setq dadGenome[m] dadGenome[n])
	         (setq dadGenome[n] chromosome)
	       )) ; end if
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq momGenome (copy momGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome momGenome[m])
	         (setq momGenome[m] momGenome[n])
	         (setq momGenome[n] chromosome)
	       )) ; end if

	   ;; Splice the chromosomes in the candidate genomes to form the progeny.
       (setq genome (new Vector: myM))
       (if (= myREGMultiple true) (setq M myM) (setq M 0))
       (loop for m from 0 until M do
         ;; Select chromosomes from each genome.
         (cond 
           ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
           ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
           ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] (eGrammar.convertToAbstractWFF momGenome[m]))) false)) (setq genome[m] newWff))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
           (else 
            (begin
               (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                   ) ; end if
               (setq genome[m] newWff)
            )) ; end case
           ) ; end chromosome cond           
         ) ; end column loop  	

	   ;; Make a Estimator linear regression wff and add it to the current population.
       Grow::
       (setq wff (list ruleMdl: genome))
       (if (isLambda (setq Lambda (createGrammarEstimator wff nosave:)))
           (begin
             (setq newWff (concreteWFF Lambda))
             (setq newWff[0] ruleMvl:)
             (createGrammarEstimator newWff)
           )) ; end if
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAbstract
	
	(defun crossOverAware(father mother)
	;; *******************************************************************
	;; summary:  Create all possible new Estimator WFFs by splicing two  
    ;;           parent WFFs together using context aware crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(k K m M n N ns NS np NP)
	   vars:(dadGenome momGenome dadWff momWff newWff (passOne true))
	   vars:(chromosome dadRule momRule newGenome genome)
       vars:(dadPairVector dadPair momSlotVector momSlot)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))
       (setq M (chromosomeLength dadGenome))
       (setq N (chromosomeLength momGenome))

       ;; Reorder the chromosomes in the candidate genomes occasionally.
       ;; Note: we use a linear genome during cross over operations.
       (if (= myREGMultiple true)
           (begin
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
           )) ; end if
      
       ;; Select chromosomes from each genome.
       (setq genome (copy dadGenome))           
       (setq M (min M N))
       (loop for m from 0 until M do
          (if (and (<> dadGenome[m] #void) (<> momGenome[m] #void))
              (begin
                (setq dadPairVector (eGrammar.selectPairWFF dadGenome[m]))
                (setq momSlotVector (eGrammar.selectSlotWFF momGenome[m]))
                (setq NP (length dadPairVector))
                (setq NS (length momSlotVector))
                (loop for np from 0 until NP do
                   (loop for ns from 0 until NS do
                      (setq K (length dadPairVector[np]))
                      (loop for k from 1 until K do 
                         (setq dadPair (eGrammar.selectPairWFF (setq dadWff (listWff dadGenome[m])))[np])
                         (setq momSlot (eGrammar.selectSlotWFF (setq momWff (listWff momGenome[m])))[ns])
                         (if (= (eGrammar.spliceImmediateWFF dadPair momSlot k) true)
                             (begin     
	            			    ;; Make a new wff and add it to the current population.                               
                                (setq (setq newGenome (copy dadGenome))[m] dadWff)
                                ;(writeln "[" m "," np "," ns "," k "]:" "new=" newGenome ", dad=" dadGenome ", mom=" momGenome)
                                (growWFF newGenome)
                             )) ; end if
                         ) ; end K loop
                      ) ; end NS loop
                   ) ; end NP loop

              )) ; end if

         ) ; end column loop  	

	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAware
	
	(defun growWFF(command ...)
	;; *******************************************************************
	;; summary:  Grow a new Estimator multivariate linear regression WFF and
	;;           add it to the current population.
	;;
	;; args:     command 	The command to determine the type of WFF to grow..
	;;           
	;; Return:   Lambda      A scored Estimator multivariate linear regression Lambda.
	;;
	;; *******************************************************************
	   regs:(k m M mm n N maxChromosomes cntChromosomes)
	   vars:(Lambda genome newGenome)
	   vars:(Rf wff)
	   vars:(IntVector:chromosomeIndices IntVector:chromosomeLimits)
	
       ;; Use the command to determine the type of WFF to grow.
       (setq maxChromosomes gsm.myMVLMaximum)
       (cond
         ;; Command is a genome vector.
         ((isVector command)
          (begin
            (setq genome command) 
          )) ; end case genome vector
         ;; Command requires growth of an mvl using root expressions.
         ((= command root:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random root expressions for each chromosome in the genome.
              (setq genome[m] (eGrammar.growRootWFF -2))
		      ) ; end column loop  
          )) ; end case root command
         ;; Command requires growth of an mvl using term expressions.
         ((= command term:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random term expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growCTermWFF m))
		          (setq genome[m] (eGrammar.growTermWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case term command
         ;; Command requires growth of an mvl using full expressions.
         ((= command full:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random full expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growWFF expression: 0))
		          (setq genome[m] (eGrammar.growRootWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case full command
         ;; All other commands return an error.
         (else (error (append "gsm.ruleMvl.growWFF: invalid command [" command "]")))
         ) ; end command cond
	
	   ;; Create the multivariate linear regression Estimator from the final WFF.
	   Last::
       (if (isLambda genome) 
           (begin 
             (setq Lambda genome)
             (if (isVector Lambda.Genome) (setq genome genome.Genome) (setq genome genome.WFF[1]))
           )) ; end if
       (if (= genome #void) (error "ruleMvl.growWFF: encountered a void genome")) 
       (setq wff (wffList (list ruleMvl: genome)))
       (setq genome wff[1])
       (setq cntChromosomes 0)
       (setq M (length genome))
       (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntChromosomes)))
       (cond
        ;; We have less than the maximum number of chromosomes
	    ((>= maxChromosomes cntChromosomes) (setq Rf (createGrammarEstimator wff)))
        ;; We have more than the maximum number of chromosomes
        ;; Note: We must be an exhaustive search of all possible
        ;;       combinations of the chromosomes in this genome
        ;;       taken 'maxChromosomes' at a time.
	    (else 
         (begin
           (setq chromosomeIndices (new Vector: Integer: maxChromosomes))
           (setq chromosomeLimits (new Vector: Integer: maxChromosomes))
           (loop for mm from 0 until maxChromosomes do (setq chromosomeIndices[mm] mm) (setq chromosomeLimits[mm] (+ (- cntChromosomes maxChromosomes) mm)))
           (while (<= chromosomeIndices[0] chromosomeLimits[0]) do
             (setq newGenome (new Vector: M))
             (loop for mm from 0 until maxChromosomes do (setq k chromosomeIndices[mm]) (setq newGenome[mm] genome[k]))
             (setq Rf (createGrammarEstimator (list ruleMvl: newGenome)))
             ;; Increment the chromosome combinatatorial indices.
             (loop for mm from (- maxChromosomes 1) to 0 by -1 do (++ chromosomeIndices[mm]) (if (<= chromosomeIndices[mm] chromosomeLimits[mm]) (setq mm -1))) 
             (loop for mm from 1 until maxChromosomes do (if (> chromosomeIndices[mm] chromosomeLimits[mm]) (setq chromosomeIndices[mm] (+ chromosomeIndices[(- mm 1)] 1)))) 
             ) ; end while
         )) ; end else
        ) ; end cond
	   Rf) ; end growWFF

	(defun mutateAbstract(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator multivariate linear regression WFF 
    ;;           using abstract expression genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff Lambda ec)
	
	   ;; Collect the WFFs rule and genome (only mutate properly formed WFFs with rules of type ruleReg or ruleMvl).
	   (if (isLambda wff) (setq wff wff.WFF))
	   (if (= wff #void) (return false))
       (setq wff (listWff wff))
	   (setq rule wff[0])
	   (setq genome wff[1])
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the abstract expression mutation strategy         
       (setq genome[m] (eGrammar.mutateAbstractC0 genome[(setq m (integer (gsm.myRandomFunction myM)))]))
       (if (<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] (eGrammar.mutateAbstractC1 genome[(setq m (integer (gsm.myRandomFunction myM)))])))

	   ;; Make an abstract Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (setq wff (list ruleMdl: genome))
       (if (isLambda (setq Lambda (createGrammarEstimator wff nosave:)))
           (begin
             (setq newWff (concreteWFF Lambda))
             (setq newWff[0] ruleMvl:)
             (createGrammarEstimator newWff)
           )) ; end if
	   true) ; end mutateAbstract

	(defun mutate(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator multivariate linear regression WFF 
    ;;           using genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff chromosome (Number:deathPct .10))
	
       ;; Mutate using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myMutateAbsPct) (return (mutateAbstract wff)))

	   ;; Extract numeric WFFs from the candidate Estimator Lambda (where necessary).
	   (if (= wff #void) (return false))
	   (if (isLambda wff) (setq wff wff.Genome))
	   (if (isPair wff) (setq wff wff[1]))
	   (setq genome wff)
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the user selected mutation strategy 
       (cond
        ;; Do we use chromosomes from multiple genome columns during cross over operations?
        ((= myMutateStrategy normal:)
         (begin
           ;; Reorder the chromosomes in the candidate genome ocasionally.
           (if (<= (gsm.myRandomFunction 1.0) .50)
               then
               (begin 
                 (setq m (integer (gsm.myRandomFunction myM)))
                 (setq n (integer (gsm.myRandomFunction myM)))
                 (setq chromosome genome[m])
                 (setq genome[m] genome[n])
                 (setq genome[n] chromosome)
               )) ; end if
           (setq m (integer (gsm.myRandomFunction myM))) 
           (setq newWff (eGrammar.mutateNumericWFF genome[m]))
           (setq n 0)(while (and (< (++ n) 20) (> (lengthWFF newWff) myMaxColWFFLen)) do (setq newWff (eGrammar.mutateNumericWFF genome[m])))
           (if (> (lengthWFF newWff) myMaxColWFFLen) (return false))
           (if (<= (gsm.myRandomFunction 1.0) deathPct) (setq genome[m] #void) (setq genome[m] newWff))
         )) ;; end normal case
        (else (error (append "gsm.ruleMvl.mutate: unknown user specified mutation strategy [" myMutateStrategy "]")))
        ) ; end mutation strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (growWFF genome)
	
	   true) ; end mutate
		
    (defun wffList(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator multivariate linear regression wff to a 
    ;;           list format. 
	;;
	;; args:     wff         The multivariate linear regression wff.
	;;           
	;; Return:   result      A Estimator multivariate linear regression WFF such as '(ruleMvl #(obj| (x0-x5) abs(x1)))
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffListFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff wff) (setq wff (string wff true)))
       (setq wff (Lisp wff)[0])
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleMvl:)) (error "gsm.ruleMvl.wffList: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating mvlregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffListFormat (list rule genome))
       wffListFormat) ; end wffList


	(defun wffSource(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator multivariate linear regression statement 
    ;;           such as 
    ;;                     "mvlregress(x0-x5,abs(x1));"
    ;;  
	;;           as an ASCI string in grammatically correct Estimator.
	;;
	;; args:     genome      The sparse vector of chromosome numeric expressions for the mvlregress statement.
	;;           
	;; Return:   result      A Estimator multivariate linear regression statement such as "mvlregress(x0-x5,abs(x1));"
	;;
	;; *******************************************************************
       regs:(m M (cn -1))
       vars:((wffSourceFormat "") wffTerm rule genome cntGenomes)
       vars:(Lambda chromosome0 chromosome1)
       ;; Eliminate all collisions before generating mvlregress genome.
       (if (isConcrete genome)
           then
           (begin
             ;; Count the final number of non duplicate chromosomes.
             (setq M (length genome))
             (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntGenomes)))
             ;; Create the final source from an empty chromosome.
             (if (= cntGenomes 0) (return (setq wffSourceFormat "regress();")))
             ;; Create the final source from a single chromosome.
             (if (= cntGenomes 1) (return (setq wffSourceFormat (append "regress(" (eGrammar genome[0]) ");"))))
             ;; Create the final source from the multiple chromosomes.
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (if (<> genome[m] #void)
                   (begin
                     (setq wffTerm (eGrammar genome[m]))
                     (if (= wffSourceFormat "") 
                         (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                         (setq wffSourceFormat (append wffSourceFormat "," wffTerm))
                         ) ; end if
                   )) ; end if
               ) ; end column loop  
	           ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	           (setq wffSourceFormat (append "mvlregress(" wffSourceFormat ");"))
           ) else
           (begin
              ;; Determine the number of existing abstract real number constants in this mvlregress genome.
              (setq Lambda (compileEstimator (evalRule (list ruleReg: genome))))
              (if (not (isLambda Lambda)) (setq cn -1) (setq cn (- Lambda.CCN 1)))
              ;; Eliminate all collisions before generating abstract mvlregress source expression.
              ;; Create the final source from the genome.
              (setq M (length genome))
              (loop for m from 0 until M do
                (if (<> genome[m] #void)
                    (begin
                      (setq wffTerm (append "(c" (++ cn) "*" (eGrammar genome[m]) ")"))
                      (if (= wffSourceFormat "") 
                          (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                          (setq wffSourceFormat (append wffSourceFormat "+" wffTerm))
                          ) ; end if
                    )) ; end if
                ) ; end column loop  
	          ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	          (setq wffSourceFormat (append "regress(" wffSourceFormat ");"))
              )) ; end if
	    wffSourceFormat) ; end ruleMvl    

   (defun wffString(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator multivariate linear regression wff to a 
    ;;           string format. 
	;;
	;; args:     wff         The multivariate linear regression wff.
	;;           
	;; Return:   result      A Estimator multivariate linear regression WFF such as "(ruleMvl #(obj| (x0-x5) abs(x1)))"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffStringFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff (Lisp wff)[0]))
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleMvl:)) (error "gsm.ruleMvl.wffString: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating mvlregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffStringFormat (string (list rule genome) true))
       wffStringFormat) ; end stringWff

   	;; *******************************************************************************
   	;; Begin main logic 
   	;; *******************************************************************************
	vars:(wffSourceFormat)
    
    (setq wffSourceFormat (wffSource wff[1]))
    wffSourceFormat) ; end ruleMvl










































































































































































;;**EXPORTKEY**:gsm.ruleReg
(defriend gsm:ruleReg(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator linear regression Lambdas. 
;;
;; Main:     Return a Estimator linear regression statement,
;;           in source format, such as 
;;                    "regress(x2*(x2-x10));" 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the linear regression statement.
;;           
;; Return:   result      A Estimator linear regression statement such as "regress(x2*(x2-x10));".
;; *******************************************************************
  	pvars:(;; Public Variables
           (genomeType EXP)         ;; This regression rule uses an expression based genome.
           (lengthExempt false)     ;; This regression rule is NOT exempt from genome length restrictions.
           ;; Public Methods
           chromosomeLength         ;; Return the number of non-empty left-most chromosomes in the genome.
           crossOver                ;; Create two new Estimator linear regression WFFs by splicing two parent WFFs together using genetic crossover.
           crossOverAbstract        ;; Create two new Estimator linear regression WFFs by splicing two parent WFFs together using anstract expression genetic crossover.
           crossOverAware    		;; Create all possible new Estimator WFFs by splicing two parent WFFs together using context aware crossover.
           growWFF                  ;; Create a new Estimator linear regression wff to the current population.
           mutateAbstract           ;; Create a new Estimator multivariate linear regression WFF using abstract expression genetic mutation.
           mutate                   ;; Create a new Estimator linear regression WFF using genetic mutation.
           wffList                  ;; Convert a Estimator linear regression wff to a list format.
           wffSource				;; Convert a Estimator linear regression wff to a source statement such as "regress(x0-x5*abs(x1));". 
           wffString                ;; Convert a Estimator linear regression wff to a string format such as "(ruleReg #(obj| (ruleSub x0 x5) (ruleAbs x1)));"
           ;; Private Maintenance Methods
	       selfTest                 ;; The self test method for ruleReg Lambdas.
           ) ; end persistant variables
   	;; *******************************************************************************
   	;; Define Public Child Lambdas 
   	;; *******************************************************************************

	(defun chromosomeLength(genome)
	;; *******************************************************************
	;; summary:  Return the number of non-empty left-most chromosomes in the genome. 
	;;
	;; args:     genome     The genome whose chromosome length is to be returned.           
	;;           
	;; Return:   length     The number of non-empty left-most chromosomes in the genome.
	;;
	;; *******************************************************************
	   regs:(m M len)
	
       (setq M (length genome))
	   (loop for m from 0 until M do
          (if (<> genome[m] #void) (++ len))
          ) ; end loop

	   len) ; end chromosomeLength


	(defun crossOver(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator linear regression WFFs, 
    ;;           by splicing two parent WFFs together using genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))

       ;; Implement the user select cross over strategy 
       (cond
        ;; Manage "Genetic" cross over?
        ;; Note: We use chromosomes in a "genetic algorithm" inspired cross over operation.
        ((and (= myCrossOverStrategy genetic:) (= myREGMultiple true))
         (begin
             ;; Select chromosomes from each genome.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (loop for m from 0 until M do
               (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m]))
               ) ; end column loop  	
         )) ; end genetic cross over strategy
        ;; Manage "Aggressive" cross over?
        ;; Note: We use chromosomes from multiple crossed genome columns during cross over operations.
        ((and (= myCrossOverStrategy aggressive:) (= myREGMultiple true))
         (begin
             ;; Reorder the chromosomes in the candidate genomes occasionally.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
      
             ;; Select chromosomes from each genome.
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (setq chromosomeCrossPct 1.5)
             (loop for m from 0 until M do
               (if (>= chromosomeCrossPct .50) (-= chromosomeCrossPct .50))
               (cond
                 ((> (gsm.myRandomFunction 1.0) chromosomeCrossPct) (setq genome[m] genome[m]))
                 ((= genome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m])))
                 ((= momGenome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] (eGrammar.mutateNumericWFF genome[m] (gsm.myRandomFunction 1.0)))))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs genome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 (else 
                  (begin
                     (setq dadWff genome[m])                    
                     (setq momSlot (setq momIndex (eGrammar.selectSlotWFF momGenome[m]))[(integer (gsm.myRandomFunction (length momIndex)))])
                     (setq dadPair (setq dadIndex (eGrammar.selectPairWFF dadWff))[(integer (gsm.myRandomFunction (length dadIndex)))])
                     (cond
                      ((isAtom dadPair) (setq genome[m] momSlot))
                      ((and (isPair momSlot) (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs (listWff dadPair) (listWff momSlot))) false))
                       (begin (setCar dadPair (car newWff))  (setCdr dadPair (cdr newWff))))
                      ((isPair momSlot) (begin (setCar dadPair (car momSlot))  (setCdr dadPair (cdr momSlot))))
                      (else (eGrammar.spliceNumericWFF dadPair momSlot 1.0))
                      ) ; end splice cond
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end aggressive cross over strategy
        ;; Manage "Normal" cross over?
        ;; Note: We use chromosomes from only single matched genome columns during cross over operations.
        ((= myCrossOverStrategy normal:)
         (begin
	         ;; Reorder the chromosomes in the candidate genomes occasionally.
	         (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	             then
	             (begin 
	               (setq dadGenome (copy dadGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome dadGenome[m])
	               (setq dadGenome[m] dadGenome[n])
	               (setq dadGenome[n] chromosome)
	             )) ; end if
	         (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	             then
	             (begin 
	               (setq momGenome (copy momGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome momGenome[m])
	               (setq momGenome[m] momGenome[n])
	               (setq momGenome[n] chromosome)
	             )) ; end if

	         ;; Splice the chromosomes in the candidate genomes to form the progeny.
             (setq genome (new Vector: myM))
             (if (= myREGMultiple true) (setq M myM) (setq M 0))
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (cond 
                 ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
                 ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
                 (else 
                  (begin
                     (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                         ) ; end if
                     (setq genome[m] newWff)
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end normal cross over strategy
        (else (error (append "gsm.ruleReg.crossOver: unknown user specified cross over strategy [" myCrossOverStrategy "]")))
        ) ; end cross over strategy cond

	   ;; Make a Estimator linear regression wff and add it to the current population.
       Grow::
       (growWFF genome)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOver
	
	(defun crossOverAbstract(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator linear regression WFFs, 
    ;;           by splicing two parent WFFs together using abstract expression
    ;;           genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)
	
       ;; Cross over using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myCrossAbsPct) (return (crossOverAbstract father mother)))

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))


	   ;; Reorder the chromosomes in the candidate genomes occasionally.
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq dadGenome (copy dadGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome dadGenome[m])
	         (setq dadGenome[m] dadGenome[n])
	         (setq dadGenome[n] chromosome)
	       )) ; end if
	   (if (and (= myREGMultiple true) (<= (gsm.myRandomFunction 1.0) .50))
	       then
	       (begin 
	         (setq momGenome (copy momGenome))
	         (setq m (integer (gsm.myRandomFunction myM)))
	         (setq n (integer (gsm.myRandomFunction myM)))
	         (setq chromosome momGenome[m])
	         (setq momGenome[m] momGenome[n])
	         (setq momGenome[n] chromosome)
	       )) ; end if

	   ;; Splice the chromosomes in the candidate genomes to form the progeny.
       (setq genome (new Vector: myM))
       (if (= myREGMultiple true) (setq M myM) (setq M 0))
       (loop for m from 0 until M do
         ;; Select chromosomes from each genome.
         (cond 
           ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
           ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
           ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] (eGrammar.convertToAbstractWFF momGenome[m]))) false)) (setq genome[m] newWff))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
           ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
           (else 
            (begin
               (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.convertToAbstractWFF (eGrammar.cutoutNumericWFF (listWff momGenome[m])))))
                   ) ; end if
               (if (> (lengthWFF newWff) myMaxColWFFLen)
                   (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                   ) ; end if
               (setq genome[m] newWff)
            )) ; end case
           ) ; end chromosome cond           
         ) ; end column loop  	

	   ;; Make a Estimator linear regression wff and add it to the current population.
       Grow::
       (createGrammarEstimator (list ruleReg: genome) concrete:)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAbstract
	
	(defun crossOverAware(father mother)
	;; *******************************************************************
	;; summary:  Create all possible new Estimator WFFs by splicing two  
    ;;           parent WFFs together using context aware crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(k K m M n N ns NS np NP)
	   vars:(dadGenome momGenome dadWff momWff newWff (passOne true))
	   vars:(chromosome dadRule momRule newGenome genome)
       vars:(dadPairVector dadPair momSlotVector momSlot)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)
       ;(writeln "start context aware crossover: dad=" dadGenome ", mom=" momGenome)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))
       (setq M (chromosomeLength dadGenome))
       (setq N (chromosomeLength momGenome))

       ;; Reorder the chromosomes in the candidate genomes occasionally.
       ;; Note: we use a linear genome during cross over operations.
       (if (= myREGMultiple true)
           (begin
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
           )) ; end if
      
       ;; Select chromosomes from each genome.
       (setq genome (copy dadGenome))           
       (setq M (min M N))
       (loop for m from 0 until M do
          (if (and (<> dadGenome[m] #void) (<> momGenome[m] #void))
              (begin
                (setq dadPairVector (eGrammar.selectPairWFF dadGenome[m]))
                (setq momSlotVector (eGrammar.selectSlotWFF momGenome[m]))
                (setq NP (length dadPairVector))
                (setq NS (length momSlotVector))
                (loop for np from 0 until NP do
                   (loop for ns from 0 until NS do
                      (setq K (length dadPairVector[np]))
                      (loop for k from 1 until K do 
                         (setq dadPair (eGrammar.selectPairWFF (setq dadWff (listWff dadGenome[m])))[np])
                         (setq momSlot (eGrammar.selectSlotWFF (setq momWff (listWff momGenome[m])))[ns])
                         (if (= (eGrammar.spliceImmediateWFF dadPair momSlot k) true)
                             (begin     
	            			    ;; Make a new wff and add it to the current population.                               
                                (setq (setq newGenome (copy dadGenome))[m] dadWff)
                                ;(writeln "[" m "," np "," ns "," k "]:" "new=" newGenome ", dad=" dadGenome ", mom=" momGenome)
                                (growWFF newGenome)
                             )) ; end if
                         ) ; end K loop
                      ) ; end NS loop
                   ) ; end NP loop

              )) ; end if

         ) ; end column loop  	

	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAware
	
	(defun growWFF(command ...)
	;; *******************************************************************
	;; summary:  Grow a new Estimator linear regression WFF and
	;;           add it to the current population.
	;;
	;; args:     command 	The command to determine the type of WFF to grow..
	;;           choice     (Optional)The choice of term column OR the choice of sequential term WFF.
	;;           
	;; Return:   Lambda      A scored Estimator linear regression Lambda.
	;;
	;; *******************************************************************
	   regs:(k m M mm n N maxChromosomes cntChromosomes)
	   vars:(Lambda genome newGenome choice)
	   vars:(Rf wff)
	   vars:(IntVector:chromosomeIndices IntVector:chromosomeLimits)
	
       ;; Use the command to determine the type of WFF to grow.
       (setq maxChromosomes gsm.myREGMaximum)
       (if (>= (argCount) 2) (setq choice (argFetch 1)))
       (if (isNumber choice) (setq choice (integer choice)) (setq choice -2))
       (cond
         ;; Command is a genome vector.
         ((isVector command)
          (begin 
            (setq genome command) 
          )) ; end case genome vector
         ;; Command requires growth of an mvl using root expressions.
         ((= command root:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random root expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random root expressions for each chromosome in the genome.
                    (setq genome[m] (eGrammar.growRootWFF -2))
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random root expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (setq genome[0] (eGrammar.growRootWFF -2))
                )) ; end multiple columns if
          )) ; end case root command
         ;; Command requires growth of an mvl using term expressions.
         ((= command seqroot:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random term expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random term expressions for each chromosome in the genome.
                    (setq genome[m] (eGrammar.growTermWFF choice m))
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random term expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (setq genome[0] (eGrammar.growTermWFF choice))
                )) ; end multiple columns if
          )) ; end case seqroot command
         ;; Command requires growth of an mvl using term expressions.
         ((= command term:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random term expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
		            ;; Select random term expressions for each chromosome in the genome.
                    (if (= myGrowWFFStyle full:)
		                (setq genome[m] (eGrammar.growCTermWFF m))
		                (setq genome[m] (eGrammar.growTermWFF -2 m))
                        ) ; end if
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random term expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
                  (if (= myGrowWFFStyle full:)
		              (setq genome[0] (eGrammar.growCTermWFF choice))
		              (setq genome[0] (eGrammar.growTermWFF -2 0))
                      ) ; end if
                )) ; end multiple columns if
          )) ; end case term command
         ;; Command requires growth of an mvl using full expressions.
         ((= command full:)
          (begin
            (if (= myREGMultiple true)
                (begin
		          ;; Select random full expressions for each chromosome in the genome.
		          (setq genome (new Vector: myM))
		          (setq M myM)
		          (loop for m from 0 until M do
                    (if (= myGrowWFFStyle full:)
		                (setq genome[m] (eGrammar.growWFF expression: 0))
		                (setq genome[m] (eGrammar.growRootWFF -2 m))
                        ) ; end if
		            ) ; end column loop  
                ) else
                (begin
		          ;; Select random full expressions for the only one random chromosome in the genome.
		          (setq genome (new Vector: myM))
		          ;; Select random full expressions for each chromosome in the genome.
                  (if (= myGrowWFFStyle full:)
		              (setq genome[0] (eGrammar.growWFF expression: 0))
		              (setq genome[0] (eGrammar.growRootWFF choice))
                      ) ; end if
                )) ; end multiple columns if
          )) ; end case full command
         ;; All other commands return an error.
         (else (error (append "gsm.ruleReg.growWFF: invalid command [" command "]")))
         ) ; end command cond
	
	   ;; Create the linear regression Estimator from the final WFF.
	   Last::
       (if (isLambda genome) 
           (begin 
             (setq Lambda genome)
             (if (isVector Lambda.Genome) (setq genome genome.Genome) (setq genome genome.WFF[1]))
           )) ; end if
       (if (= genome #void) (error "ruleReg.growWFF: encountered a void genome")) 
       (setq wff (wffList (list ruleReg: genome)))
       (setq genome wff[1])
       (setq cntChromosomes 0)
       (setq M (length genome))
       (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntChromosomes)))
       (cond
        ;; We have less than the maximum number of chromosomes
	    ((>= maxChromosomes cntChromosomes) (setq Rf (createGrammarEstimator wff)))
        ;; We have more than the maximum number of chromosomes
        ;; Note: We must be an exhaustive search of all possible
        ;;       combinations of the chromosomes in this genome
        ;;       taken 'maxChromosomes' at a time.
	    (else 
         (begin
           (setq chromosomeIndices (new Vector: Integer: maxChromosomes))
           (setq chromosomeLimits (new Vector: Integer: maxChromosomes))
           (loop for mm from 0 until maxChromosomes do (setq chromosomeIndices[mm] mm) (setq chromosomeLimits[mm] (+ (- cntChromosomes maxChromosomes) mm)))
           (while (<= chromosomeIndices[0] chromosomeLimits[0]) do
             (setq newGenome (new Vector: M))
             (loop for mm from 0 until maxChromosomes do (setq k chromosomeIndices[mm]) (setq newGenome[mm] genome[k]))
             (setq Rf (createGrammarEstimator (list ruleReg: newGenome)))
             ;; Increment the chromosome combinatatorial indices.
             (loop for mm from (- maxChromosomes 1) to 0 by -1 do (++ chromosomeIndices[mm]) (if (<= chromosomeIndices[mm] chromosomeLimits[mm]) (setq mm -1))) 
             (loop for mm from 1 until maxChromosomes do (if (> chromosomeIndices[mm] chromosomeLimits[mm]) (setq chromosomeIndices[mm] (+ chromosomeIndices[(- mm 1)] 1)))) 
             ) ; end while
         )) ; end else
        ) ; end cond
	   Rf) ; end growWFF

	(defun mutateAbstract(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator multivariate linear regression WFF 
    ;;           using abstract expression genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff Lambda)
	
	   ;; Collect the WFFs rule and genome (only mutate properly formed WFFs with rules of type ruleReg or ruleMvl).
	   (if (isLambda wff) (setq wff wff.WFF))
	   (if (= wff #void) (return false))
       (setq wff (listWff wff))
	   (setq rule wff[0])
	   (setq genome wff[1])
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the abstract expression mutation strategy         
       (setq genome[m] (eGrammar.mutateAbstractC0 genome[(setq m (integer (gsm.myRandomFunction myM)))]))
       (if (<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] (eGrammar.mutateAbstractC1 genome[(setq m (integer (gsm.myRandomFunction myM)))])))

	   ;; Make an abstract Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (setq wff (wffList (list ruleReg: genome)))
       (createGrammarEstimator wff concrete:)
	   true) ; end mutateAbstract

	(defun mutate(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator linear regression WFF 
    ;;           using genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff chromosome (Number:deathPct .10))
	
       ;; Mutate using abstract expressions occasionally.
       (if (<= (gsm.myRandomFunction 1.0) myMutateAbsPct) (return (mutateAbstract wff)))

	   ;; Extract numeric WFFs from the candidate Estimator Lambda (where necessary).
	   (if (= wff #void) (return false))
	   (if (isLambda wff) (setq wff wff.Genome))
	   (if (isPair wff) (setq wff wff[1]))
	   (setq genome wff)
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the user selected mutation strategy 
       (cond
        ;; Do we use chromosomes from multiple genome columns during cross over operations?
        ((= myMutateStrategy normal:)
         (begin
           ;; Reorder the chromosomes in the candidate genome ocasionally.
           (if (<= (gsm.myRandomFunction 1.0) .50)
               then
               (begin 
                 (setq m (integer (gsm.myRandomFunction myM)))
                 (setq n (integer (gsm.myRandomFunction myM)))
                 (setq chromosome genome[m])
                 (setq genome[m] genome[n])
                 (setq genome[n] chromosome)
               )) ; end if
           (if (= myREGMultiple true) (setq m (integer (gsm.myRandomFunction myM))) (setq m 0)) 
           (setq newWff (eGrammar.mutateNumericWFF genome[m]))
           (setq n 0)(while (and (< (++ n) 20) (> (lengthWFF newWff) myMaxColWFFLen)) do (setq newWff (eGrammar.mutateNumericWFF genome[m])))
           (if (> (lengthWFF newWff) myMaxColWFFLen) (return false))
           (if (<= (gsm.myRandomFunction 1.0) deathPct) (setq genome[m] #void) (setq genome[m] newWff))
         )) ;; end normal case
        (else (error (append "gsm.ruleReg.mutate: unknown user specified mutation strategy [" myMutateStrategy "]")))
        ) ; end mutation strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (growWFF genome)
	
	   true) ; end mutate
		
    (defun wffList(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator linear regression wff to a 
    ;;           list format. 
	;;
	;; args:     wff         The linear regression wff.
	;;           
	;; Return:   result      A Estimator linear regression WFF such as '(ruleReg #(obj| (x0-x5) abs(x1)))
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffListFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff wff) (setq wff (string wff true)))
       (setq wff (Lisp wff)[0])
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleReg:)) (error "gsm.ruleReg.wffList: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       (setq wffListFormat (list rule genome))
       wffListFormat) ; end wffList


	(defun wffSource(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator linear regression statement 
    ;;           such as 
    ;;                     "regress(x0-x5*abs(x1));"
    ;;  
	;;           as an ASCI string in grammatically correct Estimator.
	;;
	;; args:     genome      The sparse vector of chromosome numeric expressions for the regress statement.
	;;           
	;; Return:   result      A Estimator linear regression statement such as "regress(x0-x5*abs(x1));"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:((wffSourceFormat "") rule genome)
       vars:(chromosome0 chromosome1)
       ;; Create the final source from the genome.
       (setq M (length genome))
       (loop for m from 0 until M do
         ;; Select chromosomes from each genome.
         (cond 
           ((and (= wffSourceFormat "") (<> genome[m] #void)) (setq wffSourceFormat (eGrammar genome[m])))
           ((and (<> wffSourceFormat "") (<> genome[m] #void)) (setq wffSourceFormat (append wffSourceFormat "+" (eGrammar genome[m]))))
           ) ; end chromosome cond
         ) ; end column loop  
	    ;; Generate a gramatically correct Estimator linear regression statement in source format.
	   (setq wffSourceFormat (append "regress(" wffSourceFormat ");"))
	   wffSourceFormat) ; end wffSource    

    (defun wffString(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator linear regression wff to a 
    ;;           string format. 
	;;
	;; args:     wff         The linear regression wff.
	;;           
	;; Return:   result      A Estimator linear regression WFF such as "(ruleReg #(obj| (x0-x5) abs(x1)))"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffStringFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff (Lisp wff)[0]))
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleReg:)) (error "gsm.ruleReg.wffString: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       (setq wffStringFormat (string (list rule genome) true))
       wffStringFormat) ; end stringWff

	;; *******************************************************************
    ;; Define Private Maintenance Methods
	;; *******************************************************************

    (defun selfTest(Test Ms Ns Gn Pn Df Sm)
	;; *******************************************************************
	;; summary:  The self test method for ruleReg Lambdas. 
	;;
	;; args:     Test        The name of the test (including all:).
	;;           Ms          The number of independent columns in the training data.
	;;           Ns          The number of rows in the training data.
	;;           Gn          The maximum number of training interations to use in the DE training algorithm.
	;;           Pn          The number of training vectors to use in the DE training algorithm.
	;;           Df          The dampening factor to use in the DE training algorithm.
	;;           Sm          The maximum score to use in halting the DE training algorithm.
	;;           
	;; Return:   Lambda       A Estimator grammar swarm variable Lambda such as "regress((x2-c0)*abs(x1));"
	;;
	;; *******************************************************************
       regs:(k m mm M MM n N) 
       regs:(Number:InvN Number:numerator Number:denominator Number:a Number:b Number:err Number:score) 
       regs:(Number:xmean Number:xsum Number:x Number:sortScore Number:AvgY) 
       regs:(Number:ymean Number:ysum Number:y Number:oldy Number:ey Number:oldey) 
       regs:(Number:xxdot Number:yydot Number:xydot Number:NX) 
       vars:(C X Y EY sortedEY sortedY
             aHistory eHistory dHistory yHistory 
             Lambda wff wffSource genome 
             startTime endTime startTimeT endTimeT
             (checkResults true)
             ) ; end temporary variables
       (setq startTimeT (getTickCount 0))
       ;; Select the requested test case
       ;; Test Case linear 
       (if (or (= Test all:) (= Test linear:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] - C[2]*X[2] + C[3]*X[3] - C[4]*X[4] ...
               (setRandomSeed 8192.0)      
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Build and compile the ruleReg Lambda for this test case.
               (setq wff "(c0*v0)")
               (loop for m from 1 until M do (setq wff (append wff "+(c" m "*v" m ")")))
               (setq wff (append "regress(" wff ");"))
               (setq Lambda (eval (compile (gsm.estimator wff))))
               (setq Lambda.MaxGens Gn)
               (setq Lambda.MinScore Sm)
               (setq Lambda.F Df)
               (setq Lambda.PNN Pn)            
		       ;; Train on the training data.
		       (writeln _eol "Starting training on test [linear] with model = " wff)
		       (Lambda.train X Y)
		       (if (= myVerboseSW false) (writeln "gsm.ruleReg.selfTest(training): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" Lambda.AvgYSq "], NLSE=[" Lambda.NLSE "]")) 
               (if (= checkResults true)
                   (begin
                      ;; Build test data
                      (setRandomSeed 1192.0)      
                      (loop for n from 0 until N do
                         (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
                         (setq y (* C[0] X[n][0]))
                         (loop for m from 1 until M do 
                            (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                            (setq y (+ y (* X[n][m] C[m])))
                            ) ; end M loop
                         (setq Y[n] y)
                         ) ; end N loop
                      ;; Run against test data
                      ;; Note: Sort the test data in ascending order
                      (setq EY (Lambda.run X))
                      (setq sortedEY (|Gv:sort| EY < true))
                      ;; Compute error independently against test data.
                      (setq err 0.0)
                      (setq xmean 0.0)
                      (setq xsum 0.0)
                      (setq ymean 0.0)
                      (setq ysum 0.0)
                      (setq xxdot 0.0)
                      (setq yydot 0.0)
                      (setq xydot 0.0)
                      (setq sortScore 0.0) 
                      (setq InvN (/ 1.0 (number N)))
                      (setq sortScore 0.0) 
                      (setq oldy Y[sortedEY[0]])
                      (loop for n from 0 until N do 
                         (setq k sortedEY[n])
                         (setq y Y[k]) 
                         (setq x EY[k]) 
                         (+= xsum x) 
                         (+= ysum y) 
                         (+= xxdot (* x x)) 
                         (+= xydot (* x y)) 
                         (+= yydot (* y y))
                         (if (> oldy y) (++ sortScore))(setq oldy y)
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" EY[k] "] y=[" Y[k] "] err=[" (abs (- y x)) "] score=[" (/ (abs (- y x)) Lambda.AvgYSq) "]")))                                           
                      (setq xmean (/ xsum N)) 
                      (setq ymean (/ ysum N)) 
                      (setq AvgY ymean) 
                      (*= sortScore InvN) 
                      (setq numerator (- xydot (* ysum xmean))) 
                      (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                      (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                      (setq a (- ymean (* b xmean))) 
                      (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                      (setq err (sqrt (abs (* InvN err)))) 
                      (setq yydot (sqrt (abs (* InvN yydot))))
                      (setq score err)
                      (if (<> yydot 0.0) (/= score yydot)) 

                      (setq yHistory (new Vector: Number: 10))
                      (setq eHistory (new Vector: Number: 10))
                      (setq aHistory (new Vector: Number: 10))
                      (setq dHistory (new Vector: Number: 5))
                      (setq NX N)
                      (setq MM (integer (max 1 (/ NX 10))))
                      (setq sortedY (|Gv:sort| Y < true))
                      (loop for n from 0 until NX do
                         (setq k sortedEY[n])
                         (setq y Y[k])
                         (setq mm (/ n MM))
                         (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                         (setq k sortedY[n])
                         (setq y Y[k])
                         (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                         ) ; end N loop
                      (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[1] (avg eHistory[1] eHistory[0]))
                      (setq aHistory[8] (avg eHistory[8] eHistory[9]))
                      (setq aHistory[0] eHistory[0])
                      (setq aHistory[9] eHistory[9])
                      (setq dHistory[4] (- aHistory[9] aHistory[0]))
                      (setq dHistory[3] (- aHistory[8] aHistory[1]))
                      (setq dHistory[2] (- aHistory[7] aHistory[2]))
                      (setq dHistory[1] (- aHistory[6] aHistory[3]))
                      (setq dHistory[0] (- aHistory[5] aHistory[4]))
		              (writeln "gsm.ruleReg.selfTest (testing): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" yydot "], NLSE=[" err "]") 
                      (writeln "... (yHistory): [" (string yHistory true) "]")
                      (writeln "... (eHistory): [" (string eHistory true) "]")
                      (writeln "... (aHistory): [" (string aHistory true) "]")
                      (writeln "... (dHistory): [" (string dHistory true) "]")
		              (writeln "... (constants): C = [" (string C true) "]") 
		              (writeln "... (constants): CC = [" (string Lambda.CC true) "]") 
		              (writeln "... (variables): VV = [" (string Lambda.VV true) "]") 
		           )) ; end if
          )) ; end Test Case linear
       ;; Test Case square 
       (if (or (= Test all:) (= Test square:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0]*X[0] + C[1]*X[1]*X[1] - C[2]*X[2]*X[2] + C[3]*X[3]*X[3] - C[4]*X[4]*X[4] ...
               (setRandomSeed 8192.0)      
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (loop for m from 0 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Build and compile the ruleReg Lambda for this test case.
               (setq wff "(c0*v0*v0)")
               (loop for m from 1 until M do (setq wff (append wff "+(c" m "*v" m "*v" m ")")))
               (setq wff (append "regress(" wff ");"))
               (setq Lambda (eval (compile (gsm.estimator wff))))
               (setq Lambda.MaxGens Gn)
               (setq Lambda.MinScore Sm)
               (setq Lambda.F Df)
               (setq Lambda.PNN Pn)            
		       ;; Train on the training data.
		       (writeln _eol "Starting training on test [square] with model = " wff)
		       (Lambda.train X Y)
		       (if (= myVerboseSW false) (writeln "gsm.ruleReg.selfTest(training): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" Lambda.AvgYSq "], NLSE=[" Lambda.NLSE "]")) 
               (if (= checkResults true)
                   (begin
                      ;; Build test data
                      (setRandomSeed 1192.0)      
                      (loop for n from 0 until N do
                         (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
                         (setq y (* C[0] X[n][0]))
                         (loop for m from 1 until M do 
                            (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                            (setq y (+ y (* X[n][m] X[n][m] C[m])))
                            ) ; end M loop
                         (setq Y[n] y)
                         ) ; end N loop
                      ;; Run against test data
                      ;; Note: Sort the test data in ascending order
                      (setq EY (Lambda.run X))
                      (setq sortedEY (|Gv:sort| EY < true))
                      ;; Compute error independently against test data.
                      (setq err 0.0)
                      (setq xmean 0.0)
                      (setq xsum 0.0)
                      (setq ymean 0.0)
                      (setq ysum 0.0)
                      (setq xxdot 0.0)
                      (setq yydot 0.0)
                      (setq xydot 0.0)
                      (setq sortScore 0.0) 
                      (setq InvN (/ 1.0 (number N)))
                      (setq sortScore 0.0) 
                      (setq oldy Y[sortedEY[0]])
                      (loop for n from 0 until N do 
                         (setq k sortedEY[n])
                         (setq y Y[k]) 
                         (setq x EY[k]) 
                         (+= xsum x) 
                         (+= ysum y) 
                         (+= xxdot (* x x)) 
                         (+= xydot (* x y)) 
                         (+= yydot (* y y))
                         (if (> oldy y) (++ sortScore))(setq oldy y)
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" EY[k] "] y=[" Y[k] "] err=[" (abs (- y x)) "] score=[" (/ (abs (- y x)) Lambda.AvgYSq) "]")))                                           
                      (setq xmean (/ xsum N)) 
                      (setq ymean (/ ysum N)) 
                      (setq AvgY ymean) 
                      (*= sortScore InvN) 
                      (setq numerator (- xydot (* ysum xmean))) 
                      (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                      (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                      (setq a (- ymean (* b xmean))) 
                      (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                      (setq err (sqrt (abs (* InvN err)))) 
                      (setq yydot (sqrt (abs (* InvN yydot))))
                      (setq score err)
                      (if (<> yydot 0.0) (/= score yydot)) 

                      (setq yHistory (new Vector: Number: 10))
                      (setq eHistory (new Vector: Number: 10))
                      (setq aHistory (new Vector: Number: 10))
                      (setq dHistory (new Vector: Number: 5))
                      (setq NX N)
                      (setq MM (integer (max 1 (/ NX 10))))
                      (setq sortedY (|Gv:sort| Y < true))
                      (loop for n from 0 until NX do
                         (setq k sortedEY[n])
                         (setq y Y[k])
                         (setq mm (/ n MM))
                         (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                         (setq k sortedY[n])
                         (setq y Y[k])
                         (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                         ) ; end N loop
                      (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[1] (avg eHistory[1] eHistory[0]))
                      (setq aHistory[8] (avg eHistory[8] eHistory[9]))
                      (setq aHistory[0] eHistory[0])
                      (setq aHistory[9] eHistory[9])
                      (setq dHistory[4] (- aHistory[9] aHistory[0]))
                      (setq dHistory[3] (- aHistory[8] aHistory[1]))
                      (setq dHistory[2] (- aHistory[7] aHistory[2]))
                      (setq dHistory[1] (- aHistory[6] aHistory[3]))
                      (setq dHistory[0] (- aHistory[5] aHistory[4]))
		              (writeln "gsm.ruleReg.selfTest (testing): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" yydot "], NLSE=[" err "]") 
                      (writeln "... (yHistory): [" (string yHistory true) "]")
                      (writeln "... (eHistory): [" (string eHistory true) "]")
                      (writeln "... (aHistory): [" (string aHistory true) "]")
                      (writeln "... (dHistory): [" (string dHistory true) "]")
		              (writeln "... (constants): C = [" (string C true) "]") 
		              (writeln "... (constants): CC = [" (string Lambda.CC true) "]") 
		              (writeln "... (variables): VV = [" (string Lambda.VV true) "]") 
		           )) ; end if
          )) ; end Test Case square
       ;; Test Case cosine 
       (if (or (= Test all:) (= Test cosine:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*cos(C[1]*X[0]) + C[2]*cos(C[3]*X[1]) + C[4]*cos(C[5]*X[2]) ...
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
               (setRandomSeed 8192.0)      
		       (setq M Ms)
		       (setq MM (* M 2))
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: (* 2 M)))
		       (loop for m from 0 until MM do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
		          (setq y (* C[0] (cos (* C[1] X[n][0]))))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Build and compile the ruleReg Lambda for this test case.
               (setq wff "(c0*cos(c1*v0))")
               (loop for m from 1 until M do (setq wff (append wff "+(c" (* m 2) "*cos(c" (+ (* m 2) 1) "*v" m "))")))
               (setq wff (append "regress(" wff ");"))
               (setq Lambda (eval (compile (gsm.estimator wff))))
               (setq Lambda.MaxGens Gn)
               (setq Lambda.MinScore Sm)
               (setq Lambda.F Df)
               (setq Lambda.PNN Pn)            
		       ;; Train on the training data.
		       (writeln _eol "Starting training on test [cosine] with model = " wff)
		       (Lambda.train X Y)
		       (if (= myVerboseSW false) (writeln "gsm.ruleReg.selfTest(training): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" Lambda.AvgYSq "], NLSE=[" Lambda.NLSE "]")) 
               (if (= checkResults true)
                   (begin
                      ;; Build test data
                      (setRandomSeed 1192.0)    
                      (loop for n from 0 until N do
                         (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
                         (setq y (* C[0] (cos (* C[1] X[n][0]))))
                         (loop for m from 1 until M do 
                            (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                            (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
                            ) ; end M loop
                         (setq Y[n] y)
                         ) ; end N loop
                      ;; Run against test data
                      ;; Note: Sort the test data in ascending order
                      (setq EY (Lambda.run X))
                      (setq sortedEY (|Gv:sort| EY < true))
                      ;; Compute error independently against test data.
                      (setq err 0.0)
                      (setq xmean 0.0)
                      (setq xsum 0.0)
                      (setq ymean 0.0)
                      (setq ysum 0.0)
                      (setq xxdot 0.0)
                      (setq yydot 0.0)
                      (setq xydot 0.0)
                      (setq sortScore 0.0) 
                      (setq InvN (/ 1.0 (number N)))
                      (setq sortScore 0.0) 
                      (setq oldy Y[sortedEY[0]])
                      (loop for n from 0 until N do 
                         (setq k sortedEY[n])
                         (setq y Y[k]) 
                         (setq x EY[k]) 
                         (+= xsum x) 
                         (+= ysum y) 
                         (+= xxdot (* x x)) 
                         (+= xydot (* x y)) 
                         (+= yydot (* y y))
                         (if (> oldy y) (++ sortScore))(setq oldy y)
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" EY[k] "] y=[" Y[k] "] err=[" (abs (- y x)) "] score=[" (/ (abs (- y x)) Lambda.AvgYSq) "]")))                                           
                      (setq xmean (/ xsum N)) 
                      (setq ymean (/ ysum N)) 
                      (setq AvgY ymean) 
                      (*= sortScore InvN) 
                      (setq numerator (- xydot (* ysum xmean))) 
                      (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                      (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                      (setq a (- ymean (* b xmean))) 
                      (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                      (setq err (sqrt (abs (* InvN err)))) 
                      (setq yydot (sqrt (abs (* InvN yydot))))
                      (setq score err)
                      (if (<> yydot 0.0) (/= score yydot)) 

                      (setq yHistory (new Vector: Number: 10))
                      (setq eHistory (new Vector: Number: 10))
                      (setq aHistory (new Vector: Number: 10))
                      (setq dHistory (new Vector: Number: 5))
                      (setq NX N)
                      (setq MM (integer (max 1 (/ NX 10))))
                      (setq sortedY (|Gv:sort| Y < true))
                      (loop for n from 0 until NX do
                         (setq k sortedEY[n])
                         (setq y Y[k])
                         (setq mm (/ n MM))
                         (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                         (setq k sortedY[n])
                         (setq y Y[k])
                         (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                         ) ; end N loop
                      (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[1] (avg eHistory[1] eHistory[0]))
                      (setq aHistory[8] (avg eHistory[8] eHistory[9]))
                      (setq aHistory[0] eHistory[0])
                      (setq aHistory[9] eHistory[9])
                      (setq dHistory[4] (- aHistory[9] aHistory[0]))
                      (setq dHistory[3] (- aHistory[8] aHistory[1]))
                      (setq dHistory[2] (- aHistory[7] aHistory[2]))
                      (setq dHistory[1] (- aHistory[6] aHistory[3]))
                      (setq dHistory[0] (- aHistory[5] aHistory[4]))
		              (writeln "gsm.ruleReg.selfTest (testing): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" yydot "], NLSE=[" err "]") 
                      (writeln "... (yHistory): [" (string yHistory true) "]")
                      (writeln "... (eHistory): [" (string eHistory true) "]")
                      (writeln "... (aHistory): [" (string aHistory true) "]")
                      (writeln "... (dHistory): [" (string dHistory true) "]")
		              (writeln "... (constants): C = [" (string C true) "]") 
		              (writeln "... (constants): CC = [" (string Lambda.CC true) "]") 
		              (writeln "... (variables): VV = [" (string Lambda.VV true) "]") 
		           )) ; end if
          )) ; end Test Case cosine
       ;; Test Case variable 
       (if (or (= Test all:) (= Test variable:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*cos(C[1]*X[0]) + C[2]*cos(C[3]*X[1]) + C[4]*cos(C[5]*X[2]) ...
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
               (setRandomSeed 8192.0)      
		       (setq M Ms)
		       (setq MM (* M 2))
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: (* 2 M)))
		       (loop for m from 0 until MM do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
		          (setq y (* C[0] (cos (* C[1] X[n][0]))))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Build and compile the ruleReg Lambda for this test case.
               ;; Note: The training model contains variable polynomial choices goverened by embedded real constants.
               ;;       Each unary cosine function is replaced with a polynomial alternative as follows:
               ;;       c0*cos(c1*x0) ==> (c0*abs(c1*x0))+(c2*cos(c3*x0))+(c4*sin(c5*x0))+(c6*sqrt(abs(c7*x0)))+(c08*tan(c09*x0)+(c10*x0*x0)+(c11*x0*x0*x0))
               (setq wffSource "(c0*cos(c1*x0))")
               (loop for m from 1 until M do
                 (cond 
                  ((= (modi m 3) 0) (setq wffSource (append wffSource "+(c" (* m 2) "*cos(c" (+ (* m 2) 1) "*x" m "))")))
                  ((= (modi m 3) 1) (setq wffSource (append wffSource "+(c" (* m 2) "*sin(c" (+ (* m 2) 1) "*x" m "))")))
                  ((= (modi m 3) 2) (setq wffSource (append wffSource "+(c" (* m 2) "*tan(c" (+ (* m 2) 1) "*x" m "))")))
                  ) ; end cond
                 ) ; end loop
               (setq wff "(c0*cos(c1*v0))+(c2*sin(c3*v1))+(c4*tan(c5*v2))")
               (setq wff (append "regress(" wff ");"))
               (setq Lambda (eval (compile (gsm.estimator wff))))
               (setq Lambda.MaxGens Gn)
               (setq Lambda.MinScore Sm)
               (setq Lambda.F Df)
               (setq Lambda.PNN Pn)            
		       ;; Train on the training data.
		       (writeln _eol "Starting training on test data [variable] created with model = " wffSource)
		       (writeln "Starting training on test with variable special polynomial model = " wff)
		       (Lambda.train X Y)
		       (Lambda.trainMore X Y (muli Gn 10))
		       (if (= myVerboseSW false) (writeln "gsm.ruleReg.selfTest(training): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" Lambda.AvgYSq "], NLSE=[" Lambda.NLSE "]")) 
               (if (= checkResults true)
                   (begin
                      ;; Build test data
                      (setRandomSeed 1192.0)      
                      (loop for n from 0 until N do
                         (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
                         (setq y (* C[0] (cos (* C[1] X[n][0]))))
                         (loop for m from 1 until M do 
                            (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                            (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
                            ) ; end M loop
                         (setq Y[n] y)
                         ) ; end N loop
                      ;; Run against test data
                      ;; Note: Sort the test data in ascending order
                      (setq EY (Lambda.run X))
                      (setq sortedEY (|Gv:sort| EY < true))
                      ;; Compute error independently against test data.
                      (setq err 0.0)
                      (setq xmean 0.0)
                      (setq xsum 0.0)
                      (setq ymean 0.0)
                      (setq ysum 0.0)
                      (setq xxdot 0.0)
                      (setq yydot 0.0)
                      (setq xydot 0.0)
                      (setq sortScore 0.0) 
                      (setq InvN (/ 1.0 (number N)))
                      (setq sortScore 0.0) 
                      (setq oldy Y[sortedEY[0]])
                      (loop for n from 0 until N do 
                         (setq k sortedEY[n])
                         (setq y Y[k]) 
                         (setq x EY[k]) 
                         (+= xsum x) 
                         (+= ysum y) 
                         (+= xxdot (* x x)) 
                         (+= xydot (* x y)) 
                         (+= yydot (* y y))
                         (if (> oldy y) (++ sortScore))(setq oldy y)
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" EY[k] "] y=[" Y[k] "] err=[" (abs (- y x)) "] score=[" (/ (abs (- y x)) Lambda.AvgYSq) "]")))                                           
                      (setq xmean (/ xsum N)) 
                      (setq ymean (/ ysum N)) 
                      (setq AvgY ymean) 
                      (*= sortScore InvN) 
                      (setq numerator (- xydot (* ysum xmean))) 
                      (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                      (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                      (setq a (- ymean (* b xmean))) 
                      (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                      (setq err (sqrt (abs (* InvN err)))) 
                      (setq yydot (sqrt (abs (* InvN yydot))))
                      (setq score err)
                      (if (<> yydot 0.0) (/= score yydot)) 

                      (setq yHistory (new Vector: Number: 10))
                      (setq eHistory (new Vector: Number: 10))
                      (setq aHistory (new Vector: Number: 10))
                      (setq dHistory (new Vector: Number: 5))
                      (setq NX N)
                      (setq MM (integer (max 1 (/ NX 10))))
                      (setq sortedY (|Gv:sort| Y < true))
                      (loop for n from 0 until NX do
                         (setq k sortedEY[n])
                         (setq y Y[k])
                         (setq mm (/ n MM))
                         (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                         (setq k sortedY[n])
                         (setq y Y[k])
                         (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                         ) ; end N loop
                      (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[1] (avg eHistory[1] eHistory[0]))
                      (setq aHistory[8] (avg eHistory[8] eHistory[9]))
                      (setq aHistory[0] eHistory[0])
                      (setq aHistory[9] eHistory[9])
                      (setq dHistory[4] (- aHistory[9] aHistory[0]))
                      (setq dHistory[3] (- aHistory[8] aHistory[1]))
                      (setq dHistory[2] (- aHistory[7] aHistory[2]))
                      (setq dHistory[1] (- aHistory[6] aHistory[3]))
                      (setq dHistory[0] (- aHistory[5] aHistory[4]))
		              (writeln "gsm.ruleReg.selfTest (testing): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" yydot "], NLSE=[" err "]") 
                      (writeln "... (yHistory): [" (string yHistory true) "]")
                      (writeln "... (eHistory): [" (string eHistory true) "]")
                      (writeln "... (aHistory): [" (string aHistory true) "]")
                      (writeln "... (dHistory): [" (string dHistory true) "]")
		              (writeln "... (constants): C = [" (string C true) "]") 
		              (writeln "... (constants): CC = [" (string Lambda.CC true) "]") 
		              (writeln "... (variables): VV = [" (string Lambda.VV true) "]") 
		           )) ; end if
          )) ; end Test Case variable
       ;; Test Case factor 
       (if (or (= Test all:) (= Test factor:))
           (begin
		       ;; Create a test polynomial regression where y = C[0]*cos(C[1]*X[0]) + C[2]*cos(C[3]*X[1]) + C[4]*cos(C[5]*X[2]) ...
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
               (setRandomSeed 8192.0)      
		       (setq M Ms)
		       (setq MM (* M 2))
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: (* 2 M)))
		       (loop for m from 0 until MM do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
		          (setq y (* C[0] (cos (* C[1] X[n][0]))))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Build and compile the ruleReg Lambda for this test case.
               ;; Note: The training model contains variable polynomial choices goverened by embedded real constants.
               ;;       Each unary cosine function is replaced with a polynomial alternative as follows:
               ;;       c0*cos(c1*x0) ==> (c0*abs(c1*x0))+(c2*cos(c3*x0))+(c4*sin(c5*x0))+(c6*sqrt(abs(c7*x0)))+(c08*tan(c09*x0)+(c10*x0*x0)+(c11*x0*x0*x0))
               (setq wffSource "(c0*cos(c1*x0))")
               (loop for m from 1 until M do (setq wffSource (append wffSource "+(c" (* m 2) "*cos(c" (+ (* m 2) 1) "*x" m "))")))
               (setq wff "(c0*cos(c1*v0))")
               (setq wff (append "regress(" wff ");"))
               (setq Lambda (eval (compile (gsm.estimator wff))))
               (setq Lambda.MaxGens Gn)
               (setq Lambda.MinScore Sm)
               (setq Lambda.F Df)
               (setq Lambda.PNN Pn)            
		       ;; Train on the training data.
		       (writeln _eol "Starting training on test data [factor] created with model = " wffSource)
		       (writeln "Starting training on test with factor special polynomial model = " wff)
		       (Lambda.train X Y)
		       (Lambda.trainMore X Y (muli Gn 10))
		       (if (= myVerboseSW false) (writeln "gsm.ruleReg.selfTest(training): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" Lambda.AvgYSq "], NLSE=[" Lambda.NLSE "]")) 
               (if (= checkResults true)
                   (begin
                      ;; Build test data
                      (setRandomSeed 1192.0)      
                      (loop for n from 0 until N do
                         (setq X[n][0] (- (gsm.myRandomFunction 100.0) 50.0))
                         (setq y (* C[0] (cos (* C[1] X[n][0]))))
                         (loop for m from 1 until M do 
                            (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                            (setq y (+ y (* C[(* m 2)] (cos (* C[(+ (* m 2) 1)] X[n][m])))))
                            ) ; end M loop
                         (setq Y[n] y)
                         ) ; end N loop
                      ;; Run against test data
                      ;; Note: Sort the test data in ascending order
                      (setq EY (Lambda.run X))
                      (setq sortedEY (|Gv:sort| EY < true))
                      ;; Compute error independently against test data.
                      (setq err 0.0)
                      (setq xmean 0.0)
                      (setq xsum 0.0)
                      (setq ymean 0.0)
                      (setq ysum 0.0)
                      (setq xxdot 0.0)
                      (setq yydot 0.0)
                      (setq xydot 0.0)
                      (setq sortScore 0.0) 
                      (setq InvN (/ 1.0 (number N)))
                      (setq sortScore 0.0) 
                      (setq oldy Y[sortedEY[0]])
                      (loop for n from 0 until N do 
                         (setq k sortedEY[n])
                         (setq y Y[k]) 
                         (setq x EY[k]) 
                         (+= xsum x) 
                         (+= ysum y) 
                         (+= xxdot (* x x)) 
                         (+= xydot (* x y)) 
                         (+= yydot (* y y))
                         (if (> oldy y) (++ sortScore))(setq oldy y)
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" EY[k] "] y=[" Y[k] "] err=[" (abs (- y x)) "] score=[" (/ (abs (- y x)) Lambda.AvgYSq) "]")))                                           
                      (setq xmean (/ xsum N)) 
                      (setq ymean (/ ysum N)) 
                      (setq AvgY ymean) 
                      (*= sortScore InvN) 
                      (setq numerator (- xydot (* ysum xmean))) 
                      (setq denominator (- xxdot (/ (* xsum xsum) N))) 
                      (if (= denominator 0.0) (setq b 0.0) (setq b (/ numerator denominator))) 
                      (setq a (- ymean (* b xmean))) 
                      (setq err (+ yydot (* -2.0 b xydot) (* -2.0 a ysum) (* b b xxdot) (* 2.0 a b xsum) (* a a N) )) 
                      (setq err (sqrt (abs (* InvN err)))) 
                      (setq yydot (sqrt (abs (* InvN yydot))))
                      (setq score err)
                      (if (<> yydot 0.0) (/= score yydot)) 

                      (setq yHistory (new Vector: Number: 10))
                      (setq eHistory (new Vector: Number: 10))
                      (setq aHistory (new Vector: Number: 10))
                      (setq dHistory (new Vector: Number: 5))
                      (setq NX N)
                      (setq MM (integer (max 1 (/ NX 10))))
                      (setq sortedY (|Gv:sort| Y < true))
                      (loop for n from 0 until NX do
                         (setq k sortedEY[n])
                         (setq y Y[k])
                         (setq mm (/ n MM))
                         (setq eHistory[mm] (+ eHistory[mm] (/ y MM)))
                         (setq k sortedY[n])
                         (setq y Y[k])
                         (setq yHistory[mm] (+ yHistory[mm] (/ y MM)))
                         ) ; end N loop
                      (setq aHistory[4] (avg eHistory[4] eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[5] (avg eHistory[5] eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[3] (avg eHistory[3] eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[6] (avg eHistory[6] eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[2] (avg eHistory[2] eHistory[1] eHistory[0]))
                      (setq aHistory[7] (avg eHistory[7] eHistory[8] eHistory[9]))
                      (setq aHistory[1] (avg eHistory[1] eHistory[0]))
                      (setq aHistory[8] (avg eHistory[8] eHistory[9]))
                      (setq aHistory[0] eHistory[0])
                      (setq aHistory[9] eHistory[9])
                      (setq dHistory[4] (- aHistory[9] aHistory[0]))
                      (setq dHistory[3] (- aHistory[8] aHistory[1]))
                      (setq dHistory[2] (- aHistory[7] aHistory[2]))
                      (setq dHistory[1] (- aHistory[6] aHistory[3]))
                      (setq dHistory[0] (- aHistory[5] aHistory[4]))
		              (writeln "gsm.ruleReg.selfTest (testing): N = [" Ns "], M = [" Ms "], G = [" Lambda.TrainGens "], Swarm = [" Lambda.PNN  "], AvgYSq=[" yydot "], NLSE=[" err "]") 
                      (writeln "... (yHistory): [" (string yHistory true) "]")
                      (writeln "... (eHistory): [" (string eHistory true) "]")
                      (writeln "... (aHistory): [" (string aHistory true) "]")
                      (writeln "... (dHistory): [" (string dHistory true) "]")
		              (writeln "... (constants): C = [" (string C true) "]") 
		              (writeln "... (constants): CC = [" (string Lambda.CC true) "]") 
		              (writeln "... (variables): VV = [" (string Lambda.VV true) "]") 
		           )) ; end if
          )) ; end Test Case factor
       (writeln "gsm.ruleReg.selfTest: completed in [" (/ (setq endTimeT (getTickCount startTimeT)) 60.0) "] minutes.")       
       Lambda) ; end selfTest

   	;; *******************************************************************************
   	;; Begin main logic 
   	;; *******************************************************************************
	vars:(wffSourceFormat)
    
    (setq wffSourceFormat (wffSource wff[1]))
    wffSourceFormat) ; end ruleReg
















































































;;**EXPORTKEY**:gsm.ruleSvm
(defriend gsm:ruleSvm(wff)
;; *******************************************************************
;; summary:  The WFF grammar rules for all Estimator support 
;;           vector regression Lambdas. 
;;
;; Main:     Return a Estimator support vector regression statement,
;;           in source format, such as 
;;                    "svmregress(x2,(x2-x10));" 
;;           as an ASCI source string in grammatically correct estimator.
;;
;; args:     wff         The Estimator WFF of the support vector regression statement.
;;           
;; Return:   result      A Estimator support vector regression statement such as "svmregress(x2,(x2-x10));".
;; *******************************************************************
  	pvars:(;; Public Variables
           (genomeType EXP)         ;; This regression rule uses an expression based genome.
           (lengthExempt false)     ;; This regression rule is NOT exempt from genome length restrictions.
           ;; Public Methods
           chromosomeLength         ;; Return the number of non-empty left-most chromosomes in the genome.
           crossOver                ;; Create two new Estimator support vector regression WFFs by splicing two parent WFFs together using genetic crossover.
           crossOverAware    		;; Create all possible new Estimator WFFs by splicing two parent WFFs together using context aware crossover.
           growWFF                  ;; Create a new Estimator support vector regression wff to the current population.
           mutate                   ;; Create a new Estimator support vector regression WFF using genetic mutation.
           wffList                  ;; Convert a Estimator support vector regression wff to a list format.
           wffSource				;; Convert a Estimator support vector regression wff to a source statement such as "svmregress(x0-x5,abs(x1));". 
           wffString                ;; Convert a Estimator support vector regression wff to a string format such as "(ruleSvm #(obj| (ruleSub x0 x5) (ruleAbs x1)));"
           ) ; end persistant variables
   	;; *******************************************************************************
   	;; Define Public Child Lambdas 
   	;; *******************************************************************************

	(defun chromosomeLength(genome)
	;; *******************************************************************
	;; summary:  Return the number of non-empty left-most chromosomes in the genome. 
	;;
	;; args:     genome     The genome whose chromosome length is to be returned.           
	;;           
	;; Return:   length     The number of non-empty left-most chromosomes in the genome.
	;;
	;; *******************************************************************
	   regs:(m M len)
	
       (setq M (length genome))
	   (loop for m from 0 until M do
          (if (<> genome[m] #void) (++ len))
          ) ; end loop

	   len) ; end chromosomeLength


	(defun crossOver(father mother)
	;; *******************************************************************
	;; summary:  Create two new Estimator support vector regression WFFs, 
    ;;           by splicing two parent WFFs together using genetic crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(dadGenome momGenome dadRule momRule newGenome)
	   vars:(dadWff momWff newWff (passOne true) chromosome genome)
       vars:(dadIndex momIndex dadPair momSlot dadWff chromosomeCrossPct)

	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (<> gsm[momRule].genomeType EXP:) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))

       ;; Implement the user select cross over strategy 
       (cond
        ;; Manage "Genetic" cross over?
        ;; Note: We use chromosomes in a "genetic algorithm" inspired cross over operation.
        ((and (= myCrossOverStrategy genetic:) (= myREGMultiple true))
         (begin
             ;; Select chromosomes from each genome.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (loop for m from 0 until M do
               (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m]))
               ) ; end column loop  	
         )) ; end genetic cross over strategy
        ;; Manage "Aggressive" cross over?
        ;; Note: We use chromosomes from multiple crossed genome columns during cross over operations.
        ((= myCrossOverStrategy aggressive:)
         (begin
             ;; Reorder the chromosomes in the candidate genomes occasionally.
             (setq M (chromosomeLength dadGenome))
             (setq N (chromosomeLength momGenome))
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
      
             ;; Select chromosomes from each genome.
             (setq genome (copy dadGenome))           
             (setq M (max M N))
             (setq chromosomeCrossPct 1.5)
             (loop for m from 0 until M do
               (if (>= chromosomeCrossPct .50) (-= chromosomeCrossPct .50))
               (cond
                 ((> (gsm.myRandomFunction 1.0) chromosomeCrossPct) (setq genome[m] genome[m]))
                 ((= genome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] momGenome[m])))
                 ((= momGenome[m] #void) (if (<= (gsm.myRandomFunction 1.0) .25) then (setq genome[m] (eGrammar.mutateNumericWFF genome[m] (gsm.myRandomFunction 1.0)))))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs genome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 (else 
                  (begin
                     (setq dadWff genome[m])                    
                     (setq momSlot (setq momIndex (eGrammar.selectSlotWFF momGenome[m]))[(integer (gsm.myRandomFunction (length momIndex)))])
                     (setq dadPair (setq dadIndex (eGrammar.selectPairWFF dadWff))[(integer (gsm.myRandomFunction (length dadIndex)))])
                     (cond
                      ((isAtom dadPair) (setq genome[m] momSlot))
                      ((and (isPair momSlot) (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs (listWff dadPair) (listWff momSlot))) false))
                       (begin (setCar dadPair (car newWff))  (setCdr dadPair (cdr newWff))))
                      ((isPair momSlot) (begin (setCar dadPair (car momSlot))  (setCdr dadPair (cdr momSlot))))
                      (else (eGrammar.spliceNumericWFF dadPair momSlot 1.0))
                      ) ; end splice cond
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end aggressive cross over strategy
        ;; Manage "Normal" cross over?
        ;; Note: We use chromosomes from only single matched genome columns during cross over operations.
        ((= myCrossOverStrategy normal:)
         (begin
	         ;; Reorder the chromosomes in the candidate genomes occasionally.
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq dadGenome (copy dadGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome dadGenome[m])
	               (setq dadGenome[m] dadGenome[n])
	               (setq dadGenome[n] chromosome)
	             )) ; end if
	         (if (<= (gsm.myRandomFunction 1.0) .50)
	             then
	             (begin 
	               (setq momGenome (copy momGenome))
	               (setq m (integer (gsm.myRandomFunction myM)))
	               (setq n (integer (gsm.myRandomFunction myM)))
	               (setq chromosome momGenome[m])
	               (setq momGenome[m] momGenome[n])
	               (setq momGenome[n] chromosome)
	             )) ; end if

	         ;; Splice the chromosomes in the candidate genomes to form the progeny.
             (setq genome (new Vector: myM))
             (setq M myM)
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (cond 
                 ((= dadGenome[m] #void) (setq genome[m] momGenome[m]))
                 ((= momGenome[m] #void) (setq genome[m] dadGenome[m]))
                 ((and (<= (gsm.myRandomFunction 1.0) .20) (<> (setq newWff (eGrammar.marryNumericWFFs dadGenome[m] momGenome[m])) false)) (setq genome[m] newWff))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] dadGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .10) (setq genome[m] momGenome[m]))
                 ((<= (gsm.myRandomFunction 1.0) .50) (setq genome[m] dadGenome[m]))
                 (else 
                  (begin
                     (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (setq newWff (eGrammar.spliceNumericWFF (listWff dadGenome[m]) (eGrammar.cutoutNumericWFF (listWff momGenome[m]))))
                         ) ; end if
                     (if (> (lengthWFF newWff) myMaxColWFFLen)
                         (if (< (gsm.myRandomFunction 1.0) .50) (setq newWff dadGenome[m]) (setq newWff momGenome[m]))
                         ) ; end if
                     (setq genome[m] newWff)
                  )) ; end case
                 ) ; end chromosome cond           
               ) ; end column loop  	
         )) ; end normal cross over strategy
        (else (error (append "gsm.ruleSvm.crossOver: unknown user specified cross over strategy [" myCrossOverStrategy "]")))
        ) ; end cross over strategy cond

	   ;; Make a Estimator support vector regression wff and add it to the current population.
       Grow::
       (growWFF genome dadGenome)
	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOver
	
	(defun crossOverAware(father mother)
	;; *******************************************************************
	;; summary:  Create all possible new Estimator WFFs by splicing two  
    ;;           parent WFFs together using context aware crossover.
	;;
	;; args:     father     The father WFF to be mated.           
	;;           mother     The mother WFF to be mated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(k K m M n N ns NS np NP)
	   vars:(dadGenome momGenome dadWff momWff newWff (passOne true))
	   vars:(chromosome dadRule momRule newGenome genome)
       vars:(dadPairVector dadPair momSlotVector momSlot)
	
	   ;; Extract numeric WFFs from the parent Estimator Lambdas (where necessary).
	   (if (or (= father #void) (= mother #void)) (return false))
	   (if (isLambda father) (begin (setq dadRule father.Rule) (setq father father.Genome)))
	   (if (isLambda mother) (begin (setq momRule mother.Rule) (setq mother mother.Genome)))
	   (if (isPair father) (begin (setq dadRule father[0]) (setq father father[1])))
	   (if (isPair mother) (begin (setq momRule mother[0]) (setq mother mother[1])))
	   (setq dadGenome father)
	   (setq momGenome mother)

	   ;; Make sure the father and mother are genetically compatible.
	   (if (or (= father #void) (= mother #void)) (return false))
	
	   Retry::     
	
	   ;; Make copies of the candidate genomes.
	   (setq dadGenome (listWff dadGenome))
	   (setq momGenome (listWff momGenome))
       (setq M (chromosomeLength dadGenome))
       (setq N (chromosomeLength momGenome))

       ;; Reorder the chromosomes in the candidate genomes occasionally.
       ;; Note: we use a linear genome during cross over operations.
       (if (= myREGMultiple true)
           (begin
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq dadGenome (copy dadGenome))
                   (setq m (integer (gsm.myRandomFunction M)))
                   (setq n (integer (gsm.myRandomFunction M)))
                   (setq chromosome dadGenome[m])
                   (setq dadGenome[m] dadGenome[n])
                   (setq dadGenome[n] chromosome)
                 )) ; end if
             (if (<= (gsm.myRandomFunction 1.0) .50)
                 then
                 (begin 
                   (setq momGenome (copy momGenome))
                   (setq m (integer (gsm.myRandomFunction N)))
                   (setq n (integer (gsm.myRandomFunction N)))
                   (setq chromosome momGenome[m])
                   (setq momGenome[m] momGenome[n])
                   (setq momGenome[n] chromosome)
                 )) ; end if
           )) ; end if
      
       ;; Select chromosomes from each genome.
       (setq genome (copy dadGenome))           
       (setq M (min M N))
       (loop for m from 0 until M do
          (if (and (<> dadGenome[m] #void) (<> momGenome[m] #void))
              (begin
                (setq dadPairVector (eGrammar.selectPairWFF dadGenome[m]))
                (setq momSlotVector (eGrammar.selectSlotWFF momGenome[m]))
                (setq NP (length dadPairVector))
                (setq NS (length momSlotVector))
                (loop for np from 0 until NP do
                   (loop for ns from 0 until NS do
                      (setq K (length dadPairVector[np]))
                      (loop for k from 1 until K do 
                         (setq dadPair (eGrammar.selectPairWFF (setq dadWff (listWff dadGenome[m])))[np])
                         (setq momSlot (eGrammar.selectSlotWFF (setq momWff (listWff momGenome[m])))[ns])
                         (if (= (eGrammar.spliceImmediateWFF dadPair momSlot k) true)
                             (begin     
	            			    ;; Make a new wff and add it to the current population.                               
                                (setq (setq newGenome (copy dadGenome))[m] dadWff)
                                ;(writeln "[" m "," np "," ns "," k "]:" "new=" newGenome ", dad=" dadGenome ", mom=" momGenome)
                                (growWFF newGenome)
                             )) ; end if
                         ) ; end K loop
                      ) ; end NS loop
                   ) ; end NP loop

              )) ; end if

         ) ; end column loop  	

	
	   ;; Make sure to mate the father with the mother
	   (if (= passOne true) 
	       (begin 
	          (setq passOne false) 
	          (setq dadGenome mother)
	          (setq momGenome father)
	          (goto Retry:)
	       )) ; end if
	
	   true) ; end crossOverAware
	
	(defun growWFF(command ...)
	;; *******************************************************************
	;; summary:  Grow a new Estimator support vector regression WFF and
	;;           add it to the current population.
	;;
	;; args:     command 	The command to determine the type of WFF to grow..
	;;           
	;; Return:   Lambda      A scored Estimator support vector regression Lambda.
	;;
	;; *******************************************************************
	   regs:(k m M mm n N maxChromosomes cntChromosomes)
	   vars:(Lambda genome newGenome)
	   vars:(Rf wff)
	   vars:(IntVector:chromosomeIndices IntVector:chromosomeLimits)
	
       ;; Use the command to determine the type of WFF to grow.
       (setq maxChromosomes gsm.mySVMMaximum)
       (cond
         ;; Command is a genome vector.
         ((isVector command)
          (begin
            (setq genome command) 
          )) ; end case genome vector
         ;; Command requires growth of an mvl using term expressions.
         ((= command term:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random term expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growCTermWFF m))
		          (setq genome[m] (eGrammar.growTermWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case term command
         ;; Command requires growth of an mvl using full expressions.
         ((= command full:)
          (begin
		    (setq genome (new Vector: myM))
		    (setq M myM)
		    (loop for m from 0 until M do
		      ;; Select random full expressions for each chromosome in the genome.
              (if (= myGrowWFFStyle full:)
		          (setq genome[m] (eGrammar.growWFF expression: 0))
		          (setq genome[m] (eGrammar.growRootWFF -2 m))
                  ) ; end if
		      ) ; end column loop  
          )) ; end case full command
         ;; All other commands return an error.
         (else (error (append "gsm.ruleSvm.growWFF: invalid command [" command "]")))
         ) ; end command cond
	
	   ;; Create the support vector regression Estimator from the final WFF.
	   Last::
       (if (isLambda genome) 
           (begin 
             (setq Lambda genome)
             (if (isVector Lambda.Genome) (setq genome genome.Genome) (setq genome genome.WFF[1]))
           )) ; end if
       (if (or (= genome #void) (= (length genome) 0)) (error "ruleSvm.growWFF: encountered a void or empty genome")) 
       (setq wff (wffList (list ruleSvm: genome)))
       (setq genome wff[1])
       (setq cntChromosomes 0)
       (setq M (length genome))
       (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntChromosomes)))
       (cond
        ;; We have less than the maximum number of chromosomes
	    ((>= maxChromosomes cntChromosomes) (setq Rf (createGrammarEstimator wff)))
        ;; We have more than the maximum number of chromosomes
        ;; Note: We must be an exhaustive search of all possible
        ;;       combinations of the chromosomes in this genome
        ;;       taken 'maxChromosomes' at a time.
	    (else 
         (begin
           (setq chromosomeIndices (new Vector: Integer: maxChromosomes))
           (setq chromosomeLimits (new Vector: Integer: maxChromosomes))
           (loop for mm from 0 until maxChromosomes do (setq chromosomeIndices[mm] mm) (setq chromosomeLimits[mm] (+ (- cntChromosomes maxChromosomes) mm)))
           (while (<= chromosomeIndices[0] chromosomeLimits[0]) do
             (setq newGenome (new Vector: M))
             (loop for mm from 0 until maxChromosomes do (setq k chromosomeIndices[mm]) (setq newGenome[mm] genome[k]))
             (setq Rf (createGrammarEstimator (list ruleSvm: newGenome)))
             ;; Increment the chromosome combinatatorial indices.
             (loop for mm from (- maxChromosomes 1) to 0 by -1 do (++ chromosomeIndices[mm]) (if (<= chromosomeIndices[mm] chromosomeLimits[mm]) (setq mm -1))) 
             (loop for mm from 1 until maxChromosomes do (if (> chromosomeIndices[mm] chromosomeLimits[mm]) (setq chromosomeIndices[mm] (+ chromosomeIndices[(- mm 1)] 1)))) 
             ) ; end while
         )) ; end else
        ) ; end cond
	   Rf) ; end growWFF

	(defun mutate(wff)
	;; *******************************************************************
	;; summary:  Create a new Estimator support vector regression WFF 
    ;;           using genetic mutation.
	;;
	;; args:     wff     The candidate WFF to be mutated.           
	;;           
	;; Return:   none.
	;;
	;; *******************************************************************
	   regs:(m M n N)
	   vars:(rule genome newWff chromosome (Number:deathPct .10))
	
	   ;; Extract numeric WFFs from the candidate Estimator Lambda (where necessary).
	   (if (= wff #void) (return false))
	   (if (isLambda wff) (setq wff wff.Genome))
	   (if (isPair wff) (setq wff wff[1]))
	   (setq genome wff)
	   (if (= genome #void) (setq genome myColumnGenome))
	
	   ;; Make a copy of the candidate genome.
	   (setq genome (listWff genome))

       ;; Implement the user selected mutation strategy 
       (cond
        ;; Do we use chromosomes from multiple genome columns during cross over operations?
        ((= myMutateStrategy normal:)
         (begin
           ;; Reorder the chromosomes in the candidate genome ocasionally.
           (if (<= (gsm.myRandomFunction 1.0) .50)
               then
               (begin 
                 (setq m (integer (gsm.myRandomFunction myM)))
                 (setq n (integer (gsm.myRandomFunction myM)))
                 (setq chromosome genome[m])
                 (setq genome[m] genome[n])
                 (setq genome[n] chromosome)
               )) ; end if
           (setq m (integer (gsm.myRandomFunction myM))) 
           (setq newWff (eGrammar.mutateNumericWFF genome[m]))
           (setq n 0)(while (and (< (++ n) 20) (> (lengthWFF newWff) myMaxColWFFLen)) do (setq newWff (eGrammar.mutateNumericWFF genome[m])))
           (if (> (lengthWFF newWff) myMaxColWFFLen) (return false))
           (if (<= (gsm.myRandomFunction 1.0) deathPct) (setq genome[m] #void) (setq genome[m] newWff))
         )) ;; end normal case
        (else (error (append "gsm.ruleSvm.mutate: unknown user specified mutation strategy [" myMutateStrategy "]")))
        ) ; end mutation strategy cond

	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
	   ;; Make a Estimator multivariate linear regression wff and add it to the current population.
       Last::
       (growWFF genome)
	
	   true) ; end mutate
		
    (defun wffList(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator support vector regression wff to a 
    ;;           list format. 
	;;
	;; args:     wff         The support vector regression wff.
	;;           
	;; Return:   result      A Estimator support vector regression WFF such as '(ruleSvm #(obj| (x0-x5) abs(x1)))
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffListFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff wff) (setq wff (string wff true)))
       (setq wff (Lisp wff)[0])
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleSvm:)) (error "gsm.ruleSvm.wffList: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating svmregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffListFormat (list rule genome))
       wffListFormat) ; end wffList


	(defun wffSource(genome)
	;; *******************************************************************
	;; summary:  Return a Estimator support vector regression statement 
    ;;           such as 
    ;;                     "svmregress(x0-x5,abs(x1));"
    ;;  
	;;           as an ASCI string in grammatically correct Estimator.
	;;
	;; args:     genome      The sparse vector of chromosome numeric expressions for the svmregress statement.
	;;           
	;; Return:   result      A Estimator support vector regression statement such as "svmregress(x0-x5,abs(x1));"
	;;
	;; *******************************************************************
       regs:(m M (cn -1))
       vars:((wffSourceFormat "") wffTerm rule genome cntGenomes)
       vars:(Lambda chromosome0 chromosome1)
       ;; Eliminate all collisions before generating svmregress genome.
       (if (isConcrete genome)
           then
           (begin
             ;; Count the final number of non duplicate chromosomes.
             (setq M (length genome))
             (loop for m from 0 until M do (if (<> genome[m] #void) (++ cntGenomes)))
             ;; Create the final source from an empty chromosome.
             (if (= cntGenomes 0) (return (setq wffSourceFormat "regress();")))
             ;; Create the final source from a single chromosome.
             (if (= cntGenomes 1) (return (setq wffSourceFormat (append "svmregress(" (eGrammar genome[0]) ");"))))
             ;; Create the final source from the multiple chromosomes.
             (loop for m from 0 until M do
               ;; Select chromosomes from each genome.
               (if (<> genome[m] #void)
                   (begin
                     (setq wffTerm (eGrammar genome[m]))
                     (if (= wffSourceFormat "") 
                         (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                         (setq wffSourceFormat (append wffSourceFormat "," wffTerm))
                         ) ; end if
                   )) ; end if
               ) ; end column loop  
	           ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	           (setq wffSourceFormat (append "svmregress(" wffSourceFormat ");"))
           ) else
           (begin
              ;; Determine the number of existing abstract real number constants in this mvlregress genome.
              (setq Lambda (compileEstimator (evalRule (list ruleReg: genome))))
              (if (not (isLambda Lambda)) (setq cn -1) (setq cn (- Lambda.CCN 1)))
              ;; Eliminate all collisions before generating abstract mvlregress source expression.
              ;; Create the final source from the genome.
              (setq M (length genome))
              (loop for m from 0 until M do
                (if (<> genome[m] #void)
                    (begin
                      (setq wffTerm (append "(c" (++ cn) "*" (eGrammar genome[m]) ")"))
                      (if (= wffSourceFormat "") 
                          (setq wffSourceFormat (setq wffSourceFormat wffTerm))
                          (setq wffSourceFormat (append wffSourceFormat "+" wffTerm))
                          ) ; end if
                    )) ; end if
                ) ; end column loop  
	          ;; Generate a gramatically correct Estimator multivariate linear regression statement in source format.
	          (setq wffSourceFormat (append "regress(" wffSourceFormat ");"))
              )) ; end if
	   wffSourceFormat) ; end wffSource    

   (defun wffString(wff)
	;; *******************************************************************
	;; summary:  Convert a estimator support vector regression wff to a 
    ;;           string format. 
	;;
	;; args:     wff         The support vector regression wff.
	;;           
	;; Return:   result      A Estimator support vector regression WFF such as "(ruleSvm #(obj| (x0-x5) abs(x1)))"
	;;
	;; *******************************************************************
       regs:(m M)
       vars:(wffStringFormat rule genome)
       vars:(chromosome0 chromosome1)
       (if (isString wff) (setq wff (Lisp wff)[0]))
       (if (or (not (isPair wff)) (<> (length wff) 2) (<> wff[0] ruleSvm:)) (error "gsm.ruleSvm.wffString: invalid WFF"))
       (setq rule wff[0])
       (setq genome (sort (copy wff[1]) >))
       ;; Eliminate all collisions before generating svmregress genome.
       (setq M (length genome))
       (loop for m from 1 until M do
         (setq chromosome0 genome[(- m 1)])
         (setq chromosome1 genome[m])
         (if (and (<> chromosome1 #void) (= chromosome0 chromosome1))
             (setq genome[(- m 1)] #void)
             ) ; end if
         ) ; end loop   
       (setq genome (sort genome >))
       (setq wffStringFormat (string (list rule genome) true))
       wffStringFormat) ; end stringWff

   	;; *******************************************************************************
   	;; Begin main logic 
   	;; *******************************************************************************
	vars:(wffSourceFormat)
    
    (setq wffSourceFormat (wffSource wff[1]))
    wffSourceFormat) ; end ruleSvm









































































































































































;;**EXPORTKEY**:gsm.scoreNLSE
(defchild gsm:scoreNLSE(...)
;; ************************************************************************************************
;;
;; summary: Compute the tail classification error and the normalized least squared error
;;          for the specified WFF Lambda.
;; 
;;
;; Args:    wffLambda   (Optional) User specified WFF Lambda to be scored.
;;          X:         (Optional) The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   (Optional) The N Vector of score variables for each training example.
;;
;; Return:  nlse:      The computed normalized least squared error 
;;
;; ************************************************************************************************
      vars:(wffLambda X NumVector:Y) ;; Optional arguments   
      regs:(k n nn NN) 
      regs:(Number:y Number:ey Number:stdY Number:nlse Number:err) 
      vars:(NumVector:EY) 
      ;; Retrieve the user specified optional arguments.
      (if (<= (argCount) 0) (setq wffLambda myBest) (setq wffLambda (argFetch 0)))  
      (if (<= (argCount) 1) (setq X myX) (setq X (argFetch 1)))  
      (if (<= (argCount) 2) (setq Y myY) (setq Y (argFetch 2)))  
      ;; Classify the top 10% and bottom 10% of myY using the specified Lambda.
      (setq EY (wffLambda.run X))
      (setq stdY (|Gv:stdev| Y))
	  (setq NN (length EY))
	  (loop for n from 0 until NN do
	     (setq ey EY[n])
	     (setq y Y[n])
         (setq err (- ey y))
         (*= err err)
         (setq err (gsm@validate err))
         (+= nlse err)
	     ) ; end scoring loop
      (/= nlse (number NN))
      (setq nlse (sqrt nlse))
      (/= nlse stdY)
      (setq wffLambda.Pv.NLSE nlse)
      (if (< BIGPOSNUM nlse) (return false))
      nlse) ; end scoreNLSE


 ;;**EXPORTKEY**:gsm.scoreNLSEHves
(defchild gsm:scoreNLSEHves(...)
;; ************************************************************************************************
;;
;; summary: Compute the normalized least square error for the specified WFF Lambda
;; 
;;
;; Args:    wffLambda   (Optional) User specified WFF Lambda to be scored.
;;          X:         (Optional) The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   (Optional) The N Vector of score variables for each training example.
;;
;; Return:  nlse:      The computed normalized least squared error 
;;
;; ************************************************************************************************
	pvars:(NumVector:ErrVec IntVector:ErrClass)
	vars:(wffLambda X NumVector:Y) ;; Optional arguments   
	regs:(k n nn NN) 
	regs:(Number:y Number:ey Number:stdY Number:nlse Number:err Number:errSD Number:ke Number:errorEval Number:errKur) 
	vars:(NumVector:EY) 
	 
	;; Retrieve the user specified optional arguments.
	(if (<= (argCount) 0) (setq wffLambda myBest) (setq wffLambda (argFetch 0)))   
	(if (<= (argCount) 1) (setq X myX) (setq X (argFetch 1)))  
	(if (<= (argCount) 2) (setq Y myY) (setq Y (argFetch 2)))  
 
	;; Initialize the Error Vectors to be used for error analysis 
	(setq EY (wffLambda.run X))
	(setq stdY (|Gv:stdev| Y))
	(setq NN (length EY))
	(setq ErrVec (new Vector: Number: NN))
	(setq ErrClass (new Vector: Integer: NN))
	;; Classify the top 10% and bottom 10% of m
	(loop for n from 0 until NN do
		(setq ey EY[n])
		(setq y Y[n])
	    (setq err (- ey y))
	    (*= err err)
		(setq ErrVec[n] err)
		(+= errKur (expt err 4))
		(setq err (gsm@validate err))
		(setq errKur (gsm@validate errKur))
	 	(+= nlse err)
		) ; end scoring loop
	(/= nlse (number NN))
	(setq nlse (sqrt nlse))
	(setq errSD nlse)
	(setq ke (/ errKur (* NN (expt errSD 4))))
	(setq ke (sqrt ke))
	(/= nlse stdY)
	(loop for n from 0 until NN do
		(setq errorEval (abs ErrVec[n]))
		(cond
			((= errorEval 0)(setq ErrClass[n] 0))
			((< errorEval (/ errSD (+ 1 ke))) (setq ErrClass[n] -1))
			(else (setq ErrClass[n] 1))
			) ;; end cond
		) ;; end loop
	(setq wffLambda.Pv.NLSE nlse)
	(if (< BIGPOSNUM nlse) (return false))
	nlse) ; end scoreNLSEHves






























































































































;;**EXPORTKEY**:gsm.scoreTCEandNLSE
(defchild gsm:scoreTCEandNLSE(...)
;; ************************************************************************************************
;;
;; summary: Compute the tail classification error, the normalized least squared error, and the
;;          RSquared statistic for the specified WFF Lambda.
;; 
;;
;; Args:    wffLambda   (Optional) User specified WFF Lambda to be scored.
;;          X:         (Optional) The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   (Optional) The N Vector of score variables for each training example.
;;          printSW    (Optional) True iff we are to display selected instances on the console.
;;
;; Return:  EY:        The computed estimate vector for Y. 
;;
;; ************************************************************************************************
      vars:(wffLambda X NumVector:Y (printSW false)) ;; Optional arguments   
      regs:(k kk n nn NN NL NH buckets) 
      regs:(Number:tcEY Number:tcY Number:y Number:ssqY Number:ey) 
      regs:(Number:stdY Number:nlse Number:rsqr Number:err Number:InvN) 
      vars:(NumVector:EY) 
      vars:(IntVector:sortedY IntVector:sortedEY)
      ;; Retrieve the user speicified optional arguments.
      (if (<= (argCount) 0) (setq wffLambda myBest) (setq wffLambda (argFetch 0)))  
      (if (<= (argCount) 1) (setq X myX) (setq X (argFetch 1)))  
      (if (<= (argCount) 2) (setq Y myY) (setq Y (argFetch 2)))  
      (if (<= (argCount) 3) (setq printSW false) (setq printSW (argFetch 3)))  
      ;; Classify the top 10% and bottom 10% of myY using the specified Lambda.
      (setq EY (wffLambda.run X))
      (setq sortedY (|Gv:sort| Y < true))
      (setq sortedEY (|Gv:sort| EY < true))
      (setq stdY (|Gv:stdev| Y))
      (setq stdEY (|Gv:stdev| EY))
	  (setq NN (length EY))
      (setq kk (integer (max 1 (/ NN 20))))
	  (setq InvN (/ 1.0 (number NN)))
      (setq buckets 10)
	  (setq NL (/ NN buckets))
	  (setq NH (- NN NL))
	  (loop for n from 0 until NN do
	     (setq ey EY[n])
	     (setq y Y[n])
         (setq err (- ey y))
		 (if (and printSW (= (modi n kk) 0)) (writeln "X[" n "], ey=[" ey "], y=[" y "], ErrorPct=[" (/ (abs err) (number stdY)) "]"))
         (*= err err)
         (setq err (gsm@validate err))
         (+= nlse err)
	     (setq k sortedY[n])
	     (setq y Y[k])
         (if (< n NL) (-= tcY y))
         (if (>= n NH) (+= tcY y))
	     (setq k sortedEY[n])
	     (setq y Y[k])
         (if (< n NL) (-= tcEY y))
         (if (>= n NH) (+= tcEY y))
	     ) ; end scoring loop
      (/= nlse (number NN))
      (setq nlse (sqrt nlse))
      (/= nlse stdY)
      (setq rsqr (max (- 1 nlse) 0.0))
      (setq tcEY (/ (- 2.0 (+ 1.0 (/ tcEY tcY))) 2.0))
      (setq wffLambda.Pv.NLSE nlse)
      (setq wffLambda.Pv.TCE tcEY)
      (setq wffLambda.Pv.RSQ rsqr)
      (if (< BIGPOSNUM nlse) (return false))
      EY) ; end scoreTCEandNLSE































































































































;;**EXPORTKEY**:gsm.scoreWff
(defchild gsm:scoreWff(Lambda result genome)
;; ************************************************************************************************
;;
;; summary: Compute the score for a estimator wff over each training example.
;;          Note: We return these statistics:
;;                   Number:A Number:B Number:AvgYSq Number:NLSE NumVector:EY Svm WFF
;;
;; Args:    Lambda      User specified WFF Lambda to be scored.
;;          result     User specified result structure in which to place scores.
;;          genome     User specified genome to be scored.
;;
;; Return:  result     The computed result score structure. 
;;
;; ************************************************************************************************
      regs:(n N NN Number:ey Number:errPct Number:err)
      vars:(NumVector:history NumVector:EY mgr score worstBandScore)
      (onError (lambda(msg) false))
	  ;; Score the Lambda on the basis of the requested scoring style.
      (setq Lambda.ID result.ID)
      (setq Lambda.WFF result.WFF)
      (setq Lambda.Genome genome)
      (setq Lambda.AvgYSq (abs Lambda.AvgYSq))
      (setq Lambda.EY #void) 
      (setq Lambda.NLSE BIGPOSNUM)
      (setq Lambda.TCE BIGPOSNUM)
      (cond
       ;; Score the Lambda, first using the SAMPLE training data, then using the FULL training data set as an entire table, ignoring each time period as a separate table.
       ;; Note: We NEVER use sampling with Support Vectors because SVMs have their own internal sampling algorithms.
       ((and (= mySamplingON true) (<> Lambda.Rule ruleSvm:))
        (begin
	       ;; Initialize the result structure and train the Lambda to be scored.
	       ;; Note: All Estimator Lambdas are trained on a smaller sample of the training data.
	       (if (= (Lambda.train myXtrain myYtrain genome) false) (goto ReturnFailure:))
           (setq Lambda.BandNLSE (setq score (scoreNLSE Lambda myX myY)))
		   (if (= score false) 
               (begin
                 ReturnFailure::
                 (setq Lambda.NLSE BIGPOSNUM) 
                 (setq Lambda.TCE BIGPOSNUM) 
                 (return false)
               )) ; end if
         )) ; end partial training data case
       ;; Score the Lambda, using the FULL training data set as an entire table.
       (else
        (begin
	       ;; Initialize the result structure and train the Lambda to be scored.
	       ;; Note: Some Estimator Lambdas are trained on a smaller sample of the training data.
	       (if (= (Lambda.train myX myY genome) false) (return false))
           (setq Lambda.BandNLSE (setq score (scoreNLSE Lambda myX myY)))
		   (if (= score false) (goto ReturnFailure:))
         )) ; end full training data case
        ) ; end cond 
      (setq result.NLSE Lambda.NLSE)  
      result) ; end scoreWff














































;;**EXPORTKEY**:gsm.scriptBOOST
(defriend gsm:scriptBOOST(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; *******************************************************************
;;
;; summary: grammar symbolic regression, using REG-MVL grammar boosting, training script.
;; 
;;          This training script uses a grammar template based grammar swarm machine learning
;;          strategy. A Tree based genome is used wherein the head of each list is a grammar rule.
;;          Standard tree based genetic programming operators and particle swarm operators are 
;;          used for mutation and crossover.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;; *******************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1)  (Integer:VerboseSample 1))
  	vars:(result Lambda wff newWff wffString wffSource rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)

    vars:(oldBoostedLambda oldBestLambda oldBestRegressor oldBestEstimator)
    vars:(NumVector:YY NumVector:EY Integer:G regVector mvlVector)
    vars:(WFF0 Number:A0 Number:B0 WFF1 Number:A1 Number:B1 Number:avgY Number:avgYSq)

  	;; -------------------------------------------------------------------------------
  	;; scriptBOOST: Start the multiple training runs using an error boosting process 
  	;; -------------------------------------------------------------------------------
    
    ;; Save important problem data for multiple boosted training runs.
   
    (if myVerboseSW (writeln "**Starting initial evolutionary process to breed boosting champions**"))
    (if (< (setq N (length X)) 150) (error "gsm.scriptBOOST: too few training examples"))
    (setq M (length X[0]))
    (setq YY (copy Y))
    (setq mvlVector (new Vector: Object: 2)) 
    (setq regVector (new Vector: Object: M)) 
  
    ;; Generate default genome containing each column name.
    (setq genome (new Vector: M))
    (loop for m from 0 until M do (setq genome[m] (list ruleName: m)))
    (setq mvlVector[0] genome)
    (setq mvlVector[1] (new Vector: M))

    ;; Perform multiple boosting training runs.
    ;; Note: Each pass trains on the residual error from the previous passes.
    (setq MM (min M G))
    (loop for m from 0 until MM do
      (if myVerboseSW (writeln "Starting boosting training pass [" m " of " M "]"))
      (gsm.setOptions rootGPSR: 0.0 myVerboseSW)(setq myRestartGap 1000000)
      (setq Lambda (gsm X YY 1 S (* seed (+ 1.0 m))))
      (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
      (setq genome Lambda.Genome)
      (setq regVector[m] genome)
      
      (setq wff genome[0])
      (loop for mm from 1 until M do (if (<> genome[mm] #void) (setq wff (list ruleAdd: wff genome[mm]))))
      (if (<> wff #void) (setq mvlVector[1][m] wff))
      
      ;; Subtract these estimates from the dependent variable
      (setq EY (Lambda.run X))
      (loop for n from 0 until N do (setq YY[n] (- Y[n] EY[n])))
      ) ; end 

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (clear)
    (gc compact:)
    (setOptions regressBOOST: 0.0 myVerboseSW)
    (setq myRestartGap 1000000) ;; We NEVER wish to reinitiate a new evolutionary process.
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growTermWFF -1 0))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress(0.0);"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBest) 
    (setq myBestBoosted myBest)    

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
      
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
    (if myVerboseSW (writeln "**Starting final evolutionary process amoung boosting champions**"))
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))
    (setq generationGap 0)
    (setq oldBestScore BIGPOSNUM)

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Insinuate the best-of-breed population with multivariate regressions.
    ;; Note: This is done both for all MVL genomes available.
    (if myVerboseSW (writeln "...starting generation of MVL estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length mvlVector))
    (loop for nn from 0 until NN do
      (if (isVector mvlVector[nn]) (ruleMvl.growWFF mvlVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: mvlregress

    ;; Insinuate the best-of-breed population with simple regressions.
    ;; Note: This is done both for all REG genomes available.
    (if myVerboseSW (writeln "...starting generation of REG estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length regVector))
    (loop for nn from 0 until NN do
      (if (isVector regVector[nn]) (ruleReg.growWFF regVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: regress

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
             (if (<= (gsm.myRandomFunction 1.0) (/ (- myGc myG) myG)) (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; Return the best estimator Lambda.
    Goodbye::
    myBest) ; end scriptBOOST

































































































































;;**EXPORTKEY**:gsm.scriptGAB
(defriend gsm:scriptGAB(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; *******************************************************************
;;
;; summary: grammar swarm optimizer training script.
;; 
;;          This training script uses a grammar template based grammar swarm machine learning
;;          strategy. A Tree based genome is used wherein the head of each list is a grammar rule.
;;          Standard tree based genetic programming operators and particle swarm operators are 
;;          used for mutation and crossover.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;; *******************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1)  (Integer:VerboseSample 1))
  	vars:(result Lambda wff newWff wffString rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore (rootGenSW true))

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptGAB: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growTermWFF -1 0))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing one abstract variable.
    (setq myColumnGenome (new Vector: myM))
    (setq myColumnGenome[0] (list ruleVar: 0))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))
    (setq generationGap 0)
  	(setq oldBestScore BIGPOSNUM)

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress c0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Initialize the best-of-breed population with sequential root WFFs.
    ;; Note1: This generates the abstract roots.
    ;; Note2: WFF = "regress(v0+cos(v1));"
    (if (and (> myRootINIT 0) (= rootGenSW true))
        (begin
           (if myVerboseSW (writeln "...starting generation of sequential root estimator WFFs."))
           (setq rootGenSW false)
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for n from 0 until myRootINIT do
              (ruleReg.growWFF seqroot: n)
              ) ; end grow random WFF loop
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
        )) ; end if

    ;; Generate the initial population of random WFFs in the best-of-breed island.
    ;; Note1: We grow new random estimator WFFs.
    ;; Note2: This must be done in the best-of-breed island population in a race for fitness.
    (if (> myGrowSelINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of random estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for n from 0 until myGrowSelINIT do
              (ruleReg.growWFF full:)
              ) ; end grow random WFF loop
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
        )) ; end if


    ;; Initialize a tournament-of-champions (if appropriate).
    ;; Note: This must be done once for every time myBestEstimatorChampions grows to myTournamentSize.
    (if (>= (setq NN (length myBestEstimatorChampions)) myTournamentSize)
        (begin
           (if myVerboseSW (writeln "...starting tournament of champions."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for nn from 0 until NN do
             (setq wff myBestEstimatorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestEstimatorChampions if
           (setq NN (length myBestRegressorChampions))

           (loop for nn from 0 until NN do
             (setq wff myBestRegressorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestRegressorChampions if
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

           ;; Keep only the best of the champions before starting the next tournament.
           (resize myBestEstimatorChampions 1)
           (resize myBestRegressorChampions 1)

           ;; Compact memory before starting the next tournament.
           (gc compact:)
        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; ------------------------------------------------------------------
       ;; Start a new evolutionary process if too many generations have passed without improvement.
       ;; ------------------------------------------------------------------
       (if (>= generationGap myRestartGap) (begin (++ myGc) (goto StartNewEvolutionaryProcess:)))
       (if (> oldBestScore myBest.NLSE) (setq generationGap 0) (++ generationGap))
       (setq oldBestScore myBest.NLSE) 
        
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; --------------------------------------------------------------------------
       ;; Run through the current estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Generate new random WFFs in the best-of-breed island.
       ;; Note: This must be done in the best-of-breed island population in a race for fitness.
       (if (> myGrowSelGEN 0)
           (begin
              (setq myPopulation myPopulationIslands[myBestRegressorIsland])
              (loop for n from 0 until myGrowSelGEN do 
                 (ruleReg.growWFF myGrowWFFStyle)
                 ) ; end grow root WFF loop
              (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
           )) ; end if

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myContextSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myContextSelPct (number N))))
             (loop for nn from 0 until NN do (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply mutation population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myContextRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myContextRegPct (number N))))
             (loop for nn from 0 until NN do (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (setq myBest myBestEstimator)
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGab.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptGAB: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestEstimator)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq myBest (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq myBest.Estimators (new Vector:))
          (setq myBest.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)
          
          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do   
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (= Lambda.EY #void) (setq Lambda.EY (Lambda.run myX)))
              (setq N (length myBest.Estimators))
              (loop for n from 0 until N do
                 (if (> (abs (setq result (math.correlation Lambda.EY myBest.Estimators[n].EY))) .90) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq myBest.Estimators[MM] Lambda)
              (setq myBest.NLSE (+ myBest.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append "(ruleAdd " wffString " " (standAloneEstimatorRules Lambda) ")"))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (setq wffString (append "(ruleReg #((ruleDiv " wffString " " MM ")))"))
          (setq myBest.WFF (listWff wffString))
          (scoreNLSE myBest myX myY)
       )); end if 

    ;; Return the best WFF seen so.
    myBest) ; end scriptGAB

































































































































;;**EXPORTKEY**:gsm.scriptGABALPS
(defriend gsm:scriptGABALPS(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy together with age layered populations. A Tree based genome is used wherein the 
;;          head of each list is a grammar rule. Standard tree based genetic programming operators 
;;          are used for mutation and crossover. New populations are instantiated on epoch boundaries
;;          and are allowed to grow and compete independently.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 1o))
    vars:((Integer:youngestPopulationIsland 0))
  	vars:(result Lambda wff newWff wffString rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore Number:startTickCount)

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq startTickCount (getTickCount 0.0))
    (setq eGrammar expressionGrammarGab)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptGABALPS: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)

    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-of-breed population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])
    (setq wff 1.0)
    (setq genome (new Vector: myM))
    (setq genome[0] wff)
    (ruleReg.growWFF genome)
    (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

    ;; Initialize the best-of-breed population with a linear polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (ruleMvl.growWFF genome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with a quatratic polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleSquare x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with a cubic polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleCube x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with a cross correlation polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul v" m " v" (+ m myM)")"))))
          (ruleMvl.growWFF genome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with a cross rational polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleDiv v" m " v" (+ m myM)")"))))
          (ruleMvl.growWFF genome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Initialize the best-of-breed population with a collection of root genomes.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of multivariate root estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for m from 0 until myRootINIT do 
             (cond
              ((= myUseMVL true) (ruleMvl.growWFF term:))
              (else (error "gsm: root WFF initialize growth specified with invalid regression rule"))
              ) ; end cond
             (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
             ) ; end loop

        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Do NOT exceed maximum allotted time for this evolutionary process.
       (if (> (getTickCount startTickCount) myEvolutionMaxTickCount) (goto Last:))

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)

       ;; Increase the training time given each pso/de Lambda.
       (+= mySWMPool 5)
       (+= mySWMMaxGen 1)
        
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------

       ;; Initialize a new aged layered population.
       (if (= (modi myGc myRestartEpoch) 0)
           (begin

	           ;; -----------------------------------------------------------------------------------------
	           ;; Renew island population ONLY if too many generations have passed without improvement.
	           ;; -----------------------------------------------------------------------------------------
	           (if (and (< islandGenerationGap[youngestPopulationIsland] myRestartGap) (> (length myPopulationIslands[youngestPopulationIsland]) 2)) (goto SkipRenewingThisIsland:))

               ;; Clear the youngest population island of all survivors.
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population."))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:)) 	
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
                
               ;; Initialize the best-of-breed population with a collection of root genomes.
               (if (> myRootGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                      (loop for n from 0 until myRootGEN do 
                         (cond
                          ((and (= myUseREG true) (= myGrowRootRule REG:)) (ruleReg.growWFF root:))
                          ((and (= myUseMVL true) (= myGrowRootRule MVL:)) (ruleMvl.growWFF root:))
                          (else (error "gsm: root WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                         ) ; end loop

                   )) ; end if

               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (> myGrowColGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myGrowColGEN do
                         (cond
                          ((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                          ((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                          (else (error "gsm: random WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                         ) ; end grow Estimators       
                   )) ; end if
        
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
 
	          SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
              )) ; end children		
          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextColPct))
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
              )) ; end children		

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
          (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE) (setq islandGenerationGap[mm] 0) (++ islandGenerationGap[mm])) 
	      (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextSelPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       ;; Apply mutation population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)
    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all estimators from the current best of breed island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest myBestEstimator)
    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (setq myBest myBestEstimator)
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGab.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptGABALPS: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestEstimator)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq myBest (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq myBest.Estimators (new Vector:))
          (setq myBest.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)
          
          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do   
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (= Lambda.EY #void) (setq Lambda.EY (Lambda.run myX)))
              (setq N (length myBest.Estimators))
              (loop for n from 0 until N do
                 (if (> (abs (setq result (math.correlation Lambda.EY myBest.Estimators[n].EY))) .90) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq myBest.Estimators[MM] Lambda)
              (setq myBest.NLSE (+ myBest.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append "(ruleAdd " wffString " " (standAloneEstimatorRules Lambda) ")"))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (setq wffString (append "(ruleReg #((ruleDiv " wffString " " MM ")))"))
          (setq myBest.WFF (listWff wffString))
          (scoreNLSE myBest myX myY)
          (setq myBest.NLSE myBest.NLSE)
       )); end if 

    ;; Return the best WFF seen so far.
    myBest) ; end scriptGABALPS

































































































































;;**EXPORTKEY**:gsm.scriptGABBOOST
(defriend gsm:scriptGABBOOST(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; *******************************************************************
;;
;; summary: grammar symbolic regression, using REG grammar boosting, training script.
;; 
;;          This training script uses a grammar template based grammar swarm machine learning
;;          strategy. A Tree based genome is used wherein the head of each list is a grammar rule.
;;          Standard tree based genetic programming operators and particle swarm operators are 
;;          used for mutation and crossover.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;; *******************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1)  (Integer:VerboseSample 1))
  	vars:(result Lambda wff newWff wffString wffSource rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)

    vars:(oldBoostedLambda oldBestLambda oldBestRegressor oldBestEstimator)
    vars:(NumVector:YY NumVector:EY Integer:G regVector mvlVector)
    vars:(WFF0 Number:A0 Number:B0 WFF1 Number:A1 Number:B1 Number:avgY Number:avgYSq)

  	;; -------------------------------------------------------------------------------
  	;; scriptBOOST: Start the multiple training runs using an error boosting process 
  	;; -------------------------------------------------------------------------------
    
    ;; Save important problem data for multiple boosted training runs.
   
    (if myVerboseSW (writeln "**Starting initial evolutionary process to breed boosting champions**"))
    (if (< (setq N (length X)) 150) (error "gsm.scriptBOOST: too few training examples"))
    (setq M (length X[0]))
    (setq YY (copy Y))
    (setq mvlVector (new Vector: Object: 2)) 
    (setq regVector (new Vector: Object: M)) 
  
    ;; Generate default genome containing each column name.
    (setq genome (new Vector: M))
    (loop for m from 0 until M do (setq genome[m] (list ruleName: m)))
    (setq mvlVector[0] genome)
    (setq mvlVector[1] (new Vector: M))

    ;; Perform multiple boosting training runs.
    ;; Note: Each pass trains on the residual error from the previous passes.
    (setq MM (min M G))
    (loop for m from 0 until MM do
      (if myVerboseSW (writeln "Starting boosting training pass [" m " of " M "]"))
      (gsm.setOptions rootGABSR: 0.0 myVerboseSW)(setq myRestartGap 1000000)
      (setq Lambda (gsm X YY 1 S (* seed (+ 1.0 m))))
      (if (not (isAbstract Lambda)) (error "gsm.scriptGABBOOST: expected an abstract Lambda here"))
      (setq genome (concreteWFF Lambda)[1])
      (if (isVector genome)
          then
          (begin
             (setq regVector[m] genome)
             (setq wff genome[0])
             (loop for mm from 1 until M do (if (<> genome[mm] #void) (setq wff (list ruleAdd: wff genome[mm]))))
             (if (<> wff #void) (setq mvlVector[1][m] wff))
          ) else
          (begin
             (setq regVector[m] (new vector: myM genome))
             (if (<> genome #void) (setq mvlVector[1][m] genome))
          )) ; end if
      
      ;; Subtract these estimates from the dependent variable
      (setq EY (Lambda.run X))
      (loop for n from 0 until N do (setq YY[n] (- Y[n] EY[n])))
      ) ; end 

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setOptions regressGEPBOOST: 0.0 myVerboseSW)
    (setq myRestartGap 1000000) ;; We NEVER wish to reinitiate a new evolutionary process.
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growTermWFF -1 0))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))
    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress(0.0);"))))
    (setq myBest.NLSE BISPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBest) 
    (setq myBestBoosted myBest)    

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
      
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
    (if myVerboseSW (writeln "**Starting final evolutionary process amoung boosting champions**"))
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))
    (setq generationGap 0)
    (setq oldBestScore BIGPOSNUM)

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Insinuate the best-of-breed population with multivariate regressions.
    ;; Note: This is done both for all MVL genomes available.
    (if myVerboseSW (writeln "...starting generation of MVL estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length mvlVector))
    (loop for nn from 0 until NN do
      (if (isVector mvlVector[nn]) (ruleMvl.growWFF mvlVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: mvlregress

    ;; Insinuate the best-of-breed population with simple regressions.
    ;; Note: This is done both for all REG genomes available.
    (if myVerboseSW (writeln "...starting generation of REG estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length regVector))
    (loop for nn from 0 until NN do
      (if (isVector regVector[nn]) (ruleReg.growWFF regVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: regress

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do 
                (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
                (if (<= (gsm.myRandomFunction 1.0) (/ (- myGc myG) myG)) (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
                ) ; end cross over loop
             (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
           )) ; end children
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; Return the best estimator Lambda.
    Goodbye::
    (if (not (isConcrete myBest)) (error "gsm.scriptGABBOOST: expected a concrete Lambda here"))
    myBest) ; end scriptGABBOOST

































































































































;;**EXPORTKEY**:gsm.scriptGABMultiBOOST
(defriend gsm:scriptGABMultiBOOST(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; *******************************************************************
;;
;; summary: grammar symbolic regression, using REG grammar boosting, training script.
;; 
;;          This training script uses a grammar template based grammar swarm machine learning
;;          strategy. A Tree based genome is used wherein the head of each list is a grammar rule.
;;          Standard tree based genetic programming operators and particle swarm operators are 
;;          used for mutation and crossover.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;; *******************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1)  (Integer:VerboseSample 1))
  	vars:(result Lambda wff newWff wffString wffSource rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
    vars:(oldBoostedLambda oldBestLambda oldBestRegressor oldBestEstimator)
    vars:(NumVector:YY NumVector:EY Integer:G regVector mvlVector)
    vars:(WFF0 Number:A0 Number:B0 WFF1 Number:A1 Number:B1 Number:avgY Number:avgYSq)

  	;; -------------------------------------------------------------------------------
  	;; scriptBOOST: Start the multiple training runs using an error boosting process 
  	;; -------------------------------------------------------------------------------
    
    ;; Save important problem data for multiple boosted training runs.
   
    (if myVerboseSW (writeln "**Starting initial evolutionary process to breed boosting champions**"))
    (if (< (setq N (length X)) 150) (error "gsm.scriptBOOST: too few training examples"))
    (setq M (length X[0]))
    (setq YY (copy Y))
    (setq mvlVector (new Vector: Object: 2)) 
    (setq regVector (new Vector: Object: M)) 
  
    ;; Generate default genome containing each column name.
    (setq genome (new Vector: M))
    (loop for m from 0 until M do (setq genome[m] (list ruleName: m)))
    (setq mvlVector[0] genome)
    (setq mvlVector[1] (new Vector: M))
    (setq mvlVector[2] (new Vector: M))
    (setq mvlVector[3] (new Vector: M))
    (setq mvlVector[4] (new Vector: M))
    (setq mvlVector[5] (new Vector: M))

    ;; Perform multiple boosting training runs.
    ;; Note: Each pass trains on the residual error from the previous passes.
    (setq MM (min M G))
    (loop for m from 0 until MM do
      (if myVerboseSW (writeln "Starting boosting training pass [" m " of " M "]"))
      (gsm.setOptions rootGABSR: 0.0 myVerboseSW)(setq myRestartGap 1000000)
      (setq Lambda (gsm X YY 1 S (* seed (+ 1.0 m))))
      (if (not (isAbstract Lambda)) (error "gsm.scriptGABMultiBOOST: expected an abstract Lambda here"))
      (setq genome (concreteWFF Lambda)[1])
      (if (isVector genome)
          then
          (begin
             (setq regVector[m] genome)
             (setq wff genome[0])
             (loop for mm from 1 until M do (if (<> genome[mm] #void) (setq wff (list ruleAdd: wff genome[mm]))))
             (if (<> wff #void) (setq mvlVector[1][m] wff))
             (if (and (<> wff #void) (<= m 0)) (setq mvlVector[2][m] wff))
             (if (and (<> wff #void) (>= m 1))  (setq mvlVector[2][m] (list ruleMul: wff mvlVector[2][(- m 1)])))
             (if (and (<> wff #void) (<= m 0)) (setq mvlVector[3][m] wff))
             (if (and (<> wff #void) (>= m 1))  (setq mvlVector[3][m] (list ruleAdd: wff mvlVector[2][(- m 1)])))
             (if (and (<> wff #void) (<= m 0)) (setq mvlVector[4][m] wff))
             (if (and (<> wff #void) (>= m 1))  (setq mvlVector[4][m] (list ruleIf: (list ruleDiv: wff mvlVector[2][(- m 1)]) "<=" 1.0 wff mvlVector[2][(- m 1)])))
             (if (and (<> wff #void) (<= m 0)) (setq mvlVector[5][m] wff))
             (if (and (<> wff #void) (>= m 1))  (setq mvlVector[5][m] (list ruleIf: (list ruleDiv: wff mvlVector[2][(- m 1)]) ">=" 1.0 wff mvlVector[2][(- m 1)])))
          ) else
          (begin
             (setq regVector[m] (new vector: myM genome))
             (if (<> genome #void) (setq mvlVector[1][m] genome))
          )) ; end if
      
      ;; Subtract these estimates from the dependent variable
      (setq EY (Lambda.run X))
      (loop for n from 0 until N do (setq YY[n] (- Y[n] EY[n])))
      ) ; end 

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setOptions regressGEPBOOST: 0.0 myVerboseSW)
    (setq myRestartGap 1000000) ;; We NEVER wish to reinitiate a new evolutionary process.
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growTermWFF -1 0))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress(0.0);"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBest) 
    (setq myBestBoosted myBest)    

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
      
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
    (if myVerboseSW (writeln "**Starting final evolutionary process amoung boosting champions**"))
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))
    (setq generationGap 0)
    (setq oldBestScore BIGPOSNUM)

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Insinuate the best-of-breed population with multivariate regressions.
    ;; Note: This is done both for all MVL genomes available.
    (if myVerboseSW (writeln "...starting generation of MVL estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length mvlVector))
    (loop for nn from 0 until NN do
      (if (isVector mvlVector[nn]) (ruleMvl.growWFF mvlVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: mvlregress

    ;; Insinuate the best-of-breed population with simple regressions.
    ;; Note: This is done both for all REG genomes available.
    (if myVerboseSW (writeln "...starting generation of REG estimator WFFs."))
    (setq wff 1.0)
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])  
    (setq NN (length regVector))
    (loop for nn from 0 until NN do
      (if (isVector regVector[nn]) (ruleReg.growWFF regVector[nn]))
      (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
      ) ; end loop: regress

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
             (if (<= (gsm.myRandomFunction 1.0) (/ (- myGc myG) myG)) (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
             (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
           )) ; end children
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; Return the best estimator Lambda.
    Goodbye::
    (if (not (isConcrete myBest)) (error "gsm.scriptGABMultiBOOST: expected a concrete Lambda here"))
    myBest) ; end scriptGABMultiBOOST

































































































































;;**EXPORTKEY**:gsm.scriptGEP
(defriend gsm:scriptGEP(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy. A Tree based genome is used wherein the head of each list is a grammar rule.
;;          Standard tree based genetic programming operators are used for mutation and crossover.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
  	vars:(result Lambda wff newWff wffString rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptGEP: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growTermWFF -1 0))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))
    (setq generationGap 0)
  	(setq oldBestScore BIGPOSNUM)

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (bestRegressor)         
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    
    ;; Initialize the best-of-breed population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (if (or (> myRootINIT 0) (> myRootGEN 0))
        (begin
           (if myVerboseSW (writeln "...starting generation of constant estimator WFF."))
           (setq wff 1.0)
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
       
           (setq genome (new Vector: myM))
           (setq genome[0] wff)
           (ruleReg.growWFF genome)
           (bestRegressor)
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

        )) ; end if
    ;; Generate basic regress estimators for each column name.
    ;; Note1: This must be done for the case where Y is a simple linear regression on one or more columns.
    ;; Note2: WFF = "regress x0;" (regress on each column name in the respective column island)
    (if (or (> myRootINIT 0) (> myRootGEN 0))
        (begin
           (if myVerboseSW (writeln "...starting regress estimator for each column name."))
           (setq M myM)
           (loop for m from 0 to M do
              ;; Generate a basic regress estimator for this column in the training data.
              (setq myPopulation myPopulationIslands[m])
              (setq wff (list ruleName: m))
              (setq genome (new Vector: myM))
              (setq genome[m] wff)
              (cond
               ((and (= myUseFRM true) (= myRootRule FRM:)) (ruleFrm.growWFF genome))
               ((and (= myUseMVL true) (= myRootRule MVL:)) (ruleMvl.growWFF genome))
               ((and (= myUseREG true) (= myRootRule REG:)) (ruleReg.growWFF genome))
               ((and (= myUseSVM true) (= myRootRule SVM:)) (ruleSvm.growWFF genome))
               (else (error "gsm: root WFF growth specified with invalid regression rule"))
               ) ; end cond
              ) ; end generate basic colum estimators
           (bestRegressor)
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
             
        )) ; end if

    ;; Create a simple FRM estimator WFF.
    (if (= myUseFRM true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed FRM estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleFrm.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple MVL estimator WFF.
    (if (= myUseMVL true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed MVL estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleMvl.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple REG estimator WFF.
    (if (= myUseREG true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed REG estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleReg.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple cubic SVM estimator WFF.
    (if (= myUseSVM true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed SVM estimator WFF on all columns."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleSvm.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Generate the initial population of root Estimator WFFs in each column island.
    ;; Note1: We grow sequential basic root WFF estimators.
    ;; Note2: This must be done for each distinct island population in a race for fitness.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of sequential root estimator WFFs in each column island."))
           (if (= myWFFReinitSW false) (setq oldmyWFFs myWFFs))
           (loop for mm from 0 until myM do
              (setq myPopulation myPopulationIslands[mm])
              (loop for n from 0 until myRootINIT do 
                 (++ myIslands[mm])
                 (if (< myIslands[mm] myMaxRootWFFs)
                     (begin 
                        (setq wff (growTermWFF myIslands[mm] mm))
                        (setq genome (new Vector: myM))
                        (setq genome[mm] wff)
                        (cond
                         ((and (= myUseFRM true) (= myRootRule FRM:)) (ruleFrm.growWFF genome))
                         ((and (= myUseMVL true) (= myRootRule MVL:)) (ruleMvl.growWFF genome))
                         ((and (= myUseREG true) (= myRootRule REG:)) (ruleReg.growWFF genome))
                         ((and (= myUseSVM true) (= myRootRule SVM:)) (ruleSvm.growWFF genome))
                         (else (error "gsm: root WFF growth specified with invalid regression rule"))
                         ) ; end cond      
                     )) ; end if 
                 ) ; end loop
              ) ; end grow root WFF loop
           (if (= myWFFReinitSW false) (setq myWFFs oldmyWFFs)) 
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
        )) ; end if

    ;; Generate the initial population of random Estimator WFFs in each column island.
    ;; Note1: We grow new random estimator WFFs.
    ;; Note2: This must be done for each distinct island population in a race for fitness.
    (if (> myGrowColINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of random estimator WFFs in each column island."))
           (loop for mm from 0 until myM do
              (setq myPopulation myPopulationIslands[mm])
              (loop for n from 0 until myGrowColINIT do 
                 (cond
                  ((and (= myUseFRM true) (= myGrowColRule FRM:)) (ruleFrm.growWFF myGrowWFFStyle))
                  ((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                  ((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle mm))
                  ((and (= myUseSVM true) (= myGrowColRule SVM:)) (ruleSvm.growWFF myGrowWFFStyle))
                  (else (error "gsm: random WFF column growth specified with invalid regression rule"))
                  ) ; end cond
                 ) ; end loop
              ) ; end grow root WFF loop
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
        )) ; end if

    ;; Generate the initial random root-chromosome estimator WFFs in the best-of-breed island.
    ;; Note: This must be done in the best-of-breed island population in a race for fitness.
    (if (> myChromosomeINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of random root-chromosome estimator WFFs in the main island."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for n from 0 until myChromosomeINIT do
              (setq genome (new Vector: myM)) 
              (loop for mm from 0 until myM do (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0]))
              ;; Use each column island population to feed chromosomes into candiate WFFs for the best-of-breed island.
              (cond
               ((and (= myUseFRM true) (= myChromosomeRule FRM:)) (ruleFrm.growWFF genome))
               ((and (= myUseMVL true) (= myChromosomeRule MVL:)) (ruleMvl.growWFF genome))
               ((and (= myUseREG true) (= myChromosomeRule REG:)) (ruleReg.growWFF genome))
               ((and (= myUseSVM true) (= myChromosomeRule SVM:)) (ruleSvm.growWFF genome))
               (else (error "gsm: root-chromosome WFF init specified with invalid regression rule"))
               ) ; end cond
              (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
              ) ; end loop
        )) ; end if

    ;; Generate initial greedy search WFFs in the best-of-breed island.
    ;; Note: This must be done in the best-of-breed island population in a race for fitness.
    (if (and (> myGreedyINIT 0) (>= myM 3))
        (begin
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           ;; Order the island populations by fitness.
           (setq bestIslands (new Vector: Number: myM))
           (loop for mm from 0 until myM (setq bestIslands[mm] myPopulationIslands[mm][0].NLSE))
           (setq bestIslands (|Gv:sort| bestIslands < true))
           (setq greedyCounter 0)
           (setq I1 bestIslands[0])
           (setq K1 (min myGreedyDepth (length myPopulationIslands[I1])))
           (setq I2 bestIslands[1])
           (setq K2 (min myGreedyDepth (length myPopulationIslands[I2])))
           (setq I3 bestIslands[2])
           (setq K3 (min myGreedyDepth (length myPopulationIslands[I3])))
           (cond
            ((= myGreedyWidth base:) (setq genome (copy myColumnGenome)))
            ((= myGreedyWidth full:) (begin (setq genome (new Vector: myM)) (loop for mm from 0 until myM do (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0]))))
            ((= myGreedyWidth narrow:)  (setq genome (new Vector: myM)))
            ((= myGreedyWidth random:) (setq genome genome))
            (else (error "gsm: invalid myGreedyWidth user specified option"))
            ) ; end greedy width cond
           (loop for k1 from 0 until K1 do
              (loop for k2 from 0 until K2 do
                 (loop for k3 from 0 until K3 do
                   (cond
                    ((or (= myGreedyWidth base:) (= myGreedyWidth full:) (= myGreedyWidth narrow:))
                     (begin
                       (setq genome[I1] myPopulationIslands[I1][k1].Genome[0])  
                       (setq genome[I2] myPopulationIslands[I2][k2].Genome[0])  
                       (setq genome[I3] myPopulationIslands[I3][k3].Genome[0])  
                     )) ; end base full narrow case
                    ((= myGreedyWidth random:) 
                     (begin 
                       (setq genome (new Vector: myM)) 
                       (loop for mm from 0 until myM do 
                         (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0])
                         )
                     )) ; end random case
                    (else (error "gsm: invalid myGreedyWidth user specified option"))
                    ) ; end greedy width cond
                   (setq greedyRuleCnt (length myWFFs))
                   ;; Use greedy search to combine island population genomes into WFFs in the best-of-breed island.
                   (cond
                     ((and (= myUseFRM true) (= myGreedyRule FRM:)) (ruleFrm.growWFF genome))
                     ((and (= myUseMVL true) (= myGreedyRule MVL:)) (ruleMvl.growWFF genome))
                     ((and (= myUseREG true) (= myGreedyRule REG:)) (ruleReg.growWFF genome))
                     ((and (= myUseSVM true) (= myGreedyRule SVM:)) (ruleSvm.growWFF genome))
                     (else (error "gsm: greedy WFF search specified with invalid regression rule"))
                     ) ; end cond
                   (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                   (if (or (< greedyRuleCnt (length myWFFs)) (< (length myWFFs) myWFFSaveLimit)) (++ greedyCounter))
                   (if (>= greedyCounter myGreedyINIT) (goto LastInitGreedySearch:))        
                   ) ; end I3 island loop  
                 ) ; end I2 island loop  
              ) ; end I1 island loop  

           LastInitGreedySearch::
        )) ; end if

    ;; Generate the initial population of random WFFs in the best-of-breed island.
    ;; Note1: We grow new random estimator WFFs.
    ;; Note2: This must be done in the best-of-breed island population in a race for fitness.
    (if (> myGrowSelINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of random estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for n from 0 until myGrowSelINIT do
              (cond
               ((and (= myUseFRM true) (= myGrowSelRule FRM:)) (ruleFrm.growWFF myGrowWFFStyle))
               ((and (= myUseMVL true) (= myGrowSelRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
               ((and (= myUseREG true) (= myGrowSelRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
               ((and (= myUseSVM true) (= myGrowSelRule SVM:)) (ruleSvm.growWFF myGrowWFFStyle))
               (else (error "gsm: random WFF best-of-breed growth specified with invalid regression rule"))
               ) ; end cond
              ) ; end grow random WFF loop
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
        )) ; end if


    ;; Initialize a tournament-of-champions (if appropriate).
    ;; Note: This must be done once for every time myBestEstimatorChampions grows to myTournamentSize.
    (if (>= (setq NN (length myBestEstimatorChampions)) myTournamentSize)
        (begin
           (if myVerboseSW (writeln "...starting tournament of champions."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for nn from 0 until NN do
             (setq wff myBestEstimatorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestEstimatorChampions if
           (setq NN (length myBestRegressorChampions))

           (loop for nn from 0 until NN do
             (setq wff myBestRegressorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestRegressorChampions if
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

           ;; Keep only the best of the champions before starting the next tournament.
           (resize myBestEstimatorChampions 1)
           (resize myBestRegressorChampions 1)

           ;; Compact memory before starting the next tournament.
           (gc compact:)
        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; ------------------------------------------------------------------
       ;; Start a new evolutionary process if too many generations have passed without improvement.
       ;; ------------------------------------------------------------------
       (if (>= generationGap myRestartGap) (begin (++ myGc) (goto StartNewEvolutionaryProcess:)))
       (if (> oldBestScore myBest.NLSE) (setq generationGap 0) (++ generationGap))
       (setq oldBestScore myBest.NLSE) 
        
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; --------------------------------------------------------------------------
       ;; Run through the current estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do
                 
          ;; Grow new estimators from sequential basic root WFF terms.
          ;; Note: This must be done for each distinct island population.
          (if (<= myIslands[mm] myMaxRootWFFs)
              (begin
                 (setq myPopulation myPopulationIslands[mm])
                 (loop for n from 0 until myRootGEN do
                    (++ myIslands[mm]) 
                    (setq wff (growTermWFF myIslands[mm] mm))
                    (setq genome (new Vector: myM))
                    (setq genome[mm] wff)
                    (cond
                     ((and (= myUseFRM true) (= myRootRule FRM:)) (ruleFrm.growWFF genome))
                     ((and (= myUseMVL true) (= myRootRule MVL:)) (ruleMvl.growWFF genome))
                     ((and (= myUseREG true) (= myRootRule REG:)) (ruleReg.growWFF genome))
                     ((and (= myUseSVM true) (= myRootRule SVM:)) (ruleSvm.growWFF genome))
                     (else (error "gsm: root WFF growth specified with invalid regression rule"))
                     ) ; end cond
                    ) ; end grow Estimators       
              )) ; end if

          ;; Grow new estimators from random WFF terms.
          ;; Note: This must be done for each distinct island population.
          (if (> myGrowColGEN 0)
              (begin
                 (setq myPopulation myPopulationIslands[mm])
                 (loop for n from 0 until myGrowColGEN do
                    (cond
                     ((and (= myUseFRM true) (= myGrowColRule FRM:)) (ruleFrm.growWFF myGrowWFFStyle))
                     ((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                     ((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                     ((and (= myUseSVM true) (= myGrowColRule SVM:)) (ruleSvm.growWFF myGrowWFFStyle))
                     (else (error "gsm: random WFF column growth specified with invalid regression rule"))
                     ) ; end cond
                    ) ; end grow Estimators       
              )) ; end if

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(setq n (integer (gsm.myRandomFunction (- N 1))))] myPopulation[(+ n 1 (integer (gsm.myRandomFunction (- N n 1))))]))
                (if (<= (gsm.myRandomFunction 1.0) (/ (- myGc myG) myG)) (makeCrossoverAware myPopulation[(setq n (integer (gsm.myRandomFunction (- N 1))))] myPopulation[(+ n 1 (integer (gsm.myRandomFunction (- N n 1))))]))
              )) ; end children		

          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myContextColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myContextColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossoverAware myPopulation[(setq n (integer (gsm.myRandomFunction (- N 1))))] myPopulation[(+ n 1 (integer (gsm.myRandomFunction (- N n 1))))]))
              )) ; end children		

          ) ; end main island loop      

       ;; Generate new random root-chromosome estimator WFFs in the best-of-breed island.
       ;; Note: This must be done in the best-of-breed island population in a race for fitness.
       (if (> myChromosomeGEN 0)
           (begin
              (setq myPopulation myPopulationIslands[myBestRegressorIsland])
              (loop for n from 0 until myChromosomeGEN do
                 (setq genome (new Vector: myM)) 
                 (loop for mm from 0 until myM do (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0]))
                 ;; Use each column island population to feed chromosomes into candiate WFFs for the best-of-breed island.
                 (cond
                  ((and (= myUseFRM true) (= myChromosomeRule FRM:)) (ruleFrm.growWFF genome))
                  ((and (= myUseMVL true) (= myChromosomeRule MVL:)) (ruleMvl.growWFF genome))
                  ((and (= myUseREG true) (= myChromosomeRule REG:)) (ruleReg.growWFF genome))
                  ((and (= myUseSVM true) (= myChromosomeRule SVM:)) (ruleSvm.growWFF genome))
                  (else (error "gsm: root-chromosome WFF init specified with invalid regression rule"))
                  ) ; end cond
                 (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                 ) ; end loop
           )) ; end if
   
       ;; Generate new random WFFs in the best-of-breed island.
       ;; Note: This must be done in the best-of-breed island population in a race for fitness.
       (if (> myGrowSelGEN 0)
           (begin
              (setq myPopulation myPopulationIslands[myBestRegressorIsland])
              (loop for n from 0 until myGrowSelGEN do 
                 (cond
                  ((and (= myUseFRM true) (= myGrowSelRule FRM:)) (ruleFrm.growWFF myGrowWFFStyle))
                  ((and (= myUseMVL true) (= myGrowSelRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                  ((and (= myUseREG true) (= myGrowSelRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                  ((and (= myUseSVM true) (= myGrowSelRule SVM:)) (ruleSvm.growWFF myGrowWFFStyle))
                  (else (error "gsm: random WFF best-of-breed growth specified with invalid regression rule"))
                  ) ; end cond
                 ) ; end grow root WFF loop
              (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))       
           )) ; end if

       ;; Generate new greedy search WFFs in the best-of-breed island.
       ;; Note: This must be done in the best-of-breed island population in a race for fitness.
       (if (and (> myGreedyGEN 0) (>= myM 3))
           (begin
              (setq myPopulation myPopulationIslands[myBestRegressorIsland])
              ;; Order the island populations by fitness.
              (setq bestIslands (new Vector: Number: myM))
              (loop for mm from 0 until myM (setq bestIslands[mm] myPopulationIslands[mm][0].NLSE))
              (setq bestIslands (|Gv:sort| bestIslands < true))
              (setq greedyCounter 0)
              (setq I1 bestIslands[0])
              (setq K1 (min myGreedyDepth (length myPopulationIslands[I1])))
              (setq I2 bestIslands[1])
              (setq K2 (min myGreedyDepth (length myPopulationIslands[I2])))
              (setq I3 bestIslands[2])
              (setq K3 (min myGreedyDepth (length myPopulationIslands[I3])))
              (cond
               ((= myGreedyWidth base:) (setq genome (copy myColumnGenome)))
               ((= myGreedyWidth full:) (begin (setq genome (new Vector: myM)) (loop for mm from 0 until myM do (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0]))))
               ((= myGreedyWidth narrow:)  (setq genome (new Vector: myM)))
               ((= myGreedyWidth random:) (setq genome genome))
               (else (error "gsm: invalid myGreedyWidth user specified option"))
               ) ; end greedy width cond
              (loop for k1 from 0 until K1 do
                 (loop for k2 from 0 until K2 do
                    (loop for k3 from 0 until K3 do
		               (cond
		                ((or (= myGreedyWidth base:) (= myGreedyWidth full:) (= myGreedyWidth narrow:))
                         (begin
	                       (setq genome[I1] myPopulationIslands[I1][k1].Genome[0])  
	                       (setq genome[I2] myPopulationIslands[I2][k2].Genome[0])  
	                       (setq genome[I3] myPopulationIslands[I3][k3].Genome[0])  
                         )) ; end base full narrow case
		                ((= myGreedyWidth random:) 
                         (begin 
                           (setq genome (new Vector: myM)) 
                           (loop for mm from 0 until myM do 
                              (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction (length myPopulationIslands[mm])))].Genome[0])
                              )
                         )) ; end random case
		                (else (error "gsm: invalid myGreedyWidth user specified option"))
		                ) ; end greedy width cond
	                   (setq greedyRuleCnt (length myWFFs))
                       ;; Use greedy search to combine island population genomes into WFFs in the best-of-breed island.
                       (cond
                        ((and (= myUseFRM true) (= myGreedyRule FRM:)) (ruleFrm.growWFF genome))
                        ((and (= myUseMVL true) (= myGreedyRule MVL:)) (ruleMvl.growWFF genome))
                        ((and (= myUseREG true) (= myGreedyRule REG:)) (ruleReg.growWFF genome))
                        ((and (= myUseSVM true) (= myGreedyRule SVM:)) (ruleSvm.growWFF genome))
                        (else (error "gsm: greedy WFF search specified with invalid regression rule"))
                        ) ; end cond
                       (bestRegressor)
                       (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                       (if (or (< greedyRuleCnt (length myWFFs)) (< (length myWFFs) myWFFSaveLimit)) (++ greedyCounter))
                       (if (>= greedyCounter myGreedyGEN) (goto LastGreedySearch:))        
                       ) ; end I3 island loop  
                    ) ; end I2 island loop  
                 ) ; end I1 island loop  

              LastGreedySearch::
           )) ; end if

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myContextSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myContextSelPct (number N))))
             (loop for nn from 0 until NN do (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply mutation population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myContextRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myContextRegPct (number N))))
             (loop for nn from 0 until NN do (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply incremental population migration to create new estimators.
       ;; Note: all inhabitants of the chosen island are mated with all inhabitants of the best-of-breed island.
       (if (<= (gsm.myRandomFunction 1.0) myMigratePct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (++ migrationIsland)(setq migrationIsland (modi migrationIsland myM))
             (setq migPopulation myPopulationIslands[migrationIsland])
             (setq N (length myPopulation))
             (if (<= N (length migPopulation))
                 (begin
                   (setq NN (integer (* myMigratePct (number N))))
                   (makeCrossover myPopulation[0] migPopulation[1])
                   (makeCrossover myPopulation[1] migPopulation[0])
                   (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] migPopulation[(integer (gsm.myRandomFunction N))]))
                 )) ; end if
           )) ; end migration if

       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all estimators from the current best of breed island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest myBestEstimator)

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestEstimator)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq myBest (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq myBest.Estimators (new Vector:))
          (setq myBest.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)
          
          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do   
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (= Lambda.EY #void) (setq Lambda.EY (Lambda.run myX)))
              (setq N (length myBest.Estimators))
              (loop for n from 0 until N do
                 (if (> (abs (setq result (math.correlation Lambda.EY myBest.Estimators[n].EY))) .90) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq myBest.Estimators[MM] Lambda)
              (setq myBest.NLSE (+ myBest.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append "(ruleAdd " wffString " " (standAloneEstimatorRules Lambda) ")"))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (setq wffString (append "(ruleReg #((ruleDiv " wffString " " MM ")))"))
          (setq myBest.WFF (listWff wffString))
          (setq myBest.NLSE (/ myBest.NLSE MM))
       )); end if 

    ;; Return the best WFF seen so far.
    myBest) ; end scriptGEP

































































































































;;**EXPORTKEY**:gsm.scriptGEPALPS
(defriend gsm:scriptGEPALPS(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy together with age layered populations. A Tree based genome is used wherein the 
;;          head of each list is a grammar rule. Standard tree based genetic programming operators 
;;          are used for mutation and crossover. New populations are instantiated on epoch boundaries
;;          and are allowed to grow and compete independently.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0))
  	vars:(result Lambda wff newWff wffString rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore)

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq eGrammar expressionGrammarGep)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptGEPALPS: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-of-breed population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (if (or (> myRootINIT 0) (> myRootGEN 0))
        (begin
           (if myVerboseSW (writeln "...starting generation of constant estimator WFF."))
           (setq wff 1.0)
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
       
           (setq genome (new Vector: myM))
           (setq genome[0] wff)
           (ruleReg.growWFF genome)
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

        )) ; end if

    ;; Create a simple FRM estimator WFF in the best-of-breed population.
    (if (= myUseFRM true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed FRM estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleFrm.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple MVL estimator WFF in the best-of-breed population.
    (if (= myUseMVL true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed MVL estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleMvl.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple REG estimator WFF in the best-of-breed population.
    (if (= myUseREG true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed REG estimator WFF."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleReg.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Create a simple cubic SVM estimator WFF in the best-of-breed population.
    (if (= myUseSVM true)
        (begin
          (if myVerboseSW (writeln "...starting a best-of-breed SVM estimator WFF on all columns."))
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (ruleSvm.growWFF myColumnGenome)
          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if

    ;; Initialize a tournament-of-champions (if appropriate).
    ;; Note: This must be done once for every time myBestEstimatorChampions grows to myTournamentSize.
    (if (>= (setq NN (length myBestEstimatorChampions)) myTournamentSize)
        (begin
           (if myVerboseSW (writeln "...starting tournament of champions."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for nn from 0 until NN do
             (setq wff myBestEstimatorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestEstimatorChampions if
           (setq NN (length myBestRegressorChampions))

           (loop for nn from 0 until NN do
             (setq wff myBestRegressorChampions[nn 1].WFF)
             (createGrammarEstimator wff)
             ) ; end myBestRegressorChampions if
           (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))

           ;; Keep only the best of the champions before starting the next tournament.
           (resize myBestEstimatorChampions 1)
           (resize myBestRegressorChampions 1)

           ;; Compact memory before starting the next tournament.
           (gc compact:)
        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))
       (bestRegressor)
        
       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------

       ;; Initialize a new aged layered population.
       (if (= (modi myGc myRestartEpoch) 0)
           (begin

	           ;; -----------------------------------------------------------------------------------------
	           ;; Renew island population ONLY if too many generations have passed without improvement.
	           ;; -----------------------------------------------------------------------------------------
	           (if (and (< islandGenerationGap[youngestPopulationIsland] myRestartGap) (> (length myPopulationIslands[youngestPopulationIsland]) 2)) (goto SkipRenewingThisIsland:))

               ;; Clear the youngest population island of all survivors.
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population."))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:)) 	
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
                
               ;; Grow new estimators from sequential basic root WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (<= myIslands[youngestPopulationIsland] myMaxRootWFFs)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myRootGEN do
                         (++ myIslands[youngestPopulationIsland]) 
                         (setq wff (growTermWFF myIslands[youngestPopulationIsland] mm))
                         (setq genome (new Vector: myM))
                         (setq genome[0] wff)
                         (cond
                          ((and (= myUseFRM true) (= myRootRule FRM:)) (ruleFrm.growWFF genome))
                          ((and (= myUseMVL true) (= myRootRule MVL:)) (ruleMvl.growWFF genome))
                          ((and (= myUseREG true) (= myRootRule REG:)) (ruleReg.growWFF genome))
                          ((and (= myUseSVM true) (= myRootRule SVM:)) (ruleSvm.growWFF genome))
                          (else (error "gsm: root WFF growth specified with invalid regression rule"))
                          ) ; end cond
                         ) ; end grow Estimators       
                   )) ; end if
        
               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (> myGrowColGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myGrowColGEN do
                         (cond
                          ((and (= myUseFRM true) (= myGrowColRule FRM:)) (ruleFrm.growWFF myGrowWFFStyle))
                          ((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                          ((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                          ((and (= myUseSVM true) (= myGrowColRule SVM:)) (ruleSvm.growWFF myGrowWFFStyle))
                          (else (error "gsm: random WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         ) ; end grow Estimators       
                   )) ; end if
        
                ;; Generate new random root-chromosome estimator WFFs in the best-of-breed island.
                ;; Note: This must be done in the best-of-breed island population in a race for fitness.
                (if (> myChromosomeGEN 0)
                    (begin
                       (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                       (loop for n from 0 until myChromosomeGEN do
                          (setq genome (new Vector: myM)) 
                          (loop for mm from 0 until myM do
                             (setq N (length myPopulationIslands[mm])) 
                             (if (>= N 0) (setq genome[mm] myPopulationIslands[mm][(integer (gsm.myRandomFunction N))].Genome[0]))
                             ) ; end genome loop
                          ;; Use each column island population to feed chromosomes into candiate WFFs for the best-of-breed island.
                          (cond
                           ((and (= myUseFRM true) (= myChromosomeRule FRM:)) (ruleFrm.growWFF genome))
                           ((and (= myUseMVL true) (= myChromosomeRule MVL:)) (ruleMvl.growWFF genome))
                           ((and (= myUseREG true) (= myChromosomeRule REG:)) (ruleReg.growWFF genome))
                           ((and (= myUseSVM true) (= myChromosomeRule SVM:)) (ruleSvm.growWFF genome))
                           (else (error "gsm: root-chromosome WFF init specified with invalid regression rule"))
                           ) ; end cond
                          (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
                          ) ; end loop
                    )) ; end if            

               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
 
	          SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
              )) ; end children		

          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextColPct))
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
              )) ; end children		

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
          (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE) (setq islandGenerationGap[mm] 0) (++ islandGenerationGap[mm])) 
	      (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Apply mutation population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myMutateSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateSelPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) myCrossSelPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossSelPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context crossover population operator to create new best-of-breed estimators.
       (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextSelPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       ;; Apply mutation population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-of-breed regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (/ myGc myG) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all estimators from the current best of breed island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest myBestEstimator)

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestEstimator)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq myBest (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq myBest.Estimators (new Vector:))
          (setq myBest.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)
          
          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do   
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (= Lambda.EY #void) (setq Lambda.EY (Lambda.run myX)))
              (setq N (length myBest.Estimators))
              (loop for n from 0 until N do
                 (if (> (abs (setq result (math.correlation Lambda.EY myBest.Estimators[n].EY))) .90) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq myBest.Estimators[MM] Lambda)
              (setq myBest.NLSE (+ myBest.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append "(ruleAdd " wffString " " (standAloneEstimatorRules Lambda) ")"))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (setq wffString (append "(ruleReg #((ruleDiv " wffString " " MM ")))"))
          (setq myBest.WFF (listWff wffString))
          (scoreNLSE myBest myX myY)
       )); end if 

    ;; Return the best WFF seen so far.
    myBest) ; end scriptGEPALPS

































































































































;;**EXPORTKEY**:gsm.scriptGSOALPS
(defriend gsm:scriptGSOALPS(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy together with age layered populations. A Tree based genome is used wherein the 
;;          head of each list is a grammar rule. Standard tree based genetic programming operators 
;;          are used for mutation and crossover. New populations are instantiated on epoch boundaries
;;          and are allowed to grow and compete independently.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0) (newEvolutionStarted false))
  	vars:(result Lambda bagLambda wff newWff wffString wffSource wffVector rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore Number:startTickCount Number:endTickCount)

    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;; Initialize mandatory option settings
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (setq myRegressorSaveSW true)     ;; During fitness competition always allow a wff, from any island, to compete in the best regressor fitness island.
    (setq myScoreFocus full:)  	      ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq startTickCount (getTickCount 0.0))
    (setq eGrammar expressionGrammarGso)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptGSOALPS: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestUncorrelatedIsland (+ 1 myM))
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 2 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-regressor population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])
    (setq wff 1.0)
    (setq genome (new Vector: myM))
    (setq genome[0] wff)
    (ruleReg.growWFF genome)
    (if (<= myBestRegressor.NLSE myS) (goto Last:))

    ;; Initialize the best-regressor population with a linear polynomial WFF.
    (if (and (= myGc 0) (= myUseMVL true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (setq myBestLinear (ruleMvl.growWFF genome))
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a quatratic polynomial WFF.
    (if (and (= myGc 0) (= myUseMVL true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleSquare x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cubic polynomial WFF.
    (if (and (= myGc 0) (= myUseMVL true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleCube x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a double cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a triple cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul (ruleMul v" m " v" (+ m myM)") v" (+ m (* 2 myM))")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cross rational polynomial WFF.
    (if (and (= myGc 0) (= myUseMVL true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleDiv v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a collection of root genomes.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of multivariate root estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for m from 0 until myRootINIT do 
             (cond 
              ((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF root:) (ruleMvl.growWFF root:)))
              ((and (= myUseREG true) (= myGrowRootRule REG:)) (ruleReg.growWFF root:))
              ((and (= myUseMVL true) (= myGrowRootRule MVL:)) (ruleMvl.growWFF root:))
              (else (error "gsm: root WFF initialize growth specified with invalid regression rule"))
              ) ; end cond
             (if (<= myBestRegressor.NLSE myS) (goto Last:))
             ) ; end loop

        )) ; end if

    ;; Initialize the best-regressor population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= myBestRegressor.NLSE myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Do NOT exceed maximum allotted time for this evolutionary process.
       (if (> (setq endTickCount (getTickCount startTickCount)) myEvolutionMaxTickCount) (goto Last:))

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))

       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (setq myBest (bestRegressor))
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Make sure we have a reasonable candidate or return no candidate at all.
       (if (>= myBest.NLSE BIGPOSNUM) (begin (setq myBest #void) (return myBest)))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------

       ;; Initialize a new aged layered population.
       (if (= (modi myGc myRestartEpoch) 0)
           (begin

               ;; Select a new vertical training slice at random.
               (initSamplingData)

	           ;; --------------------------------------------------------------------------------------------
	           ;; Insert abstract conditional WFFs as concrete splicings of uncorrelated regression champions.
	           ;; --------------------------------------------------------------------------------------------
               (if (and (> myGc myGetSeriousGens) (>= myBest.NLSE myGetSeriousErr))
                   then
                   (begin

					   (setq myPopulation myPopulationIslands[myBestRegressorIsland])
		
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		
		               (bestRegressor)
					   (if (<= myBestRegressor.NLSE myS) (goto Last:))
		
                   )); end if 

	           ;; --------------------------------------------------------------------------------------------
	           ;; Renew and age-layered island population ONLY if the island populations are not over crowded.
	           ;; --------------------------------------------------------------------------------------------
               ;; Increment the youngest population counter in round robin fashion.
               (loop for mm from 0 until myM do
                 (cond
                  ;; Unintialized island population.
                  ((<= (length myPopulationIslands[youngestPopulationIsland]) 2) (goto RenewThisIsland:)) 
                  ;; Unproductive island population.
                  ((>= islandGenerationGap[youngestPopulationIsland] myRestartGap) (goto RenewThisIsland:))
                  ;; Increment the youngest population counter in round robin fashion.
                  (else (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))) 
                  ) ; end cond
                 ) ; end island loop
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
               (goto SkipRenewingThisIsland:)

               ;; Clear the youngest population island of all survivors.
	           RenewThisIsland::
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population at [" youngestPopulationIsland "]"))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:)) 	
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
                
               ;; Initialize the best-of-breed population with a collection of root genomes.
               (if (> myRootGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                      (loop for n from 0 until myRootGEN do 
                         (cond
                          ((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF root:) (ruleMvl.growWFF root:)))
                          ((and (= myUseREG true) (= myGrowRootRule REG:)) (ruleReg.growWFF root:))
                          ((and (= myUseMVL true) (= myGrowRootRule MVL:)) (ruleMvl.growWFF root:))
                          (else (error "gsm: root WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end loop
                   )) ; end if

               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (> myGrowColGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myGrowColGEN do
                         (cond
                          ((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF myGrowWFFStyle) (ruleMvl.growWFF myGrowWFFStyle)))
                          ((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                          ((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                          (else (error "gsm: random WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end grow Estimators       
                   )) ; end if
        
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 

	           SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
              )) ; end children		

          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
              )) ; end children		

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
          (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE) (setq islandGenerationGap[mm] 0) (++ islandGenerationGap[mm])) 
	      (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Apply mutation population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::
    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (setq myBest (setq myBestEstimator (bestRegressor))) 
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))
    ;; Make sure that we have not exited from this training run prematurely.
    (if (and (> myBest.NLSE myS) (< myGc myG) (< endTickCount myEvolutionMaxTickCount)) (error "gsm.scriptGSPALPS: premature exit from training run"))

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestUncorrelatedIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestUncorrelatedIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest (setq myBestEstimator myBestRegressor))

    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGso.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptGSOALPS: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestRegressor)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq bagLambda (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq bagLambda.Estimators (new Vector:))
          (setq bagLambda.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)

          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (or (> Lambda.NLSE 10.0) (> Lambda.NLSE 10.0)) (goto SkipThisChampion:))
              (if (= (listWff Lambda.WFF)[0] ruleSvm:) (goto SkipThisChampion:))
              (setq Lambda.EY (Lambda.run myX))
              (setq N (length bagLambda.Estimators))
              (loop for n from 0 until N do
                 (if (= bagLambda.Estimators[n].EY #void) (setq bagLambda.Estimators[n].EY (bagLambda.Estimators[n].run myX)))
                 (if (> (abs (setq result (math.correlation Lambda.EY bagLambda.Estimators[n].EY))) myCovarianceLimit) (goto SkipThisChampion:))

                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq bagLambda.Estimators[MM] Lambda)
              (setq bagLambda.NLSE (+ bagLambda.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append wffString " " (standAloneEstimatorRules Lambda)))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::

          (if (< (setq NN (length bagLambda.Estimators)) 2)
              then
              (setq myBest (setq myBestEstimator myBestRegressor))
              else
              (begin 
			    (setq myPopulation myPopulationIslands[myBestRegressorIsland])

                (setq wffString "(ruleMvl #(")
                (setq M (min myM (length bagLambda.Estimators)))
			    (loop for m from 0 until M do 
                  (setq wffString (append wffString " " (standAloneEstimatorRules bagLambda.Estimators[m])))
                  ) ; end loop
                (setq wffString (append wffString " ))"))
                (setq Lambda (createGrammarEstimator wffString))
                (bestRegressor)
			    (if (<= myBestRegressor.NLSE myS) (goto Last:))
			
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))

              )) ; end if

       ;; Delete any SVM champions with NLSE scores greater than myBaggingPct.
       ;; Note: Emperically we have found that SVM champions with a very poor NLSE have seriously over fitted.
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop

       (bestRegressor)

       )); end if 

    ;; Return the best WFF seen so far.
    GoodBye::
    (if (and (isLambda myBestLinear) (isVector myBestLinear.Pv.Mvl.myW))
        (begin
          (setq myBestLinearModel (evalRule (concreteWFF gsm.myBestLinear)))
          (setq myBestLinearAxis  myBestLinear.Pv.A)
          (setq myBestLinearCoefficients myBestLinear.Pv.Mvl.myW)
          (scoreTCEandNLSE myBestLinear)
        )) ; end linear goodbye
    (if (isLambda myBest)
        (begin
          (setq myBestModel (getEstimatorChampions)[0])
          (scoreTCEandNLSE myBest)
        )) ; end nonlinear goodbye
    myBest) ; end scriptGSOALPS

































































































































;;**EXPORTKEY**:gsm.scriptHVES
(defriend gsm:scriptHVES(ObjVector:X NumVector:Y Integer:G Number:S Number:seed ...)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, and the 
;;				Hyper Volume Error Separation(HVES) Algorithm training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy  with age layered populations and the HVES Algorithm implementation. 
;;			A Tree based genome is used wherein the head of each list is a grammar rule. 
;;			Standard tree based genetic programming operators are used for mutation and crossover. 
;;			New populations are instantiated on epoch boundaries and are allowed to grow and 
;;			compete independently. The input space, defined by the training points are grouped based on
;;			their error. The discontinuity in the input space is manipulated using recursion and 
;;			the different functions on the separated input space.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************

  	;; *******************************************************************************
  	;; scriptHVES variables
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter epochCount x)
	pvars:(  createTree 
			 partitionData
			 myHVESRecord			;; Record containing Decision Matrix(DM) fields
			 myHVESMap				;; Object Vector containing indices to DM entries per column		
			(Integer:numFit)		;; Number of fitness cases = myX
			(Integer:numCols)		;; Number of columns = myX[0]
			(NumVector:minVector)	;; List of smallest column value for all the fitness cases
			(NumVector:maxVector)	;; List of largest column values for all the fitness cases	
			(IntVector:Dr)			;; List of fitness cases NOT belonging to the hyperparallelepiped
			(IntVector:Dh)			;; List of fitness cases belonging to the hyperparallelepiped
			errorClass				;; The error classification of each fitness case 1=big error 0=no error -1=small error
			errorVec				;; The Vector of (ey - y) results 
			mergeFlag
			) ;; end pvars
	vars:(	mapVec
			oldMin
			oldMax
			fVal
			(NumVector:trainingData);; The training data/ fitness case	 
			(Boolean:hpFlag true)	;; true, if fitness case belongs inside the hyperparallepiped
									;; false, if fitness case does not 
			(Boolean:mergeFlag false)
			 myHVESPopulation
		) ;; end vars
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0) (newEvolutionStarted false))
  	vars:(result Lambda bagLambda wff newWff wffString wffSource wffVector rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore Number:startTickCount Number:endTickCount)

 

    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;; Initialize mandatory option settings
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (setq myRegressorSaveSW true)     ;; During fitness competition always allow a wff, from any island, to compete in the best regressor fitness island.
    (setq myScoreFocus full:)  	      ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq startTickCount (getTickCount 0.0))
    (setq eGrammar expressionGrammarGso)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
	(setq epochCount 0)
    (if (< myN 10) (error "gsm.scriptHVES: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 2 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 
	(if (= mergeFlag #void) (setq mergeFlag false))

    ;; Initialize the best-regressor population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
	(if (= mergeFlag false)
		(begin
    		(setq myPopulation myPopulationIslands[myBestRegressorIsland])
    		(setq wff 1.0)
    		(setq genome (new Vector: myM))
    		(setq genome[0] wff)
    		(ruleReg.growWFF genome)
			(writeln "after: myPopulation: " myPopulation)
    		;(if (<= myBestRegressor.NLSE myS) (goto Last:))

    ;; Initialize the best-regressor population with a linear polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (ruleMvl.growWFF genome)
          ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a quatratic polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleSquare x" m ")"))))
          (ruleMvl.growWFF genome)
          ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cubic polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleCube x" m ")"))))
          (ruleMvl.growWFF genome)
          ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cross correlation polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul v" m " v" (+ m myM)")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cross rational polynomial WFF.
    (if (= myUseMVL true)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleDiv v" m " v" (+ m myM)")"))))
          (ruleMvl.growWFF genome)
          ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a collection of root genomes.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of multivariate root estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for m from 0 until myRootINIT do 
             (cond 
              ((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF root:) (ruleMvl.growWFF root:)))
              ((and (= myUseREG true) (= myGrowRootRule REG:)) (ruleReg.growWFF root:))
              ((and (= myUseMVL true) (= myGrowRootRule MVL:)) (ruleMvl.growWFF root:))
              (else (error "gsm: root WFF initialize growth specified with invalid regression rule"))
              ) ; end cond
             ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
             ) ; end loop
        )) ; end if

    ;; Initialize the best-regressor population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
	)) ;; end mergeFlag false

	(if (= mergeFlag true) (setq myPopulationIslands[myBestRegressorIsland] myHVESPopulation))

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    ;(if (<= myBest.NLSE myS) (goto Last:))
 
    (loop for myGc from myGc until myG do

       ;; Do NOT exceed maximum allotted time for this evolutionary process.
       (if (> (setq endTickCount (getTickCount startTickCount)) myEvolutionMaxTickCount) (goto Last:))

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))

       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (setq myBest (bestRegressor))
       ;(if (<= myBest.NLSE myS) (goto Last:))

       ;; Make sure we have a reasonable candidate or return no candidate at all.
       (if (>= myBest.NLSE BIGPOSNUM) (begin (setq myBest #void) (return myBest)))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------


       ;; Initialize a new aged layered population.

(writeln "start myGc: " myGc)
(writeln "myRestartEpoch: "  myRestartEpoch)
       (if (= (modi myGc myRestartEpoch) 0)
           (begin
		(writeln "newEvolutionStarted: " newEvolutionStarted " -- myGc: " myGc " -- myGetSeriousGens: " myGetSeriousGens  )
		(writeln "myBest.NLSE: " myBest.NLSE " -- myGetSeriousErr: "  myGetSeriousErr " -- epochCount: " epochCount " --myHVESSW: " myHVESSW) 

               ;; Have we decided to get serious and do an expensive search?
				;; removed this first to go into hves (> myGc myGetSeriousGens) 

               ;(if (and (= newEvolutionStarted false) (> myGc myGetSeriousGens) (>= myBest.NLSE myGetSeriousErr) (= epochCount 0) (= myyHVESSW true))
      			(if (and (= newEvolutionStarted false) (>= myBest.NLSE myGetSeriousErr) (= epochCount 0) (= myHVESSW false))

                   (begin 
                     (setq newEvolutionStarted true)
                     (setq mySamplingON  false)        ;; Support initial scoring on a small sample set, followed by a small training set, before scoring on the full training data set.
                     (setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
                     (setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
                     (setq mySWMPool 0200)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	                 (setq myTrainingFactor 4)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
			 
                     ;; Save previous champions to be reinitialized in the new evolutionary process.
                     (setq N (length myBestEstimatorChampions))(loop for n from 0 until N do (setUserGrammarWFFs myBestEstimatorChampions[n].WFF))
					 (++ epochCount)
					(writeln "setting myHVESSW to true")
					 (setq myHVESSW true)
                     (goto StartNewEvolutionaryProcess:)                   
                   )); end if

			   (if (and (or (= myHVESSW true) (= epochCount 1)) (= newEvolutionStarted false))
					(begin
						(setq newEvolutionStarted true)
						(setq mySamplingON true)
 						(setq mySWMMaxGap 10)             ;; The maximum number of training generations without improvement before the swarm is reinitialized.
                     	(setq mySWMMaxGen 10)             ;; The maximum number of training generations in any one swarm regression.
                     	(setq mySWMPool 0200)             ;; The maximum size of the particle population pool allowed in any one swarm regression. (G=6,Time=4.5min,LSE=.48,CLS=.86) (G=10,Time=8.7min,LSE=.43,CLS=.89)
	                 	(setq myTrainingFactor 2)         ;; The reduction factor for determining the size of the final training data (when mySampleON is true).
						(setq myHVESSW true)			  ;; Turn on HVES parameters and enable recursion
						(setq tagDepth 1)
 						;; Save previous champions to be reinitialized in the new evolutionary process.
                     	(setq N (length myBestEstimatorChampions))(loop for n from 0 until N do (setUserGrammarWFFs myBestEstimatorChampions[n].WFF))
					 	(++ epochCount)
                     	(goto StartNewEvolutionaryProcess:)
					);; end begin
				) ;; end if

               ;; Select a new vertical training slice at random.
               (initSamplingData)

	           ;; -----------------------------------------------------------------------------------------
	           ;; Renew island population ONLY if too many generations have passed without improvement.
	           ;; -----------------------------------------------------------------------------------------
	           (if (and (< islandGenerationGap[youngestPopulationIsland] myRestartGap) (> (length myPopulationIslands[youngestPopulationIsland]) 2)) (goto SkipRenewingThisIsland:))

               ;; Clear the youngest population island of all survivors.
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population."))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:)) 	
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
               ;; Initialize the best-of-breed population with a collection of root genomes.
               (if (> myRootGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                      (loop for n from 0 until myRootGEN do 
                         (cond
                          ((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF root:) (ruleMvl.growWFF root:)))
                          ((and (= myUseREG true) (= myGrowRootRule REG:)) (ruleReg.growWFF root:))
                          ((and (= myUseMVL true) (= myGrowRootRule MVL:)) (ruleMvl.growWFF root:))
                          (else (error "gsm: root WFF column growth specified with invalid regression rule"))
                          ) ; end cond
                         ;(if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end loop
                   )) ; end if
				(setq myPopulation myPopulationIslands[myBestRegressorIsland])
 
               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
 
               	(if (> myGrowColGEN 0)
                   (begin				 
                      	(setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      	(loop for n from 0 until myGrowColGEN do 
                         	(cond 
                          		((and (= myUseREG true) (= myGrowRootRule REG:) (= myUseMVL true) (= myGrowRootRule MVL:)) (if (<= (gsm.myRandomFunction 1.0) myUseREGRatio) (ruleReg.growWFF myGrowWFFStyle) (ruleMvl.growWFF myGrowWFFStyle)))
 								((and (= myUseREG true) (= myGrowColRule REG:)) (ruleReg.growWFF myGrowWFFStyle))
                          		((and (= myUseMVL true) (= myGrowColRule MVL:)) (ruleMvl.growWFF myGrowWFFStyle))
                         	 	(else (error "gsm: random WFF column growth specified with invalid regression rule"))
                          	) ; end cond
 							;(if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end grow Estimators       
                   )) ; end if
               	;; Increment the youngest population counter in round robin fashion.
               	(if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
	         	SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))

       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
              )) ; end children		

          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
              )) ; end children		

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
          (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE) (setq islandGenerationGap[mm] 0) (++ islandGenerationGap[mm])) 
	      (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Apply mutation population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (setq myBest (setq myBestEstimator (bestRegressor))) 
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))
    ;; Make sure that we have not exited from this training run prematurely.
    (if (and (> myBest.NLSE myS) (< myGc myG) (< endTickCount myEvolutionMaxTickCount)) (error "gsm.scriptHVES: premature exit from training run"))

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------
 
    ;; Add all estimators from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop
    (setq myBest (setq myBestEstimator myBestRegressor))
 
    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGso.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptHVES: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestRegressor)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq bagLambda (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq bagLambda.Estimators (new Vector:))
          (setq bagLambda.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)

          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (or (> Lambda.NLSE 10.0) (> Lambda.NLSE 10.0)) (goto SkipThisChampion:))
              (setq Lambda.EY (Lambda.run myX))
              (setq N (length bagLambda.Estimators))
              (loop for n from 0 until N do
                 (if (= bagLambda.Estimators[n].EY #void) (setq bagLambda.Estimators[n].EY (bagLambda.Estimators[n].run myX)))
                 (if (> (abs (setq result (math.correlation Lambda.EY bagLambda.Estimators[n].EY))) myCovarianceLimit) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq bagLambda.Estimators[MM] Lambda)
              (setq bagLambda.NLSE (+ bagLambda.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append wffString " " (standAloneEstimatorRules Lambda)))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (if (<= (length bagLambda.Estimators) 2)
              then
              (setq myBest (setq myBestEstimator myBestRegressor))
              else
              (begin 

                (setq wffString (append "(ruleSvm #(" (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) " " (standAloneEstimatorRules bagLambda.Estimators[2]) "))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMvl #(" (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) " " (standAloneEstimatorRules bagLambda.Estimators[2]) "))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (bestRegressor)

              )) ; end if
       )); end if 
 
	;;-----------------------------------------------------------
	;; Implementation of the HVES Algorithm for the champion wff
	;;-----------------------------------------------------------
 
	;; Save HVES Decision Matrix (DM)  and Map in a Record and Object Vector respectively
	(if (= myHVESSW true)
		(begin
			;; This special scoring returns a vector of the EY errors and a Vector containing
			;; error classification. (-1=low error 0=no error 1=high error)
			(scoreNLSEHves myBest myX myY)	
			(setq errorClass scoreNLSEHves.ErrClass)
			(setq errorVec scoreNLSEHves.ErrVec)
		 
			(setq numFit (-  myN 1))
			(setq numCols (-  myM 1))
		 	
			(setq myHVESRecord (new Record: (+ numFit 1) Col:Number:(+ numCols 1) MapIndex:Integer:(+ numCols 1) YValue:Number:1 NLSE:Number:1  ))
			(setq myHVESMap (new Vector: Object: (+ numCols 1)))
		
			(loop for n from 0 to numFit
				(loop for m from 0 to numCols			
					(setq dmVal myX[n][m])				 
					(setq myHVESRecord[Col: m n] dmVal)
					(setq mapVec myHVESMap[m])
					 
					(if (= #void mapVec)
						(begin 
							(setq mapVec (new Vector: Number: 0))
							(setq mapVec[0] dmVal)
							(setq myHVESMap[m] mapVec)						 
						)
						else
						(begin				 
							(binaryInsert mapVec dmVal )				 
							(setq myHVESMap[m] mapVec)	
					)) 		 
				) ;; end numCols
			) ;; numFit


			DataPartition::		
			(gsm.scriptHVES.createTree)
 			(setq hvesPop (gsm.scriptHVES.partitionData Dh Dr))
			(return hvesPop)
	 
		) ;; end begin
	) ;; end if

    ;; Return the best WFF seen so far.
    GoodBye::
    myBest) ; end scriptHVES













































;;**EXPORTKEY**:gsm.scriptHVES.createTree
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; A function used by HVES to store the DM and Map information	;;
;; in a tree-like structure using pointers Structure to connect ;;
;; the nodes of the tree.										;;
;;																;;
;;	Returns: myForest							 				;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defchild gsm.scriptHVES createTree()
	pvars:(					 
			;; Child Functions
			buildHVTreeSet
 
			insertNode
			;; Tree storage structures
			(NodeTemplate			#{	DMLocation: -1
										Parent:		-1
										Children: #void
									})
			(IntVector:myForest)				;; Contains the indices contained in the tree
 			(IntVector:setNodesThisTree)		;; Indices of the fitness cases stored in the current tree
			(IntVector:setNodesAnyTree)			;; Indices of the fitness cases stored in all the trees
			(IntVector:mostDifficultTree)
			(ObjVector:nodesForThisTree)
			(Structure:RootNode)
			(NumVector:angleThreshold)
		  ) ;; end pvars 
	vars:(	 
			IntVector:tempMap
			CurrentNode			 	
			tempVal	 
			(Structure:TempNode)
			child parent childPoint parentPoint treeIndexVal2 treeIndexVal
			wed totalWed totalTotalWed errVal
            c childVec childVecLen eucDist f fVal
            highestWed hpFlag lengthThisTree mapIndex nodeEval
            nodeMax nodeMin nodeVal totalEucDist
		 ) ;; end vars
	regs:(	n nn (Integer:t) (Integer:tt) (Integer:ttt)			 
		) ;; end regs


 
	;;*********************************;; 
	;; Start CreatTree function	       ;;
	;; This is a collection of trees   ;;
	;;*********************************;;
 	(setq mapIndex (new Vector: Integer: (+ numCols 1 )))
	(setq myForest (new Vector: Integer:))
 
	;; Create MapIndex
 	(loop for nn from 0 to numCols 
		(setq tempMap myHVESMap[nn])
		(loop for n from 0 to numFit
			(setq tempVal  myHVESRecord[Col: nn n])		 		 	
			(setq myHVESRecord[MapIndex: nn n] (binarySearch  tempMap tempVal ))	
		) ;; end loop	
	) ;; end loop	
	
	(setq setNodesAnyTree (new Vector: Integer: ))
	(setq mostDifficultTree (new Vector: Integer:))
	(setq highestWed -1000000)
	 

	(loop for n from 0 until numFit  
		;; set the value of the current node
		;; each row in the DM is a root node if not member of setNodesAnyTree
		NewTree::
		(if (= (binarySearch setNodesAnyTree n ) false)
			(begin
				(writeln "--- Creating New Tree --- Node[" n "]")
				;;(debug traceon:)
				(setq setNodesThisTree (new Vector: Integer:))
				(setq nodesForThisTree (new Vector: Object:))
				(setq RootNode (new NodeTemplate))
				(setq RootNode.DMLocation n)				
				(setq RootNode.Parent n)			
				(setq TempNode (new NodeTemplate))			 
				(setq TempNode.DMLocation (+ n 1))		 
				(setq TempNode.Parent n)
			
				(gsm.scriptHVES.createTree.buildHVTreeSet TempNode)
				(setq lengthThisTree (length nodesForThisTree))
				;; Find the WED of the tree
				(if (> lengthThisTree 0)
					(begin
						(setq totalTotalWed 0)
						(loop for t from 0 until lengthThisTree
							(setq nodeEval nodesForThisTree[t])
							(setq childVec (ref nodeEval 2))
							(setq parent (ref nodeEval 0))
							(setq totalWed 0)							 
							(setq childVecLen (length childVec))						 
							(loop for tt from 0 until childVecLen
								(setq totalEucDist 0)
								(setq child childVec[tt])
								(setq errVal 0)
								(loop for ttt from 0 to numCols
									(setq childPoint myHVESRecord[Col: ttt child])								 
									(setq parentPoint myHVESRecord[Col: ttt parent])								 									 
									(setq eucDist (- parentPoint childPoint))
									(setq eucDist (sqrt eucDist))
									(setq eucDist (gsm@validate eucDist))
									(+= totalEucDist eucDist)
								) ;; end loop							 
								(setq  errVal (/ (+ errorVec[parent] errorVec[child]) 2))
								(setq wed (* totalEucDist errVal))
								(setq wed (gsm@validate wed))
								(+= totalWed wed)
							) ;; end loop
							(+= totalTotalWed totalWed)
						) ;; end loop
						(if (> totalTotalWed highestWed) (begin (setq highestWed totalTotalWed) (setq mostDifficultTree setNodesThisTree )))
					)
					else
  					(begin (goto EndTree:))	
				)

				EndTree::
				))
		) ;; end loop
	
		(setq lengthThisTree (length mostDifficultTree))
		(if (> lengthThisTree 0)
			(begin
				(setq minVector (new Vector: Number: (+ 1 numCols )))
				(setq maxVector (new Vector: Number: (+ 1 numCols )))
 		 
				(loop for nn from 0 to numCols
					(setq treeIndexVal (ref mostDifficultTree 0))
					(setq nodeMin myHVESRecord[Col: nn treeIndexVal])				 
					(setq nodeMax myHVESRecord[Col: nn treeIndexVal])
				 
					(loop for t from 1 until lengthThisTree 						
						(setq treeIndexVal2 mostDifficultTree[t])					 
						(setq nodeVal myHVESRecord[Col: nn treeIndexVal2])					 
						(if (< nodeVal nodeMin) (setq nodeMin nodeVal))
						(if (> nodeVal nodeMax) (setq nodeMax nodeVal))
					) ;; end loop
					(setq minVector[nn] nodeMin)
					(setq maxVector[nn] nodeMax)
				) ;; end loop
	
				(writeln "minVector:: " minVector)
				(writeln "maxVector:: " maxVector)

				;; Generate Hypervolume from the node boundaries
				;; By default, training data is said to belong inside the hyperparalleliped		
				(setq Dr (new Vector: Integer: 0 ))
				(setq Dh (new Vector: Integer: 0 ))
					 
				(loop for f from 0 until numFit  
					(setq hpFlag true)
					(loop for c from 0 until numCols
						(setq fVal myHVESRecord[Col: c f])
						(if (and (= hpFlag true) (or (> fVal maxVector[c]) (< fVal minVector[c])))
							(begin
								(setq hpFlag false)
								(goto EndData:) 				 
							) ;; end begin					 
						) ;; end if
					) ;; end loop	
					EndData::					 	
					(if (= hpFlag true) (begin (setq Dh[(length Dh)] f) ))
					(if (= hpFlag false) (begin  (setq Dr[(length Dr)] f) ))							 
				) ;; end begin
			) ;; end begin
		) ;; end if	 		 
 					 
		(setq myPopulation myPopulationIslands[myBestRegressorIsland])
	 			 
 
) ;; end create Tree 
































;;**EXPORTKEY**:gsm.scriptHVES.createTree.buildHVTreeSet
 (defchild gsm.scriptHVES.createTree buildHVTreeSet(inputNode)
	regs:( fitCaseNum gpIndex currentIndex nn x closeIndex nodeValue  n closestNodeIndex indexComp cols)
	vars:(	(Number:parentVal)
			(Number:colValComp)
			(Number:gpColVal)
			(IntVector:NodeLocation)
			(Number:normParent)		
			(Number:normGParent)
			(IntVector:tempMap)
			(Number:childCol)
			(Number:parentCol)	
			(Number:dist)
			(Number:eucDist)	
			(Number:shortestEucDist)
			(Structure:ParentNode)				
            colVal
            lowestColVal
            smallestColDiff
		 ) ;; end vars
 
	(setq ParentNode inputNode)

	(setq fitCaseNum ParentNode.DMLocation)
	(setq gpIndex ParentNode.Parent)
	(setq NodeLocation (new Vector: Integer:))
 
 
	FindChildNode::
	;; Search for the map index of the other nodes

	(loop for cols from 0 to numCols 	 	
		;;Preparation for getting closest node
		(setq currentIndex myHVESRecord[MapIndex: cols fitCaseNum])	 
		(setq closeIndex (+ currentIndex 1))
		;; preparation for angle threshold computation
		(setq colVal myHVESRecord[Col: cols fitCaseNum])
		(setq gpColVal myHVESRecord[Col: cols gpIndex])
		(setq lowestColVal colVal)
		;; Preparation for Angle-Distance computation
		(setq normParent (* colVal colVal))
		(+= normParent normParent)	
	 	(setq normGParent (* gpColVal gpColVal))
		(+= normGParent normGParent)
		(setq smallestColDiff 10000000)	
	 
		(if (= (binarySearch setNodesThisTree currentIndex) false) 
			(begin		
				(loop for n from 0 to numFit 
					(setq colValComp myHVESRecord[Col: cols n])
					(if (and (= (binarySearch setNodesThisTree n) false)  (<> colValComp colVal) )
						 (begin	 	
								;; Getting the possible nodes containing (+ currentIndex 1)
							 	(setq indexComp myHVESRecord[MapIndex: cols n])							 
								(if  (= closeIndex indexComp) 
									(begin 									 
										(binaryInsert NodeLocation n)									 
								))						 
					));; end if		 
				) ;; end loop			
		))	;; end if		
  
		(setq normParent (sqrt normParent))
		(setq normGParent (sqrt normGParent))
		(setq closestNodeIndex 0)
		(setq shortestEucDist -1)
		 
		
		(if (= (length NodeLocation) 0) (goto EndBuildHVTree:))
		(if (= (length NodeLocation) 1) (begin  (goto SingleCloseNode:)))
		(loop for x from 0 to (- (length NodeLocation) 1)
			;; Getting the training data
			(setq nodeValue 0)	
			(setq nodeValue NodeLocation[x])	
			(setq eucDist 0)
			(loop for nn from 0 to  numCols 			
				(setq childCol	myHVESRecord[Col: nn nodeValue])
				(setq parentCol myHVESRecord[Col: nn fitCaseNum])		
				(setq dist (- parentCol childCol))			 
					(+= eucDist (* dist dist))					 
			) ;; end loop
			(setq eucDist (sqrt eucDist))
			(if (< shortestEucDist 0) (setq shortestEucDist eucDist ))
			(if (<= eucDist shortestEucDist) 
				(begin 
					(setq closestNodeIndex nodeValue)
					(setq shortestEucDist eucDist)
				)
			) ;; end if
		) ;; end loop
		
	 
		SingleCloseNode::
		(if (= (binarySearch setNodesThisTree closestNodeIndex) false)(gsm.scriptHVES.createTree.insertNode ParentNode closestNodeIndex))
		
   ) ;; end loop

	;; if closest point already inserted, go to the next column
	EndBuildHVTree::
) ;; end buildHVTree























;;**EXPORTKEY**:gsm.scriptHVES.createTree.insertNode
(defchild gsm.scriptHVES.createTree insertNode(inputNode inIndex)
regs:(n nn)
vars:(	(Structure:ChildNode)
		(Structure:ParentNode)
		(NumVector:gradientVec)
		(NumVector:errorVec)
		(NumVector:angleVec)
		(Number:meanAngle)
		(Number:diff)
		(Number:sumDiff)
		(Number:sd)
		(Number:childVal)
		(Number:childNorm)
		(Number:parentCoordinates)
		(Number:childCoordinates)
		(Number:gpCoordinates)
		(NumVector:gppAngle)
		(NumVector:pcAngle)
		(Number:gppNorm)
		(Number:pcNorm)
		(Number:parentNorm)
		(NumVector:thetaAngle)
		(NumVector:betaAngle)
 		(Number:parentVal)
		(Number:colVal)
		(Number:colValComp)
        (Number:lowestColVal)
		(Number:smallestColDiff 1000000)
		(Number:colDif)
        angleDiff
        childVec	 ) ;; end vars
regs: (  closestNodeIndex Cr Cp Cc rootNodeIndex parentNodeIndex gpNodeIndex)

	(setq ParentNode inputNode)
	(setq closestNodeIndex inIndex)
	;(debug traceon:)
	;(writeln "		---inside insertNode: ---" )
	;(writeln "		ParentNode: " ParentNode)
	;(writeln "		RootNode: " RootNode)
	
	(setq ChildNode (new NodeTemplate) )


	(binaryInsert myForest ParentNode.DMLocation)
	;(writeln "		myForest at start of insertNode: " myForest)
		
	(setq childVec ParentNode.Children)
	(if (= #void childVec) 
		(begin
			(setq childVec (new Vector: Integer:))
		))

	InsertNode::
	;; CurrentNode is the closest node to Node
	;; Check if the current node can be inserted
	(setq rootNodeIndex RootNode.DMLocation)
	 
	;; Parent Node is the current node evaluated
	(setq parentNodeIndex ParentNode.DMLocation)
	;(writeln "		rootNodeIndex: " rootNodeIndex " -> grandparentNodeIndex: " ParentNode.Parent)
	;(writeln " 		-> parentNodeIndex: " parentNodeIndex "    -> closestNodeIndex: " closestNodeIndex )
	;(setq Cr myHVESRecord[ErrCat: 0 rootNodeIndex])
	;(setq Cp myHVESRecord[ErrCat: 0 parentNodeIndex]) 
	;(setq Cc myHVESRecord[ErrCat: 0 closestNodeIndex])
	(setq Cr errorClass[rootNodeIndex])
	(setq Cp errorClass[parentNodeIndex])
	(setq Cc errorClass[closestNodeIndex])
	;(writeln "		Cr: " Cr " -> Cp: " Cp " -> Cc: " Cc )
	(cond
		((and (= Cr	0) (= Cp 0) (= (binarySearch setNodesAnyTree closestNodeIndex) false)) 
			(begin
				;(writeln "		-Condition 1-")
				(setq ChildNode.DMLocation closestNodeIndex)
				(setq ChildNode.Parent parentNodeIndex)	 
				(binaryInsert setNodesAnyTree closestNodeIndex)
				(binaryInsert myForest closestNodeIndex) 
			)
		) ;; end cond1
		((and (= Cr -1) (or (= Cp 0) (= Cp -1)))
			(begin
				(if (and (= Cc 0) (= (binarySearch setNodesThisTree closestNodeIndex ) false))
					(begin
						;(writeln "		-Condition 2a-")
						(setq ChildNode.DMLocation closestNodeIndex)
						(setq ChildNode.Parent parentNodeIndex)
						(binaryInsert childVec closestNodeIndex)
						(binaryInsert setNodesThisTree  closestNodeIndex)
						(binaryInsert myForest closestNodeIndex) 
					))
					(if (and (= Cc -1) (= (binarySearch setNodesAnyTree closestNodeIndex ) false))
						(begin
							;(writeln "		-Condition 2b-")
							(setq ChildNode.DMLocation closestNodeIndex)
							(setq ChildNode.Parent parentNodeIndex)
							(binaryInsert setNodesAnyTree  closestNodeIndex)
							(binaryInsert myForest closestNodeIndex) 
					))
				)
			) ;; end cond2 
			((and (= Cr 1) (or (= Cp -1) (= Cp 1)))
				(begin
					(if (and (= Cc 0) (= (binarySearch  setNodesThisTree closestNodeIndex) false))
						(begin
							;(writeln "		-Condition 3a- ")
							(setq ChildNode.DMLocation closestNodeIndex)
							(setq ChildNode.Parent parentNodeIndex)
							(binaryInsert childVec closestNodeIndex)
							(binaryInsert setNodesThisTree closestNodeIndex)
							(binaryInsert myForest closestNodeIndex) 
						)else
						(begin
							;; compute the Angle threshold
							;(writeln "		-Condition 3b-")
							(setq gradientVec (new Vector: Number: (+ 1 numCols)))
							(setq errorVec (new Vector: Number: (+ 1 numCols)))
							;;(setq errorVec myBest.ErrVec)					
							(setq angleVec (new Vector: Number: (+ 1 numCols)))
							;; newly inserted - start-
							;;(setq colValComp myHVESRecord[Col: nn n])
							(setq angleThreshold (new Vector: Number: (+ numCols 1)))
							(loop for nn from 0 to  numCols  
								(setq parentVal myHVESRecord[Col: nn parentNodeIndex])
								;(writeln "parentVal: " parentVal)
								(setq smallestColDiff 1000000000)
	 	
								(loop for n from 0 to  numFit 
			 						(setq colValComp myHVESRecord[Col: nn n])
									;(writeln "colValComp: " colValComp)
		 							(if (and  (<> colValComp parentVal) (= (binarySearch setNodesThisTree colValComp) false))
										(begin
		 									;; Calculating the shortest node distance per column, from the currentNode for all the fitness cases
											;; Preparation for the angle threshold computation
						 					(setq colDif (abs (- parentVal colValComp)))
						 					(if (< colDif smallestColDiff) 
												(begin 
													;(writeln "changing values: " )
													(setq lowestColVal colValComp)
													;(writeln "----- lowestColVal ----- " lowestColVal)
													(setq smallestColDiff colDif)
												) ;; end begin
											) ;; end if			 
									)) ;; end if				
								) ;; end loop
								;(writeln "lowestColVal: " lowestColVal)
								(setq angleThreshold[nn] lowestColVal)
		;;;;;;;;;;;;;;;;;;;;;;;;
								;(writeln "angleThreshold[nn] : "  angleThreshold[nn] )
								(setq angleVec[nn]  (atan (/ parentVal angleThreshold[nn])))
								;(writeln "angleVec : " angleVec )
								(+= meanAngle angleVec[nn] )
							) ;; end
							(setq meanAngle (/ meanAngle numCols))
							(loop for nn from 0 to  numCols 
								 (setq diff (- meanAngle angleVec[nn]))
								 (+= sumDiff (* diff diff))
							) ;; end loop
							(setq sd (/ sumDiff numCols))
							(setq sd (sqrt sd))
							;(writeln "after SD: " sd)
							(loop for nn from 0 to  numCols 
								(setq childVal myHVESRecord[Col: nn closestNodeIndex])
								(+= childNorm (* childVal childVal))
								(setq angleThreshold[nn] (* sd angleThreshold[nn]))
							) ;; end loop
							(setq childNorm (sqrt childNorm))
							;(writeln  "after childNorm: " childNorm)
		
							(setq gppAngle (new Vector: Number: (+ 1 numCols)))
							(setq pcAngle (new Vector: Number: (+ 1 numCols)))
							;(writeln "parentNodeIndex: "  parentNodeIndex)
							;(writeln "closestNodeIndex: "  closestNodeIndex)
							;; Let gppAngle be the Angle Vector of the GrandparentNode and the ParentNode  
							;; Let pcAngle be the Angle Vector of the ParentNode and the ChildNode
							 (loop for nn from 0 to   numCols 
								(setq parentCoordinates  myHVESRecord[Col: nn parentNodeIndex])
								;(writeln "parentCoordinates: " parentCoordinates)
								(setq gpNodeIndex ParentNode.Parent)
								(setq gpCoordinates  myHVESRecord[Col: nn gpNodeIndex])
								;(writeln "gpCoordinates: " gpCoordinates)
								(setq childCoordinates  myHVESRecord[Col: nn closestNodeIndex])
								;(writeln "childCoordinates: " childCoordinates)
								;; Construction of vectors
								(setq gppAngle[nn] (abs (- parentCoordinates gpCoordinates)))
								;(writeln "-> gppAngle for nn: " nn "  gppAngle[nn]: "   gppAngle[nn])
								(setq pcAngle[nn] (abs (- childCoordinates parentCoordinates )))
								;(writeln "-> pcAngle for nn: " nn "  pcAngle[nn]: "   pcAngle[nn])
								(+= gppNorm gppAngle[nn])
								;(writeln "gppNorm: " gppNorm)
								(+= pcNorm pcAngle[nn])
								;(writeln "pcNorm: " pcNorm)						
							) ;; end loop
		
							(setq gppNorm (sqrt gppNorm))
							(setq pcNorm (sqrt pcNorm))
							
					 		;(writeln "after pcNorm: " pcNorm)
							;(writeln "after gppNorm: " gppNorm)
							(setq nn 0)
							(setq angleDiff 10000000)
							;(while (and (< nn numCols)(>= (abs (- gppAngle[nn] pcAngle[nn])) angleThreshold[nn])) do
							(while (and (< nn numCols) (>= angleDiff angleThreshold[nn])) do
								;; try to comment and see where the true angle computation is
								(if (<> gppNorm 0) (setq thetaAngle (acos (/ gppAngle[nn] gppNorm))))
								;(writeln "thetaAngle: " thetaAngle)
								(if (<> pcNorm 0)(setq betaAngle (acos (/ pcAngle[nn] pcNorm))))
								;(writeln "betaAngle: " betaAngle)
								(setq angleDiff (- thetaAngle betaAngle))
								(setq angleDiff (gsm@validate angleDiff))
								(setq angleDiff (abs angleDiff))
								;(writeln "angleDiff: " angleDiff)
								(++ nn)					 
							) ;; end while
							;(writeln "after beta and theta: nn: " nn "  cc: "  Cc)
							;(writeln "closestNodeIndex: " closestNodeIndex)
							;(writeln "setNodesThisTree: "  setNodesThisTree)
							;(writeln "setNodesAnyTree: "  setNodesAnyTree)
							(if (= nn numCols)
								(begin
									(if (and (= Cc -1) (= (binarySearch  setNodesThisTree closestNodeIndex) false))
										(begin
											;(writeln "		-Condition 3b.1-")
											(setq ChildNode.DMLocation closestNodeIndex)
											(setq ChildNode.Parent ParentNode.DMLocation)
											(binaryInsert childVec closestNodeIndex)
											(binaryInsert setNodesThisTree  closestNodeIndex)
											(binaryInsert myForest closestNodeIndex) 
										) ;; end begin
									) ;; end if
									(if (and (= Cc 1) (= (binarySearch setNodesAnyTree closestNodeIndex ) false))
										(begin
											;(writeln "		-Condition 3b.2-")
											(setq ChildNode.DMLocation closestNodeIndex)
											(setq ChildNode.Parent ParentNode.DMLocation)
											(binaryInsert childVec closestNodeIndex)
											(binaryInsert setNodesThisTree  closestNodeIndex)
											(binaryInsert myForest closestNodeIndex) 
										) ;; end begin
									) ;; end if
								) ;; end begin
							) ;; end if	
						) ;; end begin
					) ;; end if
				) ;; end begin
			) ;; end cond 3
		) ;; end cond
 
;(writeln "		---End Insert Node: ChildNode: " ChildNode " ---")
;(writeln "setNodesThisTree: " setNodesThisTree)
;(writeln "childVec: "childVec)
(setq ParentNode.Children childVec)
(setq nodesForThisTree[(length nodesForThisTree)] ParentNode)
(if (<> ChildNode.DMLocation -1) (gsm.scriptHVES.createTree.buildHVTreeSet ChildNode))
)


























;;**EXPORTKEY**:gsm.scriptHVES.partitionData
 (defchild gsm.scriptHVES partitionData(H R)
	vars: (
		   (Integer:myHVESPopSize)
		   (ObjVector:myHVESPopulation)
			DhVal
			DrVal
			DhAllVal
			DrAllVal
			Y1  D Yvec
			Y2
			fitIndex
			DrIndex DhIndex mergePop startPop
            DhPop DrPop G S Seed
            YVec YVec1 YVec2
            len p returnPop testDhAllVal testDrAllVal
            y1 y2
		 ) ;; end vars
	regs:(n m   )
				
	(setq Dr R)
	(setq Dh H)
 
	(setq DhIndex (length Dh))
	(setq DrIndex (length Dr))
 
	
	(setq startPop myPopulationIslands[myBestRegressorIsland])
 
	;; Define base case for HVES recursion
	;; If base case is reached, work with existing data for data partitioning
	;; Base Case 1: maximum tag depth is reached
	;; Base Case 2: data cannot be partitioned anymore
	(if (or (<= DhIndex 10) (<= DrIndex 10)) (return startPop))
	(if  (or  (= recurseFlag "forDr") (= tagDepth 3)) 
		(begin
			(setq myHVESPopulation (new Vector: Object: (length startPop)))
			(loop for n from 0 until (length startPop)
				(writeln "saving popsize:  startPop[n]: "  startPop[n] )
				(setq myHVESPopulation[n] startPop[n])
			) ;; end loop 
			;; End define base case
			(if (= tagDepth 0) 
				(begin
					(return myHVESPopulation)
				) ;; end begin
				else
				(begin
					(if (= recurseFlag "forDh") (setq recurseFlag "DhDone"))				 
					(return myHVESPopulation)
						) ;; end begin
					) ;; end if					
				) ;; end begin
			) ;; end base case 
		  
 
			;; Preparation for recursive call

		 
		 	(setq DhAllVal (new Vector: Object: DhIndex))		 
			(setq YVec1 (new Vector: Number: DhIndex))
			(setq D (new Vector: Object: (+ DhIndex DrIndex)))
			(setq YVec (new Vector: Number: (+ DhIndex DrIndex)))
			 
			(loop for n from 0 until DhIndex 
				(setq DhVal (new Vector: Number: (+ numCols 1)))
				(setq fitIndex Dh[n]) 
				(loop for m from 0 to  numCols  
					(setq DhVal[m] myHVESRecord[Col: m fitIndex])
				) ;; end loop
			 	(setq  testDhAllVal (new Vector: Number: (+ numCols 1)))
				(setq testDhAllVal DhVal)
				(setq y1 (gsm.myModelLambda testDhAllVal))
				(setq YVec1[n] (setq y1 (+ (* y1 (- 1.0 (* .50 myRandomError))) (* y1 (gsm.myRandomFunction myRandomError)))))
				(setq DhAllVal[n] testDhAllVal)
				(setq D[n] testDhAllVal)
				(setq YVec[n] YVec1[n])
			 ) ;; end loop
	 
			(setq DrAllVal (new Vector: Object: DrIndex))
			(setq YVec2 (new Vector: Number: DrIndex))
			(loop for n from 0 until DrIndex  
				(setq DrVal (new Vector: Number: (+ numCols 1)))
				(setq fitIndex Dr[n])
				(loop for m from 0 to  numCols 
					(setq DrVal[m] myHVESRecord[Col: m fitIndex])
				) ;; end loop
			(setq testDrAllVal (new Vector: Number: (+ numCols 1)))						
			(setq testDrAllVal DrVal)
			(setq y2 (gsm.myModelLambda testDrAllVal))
			(setq YVec2[n] (setq y2 (+ (* y2 (- 1.0 (* .50 myRandomError))) (* y2 (gsm.myRandomFunction myRandomError)))))
			(setq DrAllVal[n] testDrAllVal)
			(setq D[(+ n DhIndex)] testDrAllVal)
			(setq YVec[(+ n DhIndex)] YVec2[n])					
			) ;; end loop

 
			;; Recursive Case
			(++ tagDepth)		 
			(if (= recurseFlag #void) (setq recurseFlag "forDh"))		 
			(if (<> recurseFlag "DhDone") (setq returnPop (scriptHVES DhAllVal YVec1 G S Seed tagDepth)))
		 
			
			(if (= recurseFlag "DhDone") 
				(begin 
				 	(setq len (length returnPop))
					(writeln "DhDone: " len)
					(setq DhPop (new Vector: Object: len))
					;(setq tagDepth 0)
					(loop for p from 0 until len
						(setq DhPop[p] returnPop[p])
					) ;; end loop
				 	(setq recurseFlag "forDr")
				) ;; end begin
			) ;; end if

			(if (= recurseFlag "forDr")
				(begin				 
					(setq returnPop (scriptHVES DrAllVal YVec2 G S Seed tagDepth))					 
					(setq len (length returnPop))
					(setq DrPop (new Vector: Object: len))					
					(loop for p from 0 until len
						(setq DrPop[p] returnPop[p])
					) ;; end loop
					 
			))

 
;			(if (= recurseFlag "DrDone") 
;				(begin 
;						(writeln "recurseFlag before calling DrDone: " recurseFlag)
;					(setq tagDepth 0)
;					(setq returnPop (scriptHVES DrAllVal YVec2 G S Seed tagDepth))
;					(writeln "recurseFlag after calling DrDone: " recurseFlag)
;					(setq len (length returnPop))
;					(setq DrPop (new Vector: Object: len))
;					
;					(loop for p from 0 until len
;						(setq DrPop[p] returnPop[p])
;					) ;; end loop
;					(writeln "DrPop AFTER DrDone: " DrPop)
;				))

	 
			;; MERGING PHASE			
			(setq mergeFlag true)
			(setq mergePop (new Vector: Object: (+ (length startPop) (length DhPop) (length DrPop))))
		
			(loop for n from 0 until (length startPop)
				(setq mergePop[n] startPop[n])			 
			) ;; end loop 
			(loop for n from 0 until (length DhPop)
				(setq mergePop[(+ n (length startPop))] DhPop[n])
			) ;; end loop 
			(loop for n from 0 until (length DrPop)
				(setq mergePop[(+ n (length DrPop))] DrPop[n])
			) ;; end loop 
			(-- tagDepth)
			(setq mergeFlag true)
			(setq myMergedPopulation mergePop)	
			(setq D (scriptHVES D YVec G S Seed ))

)
 
























;;**EXPORTKEY**:gsm.scriptMVLALPS
(defriend gsm:scriptMVLALPS(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy together with age layered populations. A Tree based genome is used wherein the 
;;          head of each list is a grammar rule. Standard tree based genetic programming operators 
;;          are used for mutation and crossover. New populations are instantiated on epoch boundaries
;;          and are allowed to grow and compete independently.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0) (newEvolutionStarted false))
  	vars:(result Lambda bagLambda wff newWff wffString wffSource wffVector rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore Number:startTickCount Number:endTickCount)

    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;; Initialize mandatory option settings
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (setq myRegressorSaveSW true)     ;; During fitness competition always allow a wff, from any island, to compete in the best regressor fitness island.
    (setq myScoreFocus full:)  	      ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq startTickCount (getTickCount 0.0))
    (setq eGrammar expressionGrammarGso)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptMVLALPS: too few training examples"))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestUncorrelatedIsland (+ 1 myM))
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 2 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-regressor population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])
    (setq wff 1.0)
    (setq genome (new Vector: myM))
    (setq genome[0] wff)
    (ruleReg.growWFF genome)
    (if (<= myBestRegressor.NLSE myS) (goto Last:))

    ;; Initialize the best-regressor population with a linear polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (setq myBestLinear (ruleMvl.growWFF genome))
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a quatratic polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleSquare x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cubic polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleCube x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Try an SVM polynomial WFF, but do not initialize the best-regressor population with an SVM polynomial WFF.
    (if (and (= myGc 0) (= myUseSVM true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (setq wff (list ruleSvm: genome))
          (if (and (isLambda (setq Lambda (createGrammarEstimator wff nosave:))) (<= Lambda.NLSE myS))
              (begin
                (setq myBest (setq myBestRegressor Lambda))
                (goto Last:)
              )) ; end if
        )) ; end if

    ;; Initialize the best-regressor population with a double cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a triple cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul (ruleMul v" m " v" (+ m myM)") v" (+ m (* 2 myM))")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cross rational polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleDiv v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a abstract operator polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleVop " m " v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a abstract operator product polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul (ruleVop " m " v" m " v" (+ m myM)") v" (+ m (* 2 myM))")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a collection of root genomes.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of multivariate root estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for m from 0 until myRootINIT do 
             (ruleMvl.growWFF root:)
             (if (<= myBestRegressor.NLSE myS) (goto Last:))
             ) ; end loop
        )) ; end if

    ;; Initialize the best-regressor population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= myBestRegressor.NLSE myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Do NOT exceed maximum allotted time for this evolutionary process.
       (if (> (setq endTickCount (getTickCount startTickCount)) myEvolutionMaxTickCount) (goto Last:))

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))

       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (setq myBest (bestRegressor))
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Make sure we have a reasonable candidate or return no candidate at all.
       (if (>= myBest.NLSE BIGPOSNUM) (begin (setq myBest #void) (return myBest)))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------

       ;; Initialize a new aged layered population.
       (if (= (modi myGc myRestartEpoch) 0)
           (begin

               ;; Select a new vertical training slice at random.
               (initSamplingData)

	           ;; --------------------------------------------------------------------------------------------
	           ;; Insert abstract conditional WFFs as concrete splicings of uncorrelated regression champions.
	           ;; --------------------------------------------------------------------------------------------
               (if (and (> myGc myGetSeriousGens) (>= myBest.NLSE myGetSeriousErr))
                   then
                   (begin

					   (setq myPopulation myPopulationIslands[myBestRegressorIsland])
		
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		
		               (bestRegressor)
					   (if (<= myBestRegressor.NLSE myS) (goto Last:))
		
                   )); end if 

	           ;; --------------------------------------------------------------------------------------------
	           ;; Renew and age-layered island population ONLY if the island populations are not over crowded.
	           ;; --------------------------------------------------------------------------------------------
               ;; Increment the youngest population counter in round robin fashion.
               (loop for mm from 0 until myM do
                 (cond
                  ;; Unintialized island population.
                  ((<= (length myPopulationIslands[youngestPopulationIsland]) 2) (goto RenewThisIsland:)) 
                  ;; Unproductive island population.
                  ((>= islandGenerationGap[youngestPopulationIsland] myRestartGap) (goto RenewThisIsland:))
                  ;; Increment the youngest population counter in round robin fashion.
                  (else (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))) 
                  ) ; end cond
                 ) ; end island loop
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
               (goto SkipRenewingThisIsland:)

               ;; Clear the youngest population island of all survivors.
	           RenewThisIsland::
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population at [" youngestPopulationIsland "]"))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:)) 	
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
                
               ;; Initialize the best-of-breed population with a collection of root genomes.
               (if (> myRootGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                      (loop for n from 0 until myRootGEN do 
                         (ruleMvl.growWFF root:)
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end loop
                   )) ; end if

               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (> myGrowColGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myGrowColGEN do
                         (ruleMvl.growWFF myGrowWFFStyle)
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end grow Estimators       
                   )) ; end if
        
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
 
	          SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; Apply mutation population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myMutateColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myMutateColPct (number N))))
                (makeMutation myPopulation[0])
                (makeMutation myPopulation[1])
                (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
             )) ; end mutation
  
          ;; Apply crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) myCrossColPct) 
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (setq NN (integer (* myCrossColPct (number N))))
                (makeCrossover myPopulation[0] myPopulation[1])
                (makeCrossover myPopulation[1] myPopulation[0])
                (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
              )) ; end children		

          ;; Apply context aware crossover population operator to create new column island estimators.
          (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
              (begin
                (setq myPopulation myPopulationIslands[mm])
                (setq N (length myPopulation))
                (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
              )) ; end children		

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
          (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE) (setq islandGenerationGap[mm] 0) (++ islandGenerationGap[mm])) 
	      (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Apply mutation population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::
    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (setq myBest (setq myBestEstimator (bestRegressor))) 
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))
    ;; Make sure that we have not exited from this training run prematurely.
    (if (and (> myBest.NLSE myS) (< myGc myG) (< endTickCount myEvolutionMaxTickCount)) (error "gsm.scriptGSPALPS: premature exit from training run"))

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestUncorrelatedIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestUncorrelatedIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest (setq myBestEstimator myBestRegressor))

    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGso.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptMVLALPS: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestRegressor)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq bagLambda (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq bagLambda.Estimators (new Vector:))
          (setq bagLambda.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)

          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (> Lambda.NLSE 10.0) (goto SkipThisChampion:))
              (if (= (listWff Lambda.WFF)[0] ruleSvm:) (goto SkipThisChampion:))
              (setq Lambda.EY (Lambda.run myX))
              (setq N (length bagLambda.Estimators))
              (loop for n from 0 until N do
                 (if (= bagLambda.Estimators[n].EY #void) (setq bagLambda.Estimators[n].EY (bagLambda.Estimators[n].run myX)))
                 (if (> (abs (setq result (math.correlation Lambda.EY bagLambda.Estimators[n].EY))) myCovarianceLimit) (goto SkipThisChampion:))

                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq bagLambda.Estimators[MM] Lambda)
              (setq bagLambda.NLSE (+ bagLambda.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append wffString " " (standAloneEstimatorRules Lambda)))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::

          (if (< (setq NN (length bagLambda.Estimators)) 2)
              then
              (setq myBest (setq myBestEstimator myBestRegressor))
              else
              (begin 
			    (setq myPopulation myPopulationIslands[myBestRegressorIsland])

                (setq wffString "(ruleMvl #(")
                (setq M (min myM (length bagLambda.Estimators)))
			    (loop for m from 0 until M do 
                  (setq wffString (append wffString " " (standAloneEstimatorRules bagLambda.Estimators[m])))
                  ) ; end loop
                (setq wffString (append wffString " ))"))
                (setq Lambda (createGrammarEstimator wffString))
                (bestRegressor)
			    (if (<= myBestRegressor.NLSE myS) (goto Last:))
			
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))

              )) ; end if

       ;; Delete any SVM champions with NLSE scores greater than myBaggingPct.
       ;; Note: Emperically we have found that SVM champions with a very poor NLSE have seriously over fitted.
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop

       (bestRegressor)

       )); end if 

    ;; Return the best WFF seen so far.
    ;; Note: prepare both the best linear and nonlinear champions (where available). 
    GoodBye::
    (if (and (isLambda myBestLinear) (isVector myBestLinear.Pv.Mvl.myW))
        (begin
          (setq myBestLinearModel (evalRule (concreteWFF gsm.myBestLinear)))
          (setq myBestLinearAxis  myBestLinear.Pv.A)
          (setq myBestLinearCoefficients myBestLinear.Pv.Mvl.myW)
          (scoreTCEandNLSE myBestLinear)
        )) ; end linear goodbye
    (if (isLambda myBest)
        (begin
          (setq myBestModel (getEstimatorChampions)[0])
          (scoreTCEandNLSE myBest)
        )) ; end nonlinear goodbye
    myBest) ; end scriptMVLALPS

































































































































;;**EXPORTKEY**:gsm.scriptMVLALPSRQ
(defriend gsm:scriptMVLALPSRQ(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Genetic and evolutionary programming, with age layered populations, training script.
;; 
;;          This training script uses a grammar template based genetic programming machine learning
;;          strategy together with age layered populations. A Tree based genome is used wherein the 
;;          head of each list is a grammar rule. Standard tree based genetic programming operators 
;;          are used for mutation and crossover. New populations are instantiated on epoch boundaries
;;          and are allowed to grow and compete independently.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    pvars:(IsolatedEvolve)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0) (newEvolutionStarted false))
  	vars:(result Lambda bagLambda wff newWff wffString wffSource wffVector rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore Number:startTickCount Number:endTickCount)
	vars:(fileId trainingData samplingData)
    vars:(jobConfig jobData jobStatus jobLambda jobLambdaLength jobIslands jobsCompleted (jobSleep 30000) jobWaitOn jobId p P)
    vars:(Number:startTime Number:endTime)

	(if myVerboseSW (writeln "scriptMVLALPSRQ"))

    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ;; Initialize mandatory option settings
    ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    (setq myRegressorSaveSW true)     ;; During fitness competition always allow a wff, from any island, to compete in the best regressor fitness island.
    (setq myScoreFocus full:)  	      ;; The focus of scoring on the training data (full, classify, top25, top10, or top05).

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq startTickCount (getTickCount 0.0))
    (setq startTime (now))
    (setq eGrammar expressionGrammarGso)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)
    (if (< myN 150) (error "gsm.scriptMVLALPS: too few training examples"))
    (setq jobId (integer (random 10000)))

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestUncorrelatedIsland (+ 1 myM))
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 2 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest (eval (compile (estimator "regress 0.0;"))))
    (setq myBest.NLSE BIGPOSNUM)      
    (setq myBest.TCE BIGPOSNUM)
    (setq myBest.WFF "0.0")   
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; Initialize the best-regressor population with a constant WFF.
    ;; Note1: This must be done for the case where Y is all the same.
    ;; Note2: WFF = "regress 1.0;"
    (setq myPopulation myPopulationIslands[myBestRegressorIsland])
    (setq wff 1.0)
    (setq genome (new Vector: myM))
    (setq genome[0] wff)
    (ruleReg.growWFF genome)
    (if (<= myBestRegressor.NLSE myS) (goto Last:))

    ;; Initialize the best-regressor population with a linear polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (setq myBestLinear (ruleMvl.growWFF genome))
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a quatratic polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleSquare x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cubic polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleCube x" m ")"))))
          (ruleMvl.growWFF genome)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Try an SVM polynomial WFF, but do not initialize the best-regressor population with an SVM polynomial WFF.
    (if (and (= myGc 0) (= myUseSVM true))
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (append "x" m)))
          (setq wff (list ruleSvm: genome))
          (if (and (isLambda (setq Lambda (createGrammarEstimator wff nosave:))) (<= Lambda.NLSE myS))
              (begin
                (setq myBest (setq myBestRegressor Lambda))
                (goto Last:)
              )) ; end if
        )) ; end if

    ;; Initialize the best-regressor population with a double cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a triple cross correlation polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul (ruleMul v" m " v" (+ m myM)") v" (+ m (* 2 myM))")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a cross rational polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleDiv v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a abstract operator polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleVop " m " v" m " v" (+ m myM)")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a abstract operator product polynomial WFF.
    (if (= myGc 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq genome (new Vector: myM))
          (loop for m from 0 until myM do (setq genome[m] (parse (append "(ruleMul (ruleVop " m " v" m " v" (+ m myM)") v" (+ m (* 2 myM))")"))))
		  (createGrammarEstimator (list ruleReg: genome) concrete:)
          (if (<= myBestRegressor.NLSE myS) (goto Last:))
        )) ; end if

    ;; Initialize the best-regressor population with a collection of root genomes.
    (if (> myRootINIT 0)
        (begin
           (if myVerboseSW (writeln "...starting generation of multivariate root estimator WFFs."))
           (setq myPopulation myPopulationIslands[myBestRegressorIsland])
           (loop for m from 0 until myRootINIT do 
             (ruleMvl.growWFF root:)
             (if (<= myBestRegressor.NLSE myS) (goto Last:))
             ) ; end loop
        )) ; end if

    ;; Initialize the best-regressor population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= myBestRegressor.NLSE myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if

    ;; Save the training data in the job queue
    ;; Location: $JobQueue/jobId.training.data
    (setq trainingData (new Structure:
        X: myX
        Y: myY))
    (setq fileId (fileOpen (append runQueue.jobQueuePathName "/" jobId ".training.data") 1 0))
    (saveObject fileId trainingData true)
    (setq fileId (fileClose fileId 1))
    (setq trainingData #void)

    ;; ************************************************************************
    ;; Run the main evolutionary process for the maximum number of generations.
    ;; ************************************************************************
    StartMainGenerations:: 	
    (if (<= myBest.NLSE myS) (goto Last:))
    (loop for myGc from myGc until myG do

       ;; Do NOT exceed maximum allotted time for this evolutionary process.
       (if (> (setq endTickCount (getTickCount startTickCount)) myEvolutionMaxTickCount) (goto Last:))

       ;; Re-initialize the pseudo random number generator Lambda.
       (setRandomSeed (* 1000000.0 (fraction (log (+ (+ myGc (pi)) mySeed)))))

       ;; ------------------------------------------------------------------
       ;; Quit if the best available estimator has reached the halting score.
       ;; ------------------------------------------------------------------
       (setq myBest (bestRegressor))
       (if (<= myBest.NLSE myS) (goto Last:))

       ;; Make sure we have a reasonable candidate or return no candidate at all.
       (if (>= myBest.NLSE BIGPOSNUM) (begin (setq myBest #void) (return myBest)))

       ;; --------------------------------------------------------------------------
       ;; Initialize the youngest island estimator WFF population.
       ;; Note: Once each epoch, we create a new age layered population island.
       ;;       the youngest island rotates so that each island is allowed to
       ;;       mature before for many epochs before its survivors are destroyed
       ;;       to make room for a new breed of youngsters.
       ;; --------------------------------------------------------------------------

       ;; Initialize a new aged layered population.
       (if (= (modi myGc myRestartEpoch) 0)
           (begin

               ;; Select a new vertical training slice at random.
               (initSamplingData)

               ;; Save the training data in the job queue
               ;; Location: $JobQueue/jobId.sampling.data
               (setq samplingData (new Structure:
                   Xtrain: myXtrain
                   Ytrain: myYtrain))
               (setq fileId (fileOpen (append runQueue.jobQueuePathName "/" jobId ".sampling.data") 1 0))
               (saveObject fileId samplingData true)
               (setq fileId (fileClose fileId 1))
               (setq samplingData #void)

	           ;; --------------------------------------------------------------------------------------------
	           ;; Insert abstract conditional WFFs as concrete splicings of uncorrelated regression champions.
	           ;; --------------------------------------------------------------------------------------------
               (if (and (> myGc myGetSeriousGens) (>= myBest.NLSE myGetSeriousErr))
                   then
                   (begin

					   (setq myPopulation myPopulationIslands[myBestRegressorIsland])
		
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		               (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules myPopulationIslands[myBestRegressorIsland][0]) " " (standAloneEstimatorRules myPopulationIslands[myBestUncorrelatedIsland][0]) ")))"))
		               (createGrammarEstimator wffString concrete:)
		
		               (bestRegressor)
					   (if (<= myBestRegressor.NLSE myS) (goto Last:))
		
                   )); end if 

	           ;; --------------------------------------------------------------------------------------------
	           ;; Renew and age-layered island population ONLY if the island populations are not over crowded.
	           ;; --------------------------------------------------------------------------------------------
               ;; Increment the youngest population counter in round robin fashion.
               (loop for mm from 0 until myM do
                 (cond
                  ;; Unintialized island population.
                  ((<= (length myPopulationIslands[youngestPopulationIsland]) 2) (goto RenewThisIsland:)) 
                  ;; Unproductive island population.
                  ((>= islandGenerationGap[youngestPopulationIsland] myRestartGap) (goto RenewThisIsland:))
                  ;; Increment the youngest population counter in round robin fashion.
                  (else (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))) 
                  ) ; end cond
                 ) ; end island loop
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
               (goto SkipRenewingThisIsland:)

               ;; Clear the youngest population island of all survivors.
	           RenewThisIsland::
               (if myVerboseSW (writeln "...starting initialization of a new age layered WFF estimator population at [" youngestPopulationIsland "]"))
               (setq myPopulationIslands[youngestPopulationIsland] (new Vector: Object:))
    		   (setq islandGenerationGap[youngestPopulationIsland] 0)
    		   (setq islandOldBestScore[youngestPopulationIsland] BIGPOSNUM) 
                
               ;; Initialize the best-of-breed population with a collection of root genomes.
               (if (> myRootGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[myBestRegressorIsland])
                      (loop for n from 0 until myRootGEN do 
                         (ruleMvl.growWFF root:)
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end loop
                   )) ; end if

               ;; Grow new estimators from random WFF terms.
               ;; Note: This must be done for each distinct island population.
               (if (> myGrowColGEN 0)
                   (begin
                      (setq myPopulation myPopulationIslands[youngestPopulationIsland])
                      (loop for n from 0 until myGrowColGEN do
                         (ruleMvl.growWFF myGrowWFFStyle)
                         (if (<= myBestRegressor.NLSE myS) (goto Last:))
                         ) ; end grow Estimators
                   )) ; end if
        
               ;; Increment the youngest population counter in round robin fashion.
               (if (>= (++ youngestPopulationIsland) myM) (setq youngestPopulationIsland 0))                 
 
	          SkipRenewingThisIsland::
              )) ; end new epoch if 

       ;; --------------------------------------------------------------------------
       ;; Evolve each island estimator WFF population.
       ;; Note: Attempt to perform the population operators for each Estimator WFF in
       ;;       the survivor population.
       ;; Note: The percent control, for each population operator, determines the
       ;;       frequency with which the operation is performed.  
       ;; --------------------------------------------------------------------------

       ;; Display current progress (if we are in verbose mode).
       (if (and myVerboseSW (= (modi myGc VerboseSample) 0)) (writeln "Starting generation [" myGc " of " myG "],WFFs=[" (length myWFFs) "],NLSE=[" myBest.NLSE "],length(BestWFF)=[" (length myBest.WFF) "],BestWFF= " (left (evalRule myBest.WFF) 100) "..."))
     
       ;; Keep track of the islands in the JobQueue
       (setq jobIslands (new Vector: myM))

       ;; Grow create new estimator WFFs from generation of basic root WFFs.
       ;; Note: This must be done in each column island.
       (loop for mm from 0 until myM do

	      ;; -----------------------------------------------------------------------------------------
	      ;; Stop island evolutionary process if too many generations have passed without improvement.
	      ;; -----------------------------------------------------------------------------------------
	      (if (or (>= islandGenerationGap[mm] myRestartGap) (<= (length myPopulationIslands[mm]) 2)) (goto StopEvolvingThisIsland:))

          ;; ****************************************************************************************
          ;; Frank's Experiment
          ;; ****************************************************************************************

          ;; This is where we will assign each population to a RunQueue job
          ;; First, we need to find a way to save the island state (then restore it later in the subscriber)
          ;; 1. We could use the WFF member of the Lambda which is a String,
          ;; - Compile it in the Subsciber before running the evolution steps
          ;; 2. We could save the Lambda (ByteVector) and restore it later

          ;;(setq fileID (fileOpen (append "myPopulationIslands_" mm "_" myGc ".dat") 1 4))
          ;;(writeln (saveObject fileID myPopulationIslands[mm]))
          ;;(setq fileID (fileClose fileID 1))
          ;;(setq myPopulationIslands[mm] #void)
          ;;(gc compact:)
          ;;(setq fileID (fileOpen (append "myPopulationIslands_" mm "_" myGc ".dat") 0 4))
          ;;(setq myPopulationIslands[mm] (loadObject fileID))
          ;;(setq fileID (fileClose fileID 1))

          (setq jobConfig (new Structure:
              JobName: "scriptMVLALPSRQ"
              MajorName: jobId
              MinorName: myGc ; Current Generation
              SeriesName: mm  ; Population Index
              RequiredLibraries: "gsm"))

          (setq jobData (new Structure:
              JobId: jobId
              PopulationId: mm
              TrainingScript: myOptionSetting
              VerboseSW: myVerboseSW
              RandomSeed: mySeed
              TotalGenerations: myG
              CurrentGeneration: myGc
              WFFs: (new Vector:)
              TrainingDataFileName: (append jobId ".training.data")
              SamplingDataFileName: (append jobId ".sampling.data")
              ))

          ;; Save the WFF's
          (setq P (length myPopulationIslands[mm]))
          (loop for p from 0 until P do
              (if (isLambda myPopulationIslands[mm][p].WFF)
                  (setq jobData.WFFs[p] (substitute (string myPopulationIslands[mm][p].WFF.Genome true) "\"" "\\\""))
                  (setq jobData.WFFs[p] (substitute (stringWff myPopulationIslands[mm][p].WFF) "\"" "\\\""))
              ) ; end if
          ) ; end loop

          (setq jobLambda (browseLib.checkout Gsm: "gsm:scriptMVLALPSRQ:%EvolutionLambda"))
          (setq jobLambdaLength (length jobLambda))
          (setq jobLambda (mid jobLambda 7 jobLambdaLength))

          ;;(setq jobData (string jobData true))
          (runQueue.submit jobConfig jobData jobLambda)

          ;; Save the job configuration
          (setq jobIslands[mm] jobConfig)

          ;; processing of the island will be done outside this loop
 
	      StopEvolvingThisIsland::
          ) ; end main island loop      

       ;; Collect the results
       (setq jobsCompleted false)
       (while (not jobsCompleted) do
           (setq jobsCompleted true)

           ;; Check if every island has completed their evolution
           (loop for mm from 0 until myM do
               (if (isStructure jobIslands[mm])
                   (begin
                       (setq jobConfig jobIslands[mm])
                       (setq jobStatus (runQueue.getStatus jobConfig.JobName jobConfig.MajorName jobConfig.MinorName jobConfig.SeriesName))

                       (cond 
                           ((= jobStatus "done")
                               (begin
                                   ;; Get job results
                                   (setq jobResult (runQueue.getResult jobConfig.JobName jobConfig.MajorName jobConfig.MinorName jobConfig.SeriesName))
                                   (setq myPopulation myPopulationIslands[mm])

                                   (if myVerboseSW (writeln "Generation: " jobConfig.MinorName ", Population: " jobConfig.SeriesName " completed in " (/ jobResult.LambdaExecutionTime 60) " minutes."))

                                   ;; Restore the population locally
                                   (setq P (length jobResult.LambdaReturn.NewWFFs))
                                   (loop for p from 0 until P do
                                       (createGrammarEstimator jobResult.LambdaReturn.NewWFFs[p])
                                   ) ; end loop

                                   (setq gsm.myTotalEvaluations (+ gsm.myTotalEvaluations jobResult.LambdaReturn.TotalEvaluations))
                                   (setq gsm.myTotalRegressions (+ gsm.myTotalRegressions jobResult.LambdaReturn.TotalRegressions))
                                   (setq gsm.myTotalParseTime (+ gsm.myTotalParseTime jobResult.LambdaReturn.TotalParseTime))
                                   (setq gsm.myTotalCompileTime (+ gsm.myTotalCompileTime jobResult.LambdaReturn.TotalCompileTime))

                                   ;; Stop island evolutionary process if too many generations have passed without improvement.
                                   (if (> islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)
                                       (setq islandGenerationGap[mm] 0) ; true
                                       (++ islandGenerationGap[mm]) ; false
                                   ) ; end if
	                               (setq islandOldBestScore[mm] myPopulationIslands[mm][0].NLSE)

                                   ;; Remove the job from the queue
                                   ;;(runQueue.remove jobConfig.JobName jobConfig.MajorName jobConfig.MinorName jobConfig.SeriesName)

                                   ;; Remove from current jobs
                                   (setq jobIslands[mm] #void)
                               ) ; end begin
                           ) ; end case "done"

                           ((= jobStatus "errored")
                               (begin
                               ;; Stop the evolution
                               ;; Note: what if the worker crashes? How will others know?
                               (error "One of the island evolutions failed")
                               )
                           ) ; end case "errored"

                           ((= jobStatus "ready")
                               (begin
                               (setq jobsCompleted false)
                               )
                           ) ; end case "ready"

                           ((= jobStatus "running")
                               (begin
                               (setq jobsCompleted false)
                               )
                           ) ; end case "running"
                       ) ; end cond
                   ) ; end begin
               ) ; end if
           ) ; end loop

           ; The supplier can also run a few jobs
           (if (not jobsCompleted)
               (begin
                   ; Execute some jobs in the queue
                   (runQueue.run true)
                   ; Wait for a few seconds
                   (if myVerboseSW (writeln "Waiting for completed jobs..."))
                   (sleep jobSleep)
               )
           ) ; end if
       ) ; end while

       ;; Apply mutation population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myMutateRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myMutateRegPct (number N))))
             (makeMutation myPopulation[0])
             (makeMutation myPopulation[1])
             (loop for nn from 0 until NN do (makeMutation myPopulation[(integer (gsm.myRandomFunction N))]))
          )) ; end mutation

       ;; Apply crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) myCrossRegPct) 
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (setq NN (integer (* myCrossRegPct (number N))))
             (makeCrossover myPopulation[0] myPopulation[1])
             (makeCrossover myPopulation[1] myPopulation[0])
             (loop for nn from 0 until NN do (makeCrossover myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))]))
           )) ; end children
   
       ;; Apply context aware crossover population operator to create new best-regressors.
       (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ myGc myG)) myContextRegPct))
           (begin
             (setq myPopulation myPopulationIslands[myBestRegressorIsland])
             (setq N (length myPopulation))
             (makeCrossoverAware myPopulation[(integer (gsm.myRandomFunction N))] myPopulation[(integer (gsm.myRandomFunction N))])
           )) ; end children		
   
       RetryMainGenerations::

      ) ; end main generation loop

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::
    (setq endTime (now))
    (if myVerboseSW (writeln "Start time: " (date startTime) ", End time: " (date endTime)))
    ;; Make sure we have a reasonable candidate or return no candidate at all.
    (setq myBest (setq myBestEstimator (bestRegressor))) 
    (if (>= myBest.NLSE myAcceptMaxErr) (begin (setq myBest #void) (return myBest)))
    ;; Make sure that we have not exited from this training run prematurely.
    (if (and (> myBest.NLSE myS) (< myGc myG) (< endTickCount myEvolutionMaxTickCount)) (error "gsm.scriptGSPALPS: premature exit from training run"))

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    ;; Add all regressors from the current best-regressor island.
    (setq MM (length myPopulationIslands[myBestUncorrelatedIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestUncorrelatedIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest (setq myBestEstimator myBestRegressor))

    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGso.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptMVLALPS: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels myBaggingCnt)
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestRegressor)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq bagLambda (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq bagLambda.Estimators (new Vector:))
          (setq bagLambda.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)

          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (> Lambda.NLSE 10.0) (goto SkipThisChampion:))
              (if (= (listWff Lambda.WFF)[0] ruleSvm:) (goto SkipThisChampion:))
              (setq Lambda.EY (Lambda.run myX))
              (setq N (length bagLambda.Estimators))
              (loop for n from 0 until N do
                 (if (= bagLambda.Estimators[n].EY #void) (setq bagLambda.Estimators[n].EY (bagLambda.Estimators[n].run myX)))
                 (if (> (abs (setq result (math.correlation Lambda.EY bagLambda.Estimators[n].EY))) myCovarianceLimit) (goto SkipThisChampion:))

                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq bagLambda.Estimators[MM] Lambda)
              (setq bagLambda.NLSE (+ bagLambda.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append wffString " " (standAloneEstimatorRules Lambda)))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::

          (if (< (setq NN (length bagLambda.Estimators)) 2)
              then
              (setq myBest (setq myBestEstimator myBestRegressor))
              else
              (begin 
			    (setq myPopulation myPopulationIslands[myBestRegressorIsland])

                (setq wffString "(ruleMvl #(")
                (setq M (min myM (length bagLambda.Estimators)))
			    (loop for m from 0 until M do 
                  (setq wffString (append wffString " " (standAloneEstimatorRules bagLambda.Estimators[m])))
                  ) ; end loop
                (setq wffString (append wffString " ))"))
                (setq Lambda (createGrammarEstimator wffString))
                (bestRegressor)
			    (if (<= myBestRegressor.NLSE myS) (goto Last:))
			
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= v0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v0 <= v1 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= c0 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= v2 " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf c0 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf v2 <= (ruleVop 0 v0 v1) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))
                (setq wffString (append "(ruleMdl #((ruleIf (ruleVop 0 v0 v1) <= (ruleVop 1 v2 v3) " (standAloneEstimatorRules bagLambda.Estimators[0]) " " (standAloneEstimatorRules bagLambda.Estimators[1]) ")))"))
                (setq Lambda (createGrammarEstimator wffString))

              )) ; end if

       ;; Delete any SVM champions with NLSE scores greater than myBaggingPct.
       ;; Note: Emperically we have found that SVM champions with a very poor NLSE have seriously over fitted.
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop
       (setq NN (length (setq myPopulation myPopulationIslands[myBestRegressorIsland])))
       (loop for nn from (- NN 1) to 0 by -1 do 
         (if (and (= (listWff myPopulation[nn].WFF)[0] ruleSvm:) (>= myPopulation[nn].NLSE myBaggingPct)) (delete myPopulation nn))
         ) ; end NN loop

       (bestRegressor)

       )); end if 

    ;; Return the best WFF seen so far.
    ;; Note: prepare both the best linear and nonlinear champions (where available). 
    GoodBye::
    (if (and (isLambda myBestLinear) (isVector myBestLinear.Pv.Mvl.myW))
        (begin
          (setq myBestLinearModel (evalRule (concreteWFF gsm.myBestLinear)))
          (setq myBestLinearAxis  myBestLinear.Pv.A)
          (setq myBestLinearCoefficients myBestLinear.Pv.Mvl.myW)
          (scoreTCEandNLSE myBestLinear)
        )) ; end linear goodbye
    (if (isLambda myBest)
        (begin
          (setq myBestModel (getEstimatorChampions)[0])
          (scoreTCEandNLSE myBest)
        )) ; end nonlinear goodbye
    myBest) ; end scriptMVLALPSRQ

;;**EXPORTKEY**:gsm.scriptMVLALPSRQ.%EvolutionLambda
;#text#
(lambda(theData)
;; ******************************************************************************
;; summary:  This unnamed lambda perfoms 1 generation of evolution on 1 island
;;           population.
;;
;; Args:     theData       The Structure with the evolution parameters
;;                          JobId                 Unique job identifier (unique for 1 gsm run)
;;           				PopulationId          Population identifier or index
;;                          TrainingScript        Training script
;;                          VerboseSW             Verbose switch
;;                          RandomSeed            Random seed value
;;                          WFFs                  Vector of WFF strings
;;                          TotalGenerations      Total no. of generations
;;                          CurrentGeneration     Current generation
;;           				TrainingDataFileName  Filename of full training data in jobqueue
;;          				SamplingDataFileName  Filename of sample training data in jobqueue
;;
;; Return:   aResults	   A Structure containing the regression results.
;;
;; ******************************************************************************
    vars: (aResults)
    vars: (p P N NN nn)
    vars: (gsmClone rqPopulation) ;; we're doing to isolate the execution
    vars: (myVerboseSW trainingData samplingData fileId)
    vars: (saveXtrain
           saveYtrain
           saveX
           saveY
           saveGc
           saveG
           saveBestRegressorIsland
           saveBestUncorrelatedIsland
           saveTotalEvaluations
           saveTotalRegressions
           saveTotalParseTime
           saveTotalCompileTime)

    (setq myVerboseSW theData.VerboseSW)
    ;;(setq myVerboseSW false)
    (gsm.setOptions theData.TrainingScript 0% myVerboseSW)

    (if myVerboseSW (writeln "Job: " theData.JobId ", Population: " theData.PopulationId ", Generation: " theData.CurrentGeneration))

    ;; Load full training Data
    (setq fileId (fileOpen (append runQueue.jobQueuePathName "/" theData.TrainingDataFileName) 0 0))
    (setq trainingData (loadObject fileId))
    (setq fileId (fileClose fileId 1))

    ;; Load sampling data
    (setq fileId (fileOpen (append runQueue.jobQueuePathName "/" theData.SamplingDataFileName) 0 0))
    (setq samplingData (loadObject fileId))
    (setq fileId (fileClose fileId 1))

    (if myVerboseSW (writeln "Saving gsm variables"))

    ;; Save important GSM variables
    (setq saveXtrain gsm.myXtrain)
    (setq saveYtrain gsm.myYtrain)
    (setq saveX gsm.myX)
    (setq saveY gsm.myY)
    (setq saveGc gsm.myGc)
    (setq saveG gsm.myG)
    (setq saveBestRegressorIsland gsm.myBestRegressorIsland)
    (setq saveBestUncorrelatedIsland gsm.myBestUncorrelatedIsland)
    (setq saveTotalEvaluations gsm.myTotalEvaluations)
    (setq saveTotalRegressions gsm.myTotalRegressions)
    (setq saveTotalParseTime gsm.myTotalParseTime)
    (setq saveTotalCompileTime gsm.myTotalCompileTime)

    (if myVerboseSW (writeln "Restoring sampling data"))

    (setq gsm.myXtrain samplingData.Xtrain)
    (setq gsm.myYtrain samplingData.Ytrain)

    (if myVerboseSW (writeln "Restoring training data"))
    
    (setq gsm.myX trainingData.X)
    (setq gsm.myY trainingData.Y)

    (if myVerboseSW (writeln "Setting global variables"))

    ;; Set GSM global variables
    (gsm.setRandomSeed theData.RandomSeed)
    (setq gsm.myG theData.TotalGenerations)
    (setq gsm.myGc theData.CurrentGeneration)

    ;; Make sure we don't attempt to modify the best regressor and uncorrelated island
    (setq gsm.myBestRegressorIsland #void)
    (setq gsm.myBestUncorrelatedIsland #void)

    ;; Reset gsm counters
    (setq gsm.myTotalEvaluations 0)
    (setq gsm.myTotalRegressions 0)
    (setq gsm.myTotalParseTime 0)
    (setq gsm.myTotalCompileTime 0)

    (if myVerboseSW (writeln "Creating an empty island population"))

    ;; We create an empty population
    (setq gsm.myPopulation (new Vector: Object:))
    (setq rqPopulation gsm.myPopulation)

    (if myVerboseSW (writeln "Reconstructing the island from stored WFFs"))

    ;; Reconstruct island population
    (setq P (length theData.WFFs))
    (loop for p from 0 until P do
        ;;(if myVerboseSW (writeln "theData.WFFs[" p "] = " theData.WFFs[p]))
        (gsm.createGrammarEstimator theData.WFFs[p])) ; end of loop

    ;; Apply mutation population operator to create new column island estimators.
    (if (<= (gsm.myRandomFunction 1.0) gsm.myMutateColPct) 
        (begin
            ;;(if myVerboseSW (writeln "Applying mutation"))
            (setq N (length rqPopulation))
            (setq NN (integer (* gsm.myMutateColPct (number N))))
            (gsm.makeMutation rqPopulation[0])
            (gsm.makeMutation rqPopulation[1])
            (loop for nn from 0 until NN do (gsm.makeMutation rqPopulation[(integer (gsm.myRandomFunction N))]))
        )) ; end mutation

    ;; Apply crossover population operator to create new column island estimators.
    (if (<= (gsm.myRandomFunction 1.0) gsm.myCrossColPct) 
        (begin
            ;;(if myVerboseSW (writeln "Applying crossover"))
            (setq N (length rqPopulation))
            (setq NN (integer (* gsm.myCrossColPct (number N))))
            (gsm.makeCrossover rqPopulation[0] rqPopulation[1])
            (gsm.makeCrossover rqPopulation[1] rqPopulation[0])
            (loop for nn from 0 until NN do (gsm.makeCrossover rqPopulation[(integer (gsm.myRandomFunction N))] rqPopulation[(integer (gsm.myRandomFunction N))]))
        )) ; end children		
		
    ;; Apply context aware crossover population operator to create new column island estimators.
    (if (<= (gsm.myRandomFunction 1.0) (* (+ 1.0 (/ gsm.myGc gsm.myG)) gsm.myContextRegPct))
        (begin
            ;;(if myVerboseSW (writeln "Applying context-aware crossover"))
            (setq N (length rqPopulation))
            (gsm.makeCrossoverAware rqPopulation[(integer (gsm.myRandomFunction N))] rqPopulation[(integer (gsm.myRandomFunction N))])
        )) ; end children

    (if myVerboseSW (writeln "Saving the updated island population"))

    (setq aResults (new Structure:
        WFFs: theData.WFFs
        NewWFFs: (new Vector:)
        TotalEvaluations: gsm.myTotalEvaluations
        TotalRegressions: gsm.myTotalRegressions
        TotalParseTime: gsm.myTotalParseTime
        TotalCompileTime: gsm.myTotalCompileTime
        )) ; aResults

    ;; Save the updated population in the results
    (setq P (length rqPopulation))
    (loop for p from 0 until P do
        (if (isLambda rqPopulation[p].WFF)
            (setq aResults.NewWFFs[p] (substitute (string rqPopulation[p].WFF.Genome true) "\"" "\\\""))
            (setq aResults.NewWFFs[p] (substitute (gsm.stringWff rqPopulation[p].WFF) "\"" "\\\""))
        ) ; end of if
        ;;(if myVerboseSW (writeln "aResults.NewWFFs[" p "] = " aResults.NewWFFs[p]))
    ) ; end of loop

    (if myVerboseSW (writeln "Restoring gsm variables"))

    (setq gsm.myXtrain saveXtrain)
    (setq gsm.myYtrain saveYtrain)
    (setq gsm.myX saveX)
    (setq gsm.myY saveY)
    (setq gsm.myGc saveGc)
    (setq gsm.myG saveG)
    (setq gsm.myBestRegressorIsland saveBestRegressorIsland)
    (setq gsm.myBestUncorrelatedIsland saveBestUncorrelatedIsland)
    (setq gsm.myTotalEvaluations saveTotalEvaluations)
    (setq gsm.myTotalRegressions saveTotalRegressions)
    (setq gsm.myTotalParseTime saveTotalParseTime)
    (setq gsm.myTotalCompileTime saveTotalCompileTime)

    ;; return the evolution results herein.
    aResults) ; end evolution lambda
; end of file
;;**EXPORTKEY**:gsm.scriptSWARM
(defriend gsm:scriptSWARM(ObjVector:X NumVector:Y Integer:G Number:S Number:seed)
;; ************************************************************************************************
;;
;; summary: Grammar swarm optimizer training script.
;; 
;;          This training script uses a grammar template swarm machine learning strategy which can
;;          be implemented using either Differential Evolution or Particle Swarm.
;;
;; Args:    X:         - The N by M vector array representing the training data in the form of:
;;                                         x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;          Y   	   - The N Vector of score variables for each training example.
;;          G   	   - The maximum number of evolutionary generations to run.
;;          S          - The halting "score" which, if achieved, will halt the training run (as a percent of all elements 0% thru 100%).
;;          seed       - (Optional-Number)User specified seed number for the pseudo random number generator (each seed starts a different but completely deterministic training run).
;;
;; Return:  Rf:        - A new estimator Lambda in the form of: 
;;                                         Rf(Xt) ==> Ey {Xt}
;;                       where (before invoking Rf) Xt is the N by M vector array representing the testing data in the form of:
;;                       in the form of:   x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;                       and (after invoking Rf) Xt is the N by B vector array representing the "best" B vector elements
;;                       selected from the testing data by Rf
;;                       and where Ey is the B vector (returned from the Rf invocation) representing the estimated scores for the selected B elements.
;;
;;
;; ************************************************************************************************
  	;; *******************************************************************************
  	;; Start the training process 
  	;; *******************************************************************************
  	regs:(m M n N mm MM nn NN maxIslands)
  	regs:(k1 I1 K1 k2 I2 K2 k3 I3 K3 greedyCounter)
    vars:((Integer:migrationIsland -1) (Integer:VerboseSample 1) (Integer:maxModels 10))
    vars:((Integer:youngestPopulationIsland 0))
  	vars:(result Lambda wff newWff wffString rule)
  	vars:(bestIslands greedyRuleCnt genome migPopulation oldMyWFFs)
  	vars:(Integer:generationGap Number:oldBestScore)
  	vars:(Integer:islandGenerationGap Number:islandOldBestScore)

    ;; ----------------------------
    ;; Initialize persistent memory
    ;; ----------------------------
    (setq eGrammar expressionGrammarGso)
    (setq mySeed seed)
	(setq myG G)
    (setq myGc 0)
	(setq myX X)
	(setq myY Y)
	(setq myM (length X[0]))
	(setq myN (length Y))
	(setq myS S)

    ;; Initialize training data and subdivide into time periods (if requested)
    (setRandomSeed mySeed)
    (setq myMaxRootWFFs (eGrammar.growRootWFF -1))
    (setq myBestRegressorIsland myM)
    (setq myBestRegressorChampions (new Directory:))
    (setq myBestEstimatorChampions (new Directory:))
    (setq myBestEstimatorBestOfBest (new Directory:))
  	(setq myWFFs (new Directory:))

    ;; Make sure the input data is reasonable or return no candidate at all.
    (if (<> (initTrainingData) true) (begin (setq myBest #void) (return myBest)))

    ;; Generate default genome containing each column name.
    (setq myColumnGenome (new Vector: myM))
    (setq M myM)
    (loop for m from 0 until M do (setq myColumnGenome[m] (list ruleName: m)))

    ;; ************************************************************************
    ;; Run the initial evolutionary process before the first generation.
    ;; ************************************************************************
    StartNewEvolutionaryProcess::
    
    ;; Initialize all of the island communities once again here.
    ;; Note: Here we allocate one island community per data column,
	(if myVerboseSW (writeln "...starting new evolutionary process."))
    (setq youngestPopulationIsland 0)
    (if (<> myBestRegressor #void) (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor))
    (if (<> myBestEstimator #void) (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator))
    (if (<> myBestEstimator #void) (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator))
    (if (> (length myBestEstimatorBestOfBest) myBestOfBest) (resize myBestEstimatorBestOfBest myBestOfBest))
    (setq myIslands (new Vector: Integer: myM))
    (setq myPopulationIslands (new Vector: Object: (setq maxIslands (+ 1 myM))))
    (loop for n from 0 until maxIslands do (setq myPopulationIslands[n] (new Vector: Object:))) 	
    (setq islandGenerationGap (new Vector: Integer: myM))(loop for m from 0 until myM do (setq islandGenerationGap[m] myRestartGap))
    (setq islandOldBestScore (new Vector: Number: myM))(loop for m from 0 until myM do (setq islandOldBestScore[m] BIGPOSNUM)) 
  	(if (= myWFFReinitSW true) (setq myWFFs (new Directory:)))

    ;; Generate default estimator Lambda.
    (setq myBest #void)
    (setq myBestRegressor myBest) 
    (setq myBestEstimator myBestRegressor) 

    ;; The maximum number of training generations in any one swarm training.
    (setq mySWMMaxGen G)
    (setq mySvmMaxGen G)

    ;; Initialize the best-of-breed population with the user defined grammar WFFs.
    (if (> (length myUserGrammarWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserGrammarWFFs))
          (loop for n from 0 until N do 
            (createGrammarEstimator myUserGrammarWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if

    ;; Initialize the best-of-breed population with the user defined JavaScript WFFs.
    (if (> (length myUserJavaScriptWFFs) 0)
        (begin
          (setq myPopulation myPopulationIslands[myBestRegressorIsland])
          (setq N (length myUserJavaScriptWFFs))
          (loop for n from 0 until N do 
            (createJavaScriptEstimator myUserJavaScriptWFFs[n])
            (if (<= (bestRegressor)[NLSE:] myS) (goto Last:))
            ) ; end user grammar WFFs loop
        )) ; end if
    (setq myGc (setq myG G))

    ;; ------------------------------------------------------------------
    ;; Return the best estimator Lambda available.
    ;; ------------------------------------------------------------------
    Last::

    ;; Locate the best estimator and the best regressor from this training run. 
    (if myVerboseSW (writeln "...locating the best estimator and the best regressor from this training run."))
    (bestRegressor)

    (setq myBestRegressorChampions[myBestRegressor.NLSE] myBestRegressor)
    (setq myBestEstimatorChampions[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimatorBestOfBest[myBestEstimator.NLSE] myBestEstimator)
    (setq myBestEstimator myBestEstimatorBestOfBest[0 1])
    (setq myBestRegressor myBestRegressorChampions[0 1])

    ;; ------------------------------------------------------------------
    ;; Complete the pool of best estimator Lambdas.
    ;; Note: Add the current best estimators to any previous champions
    ;; ------------------------------------------------------------------

    ;; Add all estimators from the current best of breed island.
    (setq MM (length myPopulationIslands[myBestRegressorIsland]))
    (loop for mm from 0 until MM do
       (setq Lambda gsm.myPopulationIslands[myBestRegressorIsland][mm])
       (setq myBestEstimatorChampions[Lambda.NLSE] Lambda)
       ) ; end add champions loop

    (setq myBest myBestEstimator)
    ;; ------------------------------------------------------------------
    ;; Convert the best WFF seen so far as a concrete formula..
    ;; ------------------------------------------------------------------
    (setq myBest myBestEstimator)
    (if (= myBestAsConcreteWFF true)
        ;; Convert the best Lambda from this training run to concrete format. 
        (begin
          (setq Lambda myBest)
          (if (isString Lambda.WFF) (begin (setq Lambda.Genome #void) (setq Lambda.WFF (listWff Lambda.WFF))))       
          (if (and (not (isVector Lambda.Genome)) (isVector Lambda.WFF[1])) (setq Lambda.Genome (setq genome Lambda.WFF[1])))
          (setq genome Lambda.Genome)
          (setq genome (gsm.expressionGrammarGso.concreteWFF Lambda genome))
          (setq Lambda.WFF[1] genome)
          (setq Lambda.Genome genome)
          (if (and (isNumber (setq n (search "v" (setq wffString (string genome true))))) (isCharNumeric wffString[(+ n 1)])) 
              (error "gsm.scriptSWARM: abstract to concrete conversion error")
              ) ; end if 
       )); end if 

    ;; ------------------------------------------------------------------
    ;; Build the average of the best champion estimators from this training run.
    ;; ------------------------------------------------------------------
    (setq maxModels (min myBaggingCnt (length myBestEstimatorChampions)))
    (if (and (> maxModels 1) (>= myBest.NLSE myBaggingPct)) (goto BuildAnEnsambleModel:))
    (setq maxModels (min myBestAverage (length myBestEstimatorChampions)))
    (if (<= maxModels 1)
        then
        ;; Select the best Lambda from this training run. 
        (setq myBest myBestEstimator)
        else
        ;; Select the average of the best Lambdas from this training run. 
        (begin 
          BuildAnEnsambleModel::
          (setq maxModels (min maxModels (length myBestEstimatorChampions)))
          (setq myBest (eval
                       {(lambda(xv) pvars:((A 0.0) (B 1.0) Estimators NLSE TCE WFF EY Genome run) 
                           (defun run(X)
                              regs:(nn NN)
                              vars:(EY ey)
                              (setq NN (length Estimators))
                              (setq EY (Estimators[0].run X))
                              (loop for nn from 1 until NN do
                                 (setq ey (Estimators[nn].run X))
                                 (setq EY (math.vectorAdd EY ey)) 
                                 )  
                              (math.vectorDivide EY NN)
                              EY)
                           regs:(nn NN)
                           vars:(x) 
                           (setq NN (length Estimators))
                           (setq x (Estimators[0] xv))
                           (loop for nn from 1 until NN do
                              (setq x (+ x (Estimators[nn] xv)))
                              )
                           (setq x (/ x NN))  
                           x)}))
          (setq NN (length myBestEstimatorChampions))
          (setq myBest.Estimators (new Vector:))
          (setq myBest.EY (new Vector: Object:))
          (setq wffString "")
          (setq MM 0)
          
          ;; Prune all "correlated" estimators from the current best of breed island.
          (loop for nn from 0 until NN do   
              (setq Lambda myBestEstimatorChampions[nn 1])
              (if (= Lambda.EY #void) (setq Lambda.EY (Lambda.run myX)))
              (setq N (length myBest.Estimators))
              (loop for n from 0 until N do
                 (if (> (abs (setq result (math.correlation Lambda.EY myBest.Estimators[n].EY))) .90) (goto SkipThisChampion:))
                 ) ; end anti-correlation loop

              AddThisChampion::
              (setq myBest.Estimators[MM] Lambda)
              (setq myBest.NLSE (+ myBest.NLSE Lambda.NLSE))
              (if (= wffString "")
                  (setq wffString (standAloneEstimatorRules Lambda))
                  (setq wffString (append "(ruleAdd " wffString " " (standAloneEstimatorRules Lambda) ")"))
                  ) ; end if
              (++ MM)
              (if (>= MM maxModels) (goto FinishedEnsambleModel:))
              SkipThisChampion::
              ) ; end loop
          FinishedEnsambleModel::
          (setq wffString (append "(ruleReg #((ruleDiv " wffString " " MM ")))"))
          (setq myBest.WFF (listWff wffString))
          (scoreNLSE myBest myX myY)
       )); end if 

    ;; Return the best WFF seen so far.
    GoodBye::
    (setq myBestLinearModel #void)
    (setq myBestLinearAxis  #void)
    (setq myBestLinearCoefficients #void)
    (if (isLambda myBest)
        (begin
          (setq myBestModel (getEstimatorChampions)[0])
          (scoreTCEandNLSE myBest)
        )) ; end nonlinear goodbye
    myBest) ; end scriptSWARM

































































































































;;**EXPORTKEY**:gsm.simplify
(deforphan gsm:simplify(inFormula)
;; *******************************************************************
;; summary:  Returns the normalized form of any basic Estimator expression.
;;
;; Args:     inFormula    The basic Estimator expression to be simplified.    
;; Return:   result       The simplified basic Estimator expression.
;;
;; Depends:  browseLib 
;;           math 
;;           rulesLib 
;;
;; *******************************************************************
    vars:(name s i n commands keys)
    pvars:(;; Persistent Variables
           myVariables             ;; The memory for symbolic math variables.
           mathKB                  ;; The knowledgebase of symbolic math rules.
           myExplanation           ;; The explanation of symbolic math rules.
           myInFormulaString       ;; The input Estimator grammar WFF.
           ;; Child Lambdas
           errorHandler            ;; Called with user input from HTML form.
           initialize              ;; Initialize the this Lambda.
           showVariables           ;; Show the variables currently stored in symbolic math.
           ) ;; end of pvars
    ;; *******************
    ;; Define child Lambdas
    ;; *******************
    ;; Manages any unforseen errors which occur.
    (defun errorHandler(errMsg) myInFormulaString)
    ;; Initialize the this Lambda.
    (defun initialize()
        vars:(temp)
        (onError errorHandler)

	    ;;************************************************************************
	    ;;  Create a new copy of the rules Lambda and create the rule database
	    ;;  to be used for this symbolic math demonstration application.
	    ;;************************************************************************
	    (setq myVariables (new Dictionary:))
	    (setq mathKB (new |Gv:rulesLib|))
	    (mathKB.setSinglePass false)
	    (mathKB.setVerbose false)
	    ;; ****************************************************
	    ;; MATH RULE DECLARATIONS
	    ;; ****************************************************
	    ;; Declare user defined function for use in rules
	    (mathKB.assert  $VAR:(lambda(s) (if (and (isSymbol s) (isCharAlphabetic s[0]) (isMember s myVariables)) myVariables[s])))
	    (mathKB.assert  $SYM:(lambda(s) (if (and (isSymbol s) (isCharAlphabetic s[0])) s)))
	    (mathKB.assert  $SET:(lambda(s v) (setq myVariables[s] (list v)) (list v)))
	    (mathKB.assert  $SUB:(lambda(a v b) 
	                           vars:(p) 
	                           (setq p v) 
	                           (if (<> b #void) 
	                               (setq p (append (list p) b))) 
	                           (if (<> a #void) 
	                               (setq p (append a p))) p))
	    (mathKB.assert  $AOP:(lambda(x) vars:((d #{ruleAdd ruleAdd ruleAvg ruleAvg ruleDiv ruleDiv ruleExpt ruleExpt ruleMax ruleMax ruleMin ruleMin ruleMod ruleMod ruleMul ruleMul ruleSign ruleSign ruleSub ruleSub})) (if (isMember x d) d[x])))
	    (mathKB.assert  $EXP:(lambda(x) vars:((op #{ruleAdd + ruleAvg avg ruleDiv / ruleExpt expt ruleMax max ruleMin min ruleMod mod ruleMul * ruleSign sign ruleSub -})
	                                          (fn #{ruleAbs abs ruleCos cos eGrammar exp ruleInt integer ruleLog log ruleSin sin ruleSqrt sqrt ruleTan tan ruleTanh tanh}))
	                                   (if (or (isPair x) 
	                                           (isNumber x)
	                                           (and (isSymbol x)
	                                                (not (isMember x op))
	                                                (not (isMember x fn))
	                                                (isCharAlphabetic x)))
	                                            x)))
	    (mathKB.assert  $PFN:(lambda(a x fn1 y fn2 z b) 
	                             vars:(p) 
	                             (setq p (list (list x fn1 y) fn2 z)) 
	                             (if (<> b #void) 
	                                 (setq p (append (list p) b))) 
	                             (if (<> a #void) 
	                                 (setq p (append a p))) p))
	    (mathKB.assert  $NAME:(lambda(n) (gsm.eGrammar.ruleName n)))
	    (mathKB.assert  $FOLD:(lambda(op x y) vars:(f) (setq f (getGlobalValue (symbol op))) (f x y)))
	    (mathKB.assert  $IFFOLD:(lambda(x op y a b) vars:(f) (setq f (getGlobalValue (symbol op))) (if (f x y) a b)))
	    (mathKB.assert  $UFOLD:(lambda(fn x) vars:(f) (setq f (getGlobalValue (symbol (downcase (string fn))))) (f x)))
	    (mathKB.assert  $NUM:(lambda(x) (if (isNumber x) x)))
	    (mathKB.assert  $NUMPOS:(lambda(x) (if (isPositive x) x)))
	    (mathKB.assert  $NUMNEG:(lambda(x) (if (isNegative x) x)))
	    (mathKB.assert  $OP:(lambda(x) vars:((d #{ruleAdd + ruleAvg avg ruleDiv / ruleExpt expt ruleMax max ruleMin min ruleMod mod ruleMul * ruleSign sign ruleSub -})) (if (isMember x d) d[x])))
	    (mathKB.assert  $UNARY:(lambda(x) vars:((d #{ruleAbs abs ruleCos cos eGrammar exp ruleInt integer ruleLog log ruleSin sin ruleSqrt sqrt ruleTan tan ruleTanh tanh})) (if (isMember x d) d[x])))
	    (mathKB.assert  $TERM:(lambda(x) vars:((d #{ruleAbs abs ruleCos cos eGrammar exp ruleInt integer ruleLog log ruleSin sin ruleSqrt sqrt ruleTan tan ruleTanh tanh}))
	                                 (if (or (isPair x) 
	                                         (and (isSymbol x)
	                                              (not (isMember x d))
	                                              (isCharAlphabetic x)))
	                                          x)))
	    (mathKB.assert  $FACT:(lambda(a x op y b) 
	                             vars:(p) 
	                             (setq p (list x op y)) 
	                             (if (<> b #void) 
	                                 (setq p (append (list p) b))) 
	                             (if (<> a #void) 
	                                 (setq p (append a p))) p))
	    ;; Constant folding rules
	    (mathKB.assert  '(<$F=$OP> <$X=$NUM> <$Z=$NUM>) '(<$FOLD> $F $X $Z))
	    (mathKB.assert  '(<$F=$BINARY> <$X=$NUM> <$Z=$NUM>) '(<$FOLD> $F $X $Z))
	    (mathKB.assert  '(<$F=$UNARY> <$X=$NUM>) '(<$UFOLD> $F $X))
	    (mathKB.assert  '(ruleName $N) '(<$NAME> $N))
	    ;; Addition expression reduction rules
	    (mathKB.assert  '(ruleAdd (ruleAdd <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleAdd $X (<$FOLD> + $Y $Z)))
	    (mathKB.assert  '(ruleAdd (ruleAdd <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleAdd (<$FOLD> + $X $Z) $Y))
	    (mathKB.assert  '(ruleAdd (ruleSub <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleAdd $X (<$FOLD> - $Z $Y)))
	    (mathKB.assert  '(ruleAdd (ruleSub <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleSub (<$FOLD> + $X $Z) $Y))
	    (mathKB.assert  '(ruleAdd (ruleSub $X $Y) $X) '(ruleSub (ruleMul 2.0 $X) $Y))
	    (mathKB.assert  '(ruleAdd (ruleSub $X $Y) $Y) '$X)
	    (mathKB.assert  '(ruleAdd $X $X) '(ruleMul 2.0 $X))
	    (mathKB.assert  '(ruleAdd $X 0.0) '$X)
	    (mathKB.assert  '(ruleAdd 0.0 $X) '$X)
	    ;; Subtraction expression reduction rules
	    (mathKB.assert  '(ruleSub (ruleAdd <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleAdd $X (<$FOLD> - $Y $Z)))
	    (mathKB.assert  '(ruleSub (ruleAdd <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleAdd (<$FOLD> - $X $Z) $Y))
	    (mathKB.assert  '(ruleSub (ruleSub <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleSub $X (<$FOLD> + $Y $Z)))
	    (mathKB.assert  '(ruleSub (ruleSub <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleSub (<$FOLD> - $X $Z) $Y))
	    (mathKB.assert  '(ruleSub (ruleAdd $X $Y) $Y) '$X)
	    (mathKB.assert  '(ruleSub (ruleAdd $X $Y) $X) '$Y)
	    (mathKB.assert  '(ruleSub $X 0.0) '$X)
	    (mathKB.assert  '(ruleSub $X $X) 0.0)
	    ;; Division expression reduction rules
	    (mathKB.assert  '(ruleDiv (ruleMul <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleMul $X (<$FOLD> / $Y $Z)))
	    (mathKB.assert  '(ruleDiv (ruleMul <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleMul (<$FOLD> / $X $Z) $Y))
	    (mathKB.assert  '(ruleDiv (ruleDiv <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleDiv $X (<$FOLD> * $Y $Z)))
	    (mathKB.assert  '(ruleDiv (ruleDiv <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleDiv (<$FOLD> / $X $Z) $Y))
	    (mathKB.assert  '(ruleDiv (ruleMul $Y $X) (ruleMul $Z $X)) '(ruleMul (ruleDiv $Y $Z) $X))
	    (mathKB.assert  '(ruleDiv (ruleMul $Y $X) $X) '$Y)
	    (mathKB.assert  '(ruleDiv (ruleMul $Y $X) $Y) '$X)
	    (mathKB.assert  '(ruleDiv $X $X) 1.0)
	    (mathKB.assert  '(ruleDiv $X 1.0) '$X)
	    (mathKB.assert  '(ruleDiv 0.0 $X) 0.0)
	    (mathKB.assert  '(ruleDiv $X $X) 1.0)
	    ;; Multiplication expression reduction rules
	    (mathKB.assert  '(ruleMul (ruleSub <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleSub (ruleMul $X $Z) (<$FOLD> * $Y $Z)))
	    (mathKB.assert  '(ruleMul (ruleSub <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleSub (<$FOLD> * $X $Z) (ruleMul $Y $Z)))
	    (mathKB.assert  '(ruleMul (ruleMul <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleMul $X (<$FOLD> * $Y $Z)))
	    (mathKB.assert  '(ruleMul (ruleMul <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleMul (<$FOLD> * $X $Z) $Y))
	    (mathKB.assert  '(ruleMul (ruleDiv <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleMul $X (<$FOLD> / $Z $Y)))
	    (mathKB.assert  '(ruleMul (ruleDiv <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleDiv (<$FOLD> * $X $Z) $Y))
	    (mathKB.assert  '(ruleMul (ruleAdd <$X=$TERM> <$Y=$NUM>) <$Z=$NUM>) '(ruleAdd (ruleMul $X $Z) (<$FOLD> * $Y $Z)))
	    (mathKB.assert  '(ruleMul (ruleAdd <$X=$NUM> <$Y=$TERM>) <$Z=$NUM>) '(ruleAdd (<$FOLD> - $X $Z) (ruleMul $Y $Z)))
	    (mathKB.assert  '(ruleMul (ruleDiv $Y $X) $X) '$Y)
	    (mathKB.assert  '(ruleMul $X 0.0) 0.0)
	    (mathKB.assert  '(ruleMul 0.0 $X) 0.0)
	    (mathKB.assert  '(ruleMul $X 1.0) '$X)
	    (mathKB.assert  '(ruleMul 1.0 $X) '$X)
	    ;; Abs function reduction rules
	    (mathKB.assert  '(ruleAbs (ruleIf $X $Y $Z <$C1=$NUMPOS> <$C2=$NUMPOS>)) '(ruleIf $X $Y $Z $C1 $C2))
	    (mathKB.assert  '(ruleAbs (ruleAbs $X)) '(ruleAbs $X))
	    (mathKB.assert  '(ruleAbs (ruleLog $X)) '(ruleLog $X))
	    (mathKB.assert  '(ruleAbs (ruleNeg $X)) '(ruleAbs $X))
	    (mathKB.assert  '(ruleAbs (ruleSign $X)) '1.0)
	    ;; Exp function reduction rules
	    (mathKB.assert  '(eGrammar (ruleLog $X)) '$X)
	    ;; Expt function reduction rules
	    (mathKB.assert  '(ruleExpt $X 1.0) '$X)
	    (mathKB.assert  '(ruleExpt $X 0.0) 1.0)
	    ;; If function reduction rules
	    (mathKB.assert  '(ruleIf $X $Y $Z $L $L) '$L)
	    (mathKB.assert  '(ruleIf $X < $X $A $B) '$B)
	    (mathKB.assert  '(ruleIf $X <= $X $A $B) '$A)
	    (mathKB.assert  '(ruleIf $X >= $X $A $B) '$A)
	    (mathKB.assert  '(ruleIf $X > $X $A $B) '$B)
	    (mathKB.assert  '(ruleIf <$X=$NUM> $OP <$Y=$NUM> $A $B) '(<$IFFOLD> $X $OP $Y $A $B))
	    ;; Int function reduction rules
	    (mathKB.assert  '(ruleInt (ruleInt $X)) '(ruleInt $X))
	    ;; Log function reduction rules
	    (mathKB.assert  '(ruleLog (eGrammar $X)) '$X)
	    (mathKB.assert  '(ruleLogb (ruleExpt $X $Y) $X) '$Y)
	    (mathKB.assert  '(ruleLogb $X $X) '$X)
	    ;; Max function reduction rules
	    (mathKB.assert  '(ruleMax (ruleAbs $X) $X) '(ruleAbs $X))
	    (mathKB.assert  '(ruleMax $X (ruleAbs $X)) '(ruleAbs $X))
	    (mathKB.assert  '(ruleMax $X (ruleMax $X $Y)) '(ruleMax $X $Y))
	    (mathKB.assert  '(ruleMax $Y (ruleMax $X $Y)) '(ruleMax $X $Y))
	    (mathKB.assert  '(ruleMax $X $X) '$X)
	    ;; Min function reduction rules
	    (mathKB.assert  '(ruleMin (ruleNeg $X) $X) '(ruleNeg $X))
	    (mathKB.assert  '(ruleMin $X (ruleNeg $X)) '(ruleNeg $X))
	    (mathKB.assert  '(ruleMin $X (ruleMin $X $Y)) '(ruleMin $X $Y))
	    (mathKB.assert  '(ruleMin $Y (ruleMin $X $Y)) '(ruleMin $X $Y))
	    (mathKB.assert  '(ruleMin $X $X) '$X)
	    ;; Sign function reduction rules
	    (mathKB.assert  '(ruleSign (ruleIf $X $Y $Z <$C1=$NUMNEG> <$C2=$NUMNEG>)) '-1.0)
	    (mathKB.assert  '(ruleSign (ruleIf $X $Y $Z <$C1=$NUMPOS> <$C2=$NUMNEG>)) '(ruleIf $X $Y $Z 1.0 -1.0))
	    (mathKB.assert  '(ruleSign (ruleIf $X $Y $Z <$C1=$NUMNEG> <$C2=$NUMPOS>)) '(ruleIf $X $Y $Z -1.0 1.0))
	    (mathKB.assert  '(ruleSign (ruleIf $X $Y $Z <$C1=$NUMPOS> <$C2=$NUMPOS>)) '1.0)
	    (mathKB.assert  '(ruleSign (ruleSign $X)) '(ruleSign $X))
	    (mathKB.assert  '(ruleSign (ruleAbs $X)) '1.0)

        true) ;; end initialize
    ;; Show the variables currently stored in symbolic math.
    (defun showVariables()
        vars:(n N answerString)
        (setq answerString _eol)
        (setq N (length myVariables))
        (loop for n from 0 until N do
          ;; Display all atoms as is.
          (setq answerString (append answerString myVariables[n 0] " = " (prettyPrint myVariables[n 1] false) _eol))
          ) ; end loop
        answerString) ;; end showVariables

    ;; **********************************
    ;; Begin MAIN logic section.
    ;; **********************************
    vars:(stemp outFormula (stringOUT false))
    (onError errorHandler)
    (if (= mathKB #void) (initialize))

    ;; If the formula is empty, return an empty Estimator WFF.
    (if (= inFormula "") (return ""))

    ;; Simplify basic Estimator WFF expression and return a simplified Estimator WFF.
    (setq myInFormulaString inFormula)
    (if (isString inFormula) (begin (setq stringOUT true) (setq inFormula (gsm.listWff inFormula))))
    (setq outFormula (mathKB.apply inFormula))

    ;; Perform parsing validity check of simplified Estimator WFF.
    (setq stemp (string outFormula true))
    (if (isNumber (find "1.#IND" stemp)) (return myInFormulaString))
    (if (isNumber (find "1.#INF" stemp)) (return myInFormulaString))
    (Lisp stemp) 

    ;; Return simplified Estimator WFF in same format as input.
    (if (= stringOUT true) (setq outFormula stemp))

    outFormula) ;; end simplify






















































































































































































;;**EXPORTKEY**:gsm.svmRegress
(deforphan gsm:svmRegress(x y ...)
;; *******************************************************************
;; name:     svmRegress
;; 
;; summary:  Trains a support vector machine regression Lambda, using the
;;           Sequential Error Estimation (SEE) algorithm and returns the 
;;           trained estimator Lambda. (multiple regression network)
;;
;;           The Sequential Error Estimation (SEE) algorithm, allows a
;;           single kernel function or a vector of kernel functions to 
;;           build a support vector regression network linked with a
;;           multiple regression model.
;;            
;;           Sequential sample sets of the training examples are used
;;           to build multiple support vector regression models of the
;;           training data. The best of these models are linked together,
;;           via multiple regression, to form a composite model. This
;;           sequential sampling method automatically supports out-of-sample
;;           testing during the training phase; and, allows larger training
;;           data sets to be estimated in a fraction of the time required
;;           for an exhaustive Gramm matrix regression.
;;
;;           The model error is calculated based upon the absolute error of
;;           each estimate (calculated as a percent of the target variable).
;;           An error estimation grid can be constructed which penializes the
;;           model error for each grid slot whose average Y values are not
;;           sequentially increasing. This method enhances model fit in cases
;;           with low signal-to-noise ratios.  
;;
;; Parms:    x:         The N by M vector array representing the original observations
;;                      in the form of:    x x ... x
;;                                         x x ... x
;;                                             ... 
;;                                         x x ... x
;;           y   		The N vector of dependent variables.
;;           maxGen  	(Optional)The maximum generation count before halting training.
;;           verboseSW  (Optional)True iff we are to set verbose mode on.
;;
;; Return:   Lambda: 	The trained SEE regression model Lambda.
;;
;;			 Note1: Support Vector Machine regression can be highly accurate
;;				    when solving non-linear regression problems. However, the
;;                  accuracy varies from excellent to poor depending upon
;;                  the ratio of: the chosen Gaussian Sample Size (mySampleSize);
;;                  the number of regression variables (M); and the THEORETICAL
;;                  number of variables created by the kernel function to
;;                  make the non-linear problem linearly solvable. A simplified
;;                  example would be as follows.
;;
;;					Solving a quadratic regression problem with variableCount == 3,
;;                  y = sum{m from 0 until variableCount}(Cm*Xm*Xm), and 
;;                  a kernel function of vectorSquareInnerProduct, is very
;;                  accurate with a Gaussian Sample Size (mySampleSize) of 10.
;;                  However, if the variableCount is increased to 10, then the
;;                  accuracy completely breaks down and is not restored until
;;                  the Gaussian Sample Size is increased to around 100. An
;;                  explanation is as follows.
;;
;;					In order to make the quadratic regression linearly tractable,
;;                  the vectorSquareInnerProduct performs an on-the-fly squaring
;;                  of each training point vector. Thus, with a training point
;;                  vector of size three, the vectorSquareInnerProduct creates
;;                  the following on-the-fly THEORETICAL new training point:
;;					kernel(X1,X2,X3) => (X1,X2,X3,X1*X1,X2*X2,X3*X3,X1*X2,X1*X3,X2*X3).
;;                  Clearly the problem is now linearly solvable because the squared
;;                  variables are now terms in the THEORETICAL on-the-fly linear regression
;;                  created by the kernel. NOTICE however, that the THEORETICAL linear
;;                  regression, created on-the-fly by the kernel function, has nine variables
;;                  not three variables as in the original quadratic problem. Unless the
;;                  number of training points is greater than nine, and the Gaussian 
;;                  sample size is greater than nine, the on-the-fly linear regression
;;                  will not have enough data to get accurate results.
;; 
;;           Note2: See Cristianini, "Support Vector Machines", page 169.
;;           Note3: This SVM regression Lambda uses the Sequential Error Estimation (SEE)
;;                  algorithm.
;; *******************************************************************
    pvars:(;; Public option settings
           (Integer:myBaggingCnt 03)			;; The count of support vector clusters to use in building the final model.
           (Integer:myBaggingPct 1.50)	     	;; The NLSE score higher than which we begin bagging of support vector clusters to use in building the final model.
           (Integer:myDefaultSampleSize 512)	;; The default size of the training sample sets, selected from the total training examples, during each iterative regression (8 columns cubed).
           ;; Public variables
           Lambda:myModel				        ;; The final and best SEE regression model. 
           Integer:Generations          		;; The number of training cycles used to train the current SEE regression model. 
           Integer:GenerationMax        		;; The maximum number of training cycles before training is halted at any error rate. 
           kernel   		       				;; The current support vector machine kernel (compositeKernel).
           Integer:mySampleSize     			;; Size of the training sample sets, selected from the total training examples, during each iterative regression. 
           Integer:mySampleCount       	 		;; Count of the training sample sets, selected from the total training examples, during each iterative regression. 
           mySampleHistory              		;; History of the training sample sets, selected from the total training examples, during each iterative regression. 
           mySVMParent                  		;; The parent Lambda of this SVM regression Lambda community. 
           myVerboseSW      					;; True iff we are to display progress on the console. 
           Integer:M							;; The number of elements in each training example (independent variables). 
           Integer:N							;; The number of training examples (independent variables). 
           IntVector:sortedY            		;; The N vector of target points, dependent variable, sorted in ascending order. 
           NumVector:W                  		;; The weight coefficient vector for the SEE regression model.
           ObjVector:WX                 		;; The object vector of support vectors for the SEE regression model.
           X                       				;; The N x M matrix of training examples, independent variables, for training the SEE regression model. 
           NumVector:Y                  		;; The N vector of training example targets (dependent variable). 
           Number:YAvg                  		;; The average of Y (dependent variable). 
           Number:YStd                  		;; The standard deviation of Y (dependent variable). 
           ;; System Settings
           ;; Public child methods
           clear			       				;; Clear the current support vector machine.
           compositeKernel              		;; A built-in composite kernel used for machine learning.
           createSvmLambda			       		;; Return an Lambda ready to compute the svm output for a specified input vector.
           euclideanKernel                  	;; A built-in euclidean kernel used for machine learning.
           kernel   		       				;; Return the svm kernel output for the SEE regression model.
	       multipleRegression           		;; Performs a Gaussian multiple regression on the N x M+1 matrix
           polynomialKernel                  	;; A built-in polynomial kernel used for machine learning.
           radialBasisKernel              		;; A built-in radial basis kernel used for machine learning.
           scoreSvmTCEandNLSE	                ;; Compute the tail classification error and the normalized least squared error for the specified support vector block. 
           svmTraining		       				;; Train the svm machine on the specified training examples.
           trainFinalRegressionModel		    ;; Incrementally train the final SEE regression model.
           trainRegressionModel		    		;; Incrementally train the SEE regression model.
           ;; Private maintenance child methods
           selfTest                				;; The self test method for this Lambda. 
           ;; Private maintenance templates
           (myHistoryTemplate #{Step: #void SV: #void W: #void WX: #void NLSE: #void TCE: #void}) 
           ) ;; end of persistent variables
    ;; ***************************
    ;; Define Public Child Lambdas.
    ;; ***************************
    ;; Clear the current support vector machine.
    (defun clear()
       (setq kernel (lambda(k) k))
       (setq M 0)
       (setq N 0)
       (setq Generations 0) 
       (setq sortedY #void)
       (setq W #void)
       (setq X #void)
       (setq Y #void)
       (setq mySampleHistory #void)
       true) ; end clear
    ;; A built in composite kernel used for machine learning.
    (defun compositeKernel(NumVector:X NumVector:Y)
       regs:(m M n N)
       regs:(NumPointer:pX NumPointer:pY (Number:gaussianCrunchFactor 1.0E9))
       regs:(Number:kx (Number:xx 1.0) Number:ex Number:x Number:y Number:dy)
       ;; The following composite kernel function has proven superior, for
       ;; regression applications, than multiple user defined kernels. The
       ;; inspiration for this composite kernel was the body of research
       ;; on Radial Basis Functions for SVM classifiers (Google "Radial Basis Function").
       ;; Experimentation with composite dot product and kernel operators,
       ;; produced this composite kernel.
       ;;  
       (setq M (length X))
       (setq N (length Y))
       (if (<> M N) (error "gsm.svmRegress.compositeKernel: X and Y vectors must be the same length"))
       (setq pX X)
       (setq pY Y)
       (loop for n from 0 until N do
         (setq x pX[n])
         (setq y pY[n])
         (setq dy (- x y)) ;; simple difference
         (+= kx (* x y))   ;; dot product
         (+= kx (* dy dy)) ;; Euclidean distance
         ) ; end N loop
       (+= xx kx) ;; linear kernel
       (+= xx (* kx kx)) ;; square kernel
       (+= xx (* kx kx kx)) ;; cubic kernel
       (+= xx (setq kx (sqrt (abs kx)))) ;; Euclidean distance
       (+= xx (setq ex (- (/ 2.0 (+ 1.0 (exp (- (/ kx gaussianCrunchFactor))))) 1.0))) ;; Gaussian continuous kernel [-1,+1]
       (+= xx (if (> ex 0.0) 1.0 -1.0)) ;; Gaussian bipolar kernel [-1,+1]
       (+= xx (tanh (/ kx gaussianCrunchFactor))) ;; hypertangent kernel
       xx) ; end compositeKernel
    ; Return an Lambda ready to compute the svm output for a specified input points.
    (defun createSvmLambda(...)
       regs:(k K mm MM nn NN nw NW)
       vars:(NumVector:hW ObjVector:hWX)
       vars:(Lambda sampleSVCluster)
       (setq Lambda (eval "(lambda(x) pvars:(Expressions Integer:M Integer:N Strategy Kernel ObjVector:WX NumVector:W Number:WW Number:NLSE Number:TCE) regs:(n NN Number:xn Number:wn Number:ey NumPointer:pW) (setq NN (length W)) (loop for n from 0 until NN do (setq wn W[n]) (if (<> wn 0.0) then (begin (setq xn (Kernel x WX[n])) (*= xn wn) (+= ey xn)  )) ) (*= ey WW) ey)"))
       (setq Lambda.Strategy svmSEE:)
       ;; Sort the sample history support vector clusters by NLSE score.
       (sort mySampleHistory (lambda(x y) (< x.NLSE y.NLSE)))
       ;; Count all the support vectors, with non-zero coefficients, for each trained model in the sample history vector.
       (if (< mySampleHistory[0].NLSE myBaggingPct) then (setq K 1) else (setq K (min myBaggingCnt (length mySampleHistory))))
       (setq Lambda.WW (if (<= K 0) then 0.0 else (/ 1.0 (number K))))
       (setq Lambda.Kernel kernel)
       (loop for k from 0 until K do
         (setq sampleSVCluster mySampleHistory[k])
         (setq hW sampleSVCluster.W)
         (setq NN (length hW))
         (loop for nn from 0 until NN do (if (<> hW[nn] 0.0) (++ NW)))
         ) ; end first K loop
       (setq Lambda.N NW)
       (setq Lambda.W (new Vector: Number: NW))
       (setq Lambda.WX (new Vector: Object: NW))
       (setq Lambda.M M)
       ;; Average all the support vectors, with non-zero coefficients, for each trained model in the sample history vector.
       (loop for k from 0 until K do
         (setq sampleSVCluster mySampleHistory[k])
         (setq hW sampleSVCluster.W)
         (setq hWX sampleSVCluster.WX)
         (setq NN (length hW))
         (loop for nn from 0 until NN do 
           (if (<> hW[nn] 0.0)
               (begin
                 (setq Lambda.W[nw] hW[nn])
                 (setq Lambda.WX[nw] hWX[nn])
                 (++ nw)
               )) ; end if
           ) ; end N loop
         ) ; end second K loop
       (scoreSvmTCEandNLSE Lambda.Pv)
       (setq myModel Lambda)
       Lambda) ; end createSvmLambda
    ;; A built in euclidean kernel used for machine learning.
    (defun euclideanKernel(NumVector:X NumVector:Y)
       regs:(m M n N)
       regs:(NumPointer:pX NumPointer:pY (Number:gaussianCrunchFactor 1.0E9))
       regs:(Number:kx (Number:xx 1.0) Number:ex Number:x Number:y Number:dy)
       ;; The following euclidean kernel function has proven superior, for
       ;; regression applications, than multiple user defined kernels. The
       ;; inspiration for this euclidean kernel was the body of research
       ;; on Radial Basis Functions for SVM classifiers (Google "Radial Basis Function").
       ;; Experimentation with euclidean dot product and kernel operators,
       ;; produced this euclidean kernel.
       ;; 
       (setq M (length X))
       (setq N (length Y))
       (if (<> M N) (error "gsm.svmRegress.euclideanKernel: X and Y vectors must be the same length"))
       (setq pX X)
       (setq pY Y)
       (loop for n from 0 until N do
         (setq x pX[n])
         (setq y pY[n])
         (setq dy (- x y)) ;; simple difference
         (+= kx (* x y))   ;; dot product
         (+= kx (* dy dy)) ;; Euclidean distance
         ) ; end N loop
       (+= xx kx) ;; linear kernel
       (+= xx (* kx kx)) ;; square kernel
       (+= xx (* kx kx kx)) ;; cubic kernel
       (+= xx (setq kx (sqrt (abs kx)))) ;; Euclidean distance
       xx) ; end euclideanKernel
	;; summary:  Performs a Gaussian multiple regression on the N by M+1 matrix
	;; Parms:    MXY:     The N by M+1 matrix representing the original observations
	;;                    in the form of:    x x ... x y
	;;                                       x x ... x y
	;;                                           ... 
	;;                                       x x ... x y
	;; Return:   C:       The M coefficient vector for the regression.
	;; Note1:    Average error statistics are computed as a percent of the target (dependent variable).
	;; Note2:    See Sedgewick[2] chap 37.
	(defun multipleRegression(NumMatrix:MXY)
	    vars:(NumMatrix:Xt NumVector:C)
	    ;; Perform a least squares regression on all the factors.
	    (setq Xt (|Gv:makeGaussianMatrix| MXY))
	    (setq Xt (|Gv:matrixGaussianEliminate| Xt true))
	    (setq C (|Gv:matrixGaussianSubstitute| Xt))
	    ;; Return the coefficient vector for the regression.
	    C) ; end multipleRegression
    ;; A built in polynomial kernel used for machine learning.
    (defun polynomialKernel(NumVector:X NumVector:Y)
       regs:(m M n N)
       regs:(NumPointer:pX NumPointer:pY (Number:gaussianCrunchFactor 1.0E9))
       regs:(Number:kx (Number:xx 1.0) Number:ex Number:x Number:y Number:dy)
       ;; The following polynomial kernel function has proven superior, for
       ;; regression applications, than multiple user defined kernels.
       ;; 
       (setq M (length X))
       (setq N (length Y))
       (if (<> M N) (error "gsm.svmRegress.polynomialKernel: X and Y vectors must be the same length"))
       (setq pX X)
       (setq pY Y)
       (loop for n from 0 until N do
         (setq x pX[n])
         (setq y pY[n])
         (+= kx (* x y))   ;; dot product
         ) ; end N loop
       (+= xx kx) ;; linear kernel
       (+= xx (* kx kx)) ;; square kernel
       (+= xx (* kx kx kx)) ;; cubic kernel
       xx) ; end polynomialKernel
    ;; A built-in radial basis kernel used for machine learning.
    (defun radialBasisKernel(NumVector:X NumVector:Y)
       regs:(m M n N)
       regs:(NumPointer:pX NumPointer:pY (Number:gaussianCrunchFactor 1.0E9))
       regs:(Number:kx (Number:xx 1.0) Number:ex Number:x Number:y Number:dy)
       ;; The inspiration for this radial basis kernel was the body of research
       ;; on Radial Basis Functions for SVM classifiers (Google "Radial Basis Function").
       ;; 
       (setq M (length X))
       (setq N (length Y))
       (if (<> M N) (error "gsm.svmRegress.radialBasisKernel: X and Y vectors must be the same length"))
       (setq pX X)
       (setq pY Y)
       (loop for n from 0 until N do
         (setq x pX[n])
         (setq y pY[n])
         (setq dy (- x y)) ;; simple difference
         (+= kx (* dy dy)) ;; Euclidean distance
         ) ; end N loop
       (setq kx (sqrt kx)) ;; Euclidean distance
       (+= xx (setq ex (- (/ 2.0 (+ 1.0 (exp (- (/ kx gaussianCrunchFactor))))) 1.0))) ;; Gaussian continuous kernel [-1,+1]
       xx) ; end radialBasisKernel
    ;; Compute the tail classification error and the normalized least squared error for the specified support vector block.
    (defun scoreSvmTCEandNLSE(sampleSVCluster)
       regs:(k n mm MM nn NN NL NH buckets) 
       regs:(Number:tcEY Number:tcY Number:y Number:ey Number:nlse Number:err Number:wn Number:dot Number:InvN) 
       vars:(NumVector:x NumVector:wx NumVector:EY IntVector:sortedEY Lambda) 
       ;; Compute the EY vector from the support vector block.
       (setq NN (length Y))
       (setq EY (new Vector: Number: NN))
       (loop for nn from 0 until NN do
         (setq x X[nn])
         (setq y Y[nn])
         (setq ey  0.0)
         (setq MM (length sampleSVCluster.W))
         (setq wx sampleSVCluster.W)
         (loop for mm from 0 until MM do
           (setq wn wx[mm])
           (if (<> wn 0.0)
               (begin
                 (setq dot (kernel sampleSVCluster.WX[mm] x))
                 (+= ey (* wn dot))
               )) ; end if
           ) ; end ey loop
         (setq EY[nn] ey)
         ) ; end EY loop 
       ;; Classify the top 10% and bottom 10% of Y using the specified Lambda.
       (setq sortedEY (|Gv:sort| EY < true))
	   (setq NN (length EY))
	   (setq InvN (/ 1.0 (number NN)))
       (setq buckets 10)
	   (setq NL (/ NN buckets))
	   (setq NH (- NN NL))
	   (loop for n from 0 until NN do
	     (setq ey EY[n])
	     (setq y Y[n])
         (setq err (- ey y))
         (+= nlse (* err err))
	     (setq k sortedY[n])
	     (setq y Y[k])
         (if (< n NL) (-= tcY y))
         (if (>= n NH) (+= tcY y))
	     (setq k sortedEY[n])
	     (setq y Y[k])
         (if (< n NL) (-= tcEY y))
         (if (>= n NH) (+= tcEY y))
	     ) ; end scoring loop
       (/= nlse (number NN))
       (setq nlse (sqrt nlse))
       (/= nlse YStd)
       (setq tcEY (/ (- 2.0 (+ 1.0 (/ tcEY tcY))) 2.0))
       (setq sampleSVCluster.NLSE nlse)
       (setq sampleSVCluster.TCE tcEY)
       Lambda) ; end scoreSvmTCEandNLSE
    ;; Train the svm machine on the specified inputs and model.
	;; Parms:    x:         The N by M vector array representing the original observations
	;;                      in the form of:    x x ... x
	;;                                         x x ... x
	;;                                             ... 
	;;                                         x x ... x
	;;           y   		The N vector of dependent variables.
    ;;           maxGen  	The maximum generation count before halting training.
    ;;           verboseSW  True iff we are to set verbose mode on.
    ;;
	;; Return:   Lambda: 	The trained SEE regression model Lambda.
    (defun svmTraining(x y maxGen verboseSW)
        regs:(k K m n NN SN begK)
        vars:(Lambda sampleSVCluster kernelID)
	    ;; Clear support vector machine for retraining.
	    (clear)
	    ;; Retrieve any optional arguments and perform setup.
	    (setq GenerationMax maxGen)
	    (setq myVerboseSW verboseSW)
	    (if (or (<> (isVector x) true) (<> (isVector x[0]) true)) (error "svmRegress: X argument must be a Vector Array of rank 2"))
	    (setq m (length x[0]))
	    (setq n (length x))
	    (if (or (<> (isVector y) true) (<> (length y) n)) (error "svmRegress: Y argument must be a Vector of length the same as X"))
	    ;; Initialize the persistent variables before proceeding with training.
	    (setq X x)
	    (setq Y y)
        (setq YAvg (avg Y)) 
        (setq YStd (stdev Y)) 
	    (setq M m)
	    (setq N n)
        (setq kernelID gsm.mySvmKernelID)
	    ;; Initialize the user specified support vector machine kernel.
	    (cond
	      ((or (= kernelID "default") (= kernelID #void)) (setq kernel compositeKernel))
	      ((= kernelID "binary") (setq kernel |Gv:vectorBinaryInnerProduct|))
	      ((= kernelID "bipolar") (setq kernel |Gv:vectorBinaryInnerProduct|))
	      ((= kernelID "composite") (setq kernel compositeKernel))
	      ((= kernelID "cosine") (setq kernel |Gv:vectorCosineInnerProduct|))
	      ((= kernelID "cube") (setq kernel |Gv:vectorCubeInnerProduct|))
	      ((= kernelID "euclid") (setq kernel euclideanKernel))
	      ((= kernelID "exp") (setq kernel |Gv:vectorExpInnerProduct|))
	      ((= kernelID "linear") (setq kernel |Gv:vectorInnerProduct|))
	      ((= kernelID "log") (setq kernel |Gv:vectorLogInnerProduct|))
	      ((= kernelID "poly") (setq kernel polynomialKernel))
	      ((= kernelID "quart") (setq kernel |Gv:vectorQuartInnerProduct|))
	      ((= kernelID "quint") (setq kernel |Gv:vectorQuintInnerProduct|))
	      ((= kernelID "radialBasisKernel") (setq kernel radialBasisKernel))
	      ((= kernelID "sigmoid") (setq kernel |Gv:vectorSigmoidInnerProduct|))
	      ((= kernelID "sine") (setq kernel |Gv:vectorSineInnerProduct|))
	      ((= kernelID "square") (setq kernel |Gv:vectorSquareInnerProduct|))
	      ((= kernelID "tan") (setq kernel |Gv:vectorTanInnerProduct|))
	      ((= kernelID "tanh") (setq kernel |Gv:vectorTanhInnerProduct|))
	      ((isFunction kernelID) (setq kernel kernelID))
	      ((isLambda kernelID) (setq kernel kernelID))
	      (else (error (append "gsm.svmRegress.svmTraining: unknown SVM kernel identifier [" kernelID "]")))
	      ) ; end cond 
        (setq sortedY (sort Y < true))
        (setq W #void)
	    ;; Run multiple generations taking the first one to achieve success.
	    ;; Note: If no generation achieves success, we take the best so far.
        (setq mySampleSize myDefaultSampleSize)     
        (if (< N mySampleSize) (setq mySampleSize N))
        (setq mySampleCount (/ N mySampleSize))
        (if (< mySampleCount 1) then (begin (setq mySampleSize N) (setq mySampleCount 1)))
        (setq mySampleHistory (new Vector:))
	    (setq Generations 0)
	    ;; Train the next generation.
	    (while (< Generations GenerationMax) do
	       (trainRegressionModel)
           (if (<= mySampleHistory[Generations].NLSE gsm.myS) (goto HaltTraining:))
	       (++ Generations)
	       ) ; end while
	    ;; Generate the final absolute error score after training.
	    HaltTraining::
        (trainFinalRegressionModel)
        (setq Lambda (createSvmLambda))
	    (if myVerboseSW (writeln "svmRegress: Final Model Generations = [" Generations "], SV's = [" Lambda.N "]"))       
        Lambda) ; end svmTraining
    ;; Incrementally train the final SEE model on the two training points.
    (defun trainFinalRegressionModel()
       regs:(h H k K m n rm sn)
       regs:(Number:dotProduct Number:y Number:xk Number:xn)
       regs:(IntPointer:pSV IntPointer:pSortedY NumPointer:pXn NumPointer:pXk NumPointer:pRM)
       regs:(Number:avgY Number:avgErr)
       regs:(Integer:NN                  ;; Number of total training examples.
             Integer:SN                  ;; Number of seed support vectors to use in Gaussian initialization.
             Integer:firstStep           ;; Example first step size for use in support vector selection.
             Integer:stepInc             ;; Example selection step size for use in support vector selection.
             Number:weightFactor         ;; Weight factor for use in support vector merging.
             Number:maxAbsWeightFactor   ;; Maximum absolute weight factor for use in support vector merging.
             Integer:maxHistoryIndex     ;; History index of the maximum absolute weight factor for use in support vector merging..
             ) ; end register variables
       vars:(NumVector:CS                ;; The Gaussian regression coefficients for the support vectors.
             Structure:sampleSVCluster   ;; The history record for the nth sample set.
             NumMatrix:RM 				 ;; The regression matrix regressing the support vectors against all of the training points in X.
             IntVector:sortedHistories	 ;; The Integer Vector of the sorted sample set histories.
             IntVector:SV				 ;; The indices of the current support vector set. 
             NumVector:Xk 				 ;; The Number Vector, of the independent variables, for the kth training example.
             NumVector:Xn 				 ;; The Number Vector, of the independent variables, for the nth training example.
             ObjVector:tWX 				 ;; The Object Vector, of the support vectors, for the nth sample set.
             ) ; end temporary variables
       ;; Select the support vector from each sample history with the maximum absolute weight factor.
       ;; Note: This will create the final champion SEE model.
       (if (<= (setq H (length mySampleHistory)) 1) (return true))
       (setq SN mySampleSize)
       (setq SV (new Vector: Integer: SN))
       (setq pSV SV)
       (setq pSortedY sortedY)
       (loop for sn from 0 until SN do
         (setq maxAbsWeightFactor (abs mySampleHistory[0].W[0]))
         (setq maxHistoryIndex 0)
         (loop for h from 1 until H do 
           (if (< maxAbsWeightFactor (setq weightFactor (abs mySampleHistory[h].W[sn])))
               (begin
                 (setq maxAbsWeightFactor weightFactor)
                 (setq maxHistoryIndex h)
               )) ; end max if
           ) ; end inner H loop
         (setq pSV[sn] mySampleHistory[maxHistoryIndex].SV[sn])
         ) ; end outter K loop 
       ;; Construct the support vectors regression matrix.
       ;; Note: We attempt to regress a linear model of the support vectors
       ;;       against all of the training points in X. The Regression
       ;;       Matrix is of the following form:
       ;;          kernel(X[0],X[SV[0]]) ... kernel(X[0],X[SV[SN]]) Y[0]
       ;;          kernel(X[1],X[SV[0]]) ... kernel(X[1],X[SV[SN]]) Y[1]
       ;;                  ...           ...              ...
       ;;          kernel(X[N],X[SV[0]]) ... kernel(X[N],X[SV[SN]]) Y[N]
       (setq NN N)
       (setq RM #void)
       (setq RM (new Matrix: number: 2 NN (addi SN 1)))
       (vmregRunInHardware start:)
       (setq pSV SV)
       (setq pRM RM)
       (setq rm -1)
       (loop for n from 0 until NN do
           (loop for m from 0 until SN do
              (setq k pSV[m])
              (setq Xk X[k])
              (setq Xn X[n])
              (setq dotProduct (kernel Xk Xn))
              (++ rm)
              (setq pRM[rm] dotProduct)
              ) ; end SN loop
           (++ rm)
           (setq pRM[rm] Y[n])
           ) ; end NN loop
       (vmregRunInHardware stop:)
       ;; Solve for the Gaussian coefficients of the support vectors.
       ;; Note: We perform a Gaussian linear regression on the Regression
       ;;       Matrix, returning an SN Vector of coefficients, which we
       ;;       set as the weights, in the SVM  model, of each of the 
       ;;       support vectors respectively. All other non-support-vector
       ;;       weights, in the initial SVM model, are set to zero.
       (setq CS (multipleRegression RM))
       (setq K (length mySampleHistory))
       (setq mySampleHistory[K] (setq sampleSVCluster (new myHistoryTemplate)))
       (setq sampleSVCluster.Step K)
       (setq sampleSVCluster.SV SV)
       (setq sampleSVCluster.W CS)
       (setq sampleSVCluster.WX (setq tWX (new Vector: Object: SN)))
       (vmregRunInHardware start:)
       (loop for m from 0 until SN do
          (setq k SV[m])
          (setq tWX[m] X[k])
          ) ; end loop
       (vmregRunInHardware stop:)
       (scoreSvmTCEandNLSE sampleSVCluster)
       ;; This generation of SVM model training is complete.
       TrainingCompleted::
       (if myVerboseSW (writeln "svmRegress: completed training [" sampleSVCluster.Step "], NLSE=[" sampleSVCluster.NLSE "], TCE=[" sampleSVCluster.TCE "]")) 
       ;; Return success
       true) ; end trainFinalRegressionModel
    ;; Incrementally train the SEE model on the two training points.
    (defun trainRegressionModel()
       regs:(k K m n rm sn)
       regs:(Number:dotProduct Number:y Number:xk Number:xn)
       regs:(IntPointer:pSV IntPointer:pSortedY NumPointer:pXn NumPointer:pXk NumPointer:pRM)
       regs:(Number:avgY Number:avgErr)
       regs:(Integer:NN                  ;; Number of total training examples.
             Integer:SN                  ;; Number of seed support vectors to use in Gaussian initialization.
             Integer:firstStep           ;; Example first step size for use in support vector selection.
             Integer:stepInc             ;; Example selection step size for use in support vector selection.
             Number:weightFactor         ;; Weight factor for use in support vector merging.
             ) ; end register variables
       vars:(NumVector:CS                ;; The Gaussian regression coefficients for the support vectors.
             Structure:sampleSVCluster   ;; The history record for the nth sample set.
             NumMatrix:RM 				 ;; The regression matrix regressing the support vectors against all of the training points in X.
             IntVector:sortedHistories	 ;; The Integer Vector of the sorted sample set histories.
             IntVector:SV				 ;; The indices of the current support vector set. 
             NumVector:Xk 				 ;; The Number Vector, of the independent variables, for the kth training example.
             NumVector:Xn 				 ;; The Number Vector, of the independent variables, for the nth training example.
             ObjVector:tWX 				 ;; The Object Vector, of the support vectors, for the nth sample set.
             ) ; end temporary variables
       ;; Zero the errors where there are already support vectors.
       (setq firstStep (integer Generations))
       (if (>= firstStep mySampleCount) (goto TrainingCompleted:))
       (setq NN N)
       ;; Extend the support vectors with the examples with the worst percent errors
       (setq SN mySampleSize)
       (setq SV (new Vector: Integer: SN))
       (setq stepInc mySampleCount)
       (setq pSV SV)
       (setq pSortedY sortedY)
       (setq n firstStep)
       (vmregRunInHardware start:)
       (loop for sn from 0 until SN do
		  (setq pSV[sn] pSortedY[n])
          (+= n stepInc)
          ) ; end loop 
       (vmregRunInHardware stop:)
       (setq SN (length SV))
       ;; Construct the support vectors regression matrix.
       ;; Note: We attempt to regress a linear model of the support vectors
       ;;       against all of the training points in X. The Regression
       ;;       Matrix is of the following form:
       ;;          kernel(X[0],X[SV[0]]) ... kernel(X[0],X[SV[SN]]) Y[0]
       ;;          kernel(X[1],X[SV[0]]) ... kernel(X[1],X[SV[SN]]) Y[1]
       ;;                  ...           ...              ...
       ;;          kernel(X[N],X[SV[0]]) ... kernel(X[N],X[SV[SN]]) Y[N]
       (setq RM #void)
       (setq RM (new Matrix: number: 2 NN (addi SN 1)))
       (vmregRunInHardware start:)
       (setq pSV SV)
       (setq pRM RM)
       (setq rm -1)
       (loop for n from 0 until NN do
           (loop for m from 0 until SN do
              (setq k pSV[m])
              (setq Xk X[k])
              (setq Xn X[n])
              (setq dotProduct (kernel Xk Xn))
              (++ rm)
              (setq pRM[rm] dotProduct)
              ) ; end SN loop
           (++ rm)
           (setq pRM[rm] Y[n])
           ) ; end NN loop
       (vmregRunInHardware stop:)
       ;; Solve for the Gaussian coefficients of the support vectors.
       ;; Note: We perform a Gaussian linear regression on the Regression
       ;;       Matrix, returning an SN Vector of coefficients, which we
       ;;       set as the weights, in the SVM  model, of each of the 
       ;;       support vectors respectively. All other non-support-vector
       ;;       weights, in the initial SVM model, are set to zero.
       (setq CS (multipleRegression RM))
       (setq K (length mySampleHistory))
       (setq mySampleHistory[K] (setq sampleSVCluster (new myHistoryTemplate)))
       (setq sampleSVCluster.Step K)
       (setq sampleSVCluster.SV SV)
       (setq sampleSVCluster.W CS)
       (setq sampleSVCluster.WX (setq tWX (new Vector: Object: SN)))
       (vmregRunInHardware start:)
       (loop for m from 0 until SN do
          (setq k SV[m])
          (setq tWX[m] X[k])
          ) ; end loop
       (vmregRunInHardware stop:)
       (scoreSvmTCEandNLSE sampleSVCluster)
       ;; This generation of SVM model training is complete.
       TrainingCompleted::
       (if myVerboseSW (writeln "svmRegress: completed training [" sampleSVCluster.Step "], NLSE=[" sampleSVCluster.NLSE "], TCE=[" sampleSVCluster.TCE "]")) 
       ;; Return success
       true) ; end trainRegressionModel
    ;; ****************************************
    ;; Define Private Maintenance Child Lambdas.
    ;; ****************************************
    ;; The self test method for this Lambda.
    (defun selfTest(Test Ns Ms maxGen verboseSW)
       vars:(k m n g G y ey C c X Y Yv avgY stdY
             Lambda nlse err pct properties 
             startTime endTime startTimeT endTimeT
             (checkResults true)
             (tol 0.0) (errStop 0.01) (Cs 1.0)
             ) ; end temporary variables
       (clear)
       (setq startTimeT (getTickCount 0))
       (gsm.setRandomSeed 8192.0)
       (setq myVerboseSW verboseSW)      
       ;; Select the requested test case
       ;; Test Case linear 
       (if (= Test linear:)
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] - C[2]*X[2] + C[3]*X[3] - C[4]*X[4] ...
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: linear")
		       (setq Lambda (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW)))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case linear
       ;; Test Case linearSigmoid 
       (if (= Test linearSigmoid:)
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] - C[2]*X[2] + C[3]*X[3] - C[4]*X[4] ...
		       ;; Note1: The inputs, X, are restricted to the sigmoid domain.
		       ;; Note2: We support a bias by having X[0] == 1 for all N.
		       ;; Note3: This algorithm seems to work well when N is at least 25 times M.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 1) .5))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction .999999999) 0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: linearSigmoid")
		       (setq Lambda (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW)))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case linearSigmoid
       ;; Test Case srandom 
       (if (= Test srandom:)
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] - C[2]*X[2] + C[3]*X[3] - C[4]*X[4] ...
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: srandom")
		       (setq Lambda (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW)))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case srandom
       ;; Test Case mixedRandom 
       (if (= Test mixedRandom:)
           (begin
		       ;; Create a test polynomial linear model where y = C[0]*X[0] + C[1]*X[1] + C[2]*X[2] ...
		       ;; Create a test polynomial square model where y = C[0]*X[0]*X[0] + C[1]*X[1]*X[1] + C[2]*X[2]*X[2] ...
		       ;; Create a test polynomial sin model where y = C[0]*sin(X[0]) + C[1]*sin(X[1]) + C[2]*sin(X[2]) ...
		       ;; Create a test polynomial log model where y = C[0]*log(abs(X[0])+.000001) + C[1]*log(abs(X[1])+.000001) + C[1]*log(abs(X[2])+.000001) ...
               ;; These four models are mixed together and random noise is added.
		       ;; Note1: We support a bias by having X[0] == 1 for all N.
		       ;; Note2: This algorithm seems to work well when N is at least 25 times M.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
                  (setq k (modi n 4)) 
 		          (setq X[n][0] 1.0)
 		          (setq X[n][1] (number k))
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 2 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
                     ;; Mix the four models together
                     (cond
                        ;; Linear model
                        ((= k 0) (setq y (+ y (* X[n][m] C[m]))))
                        ;; Square model
                        ((= k 1) (setq y (+ y (* X[n][m] X[n][m] C[m]))))
                        ;; Sine model
                        ((= k 2) (setq y (+ y (* (|Gv:sin| X[n][m]) C[m]))))
                        ;; Log model
                        (else (setq y (+ y (* (|Gv:log| (+ .000001 (|Gv:abs| X[n][m]))) C[m]))))
                        ) ; end cond
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: mixedRandom")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case mixedRandom
       ;; Test Case randomSigmoid 
       (if (= Test randomSigmoid:)
           (begin
		       ;; Create a test polynomial regression where y = C[0]*X[0] + C[1]*X[1] - C[2]*X[2] + C[3]*X[3] - C[4]*X[4] ...
		       ;; Note1: The inputs, X, are restricted to the sigmoid domain.
		       ;; Note2: We support a bias by having X[0] == 1 for all N.
		       ;; Note3: This algorithm seems to work well when N is at least 25 times M.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 1) .5))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do 
		          	 (setq X[n][m] (- (gsm.myRandomFunction .999999999) 0))
		             (setq y (+ y (* X[n][m] C[m])))
		             ) ; end M loop
		          (setq Y[n] (+ (* y .8) (* y (gsm.myRandomFunction .4))))
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: randomSigmoid")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case randomSigmoid
       ;; Test Case cube 
       (if (= Test cube:)
           (begin
		       ;; Create a test polynomial regression where y = -11.2 + C[0]*X[0] - C[1]*(X[1]**3) + C[2]*X[2] - C[3]*(X[3]**3) ...
		       ;; Note: We support a bias by having X[0] == 1 for all N.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (if (isOdd m)
			             (setq y (+ y (* X[n][m] C[m])))
			             (setq y (+ y (* X[n][m] X[n][m] X[n][m] C[m])))
		                 ) ; end if
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: cube")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case cube
       ;; Test Case square 
       (if (= Test square:)
           (begin
		       ;; Create a test polynomial regression where y = -11.2 + C[0]*X[0] - C[1]*(X[1]**2) + C[2]*X[2] - C[3]*(X[3]**2) ...
		       ;; Note: We support a bias by having X[0] == 1 for all N.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (if (isOdd m)
			             (setq y (+ y (* X[n][m] C[m])))
			             (setq y (+ y (* X[n][m] X[n][m] C[m])))
		                 ) ; end if
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: square")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case square
       ;; Test Case tan 
       (if (= Test tan:)
           (begin
		       ;; Create a test polynomial regression where y = -11.2 + C[0]*X[0] - C[1]*(X[1]**2) + C[2]*X[2] - C[3]*(X[3]**2) ...
		       ;; Note: We support a bias by having X[0] == 1 for all N.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* (tan X[n][m]) C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: tan")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case tan
       ;; Test Case log 
       (if (= Test log:)
           (begin
		       ;; Create a test polynomial regression where y = -11.2 + C[0]*X[0] - C[1]*(X[1]**2) + C[2]*X[2] - C[3]*(X[3]**2) ...
		       ;; Note: We support a bias by having X[0] == 1 for all N.
		       (setq c Cs)
		       (setq M Ms)
		       (setq N Ns)
		       (setq X (new Vector: object: N))
		       (setq Y (new Vector: Number: N))
		       (setq C (new Vector: Number: M))
		       (setq C[0] c)
		       (loop for m from 1 until M do
		          (setq C[m] (- (gsm.myRandomFunction 100.0) 50.0))
		          ) ; end C loop
		       (loop for n from 0 until N do
		          (setq X[n] (new Vector: Number: M))
		          (setq X[n][0] 1)
		          (setq y (* C[0] X[n][0]))
		          (loop for m from 1 until M do
		          	 (setq X[n][m] (- (gsm.myRandomFunction 100.0) 50.0))
		             (setq y (+ y (* (log (+ 1.0 (abs X[n][m]))) C[m])))
		             ) ; end M loop
		          (setq Y[n] y)
		          ) ; end N loop
		       ;; Train on the test case.
		       (writeln _eol "Starting test case: log")
		       (setq Lambda (gsm.svmRegress.svmTraining X Y maxGen verboseSW))
		       (if (= myVerboseSW false) (writeln "svmRegress: N = [" Ns "], M = [" Lambda.M "], Generations = [" Generations  "], SV's = [" Lambda.N "]")) 
               (if (= checkResults true)
                   (begin
                      (setq nlse 0.0)
                      (setq avgY (avg Y))
                      (setq stdY (stdev Y))
		              (loop for n from 0 until N do
		                 (setq y Y[n])
		                 (setq ey (Lambda X[n]))
                         (setq err (abs (- ey y)))
                         (setq pct (/ err stdY)) 
		                 (+= nlse (* err err))
                         (if (= (modi n (divi N 10)) 0) (writeln "[" n "] ey=[" ey "] y=[" y "] err=[" err "] err%=[" pct "]"))
		                 ) ; end N loop
                      (setq nlse (/ (sqrt (/ nlse N)) stdY)) 
		              (writeln "svmRegress: nlse=[" nlse "], avgY=[" avgY "], stdY=[" stdY "]")
		           )) ; end if
          )) ; end Test Case log
       (writeln "svmRegress.selfTest: completed in [" (/ (setq endTimeT (getTickCount startTimeT)) 60.0) "] minutes.")       
       Lambda) ; end selfTest
    ;; *****************
    ;; Begin main logic.
    ;; ***************** 
    vars:(Lambda svmLambda (maxGen 1) (verboseSW false))

    ;; Create and train a new support vector machine.
    (if (>= (argCount) 3) (setq maxGen (argFetch 2)))
    (if (>= (argCount) 4) (setq verboseSW (argFetch 3)))
    (setq svmLambda (new (myself)))
    (setq svmLambda.mySVMParent svmLambda)
    (setq Lambda (svmLambda.svmTraining x y maxGen verboseSW))
    Lambda) ; end svmRegress



