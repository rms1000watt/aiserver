
<HTML>
<HEAD>
<link rel="stylesheet" type="text/css" href="../CoreContent/help.css">
<TITLE>AIS Essay Template</TITLE></HEAD>
<!--Page Parameters -->
<BODY BGCOLOR="#FFFFF0" TEXT="#000000" LINK="#0000ff">

<A NAME="topage"></A>
<A HREF="TOP"></A>



<P>&nbsp;</P>

<FONT COLOR="#000080"><H1>SQL Statement Syntax</H1></FONT>
<P>&nbsp;</P>

<UL>
<li><a href="#SOverview"><FONT SIZE=2>Overview</font></a></li><li><a href="#SALTER DATABASE Syntax"><FONT SIZE=2>ALTER DATABASE Syntax</font></a></li><li><a href="#SALTER EVENT Syntax"><FONT SIZE=2>ALTER EVENT Syntax</font></a></li><li><a href="#SALTER PROCEDURE and ALTER FUNCTION Syntax"><FONT SIZE=2>ALTER PROCEDURE and ALTER FUNCTION Syntax</font></a></li><li><a href="#SALTER TABLE Syntax"><FONT SIZE=2>ALTER TABLE Syntax</font></a></li><li><a href="#SALTER VIEW Syntax"><FONT SIZE=2>ALTER VIEW Syntax</font></a></li><li><a href="#SCREATE DATABASE Syntax"><FONT SIZE=2>CREATE DATABASE Syntax</font></a></li><li><a href="#SCREATE EVENT Syntax"><FONT SIZE=2>CREATE EVENT Syntax</font></a></li><li><a href="#SCREATE INDEX Syntax"><FONT SIZE=2>CREATE INDEX Syntax</font></a></li><li><a href="#SCREATE PROCEDURE and CREATE FUNCTION Syntax"><FONT SIZE=2>CREATE PROCEDURE and CREATE FUNCTION Syntax</font></a></li><li><a href="#SCREATE TABLE Syntax"><FONT SIZE=2>CREATE TABLE Syntax</font></a></li><li><a href="#SCREATE TRIGGER Syntax"><FONT SIZE=2>CREATE TRIGGER Syntax</font></a></li><li><a href="#SCREATE VIEW Syntax"><FONT SIZE=2>CREATE VIEW Syntax</font></a></li><li><a href="#SDROP DATABASE Syntax"><FONT SIZE=2>DROP DATABASE Syntax</font></a></li><li><a href="#SDROP EVENT Syntax"><FONT SIZE=2>DROP EVENT Syntax</font></a></li><li><a href="#SDROP FUNCTION Syntax"><FONT SIZE=2>DROP FUNCTION Syntax</font></a></li><li><a href="#SDROP INDEX Syntax"><FONT SIZE=2>DROP INDEX Syntax</font></a></li><li><a href="#SDROP PROCEDURE and DROP FUNCTION Syntax"><FONT SIZE=2>DROP PROCEDURE and DROP FUNCTION Syntax</font></a></li><li><a href="#SDROP TABLE Syntax"><FONT SIZE=2>DROP TABLE Syntax</font></a></li><li><a href="#SDROP TRIGGER Syntax"><FONT SIZE=2>DROP TRIGGER Syntax</font></a></li><li><a href="#SDROP VIEW Syntax"><FONT SIZE=2>DROP VIEW Syntax</font></a></li><li><a href="#SRENAME DATABASE Syntax"><FONT SIZE=2>RENAME DATABASE Syntax</font></a></li><li><a href="#SRENAME TABLE Syntax"><FONT SIZE=2>RENAME TABLE Syntax</font></a></li><li><a href="#SCALL Statement Syntax"><FONT SIZE=2>CALL Statement Syntax</font></a></li><li><a href="#SDELETE Syntax"><FONT SIZE=2>DELETE Syntax</font></a></li><li><a href="#SDO Syntax"><FONT SIZE=2>DO Syntax</font></a></li><li><a href="#SHANDLER Syntax"><FONT SIZE=2>HANDLER Syntax</font></a></li><li><a href="#SINSERT Syntax"><FONT SIZE=2>INSERT Syntax</font></a></li><li><a href="#SINSERT ... SELECT Syntax"><FONT SIZE=2>INSERT ... SELECT Syntax</font></a></li><li><a href="#SINSERT DELAYED Syntax"><FONT SIZE=2>INSERT DELAYED Syntax</font></a></li><li><a href="#SINSERT ... ON DUPLICATE KEY UPDATE Syntax"><FONT SIZE=2>INSERT ... ON DUPLICATE KEY UPDATE Syntax</font></a></li><li><a href="#SLOAD DATA INFILE Syntax"><FONT SIZE=2>LOAD DATA INFILE Syntax</font></a></li><li><a href="#SREPLACE Syntax"><FONT SIZE=2>REPLACE Syntax</font></a></li><li><a href="#SSELECT Syntax"><FONT SIZE=2>SELECT Syntax</font></a></li><li><a href="#SJOIN Syntax"><FONT SIZE=2>JOIN Syntax</font></a></li><li><a href="#SUNION Syntax"><FONT SIZE=2>UNION Syntax</font></a></li><li><a href="#SSubquery Syntax"><FONT SIZE=2>Subquery Syntax</font></a></li><li><a href="#STRUNCATE Syntax"><FONT SIZE=2>TRUNCATE Syntax</font></a></li><li><a href="#SUPDATE Syntax"><FONT SIZE=2>UPDATE Syntax</font></a></li><li><a href="#SDESCRIBE Syntax"><FONT SIZE=2>DESCRIBE Syntax</font></a></li><li><a href="#SEXPLAIN Syntax"><FONT SIZE=2>EXPLAIN Syntax</font></a></li><li><a href="#SUSE Syntax"><FONT SIZE=2>USE Syntax</font></a></li><li><a href="#SCREATE USER Syntax"><FONT SIZE=2>CREATE USER Syntax</font></a></li><li><a href="#SDROP USER Syntax"><FONT SIZE=2>DROP USER Syntax</font></a></li><li><a href="#SGRANT Syntax"><FONT SIZE=2>GRANT Syntax</font></a></li><li><a href="#SRENAME USER Syntax"><FONT SIZE=2>RENAME USER Syntax</font></a></li><li><a href="#SREVOKE Syntax"><FONT SIZE=2>REVOKE Syntax</font></a></li><li><a href="#SSET PASSWORD Syntax"><FONT SIZE=2>SET PASSWORD Syntax</font></a></li><li><a href="#SSET Syntax"><FONT SIZE=2>SET Syntax</font></a></li><li><a href="#SSHOW Syntax"><FONT SIZE=2>SHOW Syntax</font></a></li>
</UL>

<P><H2><A NAME="SOverview"></A>Overview</H2></P>		
		   <p>This chapter describes the syntax for the SQL statements supported by SQL.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SALTER DATABASE Syntax"></A>ALTER DATABASE Syntax</H2></P>
		<pre>ALTER {DATABASE | SCHEMA} [db_name]
    alter_specification ...
ALTER {DATABASE | SCHEMA} db_name
    UPGRADE DATA DIRECTORY NAME

alter_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name</pre>

		<p>ALTER DATABASE enables you to change the overall characteristics of a database.
			These characteristics are stored in the db.opt file in the database directory.
			To use ALTER DATABASE, you need the ALTER privilege on the database. ALTER SCHEMA is a synonym for ALTER DATABASE.</p>

		<p>The CHARACTER SET clause changes the default database character set.
			The COLLATE clause changes the default database collation.</p>

		<p>You can see what character sets and collations are available using, respectively,
			the SHOW CHARACTER SET and SHOW COLLATION statements.</p>

		<p>The database name can be omitted from the first syntax, in which case the statement applies to the default database.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SALTER EVENT Syntax"></A>ALTER EVENT Syntax</H2></P>
		<pre>ALTER
    [DEFINER = { user | CURRENT_USER }]
    EVENT event_name
    [ON SCHEDULE schedule]
    [ON COMPLETION [NOT] PRESERVE]
    [RENAME TO new_event_name]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'comment']
    [DO sql_statement]</pre>

		<p>The ALTER EVENT statement is used to change one or more of the characteristics of an existing event without the need to drop and recreate it.
			The syntax for each of the DEFINER, ON SCHEDULE, ON COMPLETION, COMMENT, ENABLE / DISABLE, and DO clauses is exactly the same as when used with CREATE EVENT.</p>

		<p>Any user can alter an event defined on a database for which that user has the EVENT privilege.
			When a user executes a successful ALTER EVENT statement, that user becomes the definer for the affected event.</p>

		<p>ALTER EVENT works only with an existing event:</p>
		<pre>(sql sqlHandle {ALTER EVENT no_such_event ON SCHEDULE EVERY '2:3' DAY_HOUR}) <b>Returns</b> ERROR 1517 (HY000): Unknown event 'no_such_event'</pre>

		<p>In each of the following examples, assume that the event named myevent is defined as shown here:</p>
		<pre>(sql sqlHandle {CREATE EVENT myevent ON SCHEDULE EVERY 6 HOUR COMMENT 'A sample comment.' DO UPDATE myschema.mytable SET mycol = mycol + 1})</pre>

		<p>The following statement changes the schedule for myevent from once every six hours starting immediately to once every twelve hours, starting four hours from the time the statement is run:</p>
		<pre>(sql sqlHandle {ALTER EVENT myevent ON SCHEDULE EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + 4 HOUR})</pre>

		<p>It is possible to change multiple characteristics of an event in a single statement.
			This example changes the SQL statement executed by myevent to one that deletes all records from mytable;
			it also changes the schedule for the event such that it executes once, one day after this ALTER EVENT statement is run.</p>
		<pre>(sql sqlHandle {ALTER TABLE myevent ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 DAY DO TRUNCATE TABLE myschema.mytable})</pre>
		
		<p>It is necessary to include only those options in an ALTER EVENT statement which correspond to characteristics that you actually wish to change;
			options which are omitted retain their existing values. This includes any default values for CREATE EVENT such as ENABLE.</p>

		<p>To disable myevent, use this ALTER EVENT statement:</p>

		<pre>(sql sqlHandle {ALTER EVENT myevent DISABLE})</pre>

		<p>The ON SCHEDULE clause may use expressions involving built-in SQL functions and user variables to obtain any of the timestamp or interval values which it contains.
			You may not use stored routines or user-defined functions in such expressions, nor may you use any table references;
			however, you may use SELECT FROM DUAL. This is true for both ALTER EVENT and CREATE EVENT statements.
			References to stored routines, user-defined functions, and tables in such cases are specifically disallowed, and fail with an error.</p>

		<p>An ALTER EVENT statement that contains another ALTER EVENT statement in its DO clause appears to succeed;
			however, when the server attempts to execute the resulting scheduled event, the execution fails with an error.</p>

		<p>To rename an event, use the ALTER EVENT statement's RENAME TO clause. This statement renames the event myevent to yourevent:</p>
		<pre>(sql sqlHandle {ALTER EVENT myevent RENAME TO yourevent})</pre>
		
		<p>You can also move an event to a different database using ALTER EVENT ... RENAME TO ... and db_name.event_name notation, as shown here:</p>
		<pre>(sql sqlHandle {ALTER EVENT olddb.myevent RENAME TO newdb.myevent})</pre>
		
		<p>To execute the previous statement, the user executing it must have the EVENT privilege on both the olddb and newdb databases.</p>

		<p>Note: There is no RENAME EVENT statement.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SALTER PROCEDURE and ALTER FUNCTION Syntax"></A>ALTER PROCEDURE and ALTER FUNCTION Syntax</H2></P>
		<pre>ALTER {PROCEDURE | FUNCTION} sp_name [characteristic ...]

characteristic:
    { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
  | COMMENT 'string'</pre>
 
		<p>This statement can be used to change the characteristics of a stored procedure or function.
			You must have the ALTER ROUTINE privilege for the routine. (That privilege is granted automatically to the routine creator.)
			If binary logging is enabled, the ALTER FUNCTION statement might also require the SUPER privilege.</p>

		<p>More than one change may be specified in an ALTER PROCEDURE or ALTER FUNCTION statement.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SALTER TABLE Syntax"></A>ALTER TABLE Syntax</H2></P>
		<pre>ALTER [ONLINE | OFFLINE] [IGNORE] TABLE tbl_name
    alter_specification [, alter_specification] ...

alter_specification:
    table_option ...
  | ADD [COLUMN] col_name column_definition
        [FIRST | AFTER col_name ]
  | ADD [COLUMN] (col_name column_definition,...)
  | ADD {INDEX|KEY} [index_name]
        [index_type] (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]] PRIMARY KEY
        [index_type] (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]]
        UNIQUE [INDEX|KEY] [index_name]
        [index_type] (index_col_name,...) [index_option] ...
  | ADD FULLTEXT [INDEX|KEY] [index_name]
        (index_col_name,...) [index_option] ...
  | ADD SPATIAL [INDEX|KEY] [index_name]
        (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]]
        FOREIGN KEY [index_name] (index_col_name,...)
        reference_definition
  | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  | CHANGE [COLUMN] old_col_name new_col_name column_definition
        [FIRST|AFTER col_name]
  | MODIFY [COLUMN] col_name column_definition
        [FIRST | AFTER col_name]
  | DROP [COLUMN] col_name
  | DROP PRIMARY KEY
  | DROP {INDEX|KEY} index_name
  | DROP FOREIGN KEY fk_symbol
  | DISABLE KEYS
  | ENABLE KEYS
  | RENAME [TO] new_tbl_name
  | ORDER BY col_name [, col_name] ...
  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]
  | [DEFAULT] CHARACTER SET [=] charset_name [COLLATE [=] collation_name]
  | DISCARD TABLESPACE
  | IMPORT TABLESPACE
  | partition_options
  | ADD PARTITION (partition_definition)
  | DROP PARTITION partition_names
  | COALESCE PARTITION number
  | REORGANIZE PARTITION partition_names INTO (partition_definitions)
  | ANALYZE PARTITION partition_names
  | CHECK PARTITION partition_names
  | OPTIMIZE PARTITION partition_names
  | REBUILD PARTITION partition_names
  | REPAIR PARTITION partition_names
  | REMOVE PARTITIONING

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH | RTREE}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'</pre>
  
		<p>ALTER TABLE enables you to change the structure of an existing table.
			For example, you can add or delete columns, create or destroy indexes, change the type of existing columns, or rename columns or the table itself.
			You can also change the comment for the table and type of the table.</p>

		<p>The syntax for many of the allowable alterations is similar to clauses of the CREATE TABLE statement.</p>
		<p>Some operations may result in warnings if attempted on a table for which the storage engine does not support the operation.
			These warnings can be displayed with SHOW WARNINGS.</p>

		<p>In most cases, ALTER TABLE works by making a temporary copy of the original table.
			The alteration is performed on the copy, and then the original table is deleted and the new one is renamed.
			While ALTER TABLE is executing, the original table is readable by other clients.
			Updates and writes to the table are stalled until the new table is ready, and then are automatically redirected to the new table without any failed updates.
			The temporary table is created in the database directory of the new table.
			This can be different from the database directory of the original table if ALTER TABLE is renaming the table to a different database.</p>

		<p>In some cases, no temporary table is necessary:</p>
		<ul>
			<li>
				Alterations that modify only table metadata and not table data can be made immediately by altering the table's .frm file and not touching table contents.
				The following changes are fast alterations that can be made this way:
				<ul>
					<li>Renaming a column or index.</li>
					<li>Changing the default value of a column.</li>
					<li>Changing the definition of an ENUM or SET column by adding new enumeration or set members to the end of the list of valid member values.</li>
				</ul>
			</li>
			<li>
				In some cases, an operation such as changing a VARCHAR(10) column to VARCHAR(15) may be immediate, but this depends on the storage engine for the table.
				A change such as VARCHAR(10) to a length greater than 255 is not immediate because data values must be modified from using one byte to store the length to using two bytes.
			</li>
			<li>
				If you use ALTER TABLE tbl_name RENAME TO new_tbl_name without any other options, SQL simply renames any files that correspond to the table tbl_name.
				(You can also use the RENAME TABLE statement to rename tables.) Any privileges granted specifically for the renamed table are not migrated to the new name.
				They must be changed manually.
			</li>
			<li>
				ALTER TABLE ... ADD PARTITION creates no temporary table except for SQL Cluster.
				ADD or DROP operations for RANGE or LIST partitions are immediate operations or nearly so.
				ADD or COALESCE operations for HASH or KEY partitions copy data between changed partitions;
				unless LINEAR HASH or LINEAR KEY was used, this is much the same as creating a new table (although the operation is done partition by partition).
				REORGANIZE operations copy only changed partitions and do not touch unchanged ones.
			</li>
		</ul>
		
		<p>If other cases, SQL creates a temporary table, even if the data wouldn't strictly need to be copied.
			For MyISAM tables, you can speed up the index re-creation operation (which is the slowest part of the alteration process)
			by setting the myisam_sort_buffer_size system variable to a high value.</p>

		<ul>
			<li>To use ALTER TABLE, you need ALTER, INSERT, and CREATE privileges for the table.</li>
			<li>ADD INDEX and DROP INDEX operations are performed online when the indexes are on variable-width columns only.</li>
			<li>IGNORE is a SQL extension to standard SQL. It controls how ALTER TABLE works if there are duplicates on unique keys in the new table or if warnings occur when strict mode is enabled.
				If IGNORE is not specified, the copy is aborted and rolled back if duplicate-key errors occur.
				If IGNORE is specified, only the first row is used of rows with duplicates on a unique key, The other conflicting rows are deleted.
				Incorrect values are truncated to the closest matching acceptable value.</li>
			<li>
				<p>table_option signifies a table option of the kind that can be used in the CREATE TABLE statement, such as ENGINE, AUTO_INCREMENT, or AVG_ROW_LENGTH.
					However, ALTER TABLE ignores the DATA DIRECTORY and INDEX DIRECTORY table options.</p>

				<p>For example, to convert a table to be an InnoDB table, use this statement:</p>

				<pre>(sql sqlHandle {ALTER TABLE t1 ENGINE = InnoDB})</pre>

				<p>The outcome of attempting to change a table's storage engine is affected by whether the desired storage engine
					is available and the setting of the NO_ENGINE_SUBSTITUTION SQL mode.</p>

				<p>To prevent inadvertent loss of data, ALTER TABLE cannot be used to change the storage engine of a table to MERGE or BLACKHOLE.</p>

				<p>To change the value of the AUTO_INCREMENT counter to be used for new rows, do this:</p>

				<pre>(sql sqlHandle {ALTER TABLE t2 AUTO_INCREMENT = value})</pre>
				
				<p>You cannot reset the counter to a value less than or equal to any that have already been used.
					For MyISAM, if the value is less than or equal to the maximum value currently in the AUTO_INCREMENT column,
					the value is reset to the current maximum plus one. For InnoDB, if the value is less than the current maximum value in the column,
					no error occurs and the current sequence value is not changed.</p>
				
			<li>
				<p>You can issue multiple ADD, ALTER, DROP, and CHANGE clauses in a single ALTER TABLE statement, separated by commas.
				This is a SQL extension to standard SQL, which allows only one of each clause per ALTER TABLE statement.
				For example, to drop multiple columns in a single statement, do this:</p>

				<pre>(sql sqlHandle {ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d})</pre>
			</li>
			<li>CHANGE col_name, DROP col_name, and DROP INDEX are SQL extensions to standard SQL.</li>
			<li>MODIFY is an Oracle extension to ALTER TABLE.</li>
			<li>The word COLUMN is optional and can be omitted.</li>
			<li>column_definition clauses use the same syntax for ADD and CHANGE as for CREATE TABLE.</li>
			<li>
				<p>You can rename a column using a CHANGE old_col_name new_col_name column_definition clause.
				To do so, specify the old and new column names and the definition that the column currently has.
				For example, to rename an INTEGER column from a to b, you can do this:</p>
				<pre>(sql sqlHandle {ALTER TABLE t1 CHANGE a b INTEGER})</pre>
				
				<p>If you want to change a column's type but not the name,
					CHANGE syntax still requires an old and new column name, even if they are the same. For example:</p>
				<pre>(sql sqlHandle {ALTER TABLE t1 CHANGE b b BIGINT NOT NULL})</pre>
				
				<p>You can also use MODIFY to change a column's type without renaming it:</p>
				<pre>(sql sqlHandle {ALTER TABLE t1 MODIFY b BIGINT NOT NULL})</pre>
			</li>
			<li>If you use CHANGE or MODIFY to shorten a column for which an index exists on the column,
				and the resulting column length is less than the index length, SQL shortens the index automatically.</li>

			<li>
				<p>When you change a data type using CHANGE or MODIFY, SQL tries to convert existing column values to the new type as well as possible.</p>
				<p>Warning: This conversion may result in alteration of data. For example, if you shorten a string column, values may be truncated.
					To prevent the operation from succeeding if conversions to the new data type would result in loss of data,
					enable strict SQL mode before using ALTER TABLE.</p>
			</li>

			<li>To add a column at a specific position within a table row, use FIRST or AFTER col_name.
				The default is to add the column last. You can also use FIRST and AFTER in CHANGE or MODIFY operations to reorder columns within a table.</li>

			<li>ALTER ... SET DEFAULT or ALTER ... DROP DEFAULT specify a new default value for a column or remove the old default value, respectively.
				If the old default is removed and the column can be NULL, the new default is NULL.
				If the column cannot be NULL, SQL assigns a default value.</li>

			<li>DROP INDEX removes an index. This is a SQL extension to standard SQL.
				If you are unsure of the index name, use SHOW INDEX FROM tbl_name.</li>

			<li>If columns are dropped from a table, the columns are also removed from any index of which they are a part.
				If all columns that make up an index are dropped, the index is dropped as well.</li>

			<li>If a table contains only one column, the column cannot be dropped.
				If what you intend is to remove the table, use DROP TABLE instead.</li>

			<li>DROP PRIMARY KEY drops the primary key. If there is no primary key, an error occurs.</li>

			<li>If you add a UNIQUE INDEX or PRIMARY KEY to a table, it is stored before any non-unique index so that SQL can detect duplicate keys as early as possible.</li>

			<li>Some storage engines allow you to specify an index type when creating an index. The syntax for the index_type specifier is USING type_name.
				The preferred position is after the column list.</li>

			<li>index_option values specify additional options for an index. USING is one such option.</li>

			<li>After an ALTER TABLE statement, it may be necessary to run ANALYZE TABLE to update index cardinality information.</li>

			<li>
				<p>ORDER BY enables you to create the new table with the rows in a specific order.
				Note that the table does not remain in this order after inserts and deletes.
				This option is useful primarily when you know that you are mostly to query the rows in a certain order most of the time.
				By using this option after major changes to the table, you might be able to get higher performance.
				In some cases, it might make sorting easier for SQL if the table is in order by the column that you want to order it by later.</p>

				<p>ORDER BY syntax allows for one or more column names to be specified for sorting,
				each of which optionally can be followed by ASC or DESC to indicate ascending or descending sort order, respectively.
				The default is ascending order. Only column names are allowed as sort criteria; arbitrary expressions are not allowed.</p>

				<p>ORDER BY does not make sense for InnoDB tables that contain a user-defined clustered index (PRIMARY KEY or NOT NULL UNIQUE index).
					InnoDB always orders table rows according to such an index if one is present.</p>

				<p>Note: When used on a partitioned table, ALTER TABLE ... ORDER BY orders rows within each partition only.</p>
			</li>
			<li>
				<p>If you use ALTER TABLE on a MyISAM table, all non-unique indexes are created in a separate batch (as for REPAIR TABLE).
					This should make ALTER TABLE much faster when you have many indexes.</p>
				<p>This feature can be activated explicitly for a MyISAM table.
					ALTER TABLE ... DISABLE KEYS tells SQL to stop updating non-unique indexes.
					ALTER TABLE ... ENABLE KEYS then should be used to re-create missing indexes.
					SQL does this with a special algorithm that is much faster than inserting keys one by one,
					so disabling keys before performing bulk insert operations should give a considerable speedup.
					Using ALTER TABLE ... DISABLE KEYS requires the INDEX privilege in addition to the privileges mentioned earlier.</p>

				<p>While the non-unique indexes are disabled, they are ignored for statements such as SELECT and EXPLAIN that otherwise would use them.</p>
			</li>
			<li>If ALTER TABLE for an InnoDB table results in changes to column values (for example, because a column is truncated),
				InnoDB's FOREIGN KEY constraint checks do not notice possible violations caused by changing the values.</li>
			<li>
				<p>The FOREIGN KEY and REFERENCES clauses are supported by the InnoDB storage engine,
				which implements ADD [CONSTRAINT [symbol]] FOREIGN KEY (...) REFERENCES ... (...). 
				For other storage engines, the clauses are parsed but ignored. The CHECK clause is parsed but ignored by all storage engines.
				The reason for accepting but ignoring syntax clauses is for compatibility, to make it easier to port code from other SQL servers,
				and to run applications that create tables with references.</p>
				
				<p>Important: The inline REFERENCES specifications where the references are defined as part of the column specification are silently ignored by InnoDB.
				InnoDB only accepts REFERENCES clauses defined as part of a separate FOREIGN KEY specification.</p>
				
				<p>Note: Partitioned tables do not support foreign keys.</p>
			</li>
			<li>
				<p>InnoDB supports the use of ALTER TABLE to drop foreign keys:</p>
				<pre>(sql sqlHandle {ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol})</pre>
			</li>
			<li>You cannot add a foreign key and drop a foreign key in separate clauses of a single ALTER TABLE statement. You must use separate statements.</li>
			<li>
				<p>For an InnoDB table that is created with its own tablespace in an .ibd file, that file can be discarded and imported.
					To discard the .ibd file, use this statement:</p>
				<pre>(sql sqlHandle {ALTER TABLE tbl_name DISCARD TABLESPACE})</pre>
				
				<p>This deletes the current .ibd file, so be sure that you have a backup first.
					Attempting to access the table while the tablespace file is discarded results in an error.</p>
				
				<p>To import the backup .ibd file back into the table, copy it into the database directory, and then issue this statement:</p>

				<pre>(sql sqlHandle {ALTER TABLE tbl_name IMPORT TABLESPACE})</pre>
			</li>
			<li>Pending INSERT DELAYED statements are lost if a table is write locked and ALTER TABLE is used to modify the table structure.</li>
			<li>
				<p>If you want to change the table default character set and all character columns (CHAR, VARCHAR, TEXT) to a new character set, use a statement like this:</p>
				<pre>(sql sqlHandle {ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name})</pre>
				<p>For a column that has a data type of VARCHAR or one of the TEXT types,
					CONVERT TO CHARACTER SET will change the data type as necessary to ensure that the new column is long enough to store as many characters as the original column.
					For example, a TEXT column has two length bytes, which store the byte-length of values in the column, up to a maximum of 65,535.
					For a latin1 TEXT column, each character requires a single byte, so the column can store up to 65,535 characters.
					If the column is converted to utf8, each character might require up to three bytes, for a maximum possible length of 3 × 65,535 = 196,605 bytes.
					That length will not fit in a TEXT column's length bytes, so SQL will convert the data type to MEDIUMTEXT,
					which is the smallest string type for which the length bytes can record a value of 196,605. Similarly, a VARCHAR column might be converted to MEDIUMTEXT.</p>

				<p>To avoid data type changes of the type just described, do not use CONVERT TO CHARACTER SET. Instead, use MODIFY to change individual columns. For example:</p>
				<pre>(sql sqlHandle {ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8})</pre>
				<pre>(sql sqlHandle {ALTER TABLE t MODIFY latin1_varchar_col VARCHAR(M) CHARACTER SET utf8})</pre>
				
				<p>If you specify CONVERT TO CHARACTER SET binary, the CHAR, VARCHAR, and TEXT columns are converted to their corresponding binary string types (BINARY, VARBINARY, BLOB).
					This means that the columns no longer will have a character set and a subsequent CONVERT TO operation will not apply to them.</p>

				<p>If charset_name is DEFAULT, the database character set is used.</p>

				<p>Warning: The CONVERT TO operation converts column values between the character sets.
					This is not what you want if you have a column in one character set (like latin1) but the stored values actually use some other,
					incompatible character set (like utf8). In this case, you have to do the following for each such column:</p>

				<pre>(sql sqlHandle {ALTER TABLE t1 CHANGE c1 c1 BLOB})</pre>
				<pre>(sql sqlHandle {ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8})</pre>

				<p>The reason this works is that there is no conversion when you convert to or from BLOB columns.</p>

				<p>To change only the default character set for a table, use this statement:</p>

				<pre>(sql sqlHandle {ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name})</pre>
				<p>The word DEFAULT is optional. The default character set is the character set that is used if you do not specify
					the character set for columns that you add to a table later (for example, with ALTER TABLE ... ADD column).</p>
			</li>
			<li>
				<p>A number of partitioning-related extensions to ALTER TABLE were added in SQL.
					These can be used with partitioned tables for repartitioning, for adding, dropping, merging, and splitting partitions, and for performing partitioning maintenance.</p>

				<p>Simply using a partition_options clause with ALTER TABLE on a partitioned table repartitions the table according to the partitioning scheme defined by the partition_options.
					This clause always begins with PARTITION BY, and follows the same syntax and other rules as apply to the partition_options clause for CREATE TABLE,
					and can also be used to partition an existing table that is not already partitioned. For example, consider a (non-partitioned) table defined as shown here:</p>

				<pre>(sql sqlHandle {CREATE TABLE t1 (id INT, year_col INT)})</pre>
				
				<p>This table can be partitioned by HASH, using the id column as the partitioning key, into 8 partitions by means of this statement:</p>

				<pre>(sql sqlHandle {ALTER TABLE t1 PARTITION BY HASH(id) PARTITIONS 8})</pre>
				
				<p>The table that results from using an ALTER TABLE ... PARTITION BY statement must follow the same rules as one created using CREATE TABLE ... PARTITION BY.
					This includes the rules governing the relationship between any unique keys (including any primary key) that the table might have,
					and the column or columns used in the partitioning expression. 
					The CREATE TABLE ... PARTITION BY rules for specifying the number of partitions also apply to ALTER TABLE ... PARTITION BY.</p>

				<p>The partition_definition clause for ALTER TABLE ADD PARTITION supports the same options as the clause of the same name for the CREATE TABLE statement.
					Suppose that you have the partitioned table created as shown here:</p>

				<pre>(sql sqlHandle {CREATE TABLE t1 (id INT, year_col INT) 
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999))})</pre>
	
				<p>You can add a new partition p3 to this table for storing values less than 2002 as follows:</p>
				<pre>(sql sqlHandle {ALTER TABLE t1 ADD PARTITION (PARTITION p3 VALUES LESS THAN (2002))})</pre>

				<p>DROP PARTITION can be used to drop one or more RANGE or LIST partitions.
					This statement cannot be used with HASH or KEY partitions; instead, use COALESCE PARTITION (see below).
					Any data that was stored in the dropped partitions named in the partition_names list is discarded.
					For example, given the table t1 defined previously, you can drop the partitions named p0 and p1 as shown here:</p>

				<pre>(sql sqlHandle {ALTER TABLE t1 DROP PARTITION p0, p1})</pre>
				
				<p>Note: DROP PARTITION does not work with tables that use the NDBCLUSTER storage engine.</p>

				<p>ADD PARTITION and DROP PARTITION do not currently support IF [NOT] EXISTS.
					It is also not possible to rename a partition or a partitioned table.
					Instead, if you wish to rename a partition, you must drop and re-create the partition;
					if you wish to rename a partitioned table, you must instead drop all partitions, rename the table, and then add back the partitions that were dropped.</p>

				<p>COALESCE PARTITION can be used with a table that is partitioned by HASH or KEY to reduce the number of partitions by number.
					Suppose that you have created table t2 using the following definition:</p>

				<pre>(sql sqlHandle {CREATE TABLE t2 (name VARCHAR (30), started DATE)
PARTITION BY HASH( YEAR(started) )
PARTITIONS 6})</pre>

				<p>You can reduce the number of partitions used by t2 from 6 to 4 using the following statement:</p>
				<pre>(sql sqlHandle {ALTER TABLE t2 COALESCE PARTITION 2})</pre>

				<p>The data contained in the last number partitions will be merged into the remaining partitions.
					In this case, partitions 4 and 5 will be merged into the first 4 partitions (the partitions numbered 0, 1, 2, and 3).</p>

				<p>To change some but not all the partitions used by a partitioned table, you can use REORGANIZE PARTITION. This statement can be used in several ways:</p>
				<ul>
					<li>To merge a set of partitions into a single partition.
						This can be done by naming several partitions in the partition_names list and supplying a single definition for partition_definition.</li>
					<li>To split an existing partition into several partitions.
						You can accomplish this by naming a single partition for partition_names and providing multiple partition_definitions.</li>
					<li>
						<p>To change the ranges for a subset of partitions defined using VALUES LESS THAN or the value lists for a subset of partitions defined using VALUES IN.</p>
						<p>Note: For partitions that have not been explicitly named, SQL automatically provides the default names p0, p1, p2, and so on.</p>
					</li>
				</ul>
				<p>Important: Only a single PARTITION BY, ADD PARTITION, DROP PARTITION, REORGANIZE PARTITION, or COALESCE PARTITION clause can be used in a given ALTER TABLE statement.</p>
			</li>
			<li>
				<p>Several additional options were introduced in SQL for providing partition maintenance and repair functionality analogous to that implemented for non-partitioned tables by statements such as CHECK TABLE and REPAIR TABLE 
				(which are not supported for partitioned tables). These include ANALYZE PARTITION, CHECK PARTITION, OPTIMIZE PARTITION, REBUILD PARTITION, and REPAIR PARTITION. 
				Each of these options takes a partition_names clause consisting of one or more names of partitions, separated by commas. 
				The partitions must already exist in the table to be altered.</p>

				<p>The ANALYZE PARTITION, CHECK PARTITION, OPTIMIZE PARTITION, and REPAIR PARTITION options were removed in SQL</p>

				<p>Note: You can use the statements ANALYZE TABLE, CHECK TABLE, OPTIMIZE TABLE, and REPAIR TABLE on partitioned tables.</p>
			</li>
			<li>REMOVE PARTITIONING was introduced in SQL for the purpose of removing a table's partitioning without otherwise affecting the table or its data.
				This option can be combined with other ALTER TABLE options such as those used to add, drop, or rename drop columns or indexes.</li>
		</ul>
		
		<p>Here are some examples that show uses of ALTER TABLE. Begin with a table t1 that is created as shown here:</p>
		<pre>(sql sqlHandle {CREATE TABLE t1 (a INTEGER,b CHAR(10))})</pre>
		
		<p>To rename the table from t1 to t2:</p>
		<pre>(sql sqlHandle {ALTER TABLE t1 RENAME t2})</pre>
		
		<p>To change column a from INTEGER to TINYINT NOT NULL (leaving the name the same),
			and to change column b from CHAR(10) to CHAR(20) as well as renaming it from b to c:</p>
		<pre>(sql sqlHandle {ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20)})</pre>
		
		<p>To add a new TIMESTAMP column named d:</p>
		<pre>(sql sqlHandle {ALTER TABLE t2 ADD d TIMESTAMP})</pre>
		
		<p>To add an index on column d and a UNIQUE index on column a:</p>
		<pre>(sql sqlHandle {ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a)}</pre>
		
		<p>To remove column c:</p>
		<pre>(sql sqlHandle {ALTER TABLE t2 DROP COLUMN c})</pre>
		
		<p>To add a new AUTO_INCREMENT integer column named c:</p>
		<pre>(sql sqlHandle {ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD PRIMARY KEY (c)})</pre>
		
		<p>We indexed c (as a PRIMARY KEY) because AUTO_INCREMENT columns must be indexed, and we declare c as NOT NULL because primary key columns cannot be NULL.</p>
		
		<p>When you add an AUTO_INCREMENT column, column values are filled in with sequence numbers automatically.
			For MyISAM tables, you can set the first sequence number by executing SET INSERT_ID=value before ALTER TABLE or by using the AUTO_INCREMENT=value table option.</p>

		<p>With MyISAM tables, if you do not change the AUTO_INCREMENT column, the sequence number is not affected.
			If you drop an AUTO_INCREMENT column and then add another AUTO_INCREMENT column, the numbers are resequenced beginning with 1.</p>

		<p>When replication is used, adding an AUTO_INCREMENT column to a table might not produce the same ordering of the rows on the slave and the master.
			This occurs because the order in which the rows are numbered depends on the specific storage engine used for the table and the order in which the rows were inserted.
			If it is important to have the same order on the master and slave, the rows must be ordered before assigning an AUTO_INCREMENT number.
			Assuming that you want to add an AUTO_INCREMENT column to the table t1, the following statements produce a new table t2 identical to t1 but with an AUTO_INCREMENT column:</p>

		<pre>CREATE TABLE t2 (id INT AUTO_INCREMENT PRIMARY KEY)
SELECT * FROM t1 ORDER BY col1, col2;</pre>

		<p>This assumes that the table t1 has columns col1 and col2.</p>

		<p>This set of statements will also produce a new table t2 identical to t1, with the addition of an AUTO_INCREMENT column:</p>

		<pre>(sql sqlHandle {CREATE TABLE t2 LIKE t1})</pre>
		<pre>(sql sqlHandle {ALTER TABLE T2 ADD id INT AUTO_INCREMENT PRIMARY KEY})</pre>
		<pre>(sql sqlHandle {INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2})</pre>

		<p>Important: To guarantee the same ordering on both master and slave, all columns of t1 must be referenced in the ORDER BY clause.</p>

		<p>Regardless of the method used to create and populate the copy having the AUTO_INCREMENT column,
			the final step is to drop the original table and then rename the copy:</p>

		<pre>(sql sqlHandle {DROP t1})</pre>
		<pre>(sql sqlHandle {ALTER TABLE t2 RENAME t1})</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SALTER VIEW Syntax"></A>ALTER VIEW Syntax</H2></P>
		<pre>ALTER
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { user | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]</pre>
		<p>This statement changes the definition of a view, which must exist.
			The syntax is similar to that for CREATE VIEW and the effect is the same as for CREATE OR REPLACE VIEW.
			This statement requires the CREATE VIEW and DROP privileges for the view, and some privilege for each column referred to in the SELECT statement.
			ALTER VIEW is allowed only to the definer or users with the SUPER privilege.</P>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE DATABASE Syntax"></A>CREATE DATABASE Syntax</H2></P>
		<pre>CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification] ...

create_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name</pre>
  
		<p>CREATE DATABASE creates a database with the given name.
			To use this statement, you need the CREATE privilege for the database.
			CREATE SCHEMA is a synonym for CREATE DATABASE.</p>

		<p>An error occurs if the database exists and you did not specify IF NOT EXISTS.</p>

		<p>create_specification options specify database characteristics.
			Database characteristics are stored in the db.opt file in the database directory.
			The CHARACTER SET clause specifies the default database character set.
			The COLLATE clause specifies the default database collation.</p>

		<p>A database in SQL is implemented as a directory containing files that correspond to tables in the database.
			Because there are no tables in a database when it is initially created, the CREATE DATABASE statement creates only a directory under the SQL data directory and the db.opt file.</p>

		<p>If you manually create a directory under the data directory (for example, with mkdir),
			the server considers it a database directory and it shows up in the output of SHOW DATABASES.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE EVENT Syntax"></A>CREATE EVENT Syntax</H2></P>
		<pre>CREATE 
    [DEFINER = { user | CURRENT_USER }]
    EVENT 
    [IF NOT EXISTS]
    event_name    
    ON SCHEDULE schedule
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'comment']
    DO sql_statement;

schedule:
    AT timestamp [+ INTERVAL interval] ...
  | EVERY interval 
    [STARTS timestamp [+ INTERVAL interval] ...] 
    [ENDS timestamp [+ INTERVAL interval] ...]

interval:
    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}</pre>
			  
		<p>This statement creates and schedules a new event.
			The minimum requirements for a valid CREATE EVENT statement are as follows:</p>
		<ul>
			<li>The keywords CREATE EVENT plus an event name, which uniquely identifies the event in the current schema.</li>
			<li>An ON SCHEDULE clause, which determines when and how often the event executes.</li>
			<li>A DO clause, which contains the SQL statement to be executed by an event.</li>
		</ul>

		<p>This is an example of a minimal CREATE EVENT statement:</p>
		<pre>(sql sqlHandle {CREATE EVENT myevent ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR DO UPDATE myschema.mytable SET mycol = mycol + 1})</pre>

		<p>The previous statement creates an event named myevent.
			This event executes once - one hour following its creation - by running an SQL statement that increments the value of the myschema.mytable table's mycol column by 1.</p>

		<p>The event_name must be a valid SQL identifier with a maximum length of 64 characters.
			It may be delimited using back ticks, and may be qualified with the name of a database schema.
			An event is associated with both a SQL user (the definer) and a schema, and its name must be unique among names of events within that schema.
			In general, the rules governing event names are the same as those for names of stored routines.</p>

		<p>If no schema is indicated as part of event_name, the default (current) schema is assumed.</p>

		<p>Note: SQL uses case-insensitive comparisons when checking for the uniqueness of event names.
			This means that, for example, you cannot have two events named myevent and MyEvent in the same database schema.</p>

		<p>The DEFINER clause specifies the SQL account to be used when checking access privileges at event execution time.
			If a user value is given, it should be a SQL account in 'user_name'@'host_name' format (the same format used in the GRANT statement).
			The user_name and host_name values both are required. The definer can also be given as CURRENT_USER or CURRENT_USER().
			The default DEFINER value is the user who executes the CREATE EVENT statement. (This is the same as DEFINER = CURRENT_USER.)</p>

		<p>IF NOT EXISTS has the same meaning for CREATE EVENT as for CREATE TABLE: If an event named event_name already exists in the same schema,
			no action is taken, and no error results. (However, a warning is generated in such cases.)</p>

		<p>The ON SCHEDULE clause determines when, how often, and for how long the sql_statement defined for the event repeats.
			This clause takes one of two forms:</p>

		<ul>
			<li>
			<p>AT timestamp is used for a one-time event. It specifies that the event executes one time only at the date and time given by timestamp,
				which must include both the date and time, or must be an expression that resolves to a datetime value.
				You may use a value of either the DATETIME or TIMESTAMP type for this purpose.
				If the date is in the past, a warning occurs, as shown here:</p>

			<pre>(sql sqlHandle {SELECT NOW()}) <b>Returns</b>
#(rec(|NOW()|:Date:1)| |NOW()|:#Feb,10,2006:23:59:01)</pre>

			<pre>(sql sqlHandle {CREATE EVENT e_totals ON SCHEDULE AT '2006-02-10 23:59:00' DO INSERT INTO test.totals VALUES (NOW())})</pre>

			<pre>(sql sqlHandle {SHOW WARNINGS}) <b>Returns</b>
#(rec(Level:Character:7 Code:Long:1 Message:Object:1)| Level:"Note" Code:1588 Message:"Event execution time is in the past and ON COMPLETION NOT PRESERVE is set. The event was dropped immediately after creation.")</pre>

			<p>CREATE EVENT statements which are themselves invalid - for whatever reason - fail with an error.</p>

			<p>You may use CURRENT_TIMESTAMP to specify the current date and time. In such a case, the event acts as soon as it is created.</p>

			<p>To create an event which occurs at some point in the future relative to the current date and time - such as that expressed by the phrase "three weeks from now" - you can use the optional clause + INTERVAL interval.
				The interval portion consists of two parts, a quantity and a unit of time, and follows the same syntax rules that govern intervals used in the DATE_ADD() function.
				The units keywords are also the same, except that you cannot use any units involving microseconds when defining an event.
				With some interval types, complex time units may be used. For example, "two minutes and ten seconds" can be expressed as + INTERVAL '2:10' MINUTE_SECOND.</p>

			<p>You can also combine intervals. For example, AT CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY is equivalent to "three weeks and two days from now".
				Each portion of such a clause must begin with + INTERVAL.</p>
			</li>
			<li>
			<p>To repeat actions at a regular interval, use an EVERY clause. The EVERY keyword is followed by an interval as described in the previous dicussion of the AT keyword.
				(+ INTERVAL is not used with EVERY.) For example, EVERY 6 WEEK means "every six weeks".</p>

			<p>Although + INTERVAL clauses are not allowed in an EVERY clause, you can use the same complex time units allowed in a + INTERVAL.</p>

			<p>An EVERY clause may also contain an optional STARTS clause.
				STARTS is followed by a timestamp value which indicates when the action should begin repeating, and may also use + INTERVAL interval in order to specify an amount of time "from now".
				For example, EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + 1 WEEK means "every three months, beginning one week from now".
				Similarly, you can express "every two weeks, beginning six hours and fifteen minutes from now" as EVERY 2 WEEK STARTS CURRENT_TIMESTAMP + INTERVAL '6:15' HOUR_MINUTE.
				Not specifying STARTS is the same as using STARTS CURRENT_TIMESTAMP - that is, the action specified for the event begins repeating immediately upon creation of the event.</p>

			<p>An EVERY clause may also contain an optional ENDS clause. The ENDS keyword is followed by a timestamp value which tells SQL when the event should stop repeating.
				You may also use + INTERVAL interval with ENDS; for instance,
				EVERY 12 HOUR STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS CURRENT_TIMESTAMP + INTERVAL 4 WEEK is equivalent to "every twelve hours,
				beginning thirty minutes from now, and ending four weeks from now". Not using ENDS means that the event continues executing indefinitely.</p>

			<p>ENDS supports the same syntax for complex time units as STARTS does.</p>

			<p>You may use STARTS, ENDS, both, or neither in an EVERY clause.</p>
			</li>
		</ul>
		<p>The ON SCHEDULE clause may use expressions involving built-in SQL functions and user variables to obtain any of the timestamp or interval values which it contains.
			You may not use stored functions or user-defined functions in such expressions, nor may you use any table references; however, you may use SELECT FROM DUAL.
			This is true for both CREATE EVENT and ALTER EVENT statements.
			References to stored functions, user-defined functions, and tables in such cases are specifically disallowed, and fail with an error.</p>

		<p>Normally, once an event has expired, it is immediately dropped. You can override this behavior by specifying ON COMPLETION PRESERVE.
			Using ON COMPLETION NOT PRESERVE merely makes the default non-persistent behavior explicit.</p>

		<p>You can create an event but keep it from being active using the DISABLE keyword.
			Alternatively, you may use ENABLE to make explicit the default status, which is active.
			This is most useful in conjunction with ALTER EVENT.</p>

		<p>You may supply a comment for an event using a COMMENT clause.
			comment may be any string of up to 64 characters that you wish to use for describing the event.
			The comment text, being a string literal, must be surrounded by quotation marks.</p>

		<p>The DO clause specifies an action carried by the event, and consists of an SQL statement.
			Nearly any valid SQL statement which can be used in a stored routine can also be used as the action statement for a scheduled event.
			For example, the following event e_hourly deletes all rows from the sessions table once per hour, where this table is part of the site_activity schema:</p>

		<pre>(sql sqlHandle {CREATE EVENT e_hourly
    ON SCHEDULE 
      EVERY 1 HOUR
    COMMENT 'Clears out sessions table each hour.'
    DO
      DELETE FROM site_activity.sessions})</pre>
	  
		<p>SQL stores the sql_mode system variable setting that is in effect at the time an event is created,
			and always executes the event with this setting in force, regardless of the current server SQL mode.</p>

		<p>A CREATE EVENT statement that contains an ALTER EVENT statement in its DO clause appears to succeed;
			however, when the server attempts to execute the resulting scheduled event, the execution fails with an error.</p>

		<p>Note: Statements such as SELECT or SHOW that merely return a result set have no effect when used in an event;
			the output from these is not sent to the MySQL Monitor, nor is it stored anywhere.
			However, you can use statements such as SELECT ... INTO and INSERT INTO ... SELECT that store a result.
			(See the next example in this section for an instance of the latter.)</p>

		<p>The schema to which an event belongs is the default schema for table references in the DO clause.
			Any references to tables in other schemas must be qualified with the proper schema name.</p>

		<p>As with stored routines, you can use compound-statement syntax in the DO clause by using the BEGIN and END keywords, as shown here:</p>

		<pre>(sql sqlHandle {
CREATE EVENT e_daily
    ON SCHEDULE
      EVERY 1 DAY
    COMMENT 'Saves total number of sessions then clears the table each day'
    DO
      BEGIN
        INSERT INTO site_activity.totals (time, total)
          SELECT CURRENT_TIMESTAMP, COUNT(*) 
            FROM site_activity.sessions;
        DELETE FROM site_activity.sessions;
      END})</pre>

		<p>More complex compound statements, such as those used in stored routines, are possible in an event.
			This example uses local variables, an error handler, and a flow control construct:</p>

		<pre>(sql sqlHandle {
CREATE EVENT e
    ON SCHEDULE 
      EVERY 5 SECOND
    DO
      BEGIN
        DECLARE v INTEGER;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;

        SET v = 0;

        WHILE v < 5 DO
          INSERT INTO t1 VALUES (0);
          UPDATE t2 SET s1 = s1 + 1;
          SET v = v + 1;
        END WHILE;
    END})</pre>

		<p>There is no way to pass parameters directly to or from events; however, it is possible to invoke a stored routine with parameters:</p>
		<pre>CREATE EVENT e_call_myproc
    ON SCHEDULE 
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO CALL myproc(5, 27);</pre>

		<p>In addition, if the event's definer has the SUPER privilege, that event may read and write global variables.
			As granting this privilege entails a potential for abuse, extreme care must be taken in doing so.</p>

		<p>Generally, any statements which are valid in stored routines may be used for action statements executed by events.
			For more information about statements allowable within stored routines.
			You can create an event as part of a stored routine, but an event cannot be created by another event.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE INDEX Syntax"></A>CREATE INDEX Syntax</H2></P>
		<pre>CREATE [ONLINE|OFFLINE] [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (index_col_name,...)
    [index_option] ...

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH | RTREE}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name</pre>

		<p>CREATE INDEX is mapped to an ALTER TABLE statement to create indexes.
			CREATE INDEX cannot be used to create a PRIMARY KEY; use ALTER TABLE instead.</p>

		<p>Normally, you create all indexes on a table at the time the table itself is created with CREATE TABLE.
			CREATE INDEX enables you to add indexes to existing tables.</p>

		<p>A column list of the form (col1,col2,...) creates a multiple-column index.
			Index values are formed by concatenating the values of the given columns.</p>

		<p>Indexes can be created that use only the leading part of column values,
			using col_name(length) syntax to specify an index prefix length:</p>
		<ul>
			<li>Prefixes can be specified for CHAR, VARCHAR, BINARY, and VARBINARY columns.</li>
			<li>BLOB and TEXT columns also can be indexed, but a prefix length must be given.</li>
			<li>Prefix lengths are given in characters for non-binary string types and in bytes for binary string types.
				That is, index entries consist of the first length characters of each column value for CHAR, VARCHAR, and TEXT columns,
				and the first length bytes of each column value for BINARY, VARBINARY, and BLOB columns.</li>
			<li>For spatial columns, prefix values cannot be given, as described later in this section.</li>
		</ul>

		<p>The statement shown here creates an index using the first 10 characters of the name column:</p>

		<pre>(sql sqlHandle {CREATE INDEX part_of_name ON customer (name(10))})</pre>
		
		<p>If names in the column usually differ in the first 10 characters,
			this index should not be much slower than an index created from the entire name column.
			Also, using column prefixes for indexes can make the index file much smaller,
			which could save a lot of disk space and might also speed up INSERT operations.</p>

		<p>Prefix lengths are storage engine-dependent (for example, a prefix can be up to 1000 bytes long for MyISAM tables,
			767 bytes for InnoDB tables). Note that prefix limits are measured in bytes,
			whereas the prefix length in CREATE INDEX statements is interpreted as number of characters for non-binary data types (CHAR, VARCHAR, TEXT).
			Take this into account when specifying a prefix length for a column that uses a multi-byte character set.
			For example, utf8 columns require up to three index bytes per character.</p>

		<p>Indexes on variable-width columns are created online; that is, creating the indexes does not require any copying or locking of the table.
			This is done automatically by the server whenever it determines that it is possible to do so;
			you do not have to use any special SQL syntax or server options to cause it to happen.</p>

		<p>In standard SQL releases, it is not possible to override the server when it determines that an index is to be created online.
			The rules and limitations governing online CREATE OFFLINE INDEX and CREATE ONLINE INDEX are the same as for ALTER OFFLINE TABLE ... ADD INDEX and ALTER ONLINE TABLE ... ADD INDEX.
			You cannot cause the online creation of an index that would normally be created offline by using the ONLINE keyword
			(if it is not possible to perform the CREATE INDEX operation online, then the ONLINE keyword is ignored).</p>

		<p>A UNIQUE index creates a constraint such that all values in the index must be distinct.
			An error occurs if you try to add a new row with a key value that matches an existing row.
			For all engines, a UNIQUE index allows multiple NULL values for columns that can contain NULL.
			If you specify a prefix value for a column in a UNIQUE index, the column values must be unique within the prefix.</p>

		<p>FULLTEXT indexes are supported only for MyISAM tables and can include only CHAR, VARCHAR, and TEXT columns.
			Indexing always happens over the entire column; column prefix indexing is not supported and any prefix length is ignored if specified.</p>

		<p>The MyISAM, InnoDB, NDB, BDB, and ARCHIVE storage engines support spatial columns such as (POINT and GEOMETRY.)
			However, support for spatial column indexing varies among engines.
			Spatial and non-spatial indexes are available according to the following rules.</p>

		<p>Spatial indexes (created using SPATIAL INDEX):</p>
		<ul>
			<li>Available only for MyISAM tables. Specifying a SPATIAL INDEX for other storage engines results in an error.</li>
			<li>Indexed columns must be NOT NULL.</li>
			<li>In SQL, column prefix lengths are prohibited. The full width of each column is indexed.</li>
		</ul>
		
		<p>Non-spatial indexes (created with INDEX, UNIQUE, or PRIMARY KEY):</p>
		<ul>
			<li>Allowed for any storage engine that supports spatial columns except ARCHIVE.</li>
			<li>Columns can be NULL unless the index is a primary key.</li>
			<li>For each spatial column in a non-SPATIAL index except POINT columns, a column prefix length must be specified.
				(This is the same requirement as for indexed BLOB columns.) The prefix length is given in bytes.</li>
			<li>The index type for a non-SPATIAL index depends on the storage engine. Currently, B-tree is used.</li>
			<li>You can add an index on a column that can have NULL values only if you are using the MyISAM, InnoDB, or MEMORY storage engine.</li>
			<li>You can add an index on a BLOB or TEXT column only if you are using the MyISAM, or InnoDB storage engine.</li>
		</ul>

		<p>An index_col_name specification can end with ASC or DESC. These keywords are allowed for future extensions for specifying ascending or descending index value storage.
			Currently, they are parsed but ignored; index values are always stored in ascending order.</p>

		<p>Index options can be given following the index column list. An index_option value can be any of the following:</p>
		<ul>
			<li>
				<p>KEY_BLOCK_SIZE [=] value</p>
				<p>This option provides a hint to the storage engine about the size in bytes to use for index key blocks.
					The engine is allowed to change the value if necessary. A value of 0 indicates that the default value should be used.</p>
			</li>
			<li>
				<p>index_type</p>
				<p>Some storage engines allow you to specify an index type when creating an index.
					The allowable index type values supported by different storage engines are shown in the following table.
					Where multiple index types are listed, the first one is the default when no index type specifier is given.</p>

				<table border="3">
					<tr>
						<th align="left">Storage Engine</th>
						<th align="left">Allowable Index Types</th>
					</tr>
					<tr>
						<td>MyISAM</td>
						<td>BTREE, RTREE</td>
					</tr>
					<tr>
						<td>InnoDB</td>
						<td>BTREE</td>
					</tr>
					<tr>
						<td>MEMORY/HEAP</td>
						<td>HASH, BTREE</td>
					</tr>
					<tr>
						<td>NDB</td>
						<td>HASH, BTREE (see note in text)</td>
					</tr>
				</table>
				
				<p>Note: BTREE indexes are implemented by the NDBCLUSTER storage engine as T-tree indexes.</p>
				<p>For indexes on NDBCLUSTER table columns, the USING clause can be specified only for a unique index or primary key.
					In such cases, the USING HASH clause prevents the creation of an implicit ordered index. Without USING HASH,
					a statement defining a unique index or primary key automatically results in the creation of a HASH index in addition to the ordered index,
					both of which index the same set of columns.</p>
					
				<p>The RTREE index type is allowable only for SPATIAL indexes.</p>

				<p>If you specify an index type that is not legal for a given storage engine,
					but there is another index type available that the engine can use without affecting query results,
					the engine uses the available type.</p>
					
				<p>Examples:</p>
				
				<pre>(sql sqlHandle {CREATE TABLE lookup (id INT) ENGINE = MEMORY})</pre>
				<pre>(sql sqlHandle {CREATE INDEX id_index USING BTREE ON lookup (id)})</pre>
				
				<p>TYPE type_name is recognized as a synonym for USING type_name. However, USING is the preferred form.</p>
			</li>
			<li>
				<p>WITH PARSER parser_name</p>
				<p>This option can be used only with FULLTEXT indexes.
					It associates a parser plugin with the index if full-text indexing and searching operations need special handling.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE PROCEDURE and CREATE FUNCTION Syntax"></A>CREATE PROCEDURE and CREATE FUNCTION Syntax</H2></P>
		<pre>CREATE
    [DEFINER = { user | CURRENT_USER }]
    PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = { user | CURRENT_USER }]
    FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body
    
proc_parameter:
    [ IN | OUT | INOUT ] param_name type
    
func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic:
    LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }
  | COMMENT 'string'

routine_body:
    Valid SQL procedure statement</pre>

		<p>These statements create stored routines. By default, a routine is associated with the default database.
			To associate the routine explicitly with a given database, specify the name as db_name.sp_name when you create it.</p>

		<p>When the routine is invoked, an implicit USE db_name is performed (and undone when the routine terminates).
			The causes the routine to have the given default database while it executes.
			USE statements within stored routines are disallowed.</p>

		<p>When a stored function has been created, you invoke it by referring to it in an expression.
			The function returns a value during expression evaluation.
			When a stored procedure has been created, you invoke it by using the CALL statement.</p>

		<p>To execute the CREATE PROCEDURE or CREATE FUNCTION statement, it is necessary to have the CREATE ROUTINE privilege.
			By default, MySQL automatically grants the ALTER ROUTINE and EXECUTE privileges to the routine creator.
			If binary logging is enabled, the CREATE FUNCTION statement might also require the SUPER privilege.</p>

		<p>The DEFINER and SQL SECURITY clauses specify the security context to be used when checking access privileges at routine execution time, as described later.</p>

		<p>If the routine name is the same as the name of a built-in SQL function,
			you must use a space between the name and the following parenthesis when defining the routine,
			or a syntax error occurs. This is also true when you invoke the routine later.
			For this reason, we suggest that it is better to avoid re-using the names of existing SQL functions for your own stored routines.</p>

		<p>The IGNORE_SPACE SQL mode applies to built-in functions, not to stored routines.
			It is always allowable to have spaces after a routine name, regardless of whether IGNORE_SPACE is enabled.</p>

		<p>The parameter list enclosed within parentheses must always be present.
			If there are no parameters, an empty parameter list of () should be used.</p>

		<p>Each parameter can be declared to use any valid data type, except that the COLLATE attribute cannot be used.</p>

		<p>Each parameter is an IN parameter by default. To specify otherwise for a parameter, use the keyword OUT or INOUT before the parameter name.</p>

		<p>Note: Specifying a parameter as IN, OUT, or INOUT is valid only for a PROCEDURE. (FUNCTION parameters are always regarded as IN parameters.)</p>

		<p>An IN parameter passes a value into a procedure. The procedure might modify the value,
			but the modification is not visible to the caller when the procedure returns.
			An OUT parameter passes a value from the procedure back to the caller.
			Its initial value is NULL within the procedure, and its value is visible to the caller when the procedure returns.
			An INOUT parameter is initialized by the caller, can be modified by the procedure,
			and any change made by the procedure is visible to the caller when the procedure returns.</p>

		<p>For each OUT or INOUT parameter, pass a user-defined variable so that you can obtain its value when the procedure returns.
			If you are calling the procedure from within another stored procedure or function,
			you can also pass a routine parameter or local routine variable as an IN or INOUT parameter.</p>

		<p>The RETURNS clause may be specified only for a FUNCTION, for which it is mandatory.
			It indicates the return type of the function, and the function body must contain a RETURN value statement.
			If the RETURN statement returns a value of a different type, the value is coerced to the proper type.
			For example, if a function specifies an ENUM or SET value in the RETURNS clause, but the RETURN statement returns an integer,
			the value returned from the function is the string for the corresponding ENUM member of set of SET members.</p>

		<p>The routine_body consists of a valid SQL procedure statement. This can be a simple statement such as SELECT or INSERT,
			or it can be a compound statement written using BEGIN and END. Compound statements can contain declarations, loops, and other control structure statements.</p>

		<p>Some statements are not allowed in stored routines;</p>

		<p>SQL stores the sql_mode system variable setting that is in effect at the time a routine is created,
			and always executes the routine with this setting in force, regardless of the current server SQL mode.</p>

		<p>The CREATE FUNCTION statement is also used in SQL to support UDFs (user-defined functions).
			A UDF can be regarded as an external stored function. However, do note that stored functions share their namespace with UDFs.</p>

		<p>A procedure or function is considered "deterministic" if it always produces the same result for the same input parameters,
			and "not deterministic" otherwise. If neither DETERMINISTIC nor NOT DETERMINISTIC is given in the routine definition, the default is NOT DETERMINISTIC.</p>

		<p>A routine that contains the NOW() function (or its synonyms) or RAND() is non-deterministic,
			but it might still be replication-safe. For NOW(), the binary log includes the timestamp and replicates correctly.
			RAND() also replicates correctly as long as it is invoked only once within a routine.
			(You can consider the routine execution timestamp and random number seed as implicit inputs that are identical on the master and slave.)</p>

		<p>Several characteristics provide information about the nature of data use by the routine.
			In SQL, these characteristics are advisory only.
			The server does not use them to constrain what kinds of statements a routine will be allowed to execute.</p>
		<ul>
			<li>
			<p>CONTAINS SQL indicates that the routine does not contain statements that read or write data.
			This is the default if none of these characteristics is given explicitly.
			Examples of such statements are SET @x = 1 or DO RELEASE_LOCK('abc'), which execute but neither read nor write data.</p>
			</li>
			<li>
			<p>NO SQL indicates that the routine contains no SQL statements.</p>
			</li>
			<li>
			<p>READS SQL DATA indicates that the routine contains statements that read data (for example, SELECT), but not statements that write data.</p>
			</li>
			<li>
			<p>MODIFIES SQL DATA indicates that the routine contains statements that may write data (for example, INSERT or DELETE).</p>
			</li>
		</ul>
		
		<p>The SQL SECURITY characteristic can be used to specify whether the routine should be executed using the
			permissions of the user who creates the routine or the user who invokes it. The default value is DEFINER.
			This feature is new in SQL:2003. The creator or invoker must have permission to access the database with which the routine is associated.
			It is necessary to have the EXECUTE privilege to be able to execute the routine.
			The user that must have this privilege is either the definer or invoker, depending on how the SQL SECURITY characteristic is set.</p>

		<p>The optional DEFINER clause specifies the SQL account to be used when checking access privileges at routine execution time for routines that have the SQL SECURITY DEFINER characteristic.</p>

		<p>If a user value is given for the DEFINER clause, it should be a MySQL account in 'user_name'@'host_name' format (the same format used in the GRANT statement).
			The user_name and host_name values both are required. The definer can also be given as CURRENT_USER or CURRENT_USER().
			The default DEFINER value is the user who executes the CREATE PROCEDURE or CREATE FUNCTION or statement. (This is the same as DEFINER = CURRENT_USER.)</p>

		<p>If you specify the DEFINER clause, these rules determine the legal DEFINER user values:</p>
		
		<ul>
			<li>
				<p>If you do not have the SUPER privilege, the only legal user value is your own account,
					either specified literally or by using CURRENT_USER. You cannot set the definer to some other account.</p>
			</li>
			<li>
				<p>If you have the SUPER privilege, you can specify any syntactically legal account name.
					If the account does not actually exist, a warning is generated.</p>
				<p>Although it is possible to create routines with a non-existent DEFINER value,
					an error occurs if the routine executes with definer privileges but the definer does not exist at execution time.</p>
			</li>
		</ul>

		<p>The server uses the data type of a routine parameter or function return value as follows.
			These rules also apply to local routine variables created with the DECLARE statement.</p>

		<ul>
			<li>
				<p>Assignments are checked for data type mismatches and overflow. Conversion and overflow problems result in warnings, or errors in strict mode.</p>
			</li>
			<li>
				<p>Only scalar values can be assigned to parameters or variables. For example, a statement such as SET x = (SELECT 1, 2) is invalid.</p>
			</li>
			<li>
				<p>For character data types, if there is a CHARACTER SET clause in the declaration, the specified character set and its default collation are used.
					If there is no such clause, the database character set and collation that are in effect at the time the routine is created are used.
					(These are given by the values of the character_set_database and collation_database system variables.)
					The COLLATE attribute is not supported.
					(This includes use of BINARY, because in this context BINARY specifies the binary collation of the character set.)</p>
			</li>
		</ul>

		<p>The COMMENT clause is an SQL extension, and may be used to describe the stored routine.
			This information is displayed by the SHOW CREATE PROCEDURE and SHOW CREATE FUNCTION statements.</p>

		<p>SQL allows routines to contain DDL statements, such as CREATE and DROP.
			SQL also allows stored procedures (but not stored functions) to contain SQL transaction statements such as COMMIT.
			Stored functions may not contain statements that perform explicit or implicit commit or rollback.
			Support for these statements is not required by the SQL standard, which states that each DBMS vendor may decide whether to allow them.</p>

		<p>Statements that return a result set cannot be used within a stored function.
			This includes SELECT statements that do not have an INTO var_list clause and other statements such as SHOW, EXPLAIN, and CHECK TABLE.
			For statements that can be determined at function definition time to return a result set,
			a Not allowed to return a result set from a function error occurs (ER_SP_NO_RETSET).
			For statements that can be determined only at runtime to return a result set, a PROCEDURE %s can't return a result set in the given context error occurs (ER_SP_BADSELECT).</p>

		<p>The following is an example of a simple stored procedure that uses an OUT parameter.</p>

		<pre>(sql sqlHandle {CREATE PROCEDURE simpleproc (OUT param1 INT)
BEGIN
	SELECT COUNT(*) INTO param1 FROM t;
END}) <b>Returns</b> 0</pre>

		<pre>(sql sqlHandle {CALL simpleproc(@a)}) <b>Returns</b> 0</pre>
		
		<pre>(sql sqlHandle {SELECT @a}) <b>Returns</b>
#(rec(|@a|:Integer:1)| |@a|:3)</pre>

		<p>The following is an example of a function that takes a parameter, performs an operation using an SQL function, and returns the result.</p>
			
		<pre>(sql sqlHandle {CREATE FUNCTION hello (s CHAR(20))
	RETURNS CHAR(50) DETERMINISTIC RETURN CONCAT('Hello, ',s,'!')}) <b>Returns</b> 0</pre>

		<pre>(sql sqlHandle {SELECT hello('world')}) <b>Returns</b>
#(rec(|hello('world')|:Character:50)| |hello('world')|:"Hello, world!")</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE TABLE Syntax"></A>CREATE TABLE Syntax</H2></P>
		<pre>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_option] ...
    [partition_options]
Or:

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    [(create_definition,...)]
    [table_option] ...
    [partition_options]
    select_statement
Or:

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    { LIKE old_tbl_name | (LIKE old_tbl_name) }
create_definition:
    col_name column_definition
  | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...)
      [index_option] ...
  | {INDEX|KEY} [index_name] [index_type] (index_col_name,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY]
      [index_name] [index_type] (index_col_name,...)
      [index_option] ...
  | {FULLTEXT|SPATIAL} [INDEX|KEY] [index_name] (index_col_name,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] FOREIGN KEY
      [index_name] (index_col_name,...) reference_definition
  | CHECK (expr)

column_definition:
    data_type [NOT NULL | NULL] [DEFAULT default_value]
      [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY]
      [COMMENT 'string'] [reference_definition]
      [COLUMN_FORMAT {FIXED|DYNAMIC|DEFAULT}]
      [STORAGE {DISK|MEMORY|DEFAULT}]

data_type:
    BIT[(length)]
  | TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  | SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  | INT[(length)] [UNSIGNED] [ZEROFILL]
  | INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  | BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | DECIMAL[(length[,decimals])] [UNSIGNED] [ZEROFILL]
  | NUMERIC[(length[,decimals])] [UNSIGNED] [ZEROFILL]
  | DATE
  | TIME
  | TIMESTAMP
  | DATETIME
  | YEAR
  | CHAR[(length)]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | VARCHAR(length)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | BINARY[(length)]
  | VARBINARY(length)
  | TINYBLOB
  | BLOB
  | MEDIUMBLOB
  | LONGBLOB
  | TINYTEXT [BINARY]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | TEXT [BINARY]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | MEDIUMTEXT [BINARY]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | LONGTEXT [BINARY]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | ENUM(value1,value2,value3,...)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | SET(value1,value2,value3,...)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | spatial_type

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH | RTREE}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name

reference_definition:
    REFERENCES tbl_name (index_col_name,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE reference_option]
      [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION

table_option:    
    ENGINE [=] engine_name
  | AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | CONNECTION [=] 'connect_string'
  | DATA DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | INDEX DIRECTORY [=] 'absolute path to directory'
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]
  | UNION [=] (tbl_name[,tbl_name]...)

partition_options:
    PARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY(column_list)
        | RANGE(expr)
        | LIST(expr) }
    [PARTITIONS num]
    [SUBPARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY(column_list) }
      [SUBPARTITIONS num]
    ]
    [(partition_definition [, partition_definition] ...)]

partition_definition:
    PARTITION partition_name
        [VALUES {LESS THAN {(expr) | MAXVALUE} | IN (value_list)}]
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'comment_text' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [NODEGROUP [=] node_group_id]
        [(subpartition_definition [, subpartition_definition] ...)]

subpartition_definition:
    SUBPARTITION logical_name
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'comment_text' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [NODEGROUP [=] node_group_id]

select_statement:
    [IGNORE | REPLACE] [AS] SELECT ...   (Some legal select statement)</pre>

		<p>CREATE TABLE creates a table with the given name.
			You must have the CREATE privilege for the table.</p>

		<p>By default, the table is created in the default database.
			An error occurs if the table exists, if there is no default database, or if the database does not exist.</p>

		<p>The table name can be specified as db_name.tbl_name to create the table in a specific database.
			This works regardless of whether there is a default database, assuming that the database exists.
			If you use quoted identifiers, quote the database and table names separately.
			For example, write `mydb`.`mytbl`, not `mydb.mytbl`.</p>

		<p>You can use the TEMPORARY keyword when creating a table.
			A TEMPORARY table is visible only to the current connection, and is dropped automatically when the connection is closed.
			This means that two different connections can use the same temporary table name without conflicting with each other or with an existing non-TEMPORARY table of the same name.
			(The existing table is hidden until the temporary table is dropped.)
			To create temporary tables, you must have the CREATE TEMPORARY TABLES privilege.</p>

		<p>Note: CREATE TABLE does not automatically commit the current active transaction if you use the TEMPORARY keyword.</p>

		<p>The keywords IF NOT EXISTS prevent an error from occurring if the table exists.
			However, there is no verification that the existing table has a structure identical to that indicated by the CREATE TABLE statement.</p>

		<p>Note: If you use IF NOT EXISTS in a CREATE TABLE ... SELECT statement,
			any rows selected by the SELECT part are inserted regardless of whether the table already exists.</p>

		<p>SQL represents each table by an .frm table format (definition) file in the database directory.
			The storage engine for the table might create other files as well.
			In the case of MyISAM tables, the storage engine creates data and index files.
			Thus, for each MyISAM table tbl_name, there are three disk files:</p>
		
		<table border="3">
			<tr>
				<th align="left">File</th>
				<th align="left">Purpose</th>
			</tr>
			<tr>
				<td>tbl_name.frm</td>
				<td>Table format (definition) file</td>
			</tr>
			<tr>
				<td>tbl_name.MYD</td>
				<td>Data file</td>
			</tr>
			<tr>
				<td>tbl_name.MYI</td>
				<td>Index file</td>
			</tr>
		</table>

		<p>If a table name contains special characters, the names for the table files contain encoded versions of those characters</p>
		
		<p>data_type represents the data type in a column definition.
			spatial_type represents a spatial data type. The data type syntax shown is representative only.</p>
		
		<p>Some attributes do not apply to all data types.
			AUTO_INCREMENT applies only to integer and floating-point types.
			DEFAULT does not apply to the BLOB or TEXT types.</p>
			
		<ul>
			<li>
				<p>If neither NULL nor NOT NULL is specified, the column is treated as though NULL had been specified.</p>
			</li>
			<li>
				<p>An integer or floating-point column can have the additional attribute AUTO_INCREMENT.
					When you insert a value of NULL (recommended) or 0 into an indexed AUTO_INCREMENT column, the column is set to the next sequence value.
					Typically this is value+1, where value is the largest value for the column currently in the table. AUTO_INCREMENT sequences begin with 1.</p>

				<p>To retrieve an AUTO_INCREMENT value after inserting a row, use the LAST_INSERT_ID() SQL function or the mysql_insert_id() C API function.</p>
				
				<p>If the NO_AUTO_VALUE_ON_ZERO SQL mode is enabled, you can store 0 in AUTO_INCREMENT columns as 0 without generating a new sequence value.</p>
				
				<p>Note: There can be only one AUTO_INCREMENT column per table, it must be indexed, and it cannot have a DEFAULT value.
					An AUTO_INCREMENT column works properly only if it contains only positive values.
					Inserting a negative number is regarded as inserting a very large positive number.
					This is done to avoid precision problems when numbers "wrap" over from positive to negative and also to ensure that you do not accidentally get an AUTO_INCREMENT column that contains 0.</p>
					
				<p>For MyISAM tables, you can specify an AUTO_INCREMENT secondary column in a multiple-column key.</p>
				
				<p>To make SQL compatible with some ODBC applications, you can find the AUTO_INCREMENT value for the last inserted row with the following query:</p>

				<pre>(sql sqlHandle {SELECT * FROM tbl_name WHERE auto_col IS NULL})</pre>
				
				<p>For information about InnoDB and AUTO_INCREMENT.</p>
			</li>
			<li>
				<p>Character data types (CHAR, VARCHAR, TEXT) can include CHARACTER SET and COLLATE attributes to specify the character set and collation for the column.
				CHARSET is a synonym for CHARACTER SET. Example:</p>
				
				<pre>(sql sqlHandle {CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin)})</pre>
				
				<p>SQL interprets length specifications in character column definitions in characters. Lengths for BINARY and VARBINARY are in bytes.</p>
			</li>
			<li>
				<p>The DEFAULT clause specifies a default value for a column.
					With one exception, the default value must be a constant; it cannot be a function or an expression.
					This means, for example, that you cannot set the default for a date column to be the value of a function such as NOW() or CURRENT_DATE.
					The exception is that you can specify CURRENT_TIMESTAMP as the default for a TIMESTAMP column.</p>
				<p>If a column definition includes no explicit DEFAULT value, SQL determines the default value.</p>
				<p>BLOB and TEXT columns cannot be assigned a default value.</p>
				<p>CREATE TABLE fails if a date-valued default is not correct according to the NO_ZERO_IN_DATE SQL mode,
					even if strict SQL mode is not enabled. For example, c1 DATE DEFAULT '2010-00-00' causes CREATE TABLE to fail with Invalid default value for 'c1'.</p>
			</li>
			<li>
				<p>A comment for a column can be specified with the COMMENT option, up to 255 characters long.
					The comment is displayed by the SHOW CREATE TABLE and SHOW FULL COLUMNS statements.</p>
			</li>
			<li>
				<p>KEY is normally a synonym for INDEX.
					The key attribute PRIMARY KEY can also be specified as just KEY when given in a column definition.
					This was implemented for compatibility with other database systems.</p>
			</li>
			<li>
				<p>A UNIQUE index creates a constraint such that all values in the index must be distinct.
					An error occurs if you try to add a new row with a key value that matches an existing row.
					For all engines, a UNIQUE index allows multiple NULL values for columns that can contain NULL.</p>
			</li>
			<li>
				<p>A PRIMARY KEY is a unique index where all key columns must be defined as NOT NULL.
					If they are not explicitly declared as NOT NULL, SQL declares them so implicitly (and silently).
					A table can have only one PRIMARY KEY.
					If you do not have a PRIMARY KEY and an application asks for the PRIMARY KEY in your tables, 
					SQL returns the first UNIQUE index that has no NULL columns as the PRIMARY KEY.</p>
				<p>In InnoDB tables, having a long PRIMARY KEY wastes a lot of space.</p>
			</li>
			<li>
				<p>In the created table, a PRIMARY KEY is placed first, followed by all UNIQUE indexes, and then the non-unique indexes.
					This helps the SQL optimizer to prioritize which index to use and also more quickly to detect duplicated UNIQUE keys.</p>
			</li>
			<li>
				<p>A PRIMARY KEY can be a multiple-column index.
					However, you cannot create a multiple-column index using the PRIMARY KEY key attribute in a column specification.
					Doing so only marks that single column as primary.
					You must use a separate PRIMARY KEY(index_col_name, ...) clause.</p>
			</li>
			<li>
				<p>If a PRIMARY KEY or UNIQUE index consists of only one column that has an integer type,
					you can also refer to the column as _rowid in SELECT statements.</p>
			</li>
			<li>
				<p>In SQL, the name of a PRIMARY KEY is PRIMARY.
					For other indexes, if you do not assign a name, the index is assigned the same name as the first indexed column,
					with an optional suffix (_2, _3, ...) to make it unique.
					You can see index names for a table using SHOW INDEX FROM tbl_name.</p>
			</li>
			<li>
				<p>Some storage engines allow you to specify an index type when creating an index.
					The syntax for the index_type specifier is USING type_name.</p>
					
				<p>Example:</p>
				
				<pre>(sql sqlHandle {CREATE TABLE lookup (id INT, INDEX USING BTREE (id)) ENGINE = MEMORY})</pre>

				<p>index_option values specify additional options for an index.	USING is one such option.</p>
			</li>
			<li>
				<p>In SQL, only the MyISAM, InnoDB, and MEMORY storage engines support indexes on columns that can have NULL values.
					In other cases, you must declare indexed columns as NOT NULL or an error results.</p>
			</li>
			<li>
				<p>For CHAR, VARCHAR, BINARY, and VARBINARY columns, indexes can be created that use only the leading part of column values,
					using col_name(length) syntax to specify an index prefix length. BLOB and TEXT columns also can be indexed,
					but a prefix length must be given. Prefix lengths are given in characters for non-binary string types and in bytes for binary string types.
					That is, index entries consist of the first length characters of each column value for CHAR, VARCHAR, and TEXT columns,
					and the first length bytes of each column value for BINARY, VARBINARY, and BLOB columns.
					Indexing only a prefix of column values like this can make the index file much smaller.</p>
				<p>Only the MyISAM and InnoDB storage engines support indexing on BLOB and TEXT columns. For example:</p>
				<pre>(sql sqlHandle {CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)))})</pre>
				
				<p>Prefixes can be up to 1000 bytes long (767 bytes for InnoDB tables).
					Note that prefix limits are measured in bytes, whereas the prefix length in CREATE TABLE statements is interpreted as number of characters for non-binary data types (CHAR, VARCHAR, TEXT).
					Take this into account when specifying a prefix length for a column that uses a multi-byte character set.</p>
			</li>
			<li>
				<p>An index_col_name specification can end with ASC or DESC.
					These keywords are allowed for future extensions for specifying ascending or descending index value storage.
					Currently, they are parsed but ignored; index values are always stored in ascending order.</p>
			</li>
			<li>
				<p>When you use ORDER BY or GROUP BY on a TEXT or BLOB column in a SELECT,
					the server sorts values using only the initial number of bytes indicated by the max_sort_length system variable.</p>
			</li>
			<li>
				<p>You can create special FULLTEXT indexes, which are used for full-text searches.
					Only the MyISAM storage engine supports FULLTEXT indexes.
					They can be created only from CHAR, VARCHAR, and TEXT columns.
					Indexing always happens over the entire column; column prefix indexing is not supported and any prefix length is ignored if specified.
					A WITH PARSER clause can be specified as an index_option value to associate a parser plugin with the index if full-text indexing and searching operations need special handling.
					This clause is legal only for FULLTEXT indexes.</p>
			</li>
			<li>
				<p>You can create SPATIAL indexes on spatial data types.
					Spatial types are supported only for MyISAM tables and indexed columns must be declared as NOT NULL.</p>
			</li>
			<li>
				<p>InnoDB tables support checking of foreign key constraints.
					Note that the FOREIGN KEY syntax in InnoDB is more restrictive than the syntax presented for the CREATE TABLE statement at the beginning of this section:
					The columns of the referenced table must always be explicitly named.
					InnoDB supports both ON DELETE and ON UPDATE actions on foreign keys.</p>
				<p>For other storage engines, SQL Server parses and ignores the FOREIGN KEY and REFERENCES syntax in CREATE TABLE statements.
					The CHECK clause is parsed but ignored by all storage engines.</p>
				<p><b>Important</b></p>
				<p>For users familiar with the ANSI/ISO SQL Standard, please note that no storage engine, including InnoDB,
					recognizes or enforces the MATCH clause used in referential integrity constraint definitions.
					Use of an explicit MATCH clause will not have the specified effect, and also causes ON DELETE and ON UPDATE clauses to be ignored.
					For these reasons, specifying MATCH should be avoided.</p>
					
				<p>The MATCH clause in the SQL standard controls how NULL values in a composite (multiple-column) foreign key are handled when comparing to a primary key.
					InnoDB essentially implements the semantics defined by MATCH SIMPLE, which allow a foreign key to be all or partially NULL.
					In that case, the (child table) row containing such a foreign key is allowed to be inserted, and does not match any row in the referenced (parent) table.
					It is possible to implement other semantics using triggers.</p>
					
				<p>Additionally, SQL and InnoDB require that the referenced columns be indexed for performance.
					However, the system does not enforce a requirement that the referenced columns be UNIQUE or be declared NOT NULL.
					The handling of foreign key references to non-unique keys or keys that contain NULL values is not well defined for operations such as UPDATE or DELETE CASCADE.
					You are advised to use foreign keys that reference only UNIQUE and NOT NULL keys.</p>
				
				<p>Furthermore, InnoDB does not recognize or support "inline REFERENCES specifications" (as defined in the SQL standard)
					where the references are defined as part of the column specification.
					InnoDB accepts REFERENCES clauses only when specified as part of a separate FOREIGN KEY specification.
					For other storage engines, SQL Server parses and ignores foreign key specifications.</p>
					
				<p>Note: Partitioned tables do not support foreign keys.</p>
			</li>
			<li>
				<p>There is a hard limit of 4096 columns per table, but the effective maximum may be less for a given table.</p>
			</li>
		</ul>
		
		<p>The tablespace named tablespace_name must already have been created using CREATE TABLESPACE.
			STORAGE determines the type of storage used (disk or memory), and can be one of DISK, MEMORY, or DEFAULT.</p>
			
		<p>Important: A STORAGE clause cannot be used in a CREATE TABLE statement without a TABLESPACE clause.</p>
		
		<p>The ENGINE table option specifies the storage engine for the table.</p>
		<p>The ENGINE table option takes the storage engine names shown in the following table.</p>
		
		<table border="3">
			<tr>
				<th align="left">Storage Engine</th>
				<th align="left">Description</th>
			</tr>
			<tr>
				<td>ARCHIVE</td>
				<td>The archiving storage engine.</td>
			</tr>
			<tr>
				<td>CSV</td>
				<td>Tables that store rows in comma-separated values format.</td>
			</tr>
			<tr>
				<td>EXAMPLE</td>
				<td>An example engine.</td>
			</tr>
			<tr>
				<td>FEDERATED</td>
				<td>Storage engine that accesses remote tables.</td>
			</tr>
			<tr>
				<td>HEAP</td>
				<td>This is a synonym for MEMORY.</td>
			</tr>
			<tr>
				<td>InnoDB</td>
				<td>Transaction-safe tables with row locking and foreign keys.</td>
			</tr>
			<tr>
				<td>MEMORY</td>
				<td>The data for this storage engine is stored only in memory.</td>
			</tr>
			<tr>
				<td>MERGE</td>
				<td>A collection of MyISAM tables used as one table. Also known as MRG_MyISAM.</td>
			</tr>
			<tr>
				<td>MyISAM</td>
				<td>The binary portable storage engine that is the default storage engine used by SQL.</td>
			</tr>
			<tr>
				<td>NDBCLUSTER</td>
				<td>Clustered, fault-tolerant, memory-based tables. Also known as NDB.</td>
			</tr>
		</table>

		<p>If a storage engine is specified that is not available, MySQL uses the default engine instead.
			Normally, this is MyISAM. For example, if a table definition includes the ENGINE=INNODB option but the SQL server does not support INNODB tables,
			the table is created as a MyISAM table. This makes it possible to have a replication setup where you have transactional tables on the master
			but tables created on the slave are non-transactional (to get more speed). A warning occurs if the storage engine specification is not honored.</p>

		<p>Engine substitution can be controlled by the setting of the NO_ENGINE_SUBSTITUTION SQL mode.</p>
		
		<p>Note: The older TYPE option was synonymous with ENGINE. You should not use TYPE in any new applications,
			and you should immediately begin conversion of existing applications to use ENGINE instead.</p>
			
		<p>The other table options are used to optimize the behavior of the table.
			In most cases, you do not have to specify any of them. These options apply to all storage engines unless otherwise indicated.
			Options that do not apply to a given storage engine may be accepted and remembered as part of the table definition.
			Such options then apply if you later use ALTER TABLE to convert the table to use a different storage engine.</p>
		
		<ul>
			<li>
			<p>AUTO_INCREMENT</p>
			<p>The initial AUTO_INCREMENT value for the table. This works for MyISAM, MEMORY, and InnoDB tables.
				It also works for ARCHIVE tables. To set the first auto-increment value for engines that do not support the AUTO_INCREMENT table option,
				insert a "dummy" row with a value one less than the desired value after creating the table, and then delete the dummy row.</p>
			<p>For engines that support the AUTO_INCREMENT table option in CREATE TABLE statements,
				you can also use ALTER TABLE tbl_name AUTO_INCREMENT = N to reset the AUTO_INCREMENT value.
				The value cannot be set lower than the maximum value currently in the column.</p>
			</li>
			<li>
			<p>AVG_ROW_LENGTH</p>
			<p>An approximation of the average row length for your table. You need to set this only for large tables with variable-size rows.</p>
			<p>When you create a MyISAM table, SQL uses the product of the MAX_ROWS and AVG_ROW_LENGTH options to decide how big the resulting table is.
				If you don't specify either option, the maximum size for MyISAM data and index files is 256TB by default.
				(If your operating system does not support files that large, table sizes are constrained by the file size limit.)
				If you want to keep down the pointer sizes to make the index smaller and faster and you don't really need big files,
				you can decrease the default pointer size by setting the myisam_data_pointer_size system variable.
				If you want all your tables to be able to grow above the default limit and are willing to have your tables slightly slower and larger than necessary,
				you can increase the default pointer size by setting this variable. Setting the value to 7 allows table sizes up to 65,536TB.</p>
			</li>
			<li>
			<p>[DEFAULT] CHARACTER SET</p>
			<p>Specify a default character set for the table. CHARSET is a synonym for CHARACTER SET. If the character set name is DEFAULT, the database character set is used.</p>
			</li>
			<li>
			<p>CHECKSUM</p>
			<p>Set this to 1 if you want MySQL to maintain a live checksum for all rows (that is, a checksum that MySQL updates automatically as the table changes).
				This makes the table a little slower to update, but also makes it easier to find corrupted tables.
				The CHECKSUM TABLE statement reports the checksum. (MyISAM only.)</p>
			</li>
			<li>
				<p>[DEFAULT] COLLATE</p>
				<p>Specify a default collation for the table.</p>
			</li>
			<li>
				<p>COMMENT</p>
				<p>A comment for the table, up to 60 characters long.</p>
			</li>
			<li>
				<p>CONNECTION</p>
				<p>The connection string for a FEDERATED table.</p>
			</li>
			<li>
				<p>DATA DIRECTORY, INDEX DIRECTORY</p>
				<p>By using DATA DIRECTORY='directory' or INDEX DIRECTORY='directory' you can specify where the MyISAM storage engine should put a table's data file and index file.
					The directory must be the full pathname to the directory, not a relative path.</p>
				<p><b>Important</b></p>
				<p>Table-level DATA DIRECTORY and INDEX DIRECTORY options are ignored for partitioned tables.</p>
				<p>These options work only when you are not using the --skip-symbolic-links option.
					Your operating system must also have a working, thread-safe realpath() call.</p>
				<p>If a MyISAM table is created with no DATA DIRECTORY option, the .MYD file is created in the database directory.
					By default, if MyISAM finds an existing .MYD file in this case, it overwrites it.
					The same applies to .MYI files for tables created with no INDEX DIRECTORY option.
					To suppress this behavior, start the server with the --keep_files_on_create option,
					in which case MyISAM will not overwrite existing files and returns an error instead.</p>
				<p>If a MyISAM table is created with a DATA DIRECTORY or INDEX DIRECTORY option and an existing .MYD or .MYI file is found,
					MyISAM always returns an error. It will not overwrite a file in the specified directory.</p>
				<p><b>Important</b></p>
				<p>You cannot use pathnames that contain the SQL data directory with DATA DIRECTORY or INDEX DIRECTORY.
					This includes partitioned tables and individual table partitions.</p>
			</li>
			<li>
				<p>DELAY_KEY_WRITE</p>
				<p>Set this to 1 if you want to delay key updates for the table until the table is closed.</p>
			</li>
			<li>
				<p>INSERT_METHOD</p>
				<p>If you want to insert data into a MERGE table, you must specify with INSERT_METHOD the table into which the row should be inserted.
					INSERT_METHOD is an option useful for MERGE tables only.
					Use a value of FIRST or LAST to have inserts go to the first or last table, or a value of NO to prevent inserts.</p>
			</li>
			<li>
				<p>KEY_BLOCK_SIZE</p>
				<p>This option provides a hint to the storage engine about the size in bytes to use for index key blocks.
					The engine is allowed to change the value if necessary.
					A value of 0 indicates that the default value should be used.
					Individual index definitions can specify a KEY_BLOCK_SIZE value of their own to override the table value.</p>
			</li>
			<li>
				<p>MAX_ROWS</p>
				<p>The maximum number of rows you plan to store in the table.
					This is not a hard limit, but rather a hint to the storage engine that the table must be able to store at least this many rows.</p>
			</li>
			<li>
				<p>MIN_ROWS</p>
				<p>The minimum number of rows you plan to store in the table.</p>
			</li>
			<li>
				<p>PACK_KEYS</p>
				<p>PACK_KEYS takes effect only with MyISAM tables. Set this option to 1 if you want to have smaller indexes.
					This usually makes updates slower and reads faster. Setting the option to 0 disables all packing of keys.
					Setting it to DEFAULT tells the storage engine to pack only long CHAR, VARCHAR, BINARY, or VARBINARY columns.</p>
				<p>If you do not use PACK_KEYS, the default is to pack strings, but not numbers.
					If you use PACK_KEYS=1, numbers are packed as well.</p>
				<p>When packing binary number keys, SQL uses prefix compression:</p>
				<ul>
					<li>Every key needs one extra byte to indicate how many bytes of the previous key are the same for the next key.</li>
					<li>The pointer to the row is stored in high-byte-first order directly after the key, to improve compression.</li>
				</ul>
				<p>This means that if you have many equal keys on two consecutive rows, all following "same" keys usually only take two bytes (including the pointer to the row).
					Compare this to the ordinary case where the following keys takes storage_size_for_key + pointer_size (where the pointer size is usually 4).
					Conversely, you get a significant benefit from prefix compression only if you have many numbers that are the same.
					If all keys are totally different, you use one byte more per key, if the key is not a key that can have NULL values.
					(In this case, the packed key length is stored in the same byte that is used to mark if a key is NULL.)</p>
			</li>
			<li>
				<p>PASSWORD</p>
				<p>This option is unused. If you have a need to scramble your .frm files and make them unusable to any other SQL server, please contact our sales department.</p>
			</li>
			<li>
				<p>ROW_FORMAT</p>
				<p>Defines how the rows should be stored.
					For MyISAM tables, the option value can be FIXED or DYNAMIC for static or variable-length row format.
					myisampack sets the type to COMPRESSED.</p>
				<p>For InnoDB tables, rows are stored in compact format (ROW_FORMAT=COMPACT) by default.
					The non-compact format used in older versions of MySQL can still be requested by specifying ROW_FORMAT=REDUNDANT.</p>
				<p>Note: During CREATE TABLE, if you specify a row format that the engine does support,
					the table will be created using the storage engines default row format.
					The information reported in this column in response to SHOW TABLE STATUS is the actual row format used.
					This may differ from the value in the Create_options column because the original CREATE TABLE definition is retained during creation.</p>
			</li>
			<li>
				<p>UNION</p>
				<p>UNION is used when you want to access a collection of identical MyISAM tables as one. This works only with MERGE tables.</p>
				<p>You must have SELECT, UPDATE, and DELETE privileges for the tables you map to a MERGE table.</p>
				<p>Note: Formerly, all tables used had to be in the same database as the MERGE table itself. This restriction no longer applies.</p>
			</li>
		</ul>
		<p>partition_options can be used to control partitioning of the table created with CREATE TABLE.</p>
		<p><b>Important</b></p>
		<p>Not all options shown in the syntax for partition_options at the beginning of this section are available for all partitioning types.
			Please see the listings for the following individual types for information specific to each type.</p>
		<p>If used, a partition_options clause begins with PARTITION BY.
			This clause contains the function that is used to determine the partition;
			the function returns an integer value ranging from 1 to num, where num is the number of partitions.
			(The maximum number of user-defined partitions which a table may contain is 1024;
			the number of subpartitions  discussed later in this section  is included in this maximum.)
			The choices that are available for this function in SQL are shown in the following list:</p>
		<ul>
			<li>
				<p>HASH(expr): Hashes one or more columns to create a key for placing and locating rows.
					expr is an expression using one or more table columns. This can be any legal SQL expression (including SQL functions) that yields a single integer value.
					For example, these are all valid CREATE TABLE statements using PARTITION BY HASH:</p>

				<pre>(sql sqlHandle {CREATE TABLE t1 (col1 INT, col2 CHAR(5)) PARTITION BY HASH(col1)})</pre>
				
				<pre>(sql sqlHandle {CREATE TABLE t1 (col1 INT, col2 CHAR(5)) PARTITION BY HASH( ORD(col2) )})</pre>
				
				<pre>(sql sqlHandle {CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME) PARTITION BY HASH ( YEAR(col3) )})</pre>
				
				<p>You may not use either VALUES LESS THAN or VALUES IN clauses with PARTITION BY HASH.</p>
				
				<p>PARTITION BY HASH uses the remainder of expr divided by the number of partitions (that is, the modulus).</p>
				
				<p>The LINEAR keyword entails a somewhat different algorithm.
					In this case, the number of the partition in which a row is stored is calculated as the result of one or more logical AND operations.</p>
			</li>
			<li>
				<p>KEY(column_list): This is similar to HASH, except that SQL supplies the hashing function so as to guarantee an even data distribution.
					The column_list argument is simply a list of table columns. This example shows a simple table partitioned by key, with 4 partitions:</p>
				<pre>(sql sqlHandle {CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE) PARTITION BY KEY(col3) PARTITIONS 4})</pre>
				
				<p>For tables that are partitioned by key, you can employ linear partitioning by using the LINEAR keyword.
					This has the same effect as with tables that are partitioned by HASH.
					That is, the partition number is found using the & operator rather than the modulus.
					This example uses linear partitioning by key to distribute data between 5 partitions:</p>
					
				<pre>(sql sqlHandle {CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE) PARTITION BY LINEAR KEY(col3) PARTITIONS 5})</pre>
				
				<p>You may not use either VALUES LESS THAN or VALUES IN clauses with PARTITION BY KEY.</p>
			</li>
			<li>
				<p>RANGE: In this case, expr shows a range of values using a set of VALUES LESS THAN operators.
					When using range partitioning, you must define at least one partition using VALUES LESS THAN.
					You cannot use VALUES IN with range partitioning.</p>
				<p>VALUES LESS THAN can be used with either a literal value or an expression that evaluates to a single value.</p>
				<p>Suppose that you have a table that you wish to partition on a column containing year values, according to the following scheme:</p>
				
				<table border="3">
					<tr>
						<th align="left">Partition Number:</th>
						<th align="left">Years Range:</th>
					</tr>
					<tr>
						<td>0</td>
						<td>1990 and earlier</td>
					</tr>
					<tr>
						<td>1</td>
						<td>1991  1994</td>
					</tr>
					<tr>
						<td>2</td>
						<td>1995  1998</td>
					</tr>
					<tr>
						<td>3</td>
						<td>1999  2002</td>
					</tr>
					<tr>
						<td>4</td>
						<td>2003  2005</td>
					</tr>
					<tr>
						<td>5</td>
						<td>2006 and later</td>
					</tr>
				</table>
	
				<p>A table implementing such a partitioning scheme can be realized by the CREATE TABLE statement shown here:</p>
				
				<pre>(sql sqlHandle {CREATE TABLE t1 (year_col INT, some_data INT)
PARTITION BY RANGE (year_col) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1995),
    PARTITION p2 VALUES LESS THAN (1999),
    PARTITION p3 VALUES LESS THAN (2002),
    PARTITION p4 VALUES LESS THAN (2006),
    PARTITION p5 VALUES LESS THAN MAXVALUE
)})</pre>

				<p>PARTITION ... VALUES LESS THAN ... statements work in a consecutive fashion.
					VALUES LESS THAN MAXVALUE works to specify "leftover" values that are greater than the maximum value otherwise specified.</p>

				<p>Note that VALUES LESS THAN clauses work sequentially in a manner similar to that of the case portions of a switch ... case block
					(as found in many programming languages such as C, Java, and PHP).
					That is, the clauses must be arranged in such a way that the upper limit specified in each successive VALUES LESS THAN is greater than that of the previous one,
					with the one referencing MAXVALUE coming last of all in the list.</p>
			</li>
			<li>
				<p>LIST(expr): This is useful when assigning partitions based on a table column with a restricted set of possible values,
					such as a state or country code. In such a case, all rows pertaining to a certain state or country can be assigned to a single partition,
					or a partition can be reserved for a certain set of states or countries.
					It is similar to RANGE, except that only VALUES IN may be used to specify allowable values for each partition.</p>
					
				<p>VALUES IN is used with a list of values to be matched.
					For instance, you could create a partitioning scheme such as the following:</p>
					
				<pre>(sql sqlHandle {CREATE TABLE client_firms (id INT, name VARCHAR(35))
PARTITION BY LIST (id) (
    PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
    PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
    PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
    PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
)})</pre>

				<p>When using list partitioning, you must define at least one partition using VALUES IN.
					You cannot use VALUES LESS THAN with PARTITION BY LIST.</p>
				
				<p>Note: Currently, the value list used with VALUES IN must consist of integer values only.</p>
			</li>
			<li>
				<p>The number of partitions may optionally be specified with a PARTITIONS num clause, where num is the number of partitions.
					If both this clause and any PARTITION clauses are used, num must be equal to the total number of any partitions that are declared using PARTITION clauses.</p>
					
				<p>Note: Whether or not you use a PARTITIONS clause in creating a table that is partitioned by RANGE or LIST,
					you must still include at least one PARTITION VALUES clause in the table definition (see below).</p>
			</li>
			<li>
				<p>A partition may optionally be divided into a number of subpartitions.
					This can be indicated by using the optional SUBPARTITION BY clause.
					Subpartitioning may be done by HASH or KEY. Either of these may be LINEAR.
					These work in the same way as previously described for the equivalent partitioning types.
					(It is not possible to subpartition by LIST or RANGE.)</p>
					
				<p>The number of subpartitions can be indicated using the SUBPARTITIONS keyword followed by an integer value.</p>		
			</li>
			<li>
				<p>The value used in a PARTITIONS or SUBPARTITIONS clause must adhere to the following rules:</p>
				<ul>
					<li>The value must be a positive, non-zero integer.</li>
					<li>No leading zeroes are permitted.</li>
					<li>The value must be an integer literal, and cannot not be an expression.
						For example, PARTITIONS 0.2E+01 is not allowed, even though 0.2E+01 evaluates to 2.</li>
				</ul>
				<p>Note: The expression (expr) used in a PARTITION BY clause cannot refer to any columns not in the table being created;
				Such references are specifically disallowed and cause the statement to fail with an error.</p>
			</li>
		</ul>
		<p>Each partition may be individually defined using a partition_definition clause. The individual parts making up this clause are as follows:</p>

		<ul>
			<li>
				<p>PARTITION partition_name: This specifies a logical name for the partition.</p>
			</li>
			<li>
				<p>A VALUES clause: For range partitioning, each partition must include a VALUES LESS THAN clause;
					for list partitioning, you must specify a VALUES IN clause for each partition.
					This is used to determine which rows are to be stored in this partition.</p>
			</li>
			<li>
				<p>An optional COMMENT clause may be used to specify a string that describes the partition. Example:</p>
				<pre>COMMENT = 'Data for the years previous to 1999'</pre>
			</li>
			<li>
				<p>DATA DIRECTORY and INDEX DIRECTORY may be used to indicate the directory where,
					respectively, the data and indexes for this partition are to be stored.
					Both the data_dir and the index_dir must be absolute system pathnames. Example:</p>
				<pre>(sql sqlHandle {CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
PARTITION BY LIST(YEAR(adate))
(
  PARTITION p1999 VALUES IN (1995, 1999, 2003)
    DATA DIRECTORY = '/var/appdata/95/data'
    INDEX DIRECTORY = '/var/appdata/95/idx',
  PARTITION p2000 VALUES IN (1996, 2000, 2004)
    DATA DIRECTORY = '/var/appdata/96/data'
    INDEX DIRECTORY = '/var/appdata/96/idx',
  PARTITION p2001 VALUES IN (1997, 2001, 2005)
    DATA DIRECTORY = '/var/appdata/97/data'
    INDEX DIRECTORY = '/var/appdata/97/idx',
  PARTITION p2000 VALUES IN (1998, 2002, 2006)
    DATA DIRECTORY = '/var/appdata/98/data'
    INDEX DIRECTORY = '/var/appdata/98/idx'
)})</pre>

				<p>DATA DIRECTORY and INDEX DIRECTORY behave in the same way as in the CREATE TABLE statement's table_option clause as used for MyISAM tables.</p>
				<p>One data directory and one index directory may be specified per partition.
					If left unspecified, the data and indexes are stored by default in the table's database directory.</p>
				<p>On Windows, the DATA DIRECTORY and INDEX DIRECTORY options are not supported for individual partitions or subpartitions.
					These options are ignored on Windows, except that a warning is generated.</p>
			</li>
			<li>
				<p>MAX_ROWS and MIN_ROWS may be used to specify, respectively, the maximum and minimum number of rows to be stored in the partition.
					The values for max_number_of_rows and min_number_of_rows must be positive integers.
					As with the table-level options with the same names, these act only as "suggestions" to the server and are not hard limits.</p>
			</li>
			<li>
				<p>The partitioning handler accepts a [STORAGE] ENGINE option for both PARTITION and SUBPARTITION.
					Currently, the only way in which this can be used is to set all partitions or all subpartitions to the same storage engine,
					and an attempt to set different storage engines for partitions or subpartitions in the same table will give rise to the error
					ERROR 1469 (HY000): The mix of handlers in the partitions is not allowed in this version of MySQL.</p>
			</li>
			<li>
				<p>The partition definition may optionally contain one or more subpartition_definition clauses.
					Each of these consists at a minimum of the SUBPARTITION name, where name is an identifier for the subpartition.
					Except for the replacement of the PARTITION keyword with SUBPARTITION, the syntax for a subpartition definition is identical to that for a partition definition.</p>
			</li>
			<li>
				<p>Subpartitioning must be done by HASH or KEY, and can be done only on RANGE or LIST partitions.</p>
			</li>
		</ul>
		<p>Partitions can be modified, merged, added to tables, and dropped from tables.</p>
		<p><b>Important</b></p>
		<p>The original CREATE TABLE statement, including all specifications and table options are stored by SQL when the table is created.
			The information is retained so that if you change storage engines, collations or other settings using an ALTER TABLE statement,
			the original table options specified are retained.
			This allows you to change between InnoDB and MyISAM table types even though the row formats supported by the two engines are different.</p>
		<p>Because the text of the original statement is retained, but due to the way that certain values and options may be silently reconfigured (such as the ROW_FORMAT),
			the active table definition (accessible through DESCRIBE or with SHOW TABLE STATUS) and
			the table creation string (accessible through SHOW CREATE TABLE) will report different values.</p>
			
		<p>You can create one table from another by adding a SELECT statement at the end of the CREATE TABLE statement:</p>
		<pre>(sql sqlHandle {CREATE TABLE new_tbl SELECT * FROM orig_tbl})</pre>
		
		<p>SQL creates new columns for all elements in the SELECT. For example:</p>
		<pre>(sql sqlHandle {CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (a), KEY(b)) ENGINE=MyISAM SELECT b,c FROM test2})</pre>
		
		<p>This creates a MyISAM table with three columns, a, b, and c.
			Notice that the columns from the SELECT statement are appended to the right side of the table, not overlapped onto it. Take the following example:</p>
		<pre>(sql sqlHandle {SELECT * FROM foo}) <b>Returns</b>
#(rec(n:Long:1)| n:1)</pre>

		<pre>(sql sqlHandle {CREATE TABLE bar (m INT) SELECT n FROM foo})</pre>
		
		<pre>(sql sqlHandle {SELECT * FROM bar}) <b>Returns</b>
#(rec(m:Long:1 n:Long:1)| m:0 n:1)</pre>

		<p>For each row in table foo, a row is inserted in bar with the values from foo and default values for the new columns.</p>
		<p>In a table resulting from CREATE TABLE ... SELECT, columns named only in the CREATE TABLE part come first.
			Columns named in both parts or only in the SELECT part come after that.
			The data type of SELECT columns can be overridden by also specifying the column in the CREATE TABLE part.</p>
		<p>If any errors occur while copying the data to the table, it is automatically dropped and not created.</p>
		<p>CREATE TABLE ... SELECT does not automatically create any indexes for you.
			This is done intentionally to make the statement as flexible as possible.
			If you want to have indexes in the created table, you should specify these before the SELECT statement:</p>
		<pre>(sql sqlHandle {CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo})</pre>

		<p>Some conversion of data types might occur. For example, the AUTO_INCREMENT attribute is not preserved, and VARCHAR columns can become CHAR columns.
			Retrained attributes are NULL (or NOT NULL) and, for those columns that have them, CHARACTER SET, COLLATION, COMMENT, and the DEFAULT clause.</p>
			
		<p>When creating a table with CREATE ... SELECT, make sure to alias any function calls or expressions in the query.
			If you do not, the CREATE statement might fail or result in undesirable column names.</p>
			
		<p>(sql sqlHandle {
CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id})</pre>
  
		<p>You can also explicitly specify the data type for a generated column:</p>
		<pre>(sql sqlHandle {CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar})</pre>
		
		<p>Use LIKE to create an empty table based on the definition of another table,
			including any column attributes and indexes defined in the original table:</p>
			
		<pre>(sql sqlHandle {CREATE TABLE new_tbl LIKE orig_tbl})</pre>
		
		<p>The copy is created using the same version of the table storage format as the original table.
			The SELECT privilege is required on the original table.</p>
			
		<p>LIKE works only for base tables, not for views.</p>
		
		<p>CREATE TABLE ... LIKE does not preserve any DATA DIRECTORY or INDEX DIRECTORY table options
			that were specified for the original table, or any foreign key definitions.</p>
			
		<p>You can precede the SELECT by IGNORE or REPLACE to indicate how to handle rows that duplicate unique key values.
			With IGNORE, new rows that duplicate an existing row on a unique key value are discarded.
			With REPLACE, new rows replace rows that have the same unique key value.
			If neither IGNORE nor REPLACE is specified, duplicate unique key values result in an error.</p>

		<p>To ensure that the binary log can be used to re-create the original tables,
			SQL does not allow concurrent inserts during CREATE TABLE ... SELECT.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE TRIGGER Syntax"></A>CREATE TRIGGER Syntax</H2></P>
		<pre>CREATE
    [DEFINER = { user | CURRENT_USER }]
    TRIGGER trigger_name trigger_time trigger_event
    ON tbl_name FOR EACH ROW trigger_stmt</pre>
	
		<p>This statement creates a new trigger.
			A trigger is a named database object that is associated with a table, and that activates when a particular event occurs for the table.
			The trigger becomes associated with the table named tbl_name, which must refer to a permanent table.
			You cannot associate a trigger with a TEMPORARY table or a view.</p>
			
		<p>CREATE TRIGGER requires the TRIGGER privilege for the table associated with the trigger.</p>
		<p>The DEFINER clause determines the security context to be used when checking access privileges at trigger activation time.</p>
		<p>trigger_time is the trigger action time. It can be BEFORE or AFTER to indicate that the trigger activates before or after each row to be modified.</p>
		<p>trigger_event indicates the kind of statement that activates the trigger. The trigger_event can be one of the following:</p>
		<ul>
			<li>INSERT: The trigger is activated whenever a new row is inserted into the table; for example, through INSERT, LOAD DATA, and REPLACE statements.</li>
			<li>UPDATE: The trigger is activated whenever a row is modified; for example, through UPDATE statements.</li>
			<li>DELETE: The trigger is activated whenever a row is deleted from the table; for example, through DELETE and REPLACE statements.
				However, DROP TABLE and TRUNCATE statements on the table do not activate this trigger, because they do not use DELETE.
				Dropping a partition does not activate DELETE triggers, either.</li>
		</ul>
		
		<p>It is important to understand that the trigger_event does not represent a literal type of SQL statement that activates the trigger so much as it represents a type of table operation.
			For example, an INSERT trigger is activated by not only INSERT statements but also LOAD DATA statements because both statements insert rows into a table.</p>
		
		<p>A potentially confusing example of this is the INSERT INTO ... ON DUPLICATE KEY UPDATE ... syntax:
			a BEFORE INSERT trigger will activate for every row, followed by either an AFTER INSERT trigger or both the BEFORE UPDATE and AFTER UPDATE triggers,
			depending on whether there was a duplicate key for the row.</p>

		<p>There cannot be two triggers for a given table that have the same trigger action time and event.
			For example, you cannot have two BEFORE UPDATE triggers for a table.
			But you can have a BEFORE UPDATE and a BEFORE INSERT trigger, or a BEFORE UPDATE and an AFTER UPDATE trigger.</p>
			
		<p>trigger_stmt is the statement to execute when the trigger activates.
			If you want to execute multiple statements, use the BEGIN ... END compound statement construct.
			This also enables you to use the same statements that are allowable within stored routines.
			Some statements are not allowed in triggers.</p>
		
		<p>SQL stores the sql_mode system variable setting that is in effect at the time a trigger is created,
			and always executes the trigger with this setting in force, regardless of the current server SQL mode.</p>
			
		<p>Note: Currently, triggers are not activated by cascaded foreign key actions.
			This limitation will be lifted as soon as possible.</p>
			
		<p>You can write triggers containing direct references to tables by name, such as the trigger named testref shown in this example:</p>
		
		<pre>(sql sqlHandle {CREATE TABLE test1(a1 INT))</pre>
		<pre>(sql sqlHandle {CREATE TABLE test2(a2 INT)}</pre>
		<pre>(sql sqlHandle {CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY)})</pre>
		<pre>(sql sqlHandle {CREATE TABLE test4(a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY, b4 INT DEFAULT 0)})</pre>

		<pre>(sql sqlHandle {
CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;  
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END})</pre>

		<pre>(sql sqlHandle {
INSERT INTO test3 (a3) VALUES 
  (NULL), (NULL), (NULL), (NULL), (NULL), 
  (NULL), (NULL), (NULL), (NULL), (NULL)}) <b>Returns</b> 10</pre>
  
		<pre>(sql sqlHandle {
INSERT INTO test4 (a4) VALUES 
  (0), (0), (0), (0), (0), (0), (0), (0), (0), (0)}) <b>Returns</b> 10</pre>
  
		<p>Suppose that you insert the following values into table test1 as shown here:</p>
		
		<pre>(sql sqlHandle {
INSERT INTO test1 VALUES 
  (1), (3), (1), (7), (1), (8), (4), (4)}) <b>Returns</b> 8</pre>

		<p>As a result, the data in the four tables will be as follows:</p>

		<pre>(sql sqlHandle {SELECT * FROM test1}) <b>Returns</b>
#(rec(8 a1:Long:1)| [0](a1:1) [1](a1:3) [2](a1:1) [3](a1:7) [4](a1:1) [5](a1:8) [6](a1:4) [7](a1:4))</pre>

		<pre>(sql sqlHandle {SELECT * FROM test2}) <b>Returns</b>
#(rec(8 a2:Long:1)| [0](a2:1) [1](a2:3) [2](a2:1) [3](a2:7) [4](a2:1) [5](a2:8) [6](a2:4) [7](a2:4))</pre>

		<pre>(sql sqlHandle {SELECT * FROM test3}) <b>Returns</b>
#(rec(5 a3:Long:1)| [0](a3:2) [1](a3:5) [2](a3:6) [3](a3:9) [4](a3:10))</pre>

		<pre>(sql sqlHandle {SELECT * FROM test4}) <b>Returns</b>
#(rec(10 a4:Long:1 b4:Long:1)| [0](a4:1 b4:3) [1](a4:2 b4:0) [2](a4:3 b4:1) [3](a4:4 b4:2) [4](a4:5 b4:0) [5](a4:6 b4:0) [6](a4:7 b4:1) [7](a4:8 b4:1) [8](a4:9 b4:0) [9](a4:10 b4:0))</pre>

		<p>You can refer to columns in the subject table (the table associated with the trigger) by using the aliases OLD and NEW.
			OLD.col_name refers to a column of an existing row before it is updated or deleted.
			NEW.col_name refers to the column of a new row to be inserted or an existing row after it is updated.</p>
			
		<p>The DEFINER clause specifies the SQL account to be used when checking access privileges at trigger activation time.
			If a user value is given, it should be a SQL account in 'user_name'@'host_name' format (the same format used in the GRANT statement).
			The user_name and host_name values both are required. The definer can also be given as CURRENT_USER or CURRENT_USER().
			The default DEFINER value is the user who executes the CREATE TRIGGER statement. (This is the same as DEFINER = CURRENT_USER.)</p>
			
		<p>If you specify the DEFINER clause, these rules determine the legal DEFINER user values:</p>
		
		<ul>
			<li>
				<p>If you do not have the SUPER privilege, the only legal user value is your own account,
				either specified literally or by using CURRENT_USER. You cannot set the definer to some other account.</p>
			</li>
			<li>
				<p>If you have the SUPER privilege, you can specify any syntactically legal account name.
				If the account does not actually exist, a warning is generated.</p>
				<p>Although it is possible to create triggers with a non-existent DEFINER value,
					it is not a good idea for such triggers to be activated until the definer actually does exist.
					Otherwise, the behavior with respect to privilege checking is undefined.</p>
			</li>
		</ul>
		
		<p>Note: CREATE TRIGGER requires the TRIGGER privilege and SUPER is required only to be able to set DEFINER to a value other than your own account.</p>
		
		<p>SQL checks trigger privileges like this:</p>
		
		<ul>
			<li>
				<p>At CREATE TRIGGER time, the user that issues the statement must have the TRIGGER privilege.</p>
			</li>
			<li>
				<p>At trigger activation time, privileges are checked against the DEFINER user. This user must have these privileges:</p>
				<ul>
					<li>The TRIGGER privilege.</li>
					<li>The SELECT privilege for the subject table if references to table columns occur via OLD.col_name or NEW.col_name in the trigger definition.</li>
					<li>The UPDATE privilege for the subject table if table columns are targets of SET NEW.col_name = value assignments in the trigger definition.</li>
					<li>Whatever other privileges normally are required for the statements executed by the trigger.</li>
				</ul>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE VIEW Syntax"></A>CREATE VIEW Syntax</H2></P>
		<pre>CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { user | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]</pre>
		
		<p>The CREATE VIEW statement creates a new view, or replaces an existing one if the OR REPLACE clause is given.
			If the view does not exist, CREATE OR REPLACE VIEW is the same as CREATE VIEW.
			If the view does exist, CREATE OR REPLACE VIEW is the same as ALTER VIEW.</p>
			
		<p>The select_statement is a SELECT statement that provides the definition of the view.
			(When you select from the view, you select in effect using the SELECT statement.)
			select_statement can select from base tables or other views.</p>
			
		<p>The view definition is "frozen" at creation time, so changes to the underlying tables afterward do not affect the view definition.
			For example, if a view is defined as SELECT * on a table, new columns added to the table later do not become part of the view.</p>
			
		<p>The ALGORITHM clause affects how SQL processes the view.
			The DEFINER and SQL SECURITY clauses specify the security context to be used when checking access privileges at view invocation time.
			The WITH CHECK OPTION clause can be given to constrain inserts or updates to rows in tables referenced by the view.
			These clauses are described later in this section.</p>
			
		<p>The CREATE VIEW statement requires the CREATE VIEW privilege for the view,
			and some privilege for each column selected by the SELECT statement.
			For columns used elsewhere in the SELECT statement you must have the SELECT privilege.
			If the OR REPLACE clause is present, you must also have the DROP privilege for the view.</p>
			
		<p>A view belongs to a database. By default, a new view is created in the default database.
			To create the view explicitly in a given database, specify the name as db_name.view_name when you create it.</p>
			
		<pre>(sql sqlHandle {CREATE VIEW test.v AS SELECT * FROM t})</pre>
		
		<p>Base tables and views share the same namespace within a database,
			so a database cannot contain a base table and a view that have the same name.</p>
			
		<p>Views must have unique column names with no duplicates, just like base tables.
			By default, the names of the columns retrieved by the SELECT statement are used for the view column names.
			To define explicit names for the view columns, the optional column_list clause can be given as a list of comma-separated identifiers.
			The number of names in column_list must be the same as the number of columns retrieved by the SELECT statement.</p>
		
		<p><b>Note</b></p>

		<p>When you modify an existing view, the current view definition is backed up and saved.
			It is stored in that table's database directory, in a subdirectory named arc.
			The backup file for a view v is named v.frm-00001. If you alter the view again, the next backup is named v.frm-00002.
			The three latest view backup definitions are stored.</p>

		<p>Backed up view definitions are not preserved by mysqldump, or any other such programs, but you can retain them using a file copy operation.
			However, they are not needed for anything but to provide you with a backup of your previous view definition.</p>
			
		<p>It is safe to remove these backup definitions, but only while mysqld is not running.
			If you delete the arc subdirectory or its files while mysqld is running, you will receive an error the next time you try to alter the view:</p>

		<pre>(sql sqlHandle {ALTER VIEW v AS SELECT * FROM t}) <b>Returns</b> ERROR 6 (HY000): Error on delete of '.\test\arc/v.frm-0004' (Errcode: 2)</pre>
		
		<p>Columns retrieved by the SELECT statement can be simple references to table columns.
			They can also be expressions that use functions, constant values, operators, and so forth.</p>
			
		<p>Unqualified table or view names in the SELECT statement are interpreted with respect to the default database.
			A view can refer to tables or views in other databases by qualifying the table or view name with the proper database name.</p>
			
		<p>A view can be created from many kinds of SELECT statements. It can refer to base tables or other views.
			It can use joins, UNION, and subqueries. The SELECT need not even refer to any tables.
			The following example defines a view that selects two columns from another table, as well as an expression calculated from those columns:</p>
			
		<pre>(sql sqlHandle {CREATE TABLE t (qty INT, price INT)}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {INSERT INTO t VALUES(3, 50)}) <b>Returns</b> 1</pre>
		<pre>(sql sqlHandle {CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {SELECT * FROM v}) <b>Returns</b>
#(rec(qty:Long:1 price:Long:1 value:Integer:1)| qty:3 price:50 value:150)</pre>

		<p>A view definition is subject to the following restrictions:</p>
		<ul>
			<li>
				<p>The SELECT statement cannot contain a subquery in the FROM clause.</p>
			</li>
			<li>
				<p>The SELECT statement cannot refer to system or user variables.</p>
			</li>
			<li>
				<p>The SELECT statement cannot refer to prepared statement parameters.</p>
			</li>
			<li>
				<p>Within a stored routine, the definition cannot refer to routine parameters or local variables.</p>
			</li>
			<li>
				<p>Any table or view referred to in the definition must exist. However, after a view has been created, it is possible to drop a table or view that the definition refers to.
				In this case, use of the view results in an error. To check a view definition for problems of this kind, use the CHECK TABLE statement.</p>
			</li>
			<li>
				<p>The definition cannot refer to a TEMPORARY table, and you cannot create a TEMPORARY view.</p>
			</li>
			<li>
				<p>The tables named in the view definition must already exist.</p>
			</li>
			<li>
				<p>You cannot associate a trigger with a view.</p>
			</li>
		</ul>
		
		<p>ORDER BY is allowed in a view definition, but it is ignored if you select from a view using a statement that has its own ORDER BY.</p>
		
		<p>For other options or clauses in the definition,
			they are added to the options or clauses of the statement that references the view, but the effect is undefined.
			For example, if a view definition includes a LIMIT clause, and you select from the view using a statement that has its own LIMIT clause,
			it is undefined which limit applies. This same principle applies to options such as ALL, DISTINCT,
			or SQL_SMALL_RESULT that follow the SELECT keyword, and to clauses such as INTO, FOR UPDATE, LOCK IN SHARE MODE, and PROCEDURE.</p>
			
		<p>If you create a view and then change the query processing environment by changing system variables, that may affect the results that you get from the view:</p>
		
		<pre>(sql sqlHandle {CREATE VIEW v (mycol) AS SELECT 'abc'}) <b>Returns</b> 0</pre>
		
		<pre>(sql sqlHandle {SET sql_mode = ''}) <b>Returns</b> 0</pre>

		<pre>(sql sqlHandle {SELECT "mycol" FROM v}) <b>Returns</b>
#(rec(mycol:Character:5)| mycol:"mycol")</pre>

		<pre>(sql sqlHandle {SET sql_mode = 'ANSI_QUOTES'}) <b>Returns</b> 0</pre>

		<pre>(sql sqlHandle {SELECT "mycol" FROM v}) <b>Returns</b>
#(rec(mycol:Character:3)| mycol:"abc")</pre>

		<p>The DEFINER and SQL SECURITY clauses determine which SQL account to use when checking access privileges for the view when a statement is executed that references the view.
			The legal SQL SECURITY characteristic values are DEFINER and INVOKER.
			These indicate that the required privileges must be held by the user who defined or invoked the view, respectively.
			The default SQL SECURITY value is DEFINER.</p>
			
		<p>If a user value is given for the DEFINER clause, it should be a SQL account in 'user_name'@'host_name' format (the same format used in the GRANT statement).
			The user_name and host_name values both are required. The definer can also be given as CURRENT_USER or CURRENT_USER().
			The default DEFINER value is the user who executes the CREATE VIEW statement.
			This is the same as specifying DEFINER = CURRENT_USER explicitly.</p>
			
		<p>If you specify the DEFINER clause, these rules determine the legal DEFINER user values:</p>
		<ul>
			<li>
				<p>If you do not have the SUPER privilege, the only legal user value is your own account,
					either specified literally or by using CURRENT_USER. You cannot set the definer to some other account.</p>
			</li>
			<li>
				<p>If you have the SUPER privilege, you can specify any syntactically legal account name.
					If the account does not actually exist, a warning is generated.</p>
				<p>If the SQL SECURITY value is DEFINER but the definer account does not exist when the view is referenced, an error occurs.</p>
			</li>
		</ul>
		
		<p>Within a stored routine that is defined with the SQL SECURITY DEFINER characteristic, CURRENT_USER returns the routine creator.
			This also affects a view defined within such a routine, if the view definition contains a DEFINER value of CURRENT_USER.</p>
			
		<p>When the DEFINER and SQL SECURITY clauses were implemented, view privileges are checked like this:</p>
		<ul>
			<li>
				<p>At view definition time, the view creator must have the privileges needed to use the top-level objects accessed by the view.
					For example, if the view definition refers to table columns, the creator must have privileges for the columns, as described previously.
					If the definition refers to a stored function, only the privileges needed to invoke the function can be checked.
					The privileges required when the function runs can be checked only as it executes:
					For different invocations of the function, different execution paths within the function might be taken.</p>
			</li>
			<li>
				<p>When a view is referenced, privileges for objects accessed by the view are checked against the privileges held by the view creator or invoker,
					depending on whether the SQL SECURITY characteristic is DEFINER or INVOKER, respectively.</p>
			</li>
			<li>
				<p>If reference to a view causes execution of a stored function, privilege checking for statements executed within the function depend on whether
					the function is defined with a SQL SECURITY characteristic of DEFINER or INVOKER. If the security characteristic is DEFINER,
					the function runs with the privileges of its creator. If the characteristic is INVOKER,
					the function runs with the privileges determined by the view's SQL SECURITY characteristic.</p>
			</li>
		</ul>
		
		<p>The optional ALGORITHM clause is an extension to standard SQL.
			It affects how SQL processes the view. ALGORITHM takes three values: MERGE, TEMPTABLE, or UNDEFINED.
			The default algorithm is UNDEFINED if no ALGORITHM clause is present.</p>
			
		<p>Some views are updatable. That is, you can use them in statements such as UPDATE, DELETE, or INSERT to update the contents of the underlying table.
			For a view to be updatable, there must be a one-to-one relationship between the rows in the view and the rows in the underlying table.
			There are also certain other constructs that make a view non-updatable.</p>
			
		<p>The WITH CHECK OPTION clause can be given for an updatable view to prevent inserts or updates to rows except those for which the WHERE clause in the select_statement is true.</p>
		
		<p>In a WITH CHECK OPTION clause for an updatable view, the LOCAL and CASCADED keywords determine the scope of check testing when the view is defined in terms of another view.
			The LOCAL keyword restricts the CHECK OPTION only to the view being defined.
			CASCADED causes the checks for underlying views to be evaluated as well.
			When neither keyword is given, the default is CASCADED.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP DATABASE Syntax"></A>DROP DATABASE Syntax</H2></P>
		<pre>DROP {DATABASE | SCHEMA} [IF EXISTS] db_name</pre>
		
		<p>DROP DATABASE drops all tables in the database and deletes the database.
			Be very careful with this statement! To use DROP DATABASE, you need the DROP privilege on the database.
			DROP SCHEMA is a synonym for DROP DATABASE.</p>
			
		<p>Important: When a database is dropped, user privileges on the database are not automatically dropped.</p>
		
		<p>IF EXISTS is used to prevent an error from occurring if the database does not exist.</p>
		
		<p>If you use DROP DATABASE on a symbolically linked database, both the link and the original database are deleted.</p>
		
		<p>DROP DATABASE returns the number of tables that were removed. This corresponds to the number of .frm files removed.</p>
		
		<p>The DROP DATABASE statement removes from the given database directory those files and directories that SQL itself may create during normal operation:</p>
		<ul>
			<li>
				<p>All files with these extensions:</p>
				<p>.BAK .DAT .HSH .MRG .MYD .MYI .TRG .TRN .db .frm .ibd .ndb .par</p>
			</li>
			<li>
				<p>The db.opt file, if it exists.</p>
			</li>
		</ul>
		
		<p>If other files or directories remain in the database directory after SQL removes those just listed, the database directory cannot be removed.
			In this case, you must remove any remaining files or directories manually and issue the DROP DATABASE statement again.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP EVENT Syntax"></A>DROP EVENT Syntax</H2></P>
		<pre>DROP EVENT [IF EXISTS] event_name</pre>
		
		<p>This statement drops the event named event_name. The event immediately ceases being active, and is deleted completely from the server.</p>
		<p>If the event does not exist, the error ERROR 1517 (HY000): Unknown event 'event_name' results.
			You can override this and cause the statement to generate a warning for non-existent events instead using IF EXISTS.</p>
			
		<p>An event can be dropped by any user having the EVENT privilege on the database schema to which the event to be dropped belongs.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP FUNCTION Syntax"></A>DROP FUNCTION Syntax</H2></P>
		<p>The DROP FUNCTION statement is used to drop stored functions and user-defined functions (UDFs).</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP INDEX Syntax"></A>DROP INDEX Syntax</H2></P>
		<pre>DROP [ONLINE|OFFLINE] INDEX index_name ON tbl_name</pre>
		
		<p>DROP INDEX drops the index named index_name from the table tbl_name.
			This statement is mapped to an ALTER TABLE statement to drop the index.</p>
			
		<p>Indexes on variable-width columns are dropped online; that is, dropping the indexes does not require any copying or locking of the table.
			This is done automatically by the server whenever it determines that it is possible to do so;
			you do not have to use any special SQL syntax or server options to cause it to happen.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP PROCEDURE and DROP FUNCTION Syntax"></A>DROP PROCEDURE and DROP FUNCTION Syntax</H2></P>
		<pre>DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name</pre>
		
		<p>This statement is used to drop a stored procedure or function.
			That is, the specified routine is removed from the server.
			You must have the ALTER ROUTINE privilege for the routine.
			(That privilege is granted automatically to the routine creator.)</p>
		
		<p>The IF EXISTS clause is an SQL extension.
			It prevents an error from occurring if the procedure or function does not exist.
			A warning is produced that can be viewed with SHOW WARNINGS.</p>

		<p>DROP FUNCTION is also used to drop user-defined functions.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP TABLE Syntax"></A>DROP TABLE Syntax</H2></P>
		<pre>DROP [TEMPORARY] TABLE [IF EXISTS]
    tbl_name [, tbl_name] ...
    [RESTRICT | CASCADE]</pre>
	
		<p>DROP TABLE removes one or more tables. You must have the DROP privilege for each table.
			All table data and the table definition are removed, so be careful with this statement!
			If any of the tables named in the argument list do not exist,
			SQL returns an error indicating by name which non-existing tables it was unable to drop,
			but it also drops all of the tables in the list that do exist.</p>
			
		<p>Important: When a table is dropped, user privileges on the table are not automatically dropped.</p>
		
		<p>Note that for a partitioned table, DROP TABLE permanently removes the table definition,
			all of its partitions, and all of the data which was stored in those partitions.
			It also removes the partitioning definition (.par) file associated with the dropped table.</p>
			
		<p>Use IF EXISTS to prevent an error from occurring for tables that do not exist.
			A NOTE is generated for each non-existent table when using IF EXISTS.</p>
			
		<p>RESTRICT and CASCADE are allowed to make porting easier.</p>
		
		<p>Note: DROP TABLE automatically commits the current active transaction, unless you use the TEMPORARY keyword.</p>
		
		<p>The TEMPORARY keyword has the following effects:</p>
		<ul>
			<li>The statement drops only TEMPORARY tables.</li>
			<li>The statement does not end an ongoing transaction.</li>
			<li>No access rights are checked. (A TEMPORARY table is visible only to the client that created it, so no check is necessary.)</li>
		</ul>
		
		<p>Using TEMPORARY is a good way to ensure that you do not accidentally drop a non-TEMPORARY table.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP TRIGGER Syntax"></A>DROP TRIGGER Syntax</H2></P>
		<pre>DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name</pre>
		
		<p>This statement drops a trigger. The schema (database) name is optional.
			If the schema is omitted, the trigger is dropped from the default schema.
			Its use requires the TRIGGER privilege for the table associated with the trigger.</p>
			
		<p>Use IF EXISTS to prevent an error from occurring for a trigger that does not exist.
			A NOTE is generated for a non-existent trigger when using IF EXISTS.</p>
			
		<p>Triggers for a table are also dropped if you drop the table.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP VIEW Syntax"></A>DROP VIEW Syntax</H2></P>
		<pre>DROP VIEW [IF EXISTS]
    view_name [, view_name] ...
    [RESTRICT | CASCADE]</pre>
	
		<p>DROP VIEW removes one or more views. You must have the DROP privilege for each view.
			If any of the views named in the argument list do not exist,
			SQL returns an error indicating by name which non-existing views it was unable to drop,
			but it also drops all of the views in the list that do exist.</p>

		<p>The IF EXISTS clause prevents an error from occurring for views that don't exist.
			When this clause is given, a NOTE is generated for each non-existent view.</p>
			
		<p>RESTRICT and CASCADE, if given, are parsed and ignored.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRENAME DATABASE Syntax"></A>RENAME DATABASE Syntax</H2></P>
		<pre>RENAME {DATABASE | SCHEMA} db_name TO new_db_name;</pre>
		
		<p>This statement was found to be dangerous and was removed in SQL. Use of this statement could result in loss of database contents, which is why it was removed. Do not use RENAME DATABASE in earlier versions in which it is present.</p>
		
		<p>To perform the task of upgrading database names with the new encoding, use ALTER DATABASE db_name UPGRADE DATA DIRECTORY NAME instead.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRENAME TABLE Syntax"></A>RENAME TABLE Syntax</H2></P>
		<pre>RENAME TABLE tbl_name TO new_tbl_name
    [, tbl_name2 TO new_tbl_name2] ...</pre>
	
		<p>This statement renames one or more tables.</p>
		
		<p>The rename operation is done atomically, which means that no other thread can access any of the tables while the rename is running.
			For example, if you have an existing table old_table, you can create another table new_table that has the same structure but is empty,
			and then replace the existing table with the empty one as follows (assuming that backup_table does not already exist):</p>
			
		<pre>(sql sqlHandle {CREATE TABLE new_table (...)})
(sql sqlHandle {RENAME TABLE old_table TO backup_table, new_table TO old_table})</pre>

		<p>If the statement renames more than one table, renaming operations are done from left to right.
			If you want to swap two table names, you can do so like this (assuming that tmp_table does not already exist):</p>
			
		<pre>(sql sqlHandle {RENAME TABLE old_table TO tmp_table, new_table TO old_table, tmp_table TO new_table})</pre>
			 
		<p>As long as two databases are on the same filesystem, you can use RENAME TABLE to move a table from one database to another:</p>
		
		<pre>(sql sqlHandle {RENAME TABLE current_db.tbl_name TO other_db.tbl_name})</pre>
		
		<p>If there are any triggers associated with a table which is moved to a different database using RENAME TABLE,
			then the statement fails with the error Trigger in wrong schema.</p>
			
		<p>RENAME TABLE also works for views, as long as you do not try to rename a view into a different database.</p>
		
		<p>Any privileges granted specifically for the renamed table or view are not migrated to the new name. They must be changed manually.</p>
		
		<p>When you execute RENAME, you cannot have any locked tables or active transactions.
			You must also have the ALTER and DROP privileges on the original table, and the CREATE and INSERT privileges on the new table.</p>
			
		<p>If SQL encounters any errors in a multiple-table rename,
			it does a reverse rename for all renamed tables to return everything to its original state.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCALL Statement Syntax"></A>CALL Statement Syntax</H2></P>
		<pre>CALL sp_name([parameter[,...]])
CALL sp_name[()]</pre>

		<p>The CALL statement invokes a stored procedure that was defined previously with CREATE PROCEDURE.</p>
		
		<p>CALL can pass back values to its caller using parameters that are declared as OUT or INOUT parameters.
			When the procedure returns, a client program can also obtain the number of rows affected for the final statement executed within the routine:
			At the SQL level, call the ROW_COUNT() function.</p>

		<p>stored procedures that take no arguments can be invoked without parentheses. That is, CALL p() and CALL p are equivalent.</p>
		
		<p>To get back a value from a procedure using an OUT or INOUT parameter, pass the parameter by means of a user variable,
			and then check the value of the variable after the procedure returns. (If you are calling the procedure from within another stored procedure or function,
			you can also pass a routine parameter or local routine variable as an IN or INOUT parameter.)
			For an INOUT parameter, initialize its value before passing it to the procedure.
			The following procedure has an OUT parameter that the procedure sets to the current server version,
			and an INOUT value that the procedure increments by one from its current value:</p>
			
		<pre>(sql sqlHandle {CREATE PROCEDURE p (OUT ver_param VARCHAR(25), INOUT incr_param INT)
BEGIN
  # Set value of OUT parameter
  SELECT VERSION() INTO ver_param;
  # Increment value of INOUT parameter
  SET incr_param = incr_param + 1;
END}) <b>Returns</b> 0</pre>

		<p>Before calling the procedure, initialize the variable to be passed as the INOUT parameter.
			After calling the procedure, the values of the two variables will have been set or modified:</p>
			
		<pre>(sql sqlHandle {SET @increment = 10}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {CALL p(@version, @increment)}) <b>Returns</b> 0</pre>
		<pre>(sql sqlHandle {SELECT @version, @increment}) <b>Returns</b>
#(rec(|@version|:Object:1 |@increment|:Integer:1)| |@version|:"5.1.26-rc-community" |@increment|:11)</pre>

		<p>For programs written in a language that provides an SQL interface,
			there is no native method for directly retrieving the results of OUT or INOUT parameters from CALL statements.
			To get the parameter values, pass user-defined variables to the procedure in the CALL statement and then execute a SELECT statement to produce a result set containing the variable values.
			The following example illustrates the technique (without error checking) for a stored procedure p1 that has two OUT parameters.</p>
			
		<p>To handle INOUT parameters, execute a statement prior to the CALL that sets the user variables to the values to be passed to the procedure.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDELETE Syntax"></A>DELETE Syntax</H2></P>
		<p>Single-table syntax:</p>
		<pre>DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM tbl_name
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]</pre>
	
		<p>Multiple-table syntax:</p>
		<pre>DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    tbl_name[.*] [, tbl_name[.*]] ...
    FROM table_references
    [WHERE where_condition]
Or:

DELETE [LOW_PRIORITY] [QUICK] [IGNORE]
    FROM tbl_name[.*] [, tbl_name[.*]] ...
    USING table_references
    [WHERE where_condition]</pre>
	
		<p>For the single-table syntax, the DELETE statement deletes rows from tbl_name and returns a count of the number of deleted rows.
			This count can be obtained by calling the ROW_COUNT() function.
			The WHERE clause, if given, specifies the conditions that identify which rows to delete.
			With no WHERE clause, all rows are deleted. If the ORDER BY clause is specified,
			the rows are deleted in the order that is specified. The LIMIT clause places a limit on the number of rows that can be deleted.</p>
			
		<p>For the multiple-table syntax, DELETE deletes from each tbl_name the rows that satisfy the conditions.
			In this case, ORDER BY and LIMIT cannot be used.</p>
		
		<p>where_condition is an expression that evaluates to true for each row to be deleted.</p>
		
		<p>Currently, you cannot delete from a table and select from the same table in a subquery.</p>
		
		<p>As stated, a DELETE statement with no WHERE clause deletes all rows.
			A faster way to do this, when you do not need to know the number of deleted rows, is to use TRUNCATE TABLE.
			However, within a transaction or if you have a lock on the table, TRUNCATE TABLE cannot be used whereas DELETE can.</p>
			
		<p>If you delete the row containing the maximum value for an AUTO_INCREMENT column, the value is not reused for a MyISAM or InnoDB table.
			If you delete all rows in the table with DELETE FROM tbl_name (without a WHERE clause) in AUTOCOMMIT mode, the sequence starts over for all storage engines except InnoDB and MyISAM.
			There are some exceptions to this behavior for InnoDB tables.</p>
			
		<p>For MyISAM tables, you can specify an AUTO_INCREMENT secondary column in a multiple-column key.
			In this case, reuse of values deleted from the top of the sequence occurs even for MyISAM tables.</p>
			
		<p>The DELETE statement supports the following modifiers:</p>
		
		<ul>
			<li>
				<p>If you specify LOW_PRIORITY, the server delays execution of the DELETE until no other clients are reading from the table.
					This affects only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE).</p>
			</li>
			<li>
				<p>For MyISAM tables, if you use the QUICK keyword,
					the storage engine does not merge index leaves during delete, which may speed up some kinds of delete operations.</p>
			</li>
			<li>
				<p>The IGNORE keyword causes SQL to ignore all errors during the process of deleting rows.
				(Errors encountered during the parsing stage are processed in the usual manner.)
				Errors that are ignored due to the use of IGNORE are returned as warnings.</p>
			</li>
		</ul>
		
		<p>In MyISAM tables, deleted rows are maintained in a linked list and subsequent INSERT operations reuse old row positions.
			To reclaim unused space and reduce file sizes, use the OPTIMIZE TABLE statement or the myisamchk utility to reorganize tables.
			OPTIMIZE TABLE is easier to use, but myisamchk is faster.</p>
			
		<p>The QUICK modifier affects whether index leaves are merged for delete operations.
			DELETE QUICK is most useful for applications where index values for deleted rows are replaced by similar index values from rows inserted later.
			In this case, the holes left by deleted values are reused.</p>
			
		<p>DELETE QUICK is not useful when deleted values lead to underfilled index blocks spanning a range of index values for which new inserts occur again.
			In this case, use of QUICK can lead to wasted space in the index that remains unreclaimed. Here is an example of such a scenario:</p>
			
		<ol>
			<li><p>Create a table that contains an indexed AUTO_INCREMENT column.</p></li>
			<li><p>Insert many rows into the table. Each insert results in an index value that is added to the high end of the index.</p></li>
			<li><p>Delete a block of rows at the low end of the column range using DELETE QUICK.</p></li>
		</ol>
		
		<p>In this scenario, the index blocks associated with the deleted index values become underfilled but are not merged with other index blocks due to the use of QUICK.
			They remain underfilled when new inserts occur, because new rows do not have index values in the deleted range.
			Furthermore, they remain underfilled even if you later use DELETE without QUICK,
			unless some of the deleted index values happen to lie in index blocks within or adjacent to the underfilled blocks.
			To reclaim unused index space under these circumstances, use OPTIMIZE TABLE.</p>
			
		<p>If you are going to delete many rows from a table, it might be faster to use DELETE QUICK followed by OPTIMIZE TABLE.
			This rebuilds the index rather than performing many index block merge operations.</p>
			
		<p>The SQL-specific LIMIT row_count option to DELETE tells the server the maximum number of rows to be deleted before control is returned to the client.
			This can be used to ensure that a given DELETE statement does not take too much time.
			You can simply repeat the DELETE statement until the number of affected rows is less than the LIMIT value.</p>
			
		<p>If the DELETE statement includes an ORDER BY clause, rows are deleted in the order specified by the clause.
			This is useful primarily in conjunction with LIMIT. For example, the following statement finds rows matching the WHERE clause,
			sorts them by timestamp_column, and deletes the first (oldest) one:</p>
			
		<pre>(sql sqlHandle {
DELETE FROM somelog WHERE user = 'jcole'
ORDER BY timestamp_column LIMIT 1})</pre>

		<p>ORDER BY may also be useful in some cases to delete rows in an order required to avoid referential integrity violations.</p>
		
		<p>You can specify multiple tables in a DELETE statement to delete rows from one or more tables depending on the particular condition in the WHERE clause.
			However, you cannot use ORDER BY or LIMIT in a multiple-table DELETE. The table_references clause lists the tables involved in the join.</p>
			
		<p>For the first multiple-table syntax, only matching rows from the tables listed before the FROM clause are deleted.
			For the second multiple-table syntax, only matching rows from the tables listed in the FROM clause (before the USING clause) are deleted.
			The effect is that you can delete rows from many tables at the same time and have additional tables that are used only for searching:</p>
			
		<pre>(sql sqlHandle {
DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id})</pre>

		<p>Or:</p>
		
		<pre>(sql sqlHandle {
DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3
WHERE t1.id=t2.id AND t2.id=t3.id})</pre>

		<p>These statements use all three tables when searching for rows to delete, but delete matching rows only from tables t1 and t2.</p>
		
		<p>The preceding examples show inner joins that use the comma operator,
			but multiple-table DELETE statements can use other types of join allowed in SELECT statements,
			such as LEFT JOIN. For example, to delete rows that exist in t1 that have no match in t2, use a LEFT JOIN:</p>
			
		<pre>(sql sqlHandle {
DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL})</pre>

		<p>The syntax allows .* after each tbl_name for compatibility with Access.</p>
		
		<p>If you use a multiple-table DELETE statement involving InnoDB tables for which there are foreign key constraints,
			the SQL optimizer might process tables in an order that differs from that of their parent/child relationship.
			In this case, the statement fails and rolls back.
			Instead, you should delete from a single table and rely on the ON DELETE capabilities that InnoDB provides to cause the other tables to be modified accordingly.</p>
			
		<p>Note: If you declare an alias for a table, you must use the alias when referring to the table:</p>
		
		<pre>(sql sqlHandle {DELETE t1 FROM test AS t1, test2 WHERE ...})</pre>
		
		<p>Table aliases in a multiple-table DELETE statement should be declared only in the table_references part.
			Elsewhere in the statement, alias references are allowed but not alias declarations.</p>
			
		<p>Correct:</p>
		
		<pre>(sql sqlHandle {
DELETE a1, a2 FROM t1 AS a2 INNER JOIN t2 AS a2
WHERE a1.id=a2.id})</pre>

		<pre>(sql sqlHandle {
DELETE FROM a1, a2 USING t1 AS a2 INNER JOIN t2 AS a2
WHERE a1.id=a2.id})</pre>

		<p>Incorrect:</p>
		
		<pre>(sql sqlHandle {
DELETE t1 AS a1, t2 AS a2 FROM t1 INNER JOIN t2
WHERE a1.id=a2.id})</pre>

		<pre>(sql sqlHandle {
DELETE FROM t1 AS a1, t2 AS a2 USING t1 INNER JOIN t2
WHERE a1.id=a2.id})</pre>

		<p>Declaration of aliases other than in the table_references part can lead to ambiguous statements that have unexpected results such as deleting rows from the wrong table.
			This is such a statement:</p>
			
		<pre>(sql sqlHandle {
DELETE FROM t1 AS a2 USING t1 AS a1 INNER JOIN t2 AS a2})</pre>

		<p>Cross-database deletes are supported for multiple-table deletes, but in this case, you must refer to the tables without using aliases. For example:</p>
		
		<pre>(sql sqlHandle {DELETE test1.tmp1, test2.tmp2 FROM test1.tmp1, test2.tmp2 WHERE ...})</pre>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDO Syntax"></A>DO Syntax</H2></P>
		<pre>DO expr [, expr] ...</pre>
		
		<p>DO executes the expressions but does not return any results.
			In most respects, DO is shorthand for SELECT expr, ..., but has the advantage that it is slightly faster when you do not care about the result.</p>
			
		<p>DO is useful primarily with functions that have side effects, such as RELEASE_LOCK().</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SHANDLER Syntax"></A>HANDLER Syntax</H2></P>
		<pre>HANDLER tbl_name OPEN [ [AS] alias]
HANDLER tbl_name READ index_name { = | >= | <= | < } (value1,value2,...)
    [ WHERE where_condition ] [LIMIT ... ]
HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
    [ WHERE where_condition ] [LIMIT ... ]
HANDLER tbl_name READ { FIRST | NEXT }
    [ WHERE where_condition ] [LIMIT ... ]
HANDLER tbl_name CLOSE</pre>

		<p>The HANDLER statement provides direct access to table storage engine interfaces.
			It is available for MyISAM and InnoDB tables.</p>
		
		<p>The HANDLER ... OPEN statement opens a table, making it accessible via subsequent HANDLER ... READ statements.
			This table object is not shared by other threads and is not closed until the thread calls HANDLER ... CLOSE or the thread terminates.
			If you open the table using an alias, further references to the open table with other HANDLER statements must use the alias rather than the table name.</p>

		<p>The first HANDLER ... READ syntax fetches a row where the index specified satisfies the given values and the WHERE condition is met.
			If you have a multiple-column index, specify the index column values as a comma-separated list.
			Either specify values for all the columns in the index, or specify values for a leftmost prefix of the index columns.
			Suppose that an index my_idx includes three columns named col_a, col_b, and col_c, in that order.
			The HANDLER statement can specify values for all three columns in the index, or for the columns in a leftmost prefix. For example:</p>
		
		<pre>HANDLER ... READ my_idx = (col_a_val,col_b_val,col_c_val) ...
HANDLER ... READ my_idx = (col_a_val,col_b_val) ...
HANDLER ... READ my_idx = (col_a_val) ...</pre>

		<p>To employ the HANDLER interface to refer to a table's PRIMARY KEY, use the quoted identifier `PRIMARY`:</p>
		
		<pre>HANDLER tbl_name READ `PRIMARY` ...</pre>
		
		<p>The second HANDLER ... READ syntax fetches a row from the table in index order that matches the WHERE condition.</p>

		<p>The third HANDLER ... READ syntax fetches a row from the table in natural row order that matches the WHERE condition.
			It is faster than HANDLER tbl_name READ index_name when a full table scan is desired.
			Natural row order is the order in which rows are stored in a MyISAM table data file.
			This statement works for InnoDB tables as well, but there is no such concept because there is no separate data file.</p>
			
		<p>Without a LIMIT clause, all forms of HANDLER ... READ fetch a single row if one is available.
			To return a specific number of rows, include a LIMIT clause. It has the same syntax as for the SELECT statement.</p>
			
		<p>HANDLER ... CLOSE closes a table that was opened with HANDLER ... OPEN.</p>
		
		<p>HANDLER is a somewhat low-level statement. For example, it does not provide consistency.
			That is, HANDLER ... OPEN does not take a snapshot of the table, and does not lock the table.
			This means that after a HANDLER ... OPEN statement is issued, table data can be modified
			(by the current thread or other threads) and these modifications might be only partially visible to HANDLER ... NEXT or HANDLER ... PREV scans.</p>
			
		<p>There are several reasons to use the HANDLER interface instead of normal SELECT statements:</p>
		<ul>
			<li>
				<p>HANDLER is faster than SELECT:</p>
				<ul>
					<li>
						<p>A designated storage engine handler object is allocated for the HANDLER ... OPEN.
							The object is reused for subsequent HANDLER statements for that table; it need not be reinitialized for each one.</p>
					</li>
					<li>
						<p>There is less parsing involved.</p>
					</li>
					<li>
						<p>There is no optimizer or query-checking overhead.</p>
					</li>
					<li>
						<p>The table does not have to be locked between two handler requests.</p>
					</li>
					<li>
						<p>The handler interface does not have to provide a consistent look of the data (for example, dirty reads are allowed),
							so the storage engine can use optimizations that SELECT does not normally allow.</p>
					</li>
				</ul>
			</li>
			<li>
				<p>For applications that use a low-level ISAM-like interface, HANDLER makes it much easier to port them to SQL.</p>
			</li>
			<li>
				<p>HANDLER enables you to traverse a database in a manner that is difficult (or even impossible) to accomplish with SELECT.
					The HANDLER interface is a more natural way to look at data when working with applications that provide an interactive user interface to the database.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SINSERT Syntax"></A>INSERT Syntax</H2></P>
		<pre>INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name [(col_name,...)]
    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]
Or:

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    SET col_name={expr | DEFAULT}, ...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]
Or:

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name [(col_name,...)]
    SELECT ...
    [ ON DUPLICATE KEY UPDATE
      col_name=expr
        [, col_name=expr] ... ]</pre>
		
		<p>INSERT inserts new rows into an existing table. The INSERT ... VALUES and INSERT ... SET forms of the statement insert rows based on explicitly specified values.
			The INSERT ... SELECT form inserts rows selected from another table or tables.</p>
			
		<p>You can use REPLACE instead of INSERT to overwrite old rows.
			REPLACE is the counterpart to INSERT IGNORE in the treatment of new rows that contain unique key values that duplicate old rows:
			The new rows are used to replace the old rows rather than being discarded.</p>

		<p>tbl_name is the table into which rows should be inserted. The columns for which the statement provides values can be specified as follows:</p>
		
		<ul>
			<li>
				<p>You can provide a comma-separated list of column names following the table name.
					In this case, a value for each named column must be provided by the VALUES list or the SELECT statement.</p>
			</li>
			<li>
				<p>If you do not specify a list of column names for INSERT ... VALUES or INSERT ... SELECT,
					values for every column in the table must be provided by the VALUES list or the SELECT statement.
					If you do not know the order of the columns in the table, use DESCRIBE tbl_name to find out.</p>
			</li>
			<li>
				<p>The SET clause indicates the column names explicitly.</p>
			</li>
		</ul>
		
		<p>Column values can be given in several ways:</p>
		
		<ul>
			<li>
				<p>If you are not running in strict SQL mode, any column not explicitly given a value is set to its default (explicit or implicit) value.
					For example, if you specify a column list that does not name all the columns in the table, unnamed columns are set to their default values.</p>
				<p>If you want an INSERT statement to generate an error unless you explicitly specify values for all columns that do not have a default value, you should use strict mode.</p>
			</li>
			<li>
				<p>Use the keyword DEFAULT to set a column explicitly to its default value.
					This makes it easier to write INSERT statements that assign values to all but a few columns,
					because it enables you to avoid writing an incomplete VALUES list that does not include a value for each column in the table.
					Otherwise, you would have to write out the list of column names corresponding to each value in the VALUES list.</p>
				<p>You can also use DEFAULT(col_name) as a more general form that can be used in expressions to produce a given column's default value.</p>
			</li>
			<li>
				<p>If both the column list and the VALUES list are empty, INSERT creates a row with each column set to its default value:</p>
				<pre>(sql sqlHandle {INSERT INTO tbl_name () VALUES()})</pre>
				<p>In strict mode, an error occurs if any column doesn't have a default value. Otherwise,
					SQL uses the implicit default value for any column that does not have an explicitly defined default.</p>
			</li>
			<li>
				<p>You can specify an expression expr to provide a column value.
					This might involve type conversion if the type of the expression does not match the type of the column,
					and conversion of a given value can result in different inserted values depending on the data type.
					For example, inserting the string '1999.0e-2' into an INT, FLOAT, DECIMAL(10,6), or YEAR column results in the values 1999, 19.9921, 19.992100, and 1999 being inserted, respectively.
					The reason the value stored in the INT and YEAR columns is 1999 is that the string-to-integer conversion looks only at as much of the initial part of the string as may be considered a valid integer or year.
					For the floating-point and fixed-point columns, the string-to-floating-point conversion considers the entire string a valid floating-point value.</p
				<p>An expression expr can refer to any column that was set earlier in a value list.
					For example, you can do this because the value for col2 refers to col1, which has previously been assigned:</p>
				<pre>(sql sqlHandle {INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2)})</pre>
				
				<p>But the following is not legal, because the value for col1 refers to col2, which is assigned after col1:</p>
				<pre>(sql sqlHandle {INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15)})</pre>
				
				<p>One exception involves columns that contain AUTO_INCREMENT values.
					Because the AUTO_INCREMENT value is generated after other value assignments, any reference to an AUTO_INCREMENT column in the assignment returns a 0.</p>
			</li>
		</ul>
		
		<p>INSERT statements that use VALUES syntax can insert multiple rows.
			To do this, include multiple lists of column values, each enclosed within parentheses and separated by commas. Example:</p>
		<pre>(sql sqlHandle {INSERT INTO tbl_name (a,b,c) VALUES(1,2,3),(4,5,6),(7,8,9)})</pre>
		
		<p>The values list for each row must be enclosed within parentheses.
			The following statement is illegal because the number of values in the list does not match the number of column names:</p>
		<pre>(sql sqlHandle {INSERT INTO tbl_name (a,b,c) VALUES(1,2,3,4,5,6,7,8,9)})</pre>
		
		<p>VALUE is a synonym for VALUES in this context.
			Neither implies anything about the number of values lists, and either may be used whether there is a single values list or multiple lists.</p>
			
		<p>The affected-rows value for an INSERT can be obtained using the ROW_COUNT() function.</p>
		
		<p>If you use an INSERT ... VALUES statement with multiple value lists or INSERT ... SELECT, the statement returns an information string in this format:</p>
		<pre>Records: 100 Duplicates: 0 Warnings: 0</pre>
		
		<p>Records indicates the number of rows processed by the statement.
			(This is not necessarily the number of rows actually inserted because Duplicates can be non-zero.)
			Duplicates indicates the number of rows that could not be inserted because they would duplicate some existing unique index value.
			Warnings indicates the number of attempts to insert column values that were problematic in some way.
			Warnings can occur under any of the following conditions:</p>
			
		<ul>
			<li>
				<p>Inserting NULL into a column that has been declared NOT NULL.
					For multiple-row INSERT statements or INSERT INTO ... SELECT statements, the column is set to the implicit default value for the column data type.
					This is 0 for numeric types, the empty string ('') for string types, and the "zero" value for date and time types.
					INSERT INTO ... SELECT statements are handled the same way as multiple-row inserts because the server does not examine the result set from the SELECT to see whether it returns a single row.
					(For a single-row INSERT, no warning occurs when NULL is inserted into a NOT NULL column. Instead, the statement fails with an error.)</p>
			</li>
			<li>
				<p>Setting a numeric column to a value that lies outside the column's range.
					The value is clipped to the closest endpoint of the range.</p>
			</li>
			<li>
				<p>Assigning a value such as '10.34 a' to a numeric column.
					The trailing non-numeric text is stripped off and the remaining numeric part is inserted.
					If the string value has no leading numeric part, the column is set to 0.</p>
			</li>
			<li>
				<p>Inserting a string into a string column (CHAR, VARCHAR, TEXT, or BLOB) that exceeds the column's maximum length.
					The value is truncated to the column's maximum length.</p>
			</li>
			<li>
				<p>Inserting a value into a date or time column that is illegal for the data type.
					The column is set to the appropriate zero value for the type.</p>
			</li>
		</ul>
		
		<p>If INSERT inserts a row into a table that has an AUTO_INCREMENT column,
			you can find the value used for that column by using the SQL LAST_INSERT_ID() function.</p>
		
		<p>The INSERT statement supports the following modifiers:</p>
		
		<ul>
			<li>
				<p>If you use the DELAYED keyword, the server puts the row or rows to be inserted into a buffer,
					and the client issuing the INSERT DELAYED statement can then continue immediately.
					If the table is in use, the server holds the rows. When the table is free, the server begins inserting rows,
					checking periodically to see whether there are any new read requests for the table.
					If there are, the delayed row queue is suspended until the table becomes free again.</p>
				<p>DELAYED is ignored with INSERT ... SELECT or INSERT ... ON DUPLICATE KEY UPDATE.</p>
				<p>DELAYED is also disregarded for an INSERT that uses functions accessing tables or triggers, or that is called from a function or a trigger.</p>
			</li>
			<li>
				<p>If you use the LOW_PRIORITY keyword, execution of the INSERT is delayed until no other clients are reading from the table.
					This includes other clients that began reading while existing clients are reading, and while the INSERT LOW_PRIORITY statement is waiting.
					It is possible, therefore, for a client that issues an INSERT LOW_PRIORITY statement to wait for a very long time (or even forever) in a read-heavy environment.
					(This is in contrast to INSERT DELAYED, which lets the client continue at once.
					Note that LOW_PRIORITY should normally not be used with MyISAM tables because doing so disables concurrent inserts.</p>
				<p>If you specify HIGH_PRIORITY, it overrides the effect of the --low-priority-updates option if the server was started with that option.
					It also causes concurrent inserts not to be used.</p>
				<p>LOW_PRIORITY and HIGH_PRIORITY affect only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE).</p>
			</li>
			<li>
				<p>If you use the IGNORE keyword, errors that occur while executing the INSERT statement are treated as warnings instead.
					For example, without IGNORE, a row that duplicates an existing UNIQUE index or PRIMARY KEY value in the table causes a duplicate-key error and the statement is aborted.
					With IGNORE, the row still is not inserted, but no error is issued.</p>
				<p>IGNORE has a similar effect on inserts into partitioned tables where no partition matching a given value is found.
					Without IGNORE, such INSERT statements are aborted with an error; however, when INSERT IGNORE is used,
					the insert operation fails silently for the row containing the unmatched value, but any rows that are matched are inserted.</p>
				<p>Data conversions that would trigger errors abort the statement if IGNORE is not specified.
					With IGNORE, invalid values are adjusted to the closest values and inserted; warnings are produced but the statement does not abort.</p>
			</li>
			<li>
				<p>If you specify ON DUPLICATE KEY UPDATE, and a row is inserted that would cause a duplicate value in a UNIQUE index or PRIMARY KEY,
					an UPDATE of the old row is performed.
					The affected-rows value per row is 1 if the row is inserted as a new row and 2 if an existing row is updated.</p>
			</li>
		</ul>
		<p>Inserting into a table requires the INSERT privilege for the table.
			If the ON DUPLICATE KEY UPDATE clause is used and a duplicate key causes an UPDATE to be performed instead,
			the statement requires the UPDATE privilege for the columns to be updated.
			For columns that are read but not modified you need only the SELECT privilege
			(such as for a column referenced only on the right hand side of an col_name=expr assignment in an ON DUPLICATE KEY UPDATE clause).</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SINSERT ... SELECT Syntax"></A>INSERT ... SELECT Syntax</H2></P>
		<pre>INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name [(col_name,...)]
    SELECT ...
    [ ON DUPLICATE KEY UPDATE col_name=expr, ... ]</pre>
	
		<p>With INSERT ... SELECT, you can quickly insert many rows into a table from one or many tables. For example:</p>
		
		<pre>(sql sqlHandle {
INSERT INTO tbl_temp2 (fld_id)
  SELECT tbl_temp1.fld_order_id
  FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100})</pre>
  
		<p>The following conditions hold for a INSERT ... SELECT statements:</p>
		<ul>
			<li>
				<p>Specify IGNORE to ignore rows that would cause duplicate-key violations.</p>
			</li>
			<li>
				<p>DELAYED is ignored with INSERT ... SELECT.</p>
			</li>
			<li>
				<p>The target table of the INSERT statement may appear in the FROM clause of the SELECT part of the query.
				(This was not possible in some older versions of MySQL.) In this case, SQL creates a temporary table to hold the rows from the SELECT and then inserts those rows into the target table.
				However, it remains true that you cannot use INSERT INTO t ... SELECT ... FROM t when t is a TEMPORARY table, because TEMPORARY tables cannot be referred to twice in the same statement.</p>
			</li>
			<li>
				<p>AUTO_INCREMENT columns work as usual.</p>
			</li>
			<li>
				<p>To ensure that the binary log can be used to re-create the original tables,
					SQL does not allow concurrent inserts for INSERT ... SELECT statements.</p>
			</li>
			<li>
				<p>Currently, you cannot insert into a table and select from the same table in a subquery.</p>
			</li>
			<li>
				<p>To avoid ambiguous column reference problems when the SELECT and the INSERT refer to the same table,
					provide a unique alias for each table used in the SELECT part, and qualify column names in that part with the appropriate alias.</p>
			</li>
		</ul>
		<p>In the values part of ON DUPLICATE KEY UPDATE, you can refer to columns in other tables,
			as long as you do not use GROUP BY in the SELECT part. One side effect is that you must qualify non-unique column names in the values part.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SINSERT DELAYED Syntax"></A>INSERT DELAYED Syntax</H2></P>
		<pre>INSERT DELAYED ...</pre>
		
		<p>The DELAYED option for the INSERT statement is an SQL extension to standard SQL that is very useful if you have clients that cannot or need not wait for the INSERT to complete.
			This is a common situation when you use MySQL for logging and you also periodically run SELECT and UPDATE statements that take a long time to complete.</p>
			
		<p>When a client uses INSERT DELAYED, it gets an okay from the server at once, and the row is queued to be inserted when the table is not in use by any other thread.</p>
		
		<p>Another major benefit of using INSERT DELAYED is that inserts from many clients are bundled together and written in one block.
			This is much faster than performing many separate inserts.</p>
			
		<p>Note that INSERT DELAYED is slower than a normal INSERT if the table is not otherwise in use.
			There is also the additional overhead for the server to handle a separate thread for each table for which there are delayed rows.
			This means that you should use INSERT DELAYED only when you are really sure that you need it.</p>
		
		<p>The queued rows are held only in memory until they are inserted into the table.
			This means that if you terminate mysqld forcibly (for example, with kill -9) or if mysqld dies unexpectedly, any queued rows that have not been written to disk are lost.</p>
			
		<p>There are some constraints on the use of DELAYED:</p>
		<ul>
			<li>
				<p>INSERT DELAYED works only with MyISAM, MEMORY, ARCHIVE, and BLACKHOLE tables.</p>
			</li>
			<li>
				<p>For MyISAM tables, if there are no free blocks in the middle of the data file, concurrent SELECT and INSERT statements are supported.
					Under these circumstances, you very seldom need to use INSERT DELAYED with MyISAM.</p>
			</li>
			<li>
				<p>INSERT DELAYED should be used only for INSERT statements that specify value lists.
					The server ignores DELAYED for INSERT ... SELECT or INSERT ... ON DUPLICATE KEY UPDATE statements.</p>
			</li>
			<li>
				<p>Because the INSERT DELAYED statement returns immediately, before the rows are inserted,
					you cannot use LAST_INSERT_ID() to get the AUTO_INCREMENT value that the statement might generate.</p>
			</li>
			<li>
				<p>DELAYED rows are not visible to SELECT statements until they actually have been inserted.</p>
			</li>
			<li>
				<p>DELAYED is ignored on slave replication servers, so that INSERT DELAYED is treated as a normal INSERT on slaves.
					This is because DELAYED could cause the slave to have different data than the master.</p>
			</li>
			<li>
				<p>Pending INSERT DELAYED statements are lost if a table is write locked and ALTER TABLE is used to modify the table structure.</p>
			</li>
			<li>
				<p>INSERT DELAYED is not supported for views.</p>
			</li>
			<li>
				<p>INSERT DELAYED is not supported for partitioned tables.</p>
			</li>
		</ul>
		
		<p>The following describes in detail what happens when you use the DELAYED option to INSERT or REPLACE.
			In this description, the "thread" is the thread that received an INSERT DELAYED statement and "handler" is the thread that handles all INSERT DELAYED statements for a particular table.</p>

		<ul>
			<li>
				<p>When a thread executes a DELAYED statement for a table, a handler thread is created to process all DELAYED statements for the table, if no such handler already exists.</p>
			</li>
			<li>
				<p>The thread checks whether the handler has previously acquired a DELAYED lock; if not, it tells the handler thread to do so.
					The DELAYED lock can be obtained even if other threads have a READ or WRITE lock on the table.
					However, the handler waits for all ALTER TABLE locks or FLUSH TABLES statements to finish, to ensure that the table structure is up to date.</p>
			</li>
			<li>
				<p>The thread executes the INSERT statement, but instead of writing the row to the table,
					it puts a copy of the final row into a queue that is managed by the handler thread.
					Any syntax errors are noticed by the thread and reported to the client program.</p>
			</li>
			<li>
				<p>The client cannot obtain from the server the number of duplicate rows or the AUTO_INCREMENT value for the resulting row,
					because the INSERT returns before the insert operation has been completed.</p>
			</li>
			<li>
				<p>The binary log is updated by the handler thread when the row is inserted into the table.
					In case of multiple-row inserts, the binary log is updated when the first row is inserted.</p>
			</li>
			<li>
				<p>Each time that delayed_insert_limit rows are written, the handler checks whether any SELECT statements are still pending.
					If so, it allows these to execute before continuing.</p>
			</li>
			<li>
				<p>When the handler has no more rows in its queue, the table is unlocked.
					If no new INSERT DELAYED statements are received within delayed_insert_timeout seconds, the handler terminates.</p>
			</li>
			<li>
				<p>If more than delayed_queue_size rows are pending in a specific handler queue,
					the thread requesting INSERT DELAYED waits until there is room in the queue.
					This is done to ensure that mysqld does not use all memory for the delayed memory queue.</p>
			</li>
			<li>
				<p>The handler thread shows up in the SQL process list with delayed_insert in the Command column.
					It is killed if you execute a FLUSH TABLES statement or kill it with KILL thread_id.
					However, before exiting, it first stores all queued rows into the table.
					During this time it does not accept any new INSERT statements from other threads.
					If you execute an INSERT DELAYED statement after this, a new handler thread is created.</p>
				<p>Note that this means that INSERT DELAYED statements have higher priority than normal INSERT statements if there is an INSERT DELAYED handler running.
					Other update statements have to wait until the INSERT DELAYED queue is empty,
					someone terminates the handler thread (with KILL thread_id), or someone executes a FLUSH TABLES.</p>
			</li>
			<li>
				<p>The following status variables provide information about INSERT DELAYED statements:</p>
				<table border="3">
					<tr>
						<th align="left">Status Variable</th>
						<th align="left">Meaning</th>
					</tr>
					<tr>
						<td>Delayed_insert_threads</td>
						<td>Number of handler threads</td>
					</tr>
					<tr>
						<td>Delayed_writes</td>
						<td>Number of rows written with INSERT DELAYED</td>
					</tr>
					<tr>
						<td>Not_flushed_delayed_rows</td>
						<td>Number of rows waiting to be written</td>
					</tr>
				</table>
				<p>You can view these variables by issuing a SHOW STATUS statement or by executing a mysqladmin extended-status command.</p>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SINSERT ... ON DUPLICATE KEY UPDATE Syntax"></A>INSERT ... ON DUPLICATE KEY UPDATE Syntax</H2></P>
		<p>If you specify ON DUPLICATE KEY UPDATE, and a row is inserted that would cause a duplicate value in a UNIQUE index or PRIMARY KEY,
			an UPDATE of the old row is performed. For example, if column a is declared as UNIQUE and contains the value 1, the following two statements have identical effect:</p>
			
		<pre>(sql sqlHandle {INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=c+1})</pre>
  
		<pre>(sql sqlHandle {UPDATE table SET c=c+1 WHERE a=1})</pre>
		
		<p>With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row and 2 if an existing row is updated.</p>
		
		<p>If column b is also unique, the INSERT is equivalent to this UPDATE statement instead:</p>
		
		<pre>(sql sqlHandle {UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1})</pre>
		
		<p>If a=1 OR b=2 matches several rows, only one row is updated.
			In general, you should try to avoid using an ON DUPLICATE KEY UPDATE clause on tables with multiple unique indexes.</p>
			
		<p>The ON DUPLICATE KEY UPDATE clause can contain multiple column assignments, separated by commas.</p>
		
		<p>You can use the VALUES(col_name) function in the UPDATE clause to refer to column values from the INSERT portion of the INSERT ... ON DUPLICATE KEY UPDATE statement.
			In other words, VALUES(col_name) in the ON DUPLICATE KEY UPDATE clause refers to the value of col_name that would be inserted, had no duplicate-key conflict occurred.
			This function is especially useful in multiple-row inserts. The VALUES() function is meaningful only in INSERT ... UPDATE statements and returns NULL otherwise. Example:</p>
			
		<pre>(sql sqlHandle {
INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6)
  ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b)})</pre>
  
		<p>That statement is identical to the following two statements:</p>
		<pre>(sql sqlHandle {
INSERT INTO table (a,b,c) VALUES (1,2,3)
  ON DUPLICATE KEY UPDATE c=3;
INSERT INTO table (a,b,c) VALUES (4,5,6)
  ON DUPLICATE KEY UPDATE c=9})</pre>
 
		<p>If a table contains an AUTO_INCREMENT column and INSERT ... ON DUPLICATE KEY UPDATE inserts a row,
			the LAST_INSERT_ID() function returns the AUTO_INCREMENT value.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SLOAD DATA INFILE Syntax"></A>LOAD DATA INFILE Syntax</H2></P>
		<pre>LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name'
    [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [CHARACTER SET charset_name]
    [{FIELDS | COLUMNS}
        [TERMINATED BY 'string']
        [[OPTIONALLY] ENCLOSED BY 'char']
        [ESCAPED BY 'char']
    ]
    [LINES
        [STARTING BY 'string']
        [TERMINATED BY 'string']
    ]
    [IGNORE number LINES]
    [(col_name_or_user_var,...)]
    [SET col_name = expr,...]</pre>
	
		<p>The LOAD DATA INFILE statement reads rows from a text file into a table at a very high speed. The filename must be given as a literal string.</p>
		<p>LOAD DATA INFILE is the complement of SELECT ... INTO OUTFILE. To write data from a table to a file, use SELECT ... INTO OUTFILE. To read the file back into a table, use LOAD DATA INFILE.
			The syntax of the FIELDS and LINES clauses is the same for both statements. Both clauses are optional, but FIELDS must precede LINES if both are specified.</p>
		<p>The character set indicated by the character_set_database system variable is used to interpret the information in the file.
			SET NAMES and the setting of character_set_client do not affect interpretation of input.
			If the contents of the input file use a character set that differs from the default, it is usually preferable to specify the character set of the file by using the CHARACTER SET clause.</p>
		<p>LOAD DATA INFILE interprets all fields in the file as having the same character set, regardless of the data types of the columns into which field values are loaded.
			For proper interpretation of file contents, you must ensure that it was written with the correct character set.</p>
		<p>Note that it is currently not possible to load data files that use the ucs2 character set.</p>
		<p>The character_set_filesystem system variable controls the interpretation of the filename.</p>

		<p>If you use LOW_PRIORITY, execution of the LOAD DATA statement is delayed until no other clients are reading from the table.
			This affects only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE).</p>
		<p>If you specify CONCURRENT with a MyISAM table that satisfies the condition for concurrent inserts (that is, it contains no free blocks in the middle),
			other threads can retrieve data from the table while LOAD DATA is executing.
			Using this option affects the performance of LOAD DATA a bit, even if no other thread is using the table at the same time.</p>
		<p>CONCURRENT is not replicated when using statement-based replication; however, it is replicated when using row-based replication.</p>
		
		<p>The LOCAL keyword, if specified, is interpreted with respect to the client end of the connection:</p>
		<ul>
			<li>
				<p>If LOCAL is specified, the file is read by the client program on the client host and sent to the server.
					The file can be given as a full pathname to specify its exact location.
					If given as a relative pathname, the name is interpreted relative to the directory in which the client program was started.</p>
			</li>
			<li>
				<p>If LOCAL is not specified, the file must be located on the server host and is read directly by the server.
					The server uses the following rules to locate the file:</p>
				<ul>
					<li>
						<p>If the filename is an absolute pathname, the server uses it as given.</p>
					</li>
					<li>
						<p>If the filename is a relative pathname with one or more leading components,
							the server searches for the file relative to the server's data directory.</p>
					</li>
					<li>
						<p>If a filename with no leading components is given, the server looks for the file in the database directory of the default database.</p>
					</li>
				</ul>
			</li>
		</ul>

		<p>Note that, in the non-LOCAL case, these rules mean that a file named as ./myfile.txt is read from the server's data directory,
			whereas the file named as myfile.txt is read from the database directory of the default database.
			For example, if db1 is the default database, the following LOAD DATA statement reads the file data.txt from the database directory for db1,
			even though the statement explicitly loads the file into a table in the db2 database:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE 'data.txt' INTO TABLE db2.my_table})</pre>
		
		<p>Windows pathnames are specified using forward slashes rather than backslashes.
			If you do use backslashes, you must double them.</p>

		<p>For security reasons, when reading text files located on the server, the files must either reside in the database directory or be readable by all.
			Also, to use LOAD DATA INFILE on server files, you must have the FILE privilege.</p>
			
		<p>Using LOCAL is a bit slower than letting the server access the files directly,
			because the contents of the file must be sent over the connection by the client to the server.
			On the other hand, you do not need the FILE privilege to load local files.</p>
			
		<p>With LOCAL, the default behavior is the same as if IGNORE is specified;
			this is because the server has no way to stop transmission of the file in the middle of the operation.
			IGNORE is explained further later in this section.</p>

		<p>LOCAL works only if your server and your client both have been enabled to allow it.
			For example, if mysqld was started with --local-infile=0, LOCAL does not work.</p>
			
		<p>On Unix, if you need LOAD DATA to read from a pipe, you can use the following technique (here we load the listing of the / directory into a table):</p>
		
		<pre>
mkfifo /mysql/db/x/x
chmod 666 /mysql/db/x/x
find / -ls > /mysql/db/x/x &
mysql -e "LOAD DATA INFILE 'x' INTO TABLE x" x</pre>

		<p>Note that you must run the command that generates the data to be loaded and the mysql commands either on separate terminals,
			or run the data generation process in the background (as shown in the preceding example). If you do not do this, the pipe will block until data is read by the mysql process.</p>
			
		<p>The REPLACE and IGNORE keywords control handling of input rows that duplicate existing rows on unique key values:</p>
		
		<ul>
			<li>
				<p>If you specify REPLACE, input rows replace existing rows. In other words, rows that have the same value for a primary key or unique index as an existing row.</p>
			</li>
			<li>
				<p>If you specify IGNORE, input rows that duplicate an existing row on a unique key value are skipped.
					If you do not specify either option, the behavior depends on whether the LOCAL keyword is specified.
					Without LOCAL, an error occurs when a duplicate key value is found, and the rest of the text file is ignored.
					With LOCAL, the default behavior is the same as if IGNORE is specified; this is because the server has no way to stop transmission of the file in the middle of the operation.</p>
			</li>
		</ul>
		<p>If you want to ignore foreign key constraints during the load operation, you can issue a SET FOREIGN_KEY_CHECKS=0 statement before executing LOAD DATA.</p>
		<p>If you use LOAD DATA INFILE on an empty MyISAM table, all non-unique indexes are created in a separate batch (as for REPAIR TABLE).
			Normally, this makes LOAD DATA INFILE much faster when you have many indexes.
			In some extreme cases, you can create the indexes even faster by turning them off with ALTER TABLE ... DISABLE KEYS before loading the file into the table and using 
			ALTER TABLE ... ENABLE KEYS to re-create the indexes after loading the file.</p>
		<p>For both the LOAD DATA INFILE and SELECT ... INTO OUTFILE statements, the syntax of the FIELDS and LINES clauses is the same.
			Both clauses are optional, but FIELDS must precede LINES if both are specified.</p>
		<p>If you specify a FIELDS clause, each of its subclauses (TERMINATED BY, [OPTIONALLY] ENCLOSED BY, and ESCAPED BY) is also optional,
			except that you must specify at least one of them.</p>
		<p>If you specify no FIELDS clause, the defaults are the same as if you had written this:</p>
		<pre>FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'</pre>
		
		<p>If you specify no LINES clause, the defaults are the same as if you had written this:</p>
		<pre>LINES TERMINATED BY '\n' STARTING BY ''</pre>
		
		<p>In other words, the defaults cause LOAD DATA INFILE to act as follows when reading input:</p>
		<ul>
			<li>
				<p>Look for line boundaries at newlines.</p>
			</li>
			<li>
				<p>Do not skip over any line prefix.</p>
			</li>
			<li>
				<p>Break lines into fields at tabs.</p>
			</li>
			<li>
				<p>Do not expect fields to be enclosed within any quoting characters.</p>
			</li>
			<li>
				<p>Interpret occurrences of tab, newline, or "\" preceded by "\" as literal characters that are part of field values.</p>
			</li>
		</ul>
		
		<p>Conversely, the defaults cause SELECT ... INTO OUTFILE to act as follows when writing output:</p>
		<ul>
			<li>
				<p>Write tabs between fields.</p>
			</li>
			<li>
				<p>Do not enclose fields within any quoting characters.</p>
			</li>
			<li>
				<p>Use "\" to escape instances of tab, newline, or "\" that occur within field values.</p>
			</li>
			<li>
				<p>Write newlines at the ends of lines.</p>
			</li>
		</ul>
		
		<p>Backslash is the SQL escape character within strings, so to write FIELDS ESCAPED BY '\\',
			you must specify two backslashes for the value to be interpreted as a single backslash.</p>
			
		<p>Note: If you have generated the text file on a Windows system, you might have to use LINES TERMINATED BY '\r\n' to read the file properly,
			because Windows programs typically use two characters as a line terminator.
			Some programs, such as WordPad, might use \r as a line terminator when writing files.
			To read such files, use LINES TERMINATED BY '\r'.</p>
			
		<p>If all the lines you want to read in have a common prefix that you want to ignore,
			you can use LINES STARTING BY 'prefix_string' to skip over the prefix, and anything before it.
			If a line does not include the prefix, the entire line is skipped. Suppose that you issue the following statement:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test FIELDS TERMINATED BY ','  LINES STARTING BY 'xxx'})</pre>
		
		<p>If the data file looks like this:</p>
		<pre>xxx"abc",1
something xxx"def",2
"ghi",3</pre>

		<p>The resulting rows will be ("abc",1) and ("def",2). The third row in the file is skipped because it does not contain the prefix.</p>
		
		<p>The IGNORE number LINES option can be used to ignore lines at the start of the file.
			For example, you can use IGNORE 1 LINES to skip over an initial header line containing column names:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE '/tmp/test.txt' INTO TABLE test IGNORE 1 LINES})</pre>
		
		<p>When you use SELECT ... INTO OUTFILE in tandem with LOAD DATA INFILE to write data from a database into a file and
			then read the file back into the database later, the field- and line-handling options for both statements must match.
			Otherwise, LOAD DATA INFILE will not interpret the contents of the file properly.
			Suppose that you use SELECT ... INTO OUTFILE to write a file with fields delimited by commas:</p>

		<pre>(sql sqlHandle {SELECT * INTO OUTFILE 'data.txt' FIELDS TERMINATED BY ',' FROM table2})</pre>
		
		<p>To read the comma-delimited file back in, the correct statement would be:</p>
		
		<pre>(sql sqlHandle {LOAD DATA INFILE 'data.txt' INTO TABLE table2 FIELDS TERMINATED BY ','})</pre>
		
		<p>If instead you tried to read in the file with the statement shown following,
			it wouldn't work because it instructs LOAD DATA INFILE to look for tabs between fields:</p>

		<pre>(sql sqlHandle {LOAD DATA INFILE 'data.txt' INTO TABLE table2 FIELDS TERMINATED BY '\t'})</pre>
		
		<p>The likely result is that each input line would be interpreted as a single field.</p>
		
		<p>LOAD DATA INFILE can be used to read files obtained from external sources.
			For example, many programs can export data in comma-separated values (CSV) format, such that lines have fields separated by commas and enclosed within double quotes.
			If lines in such a file are terminated by newlines, the statement shown here illustrates the field- and line-handling options you would use to load the file:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n';)</pre>
		
		<p>If the input values are not necessarily enclosed within quotes, use OPTIONALLY before the ENCLOSED BY keywords.</p>
		
		<p>Any of the field- or line-handling options can specify an empty string ('').
			If not empty, the FIELDS [OPTIONALLY] ENCLOSED BY and FIELDS ESCAPED BY values must be a single character.
			The FIELDS TERMINATED BY, LINES STARTING BY, and LINES TERMINATED BY values can be more than one character.
			For example, to write lines that are terminated by carriage return/linefeed pairs, or to read a file containing such lines, specify a LINES TERMINATED BY '\r\n' clause.</p>
			
		<p>To read a file containing jokes that are separated by lines consisting of %%, you can do this</p>

		<pre>(sql sqlHandle {
CREATE TABLE jokes
  (a INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  joke TEXT NOT NULL);
LOAD DATA INFILE '/tmp/jokes.txt' INTO TABLE jokes
  FIELDS TERMINATED BY ''
  LINES TERMINATED BY '\n%%\n' (joke)})</pre>
  
		<p>FIELDS [OPTIONALLY] ENCLOSED BY controls quoting of fields.
			For output (SELECT ... INTO OUTFILE), if you omit the word OPTIONALLY, all fields are enclosed by the ENCLOSED BY character.
			An example of such output (using a comma as the field delimiter) is shown here:</p>
			
		<pre>
"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"</pre>

		<p>If you specify OPTIONALLY, the ENCLOSED BY character is used only to enclose values from columns that have a string data type (such as CHAR, BINARY, TEXT, or ENUM):</p>
		
		<pre>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20</pre>

		<p>Note that occurrences of the ENCLOSED BY character within a field value are escaped by prefixing them with the ESCAPED BY character.
			Also note that if you specify an empty ESCAPED BY value, it is possible to inadvertently generate output that cannot be read properly by LOAD DATA INFILE.
			For example, the preceding output just shown would appear as follows if the escape character is empty.
			Observe that the second field in the fourth line contains a comma following the quote, which (erroneously) appears to terminate the field:</p>
			
		<pre>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20</pre>

		<p>For input, the ENCLOSED BY character, if present, is stripped from the ends of field values.
			(This is true regardless of whether OPTIONALLY is specified; OPTIONALLY has no effect on input interpretation.)
			Occurrences of the ENCLOSED BY character preceded by the ESCAPED BY character are interpreted as part of the current field value.</p>
			
		<p>If the field begins with the ENCLOSED BY character,
			instances of that character are recognized as terminating a field value only if followed by the field or line TERMINATED BY sequence.
			To avoid ambiguity, occurrences of the ENCLOSED BY character within a field value can be doubled and are interpreted as a single instance of the character.
			For example, if ENCLOSED BY '"' is specified, quotes are handled as shown here:</p>

		<pre>
"The ""BIG"" boss"  -> The "BIG" boss
The "BIG" boss      -> The "BIG" boss
The ""BIG"" boss    -> The ""BIG"" boss</pre>

		<p>FIELDS ESCAPED BY controls how to write or read special characters.
			If the FIELDS ESCAPED BY character is not empty, it is used to prefix the following characters on output:</p>
			
		<ul>
			<li>
				<p>The FIELDS ESCAPED BY character</p>
			</li>
			<li>
				<p>The FIELDS [OPTIONALLY] ENCLOSED BY character</p>
			</li>
			<li>
				<p>The first character of the FIELDS TERMINATED BY and LINES TERMINATED BY values</p>
			</li>
			<li>
				<p>ASCII 0 (what is actually written following the escape character is ASCII "0", not a zero-valued byte)</p>
			</li>
		</ul>
		
		<p>If the FIELDS ESCAPED BY character is empty, no characters are escaped and NULL is output as NULL, not \N.
			It is probably not a good idea to specify an empty escape character, particularly if field values in your data contain any of the characters in the list just given.</p>
			
		<p>For input, if the FIELDS ESCAPED BY character is not empty, occurrences of that character are stripped and the following character is taken literally as part of a field value.
			Some two-character sequences that are exceptions, where the first character is the escape character.
			These sequences are shown in the following table (using "\" for the escape character). The rules for NULL handling are described later in this section.</p>
			
		<table border="3">
			<tr>
				<td>\0</td>
				<td>An ASCII 0 (NUL) character</td>
			</tr>
			<tr>
				<td>\b</td>
				<td>A backspace character</td>
			</tr>
			<tr>
				<td>\n</td>
				<td>A newline (linefeed) character</td>
			</tr>
			<tr>
				<td>\r</td>
				<td>A carriage return character</td>
			</tr>
			<tr>
				<td>\t</td>
				<td>A tab character.</td>
			</tr>
			<tr>
				<td>\Z</td>
				<td>ASCII 26 (Control-Z)</td>
			</tr>
			<tr>
				<td>\N</td>
				<td>NULL</td>
			</tr>
		</table>

		<p>In certain cases, field- and line-handling options interact:</p>
		<ul>
			<li>
				<p>If LINES TERMINATED BY is an empty string and FIELDS TERMINATED BY is non-empty, lines are also terminated with FIELDS TERMINATED BY.</p>
			</li>
			<li>
				<p>If the FIELDS TERMINATED BY and FIELDS ENCLOSED BY values are both empty (''), a fixed-row (non-delimited) format is used.
					With fixed-row format, no delimiters are used between fields (but you can still have a line terminator).
					Instead, column values are read and written using a field width wide enough to hold all values in the field.
					For TINYINT, SMALLINT, MEDIUMINT, INT, and BIGINT, the field widths are 4, 6, 8, 11, and 20, respectively, no matter what the declared display width is.</p>
				<p>LINES TERMINATED BY is still used to separate lines. If a line does not contain all fields, the rest of the columns are set to their default values.
					If you do not have a line terminator, you should set this to ''. In this case, the text file must contain all fields for each row.</p>
				<p>Fixed-row format also affects handling of NULL values, as described later. Note that fixed-size format does not work if you are using a multi-byte character set.</p>
			</li>
		</ul>

		<p>Handling of NULL values varies according to the FIELDS and LINES options in use:</p>
		<ul>
			<li>
				<p>For the default FIELDS and LINES values, NULL is written as a field value of \N for output, and a field value of \N is read as NULL for input (assuming that the ESCAPED BY character is "\").</p>
			</li>
			<li>
				<p>If FIELDS ENCLOSED BY is not empty, a field containing the literal word NULL as its value is read as a NULL value.
					This differs from the word NULL enclosed within FIELDS ENCLOSED BY characters, which is read as the string 'NULL'.</p>
			</li>
			<li>
				<p>If FIELDS ESCAPED BY is empty, NULL is written as the word NULL.</p>
			</li>
			<li>
				<p>With fixed-row format (which is used when FIELDS TERMINATED BY and FIELDS ENCLOSED BY are both empty),
					NULL is written as an empty string. Note that this causes both NULL values and empty strings in the
					table to be indistinguishable when written to the file because both are written as empty strings.
					If you need to be able to tell the two apart when reading the file back in, you should not use fixed-row format.</p>
			</li>
		</ul>
		
		<p>An attempt to load NULL into a NOT NULL column causes assignment of the implicit default value for the column's data type and a warning,
			or an error in strict SQL mode.</p>

		<p>Some cases are not supported by LOAD DATA INFILE:</p>
		<ul>
			<li>
				<p>Fixed-size rows (FIELDS TERMINATED BY and FIELDS ENCLOSED BY both empty) and BLOB or TEXT columns.</p>
			</li>
			<li>
				<p>If you specify one separator that is the same as or a prefix of another, LOAD DATA INFILE cannot interpret the input properly.
					For example, the following FIELDS clause would cause problems:</p>
				<pre>FIELDS TERMINATED BY '"' ENCLOSED BY '"'</pre>
			</li>
		</ul>
		
		<p>If FIELDS ESCAPED BY is empty, a field value that contains an occurrence of FIELDS ENCLOSED BY or LINES TERMINATED BY followed by the FIELDS TERMINATED BY value causes LOAD DATA INFILE to stop reading a field or line too early.
			This happens because LOAD DATA INFILE cannot properly determine where the field or line value ends.</p>

		<p>The following example loads all columns of the persondata table:</p>
		
		<pre>(sql sqlHandle {LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata})</pre>
		
		<p>By default, when no column list is provided at the end of the LOAD DATA INFILE statement, input lines are expected to contain a field for each table column.
			If you want to load only some of a table's columns, specify a column list:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata (col1,col2,...)})</pre>
		
		<p>You must also specify a column list if the order of the fields in the input file differs from the order of the columns in the table.
			Otherwise, SQL cannot tell how to match input fields with table columns.</p>
			
		<p>The column list can contain either column names or user variables.
			With user variables, the SET clause enables you to perform transformations on their values before assigning the result to columns.</p>
			
		<p>User variables in the SET clause can be used in several ways.
			The following example uses the first input column directly for the value of t1.column1,
			and assigns the second input column to a user variable that is subjected to a division operation before being used for the value of t1.column2:</p>
			
		<pre>(sql sqlHandle {LOAD DATA INFILE 'file.txt' INTO TABLE t1 (column1, @var1) SET column2 = @var1/100})</pre>
		
		<p>The SET clause can be used to supply values not derived from the input file. The following statement sets column3 to the current date and time:</p>
		
		<pre>(sql sqlHandle {LOAD DATA INFILE 'file.txt' INTO TABLE t1 (column1, column2) SET column3 = CURRENT_TIMESTAMP})</pre>
		
		<p>You can also discard an input value by assigning it to a user variable and not assigning the variable to a table column:</p>
		
		<pre>(sql sqlHandle {LOAD DATA INFILE 'file.txt' INTO TABLE t1 (column1, @dummy, column2, @dummy, column3)})</pre>
		
		<p>Use of the column/variable list and SET clause is subject to the following restrictions:</p>
		<ul>
			<li>
				<p>Assignments in the SET clause should have only column names on the left hand side of assignment operators.</p>
			</li>
			<li>
				<p>You can use subqueries in the right hand side of SET assignments.
					A subquery that returns a value to be assigned to a column may be a scalar subquery only.
					Also, you cannot use a subquery to select from the table that is being loaded.</p>
			</li>
			<li>
				<p>Lines ignored by an IGNORE clause are not processed for the column/variable list or SET clause.</p>
			</li>
			<li>
				<p>User variables cannot be used when loading data with fixed-row format because user variables do not have a display width.</p>
			</li>
		</ul>

		<p>When processing an input line, LOAD DATA splits it into fields and uses the values according to the column/variable list and the SET clause, if they are present.
			Then the resulting row is inserted into the table. If there are BEFORE INSERT or AFTER INSERT triggers for the table, they are activated before or after inserting the row, respectively.</p>
			
		<p>If an input line has too many fields, the extra fields are ignored and the number of warnings is incremented.</p>

		<p>If an input line has too few fields, the table columns for which input fields are missing are set to their default values.</p>
		
		<p>An empty field value is interpreted differently than if the field value is missing:</p>
		<ul>
			<li>
				<p>For string types, the column is set to the empty string.</p>
			</li>
			<li>
				<p>For numeric types, the column is set to 0.</p>
			</li>
			<li>
				<p>For date and time types, the column is set to the appropriate "zero" value for the type. See Section 10.3, "Date and Time Types".</p>
			</li>
		</ul>
		
		<p>These are the same values that result if you assign an empty string explicitly to a string, numeric, or date or time type explicitly in an INSERT or UPDATE statement.</p>
		
		<p>TIMESTAMP columns are set to the current date and time only if there is a NULL value for the column (that is, \N) and the column is not declared to allow NULL values,
			or if the TIMESTAMP column's default value is the current timestamp and it is omitted from the field list when a field list is specified.</p>
			
		<p>LOAD DATA INFILE regards all input as strings, so you cannot use numeric values for ENUM or SET columns the way you can with INSERT statements.
			All ENUM and SET values must be specified as strings.</p>
			
		<p>BIT values cannot be loaded using binary notation (for example, b'011010').
			To work around this, specify the values as regular integers and use the SET clause to convert them so that SQL performs a numeric type conversion and loads them into the BIT column properly:</p>
			
		<pre>shell> cat /tmp/bit_test.txt
2
127</pre>

		<pre>(sql sqlHandle {LOAD DATA INFILE '/tmp/bit_test.txt' INTO TABLE bit_test (@var1) SET b= CAST(@var1 AS UNSIGNED)})</pre>

		<pre>(sql sqlHandle {mysql> SELECT BIN(b+0) FROM bit_test}) <b>Returns</b>
#(rec(2 |BIN(b+0)|:Character:64)| [0](|BIN(b+0)|:"10") [1](|BIN(b+0)|:"1111111"))</pre>

		<p>When the LOAD DATA INFILE statement finishes, it returns an information string in the following format:</p>
		<pre>Records: 1  Deleted: 0  Skipped: 0  Warnings: 0</pre>
		
		<p>Warnings occur under the same circumstances as when values are inserted via the INSERT statement,
			except that LOAD DATA INFILE also generates warnings when there are too few or too many fields in the input row.
			The warnings are not stored anywhere; the number of warnings can be used only as an indication of whether everything went well.</p>
			
		<p>You can use SHOW WARNINGS to get a list of the first max_error_count warnings as information about what went wrong.</p>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SREPLACE Syntax"></A>REPLACE Syntax</H2></P>
		<pre>REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] tbl_name [(col_name,...)]
    {VALUES | VALUE} ({expr | DEFAULT},...),(...),...
Or:

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] tbl_name
    SET col_name={expr | DEFAULT}, ...
Or:

REPLACE [LOW_PRIORITY | DELAYED]
    [INTO] tbl_name [(col_name,...)]
    SELECT ...</pre>
	
		<p>REPLACE works exactly like INSERT, except that if an old row in the table has the same value as a new row for a PRIMARY KEY or a UNIQUE index,
			the old row is deleted before the new row is inserted.</p>
			
		<p>REPLACE is an SQL extension to the SQL standard. It either inserts, or deletes and inserts.</p>
		
		<p>Note that unless the table has a PRIMARY KEY or UNIQUE index, using a REPLACE statement makes no sense.
			It becomes equivalent to INSERT, because there is no index to be used to determine whether a new row duplicates another.</p>
			
		<p>Values for all columns are taken from the values specified in the REPLACE statement.
			Any missing columns are set to their default values, just as happens for INSERT.
			You cannot refer to values from the current row and use them in the new row.
			If you use an assignment such as SET col_name = col_name + 1,
			the reference to the column name on the right hand side is treated as DEFAULT(col_name),
			so the assignment is equivalent to SET col_name = DEFAULT(col_name) + 1.</p>
			
		<p>To use REPLACE, you must have both the INSERT and DELETE privileges for the table.</p>
		
		<p>The REPLACE statement returns a count to indicate the number of rows affected.
			This is the sum of the rows deleted and inserted.
			If the count is 1 for a single-row REPLACE, a row was inserted and no rows were deleted.
			If the count is greater than 1, one or more old rows were deleted before the new row was inserted.
			It is possible for a single row to replace more than one old row if the table contains multiple
			unique indexes and the new row duplicates values for different old rows in different unique indexes.</p>
			
		<p>The affected-rows count makes it easy to determine whether REPLACE only added a row or
			whether it also replaced any rows: Check whether the count is 1 (added) or greater (replaced).</p>
			
		<p>Currently, you cannot replace into a table and select from the same table in a subquery.</p>
		
		<p>SQL uses the following algorithm for REPLACE (and LOAD DATA ... REPLACE):</p>
		
		<ol>
			<li>
				<p>Try to insert the new row into the table</p>
			</li>
			<li>
				<p>While the insertion fails because a duplicate-key error occurs for a primary key or unique index:</p>
				<ol>
					<li>
						<p>Delete from the table the conflicting row that has the duplicate key value</p>
					</li>
					<li>
						<p>Try again to insert the new row into the table</p>
					</li>
				</ol>
			</li>
		</ol>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSELECT Syntax"></A>SELECT Syntax</H2></P>
		<pre>SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr, ...
    [FROM table_references
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
    [PROCEDURE procedure_name(argument_list)]
    [INTO OUTFILE 'file_name' export_options
      | INTO DUMPFILE 'file_name'
      | INTO var_name [, var_name]]
    [FOR UPDATE | LOCK IN SHARE MODE]]</pre>
	
		<p>SELECT is used to retrieve rows selected from one or more tables, and can include UNION statements and subqueries.</p>
		
		<p>The most commonly used clauses of SELECT statements are these:</p>
		<ul>
			<li>
				<p>Each select_expr indicates a column that you want to retrieve. There must be at least one select_expr.</p>
			</li>
			<li>
				<p>table_references indicates the table or tables from which to retrieve rows.</p>
			</li>
			<li>
				<p>The WHERE clause, if given, indicates the condition or conditions that rows must satisfy to be selected.
					where_condition is an expression that evaluates to true for each row to be selected.
					The statement selects all rows if there is no WHERE clause.</p>
			</li>
		</ul>
		
		<p>In the WHERE clause, you can use any of the functions and operators that SQL supports, except for aggregate (summary) functions.</p>
		
		<p>SELECT can also be used to retrieve rows computed without reference to any table.</p>
		
		<p>For example:</p>
		
		<pre>(sql sqlHandle {SELECT 1 + 1}) <b>Returns</b> #(rec(|1 + 1|:Integer:1)| |1 + 1|:2)</pre>

		<p>You are allowed to specify DUAL as a dummy table name in situations where no tables are referenced:</p>

		<pre>(sql sqlHandle {SELECT 1 + 1 FROM DUAL}) <b>Returns</b> #(rec(|1 + 1|:Integer:1)| |1 + 1|:2)</pre>

		<p>DUAL is purely for the convenience of people who require that all SELECT statements should have FROM and possibly other clauses.
			SQL may ignore the clauses. SQL does not require FROM DUAL if no tables are referenced.</p>
		
		<ul>
			<li>
				<p>In general, clauses used must be given in exactly the order shown in the syntax description.
					For example, a HAVING clause must come after any GROUP BY clause and before any ORDER BY clause.
					The exception is that the INTO clause can appear either as shown in the syntax description or immediately following the select_expr list.</p>
			
				<p>A select_expr can be given an alias using AS alias_name.
					The alias is used as the expression's column name and can be used in GROUP BY, ORDER BY, or HAVING clauses. For example:</p>
					
				<pre>(sql sqlHandle {SELECT CONCAT(last_name,', ',first_name) AS full_name FROM mytable ORDER BY full_name})</pre>
				
				<p>The AS keyword is optional when aliasing a select_expr. The preceding example could have been written like this:</p>
				
				<pre>(sql sqlHandle {SELECT CONCAT(last_name,', ',first_name) full_name FROM mytable ORDER BY full_name})</pre>
				
				<p>However, because the AS is optional, a subtle problem can occur if you forget the comma between two select_expr expressions: 
					SQL interprets the second as an alias name. For example, in the following statement, columnb is treated as an alias name:</p>
					
				<pre>(sql sqlHandle {SELECT columna columnb FROM mytable})</pre>
				
				<p>For this reason, it is good practice to be in the habit of using AS explicitly when specifying column aliases.</p>
				
				<p>It is not allowable to refer to a column alias in a WHERE clause,
					because the column value might not yet be determined when the WHERE clause is executed.</p>
			</li>
			<li>
				<p>The FROM table_references clause indicates the table or tables from which to retrieve rows.
					If you name more than one table, you are performing a join. For each table specified, you can optionally specify an alias.</p>
					
				<pre>tbl_name [[AS] alias] [index_hint]</pre>
				
				<p>The use of index hints provides the optimizer with information about how to choose indexes during query processing.</p>

				<p>You can use SET max_seeks_for_key=value as an alternative way to force SQL to prefer key scans instead of table scans.</p>
			</li>
			<li>
				<p>You can refer to a table within the default database as tbl_name, or as db_name.tbl_name to specify a database explicitly.
					You can refer to a column as col_name, tbl_name.col_name, or db_name.tbl_name.col_name.
					You need not specify a tbl_name or db_name.tbl_name prefix for a column reference unless the reference would be ambiguous.</p>
			</li>
			<li>
				<p>A table reference can be aliased using tbl_name AS alias_name or tbl_name alias_name:</p>
				
				<pre>(sql sqlHandle {SELECT t1.name, t2.salary FROM employee AS t1, info AS t2 WHERE t1.name = t2.name})</pre>
				
				<pre>(sql sqlHandle {SELECT t1.name, t2.salary FROM employee t1, info t2 WHERE t1.name = t2.name})</pre>
			</li>
			<li>
				<p>Columns selected for output can be referred to in ORDER BY and GROUP BY clauses using column names,
					column aliases, or column positions. Column positions are integers and begin with 1:</p>
					
				<pre>(sql sqlHandle {SELECT college, region, seed FROM tournament ORDER BY region, seed})</pre>
				
				<pre>(sql sqlHandle {SELECT college, region AS r, seed AS s FROM tournament ORDER BY r, s})</pre>
				
				<pre>(sql sqlHandle {SELECT college, region, seed FROM tournament ORDER BY 2, 3})</pre>
				
				<p>To sort in reverse order, add the DESC (descending) keyword to the name of the column in the ORDER BY clause that you are sorting by.
					The default is ascending order; this can be specified explicitly using the ASC keyword.</p>
					
				<p>If ORDER BY occurs within a subquery and also is applied in the outer query, the outermost ORDER BY takes precedence.
					For example, results for the following statement are sorted in descending order, not ascending order:</p>
					
				<pre>(sql sqlHandle {(SELECT ... ORDER BY a) ORDER BY a DESC})</pre>
				
				<p>Use of column positions is deprecated because the syntax has been removed from the SQL standard.</p>
			</li>
			<li>
				<p>If you use GROUP BY, output rows are sorted according to the GROUP BY columns as if you had an ORDER BY for the same columns.
					To avoid the overhead of sorting that GROUP BY produces, add ORDER BY NULL:</p>
				
				<pre>(sql sqlHandle {SELECT a, COUNT(b) FROM test_table GROUP BY a ORDER BY NULL})</pre>
			</li>
			<li>
				<p>SQL extends the GROUP BY clause so that you can also specify ASC and DESC after columns named in the clause:</p>
				
				<pre>(sql sqlHandle {SELECT a, COUNT(b) FROM test_table GROUP BY a DESC})</pre>
			</li>
			<li>
				<p>SQL extends the use of GROUP BY to allow selecting fields that are not mentioned in the GROUP BY clause.</p>
			</li>
			<li>
				<p>GROUP BY allows a WITH ROLLUP modifier.</p>
			</li>
			<li>
				<p>The HAVING clause is applied nearly last, just before items are sent to the client,
					with no optimization. (LIMIT is applied after HAVING.)</p>
				
				<p>The SQL standard requires that HAVING must reference only columns in the GROUP BY clause or columns used in aggregate functions.
					However, SQL supports an extension to this behavior, and allows HAVING to refer to columns in the SELECT list and columns in outer subqueries as well.</p>
					
				<p>If the HAVING clause refers to a column that is ambiguous, a warning occurs.
					In the following statement, col2 is ambiguous because it is used as both an alias and a column name:</p>
					
				<pre>(sql sqlHandle {SELECT COUNT(col1) AS col2 FROM t GROUP BY col2 HAVING col2 = 2})</pre>
				
				<p>Preference is given to standard SQL behavior, so if a HAVING column name is used both in GROUP BY and as an aliased column in the output column list,
					preference is given to the column in the GROUP BY column.</p>
			</li>
			<li>
				<p>Do not use HAVING for items that should be in the WHERE clause. For example, do not write the following:</p>
				
				<pre>(sql sqlHandle {SELECT col_name FROM tbl_name HAVING col_name > 0})</pre>
				
				<p>Write this instead:</p>
				
				<pre>(sql sqlHandle {SELECT col_name FROM tbl_name WHERE col_name > 0})</pre>
			</li>
			<li>
				<p>The HAVING clause can refer to aggregate functions, which the WHERE clause cannot:</p>

				<pre>(sql sqlHandle {SELECT user, MAX(salary) FROM users GROUP BY user HAVING MAX(salary) > 10})</pre>
			</li>
			<li>
				<p>SQL allows duplicate column names. That is, there can be more than one select_expr with the same name.
					This is an extension to standard SQL.
					Because SQL also allows GROUP BY and HAVING to refer to select_expr values,this can result in an ambiguity:</p>
					
				<pre>(sql sqlHandle {SELECT 12 AS a, a FROM t GROUP BY a}</pre>

				<p>In that statement, both columns have the name a.
					To ensure that the correct column is used for grouping, use different names for each select_expr.</p>
			</li>
			<li>
				<p>SQL resolves unqualified column or alias references in ORDER BY clauses by searching in the select_expr values,
					then in the columns of the tables in the FROM clause. For GROUP BY or HAVING clauses,
					it searches the FROM clause before searching in the select_expr values.</p>
			</li>
			<li>
				<p>The LIMIT clause can be used to constrain the number of rows returned by the SELECT statement.
					LIMIT takes one or two numeric arguments, which must both be non-negative integer constants (except when using prepared statements).</p>
			
				<p>With two arguments, the first argument specifies the offset of the first row to return,
					and the second specifies the maximum number of rows to return. The offset of the initial row is 0 (not 1):</p>
					
				<pre>(sql sqlHandle {SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15})</pre>
				
				<p>To retrieve all rows from a certain offset up to the end of the result set,
					you can use some large number for the second parameter.
					This statement retrieves all rows from the 96th row to the last:</p>
					
				<pre>(sql sqlHandle {SELECT * FROM tbl LIMIT 95,18446744073709551615})</pre>
				
				<p>With one argument, the value specifies the number of rows to return from the beginning of the result set:</p>
				
				<pre>(sql sqlHandle {SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows})</pre>
				
				<p>In other words, LIMIT row_count is equivalent to LIMIT 0, row_count.</p>
				
				<p>For prepared statements, you can use placeholders. The following statements will return one row from the tbl table:</p>
				
				<pre>(sql sqlHandle {
SET @a=1;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?';
EXECUTE STMT USING @a;})</pre>

				<p>The following statements will return the second to sixth row from the tbl table:</p>
				
				<pre>(sql sqlHandle {
SET @skip=1; SET @numrows=5;
PREPARE STMT FROM 'SELECT * FROM tbl LIMIT ?, ?';
EXECUTE STMT USING @skip, @numrows;})</pre>

				<p>SQL also supports the LIMIT row_count OFFSET offset syntax.</p>
				
				<p>If LIMIT occurs within a subquery and also is applied in the outer query,
					the outermost LIMIT takes precedence. For example, the following statement produces two rows, not one:</p>
				
				<pre>(sql sqlHandle {(SELECT ... LIMIT 1) LIMIT 2})</pre>
			</li>
			<li>
				<p>A PROCEDURE clause names a procedure that should process the data in the result set.</p>
			</li>
			<li>
				<p>The SELECT ... INTO OUTFILE 'file_name' form of SELECT writes the selected rows to a file.
					The file is created on the server host, so you must have the FILE privilege to use this syntax.
					file_name cannot be an existing file, which among other things prevents files such as /etc/passwd and database tables from being destroyed.
					The character_set_filesystem system variable controls the interpretation of the filename.</p>
			
				<p>The SELECT ... INTO OUTFILE statement is intended primarily to let you very quickly dump a table to a text file on the server machine.
					If you want to create the resulting file on some client host other than the server host,
					you cannot use SELECT ... INTO OUTFILE. In that case,
					you should instead use a command such as mysql -e "SELECT ..." > file_name to generate the file on the client host.</p>
				
				<p>SELECT ... INTO OUTFILE is the complement of LOAD DATA INFILE;
					the syntax for the export_options part of the statement consists of the same FIELDS and LINES
					clauses that are used with the LOAD DATA INFILE statement.</p>
					
				<p>Column values are dumped using the binary character set.
					In effect, there is no character set conversion. If a table contains columns in several character sets,
					the output data file will as well and you may not be able to reload the file correctly.</p>
					
				<p>FIELDS ESCAPED BY controls how to write special characters.
					If the FIELDS ESCAPED BY character is not empty, it is used as a prefix that precedes following characters on output:</p>
					
				<ul>
					<li>
						<p>The FIELDS ESCAPED BY character</p>
					</li>
					<li>
						<p>The FIELDS [OPTIONALLY] ENCLOSED BY character</p>
					</li>
					<li>
						<p>The first character of the FIELDS TERMINATED BY and LINES TERMINATED BY values</p>
					</li>
					<li>
						<p>ASCII NUL (the zero-valued byte; what is actually written following the escape character is ASCII "0", not a zero-valued byte)</p>
					</li>
				</ul>
				
				<p>The FIELDS TERMINATED BY, ENCLOSED BY, ESCAPED BY, or LINES TERMINATED BY characters must be escaped so that you can read the file back in reliably.
					ASCII NUL is escaped to make it easier to view with some pagers.</p>
					
				<p>The resulting file does not have to conform to SQL syntax, so nothing else need be escaped.</p>
				
				<p>If the FIELDS ESCAPED BY character is empty, no characters are escaped and NULL is output as NULL, not \N.
					It is probably not a good idea to specify an empty escape character,
					particularly if field values in your data contain any of the characters in the list just given.</p>
					
				<p>Here is an example that produces a file in the comma-separated values (CSV) format used by many programs:</p>
				
				<pre>(sql sqlHandle {
SELECT a,b,a+b INTO OUTFILE '/tmp/result.txt'
  FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  LINES TERMINATED BY '\n'
  FROM test_table})</pre>
			</li>
			<li>
				<p>If you use INTO DUMPFILE instead of INTO OUTFILE, SQL writes only one row into the file,
					without any column or line termination and without performing any escape processing.
					This is useful if you want to store a BLOB value in a file.</p>
			</li>
			<li>
				<p>The INTO clause can name a list of one or more variables, which can be user-defined variables, 
					or parameters or local variables within a stored function or procedure body.
					The selected values are assigned to the variables. The number of variables must match the number of columns.</p>
				
				<p>Note: Any file created by INTO OUTFILE or INTO DUMPFILE is writable by all users on the server host.
					The reason for this is that the SQL server cannot create a file that is owned by anyone other than the user under whose account it is running.
					(You should never run mysqld as root for this and other reasons.)
					The file thus must be world-writable so that you can manipulate its contents.</p>
			</li>
			<li>
				<p>The SELECT syntax description at the beginning this section shows the INTO clause near the end of the statement.
					It is also possible to use INTO immediately following the select_expr list.</p>
			</li>
			<li>
				<p>An INTO clause should not be used in a nested SELECT because such a SELECT must return its result to the outer context.</p>
			</li>
			<li>
				<p>If you use FOR UPDATE with a storage engine that uses page or row locks,
					rows examined by the query are write-locked until the end of the current transaction.
					Using LOCK IN SHARE MODE sets a shared lock that allows other transactions to read the examined rows but not to update or delete them.</p>
			</li>
		</ul>
		
		<p>Following the SELECT keyword, you can use a number of options that affect the operation of the statement.</p>
		
		<p>The ALL, DISTINCT, and DISTINCTROW options specify whether duplicate rows should be returned.
			If none of these options are given, the default is ALL (all matching rows are returned).
			DISTINCT and DISTINCTROW are synonyms and specify removal of duplicate rows from the result set.</p>
			
		<p>HIGH_PRIORITY, STRAIGHT_JOIN, and options beginning with SQL_ are SQL extensions to standard SQL.</p>
		
		<ul>
			<li>
				<p>HIGH_PRIORITY gives the SELECT higher priority than a statement that updates a table.
					You should use this only for queries that are very fast and must be done at once.
					A SELECT HIGH_PRIORITY query that is issued while the table is locked for reading runs even if there is an update statement waiting for the table to be free.
					This affects only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE).</p>
				<p>HIGH_PRIORITY cannot be used with SELECT statements that are part of a UNION.</p>
			</li>
			<li>
				<p>STRAIGHT_JOIN forces the optimizer to join the tables in the order in which they are listed in the FROM clause.
					You can use this to speed up a query if the optimizer joins the tables in non-optimal order.
					STRAIGHT_JOIN also can be used in the table_references list.</p>
				<p>STRAIGHT_JOIN does not apply to any table that the optimizer treats as a const or system table.
					Such a table produces a single row, is read during the optimization phase of query execution,
					and references to its columns are replaced with the appropriate column values before query execution proceeds.
					These tables will appear first in the query plan displayed by EXPLAIN.
					This exception may not apply to const or system tables that are used on the NULL-complemented side of an outer join
					(that is, the right-side table of a LEFT JOIN or the left-side table of a RIGHT JOIN.</p>
			</li>
			<li>
				<p>SQL_BIG_RESULT can be used with GROUP BY or DISTINCT to tell the optimizer that the result set has many rows.
					In this case, SQL directly uses disk-based temporary tables if needed,
					and prefers sorting to using a temporary table with a key on the GROUP BY elements.</p>
			</li>
			<li>
				<p>SQL_BUFFER_RESULT forces the result to be put into a temporary table.
					This helps SQL free the table locks early and helps in cases where it takes a long time to send the result set to the client.</p>
			</li>
			<li>
				<p>SQL_SMALL_RESULT can be used with GROUP BY or DISTINCT to tell the optimizer that the result set is small.
					In this case, SQL uses fast temporary tables to store the resulting table instead of using sorting.
					This should not normally be needed.</p>
			</li>
			<li>
				<p>SQL_CALC_FOUND_ROWS tells SQL to calculate how many rows there would be in the result set, disregarding any LIMIT clause.
					The number of rows can then be retrieved with SELECT FOUND_ROWS().</p>
			</li>
			<li>
				<p>The SQL_CACHE and SQL_NO_CACHE options affect caching of query results in the query cache.
					SQL_CACHE tells SQL to store the result in the query cache if it is cacheable and the value of the query_cache_type system variable is 2 or DEMAND.
					SQL_NO_CACHE tells MySQL not to store the result in the query cache. For a query that uses UNION, subqueries, or views, the following rules apply:</p>
					
				<ul>
					<li>
						<p>SQL_NO_CACHE applies if it appears in any SELECT in the query.</p>
					</li>
					<li>
						<p>For a cacheable query, SQL_CACHE applies if it appears in the first SELECT of the query,
							or in the first SELECT of a view referred to by the query.</p>
					</li>
				</ul>
			</li>
		</ul>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SJOIN Syntax"></A>JOIN Syntax</H2></P>
		<p>SQL supports the following JOIN syntaxes for the table_references part of SELECT statements and multiple-table DELETE and UPDATE statements:</p>
		
		<pre>table_references:
    table_reference [, table_reference] ...

table_reference:
    table_factor
  | join_table

table_factor:
    tbl_name [[AS] alias] [index_hint_list]
  | table_subquery [AS] alias
  | ( table_references )
  | { OJ table_reference LEFT OUTER JOIN table_reference
        ON conditional_expr }

join_table:
    table_reference [INNER | CROSS] JOIN table_factor [join_condition]
  | table_reference STRAIGHT_JOIN table_factor
  | table_reference STRAIGHT_JOIN table_factor ON conditional_expr
  | table_reference {LEFT|RIGHT} [OUTER] JOIN table_reference join_condition
  | table_reference NATURAL [{LEFT|RIGHT} [OUTER]] JOIN table_factor

join_condition:
    ON conditional_expr
  | USING (column_list)

index_hint_list:
    index_hint [, index_hint] ...

index_hint:
    USE {INDEX|KEY}
      [{FOR {JOIN|ORDER BY|GROUP BY}] ([index_list])
  | IGNORE {INDEX|KEY}
      [{FOR {JOIN|ORDER BY|GROUP BY}] (index_list)
  | FORCE {INDEX|KEY}
      [{FOR {JOIN|ORDER BY|GROUP BY}] (index_list)

index_list:
    index_name [, index_name] ...</pre>
	
		<p>A table reference is also known as a join expression.</p>
		
		<p>The syntax of table_factor is extended in comparison with the SQL Standard.
			The latter accepts only table_reference, not a list of them inside a pair of parentheses.</p>
			
		<p>This is a conservative extension if we consider each comma in a list of table_reference
			items as equivalent to an inner join. For example:</p>
			
		<pre>(sql sqlHandle {SELECT * FROM t1 LEFT JOIN (t2, t3, t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)})</pre>
		
		<p>is equivalent to:</p>
		
		<pre>(sql sqlHandle {SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)})</pre>
		
		<p>In SQL, CROSS JOIN is a syntactic equivalent to INNER JOIN (they can replace each other). 
			In standard SQL, they are not equivalent. INNER JOIN is used with an ON clause, CROSS JOIN is used otherwise.</p>
			
		<p>In general, parentheses can be ignored in join expressions containing only inner join operations.
			SQL also supports nested joins.</p>

		<p>Index hints can be specified to affect how the SQL optimizer makes use of indexes.</p>
		
		<p>The following list describes general factors to take into account when writing joins.</p>

		<ul>
			<li>
				<p>A table reference can be aliased using tbl_name AS alias_name or tbl_name alias_name:</p>
				
				<pre>(sql sqlHandle {SELECT t1.name, t2.salary FROM employee AS t1 INNER JOIN info AS t2 ON t1.name = t2.name})</pre>
				
				<pre>(sql sqlHandle {SELECT t1.name, t2.salary FROM employee t1 INNER JOIN info t2 ON t1.name = t2.name})</pre>
			</li>
			<li>
				<p>A table_subquery is also known as a subquery in the FROM clause.
					Such subqueries must include an alias to give the subquery result a table name.
					A trivial example follows;</p>
					
				<pre>(sql sqlHandle {SELECT * FROM (SELECT 1, 2, 3) AS t1})</pre>
			</li>
			<li>
				<p>INNER JOIN and , (comma) are semantically equivalent in the absence of a join condition:
					both produce a Cartesian product between the specified tables
					(that is, each and every row in the first table is joined to each and every row in the second table).</p>
				
				<p>However, the precedence of the comma operator is less than of INNER JOIN, CROSS JOIN, LEFT JOIN, and so on.
					If you mix comma joins with the other join types when there is a join condition,
					an error of the form Unknown column 'col_name' in 'on clause' may occur.
					Information about dealing with this problem is given later in this section.</p>
			</li>
			<li>
				<p>The conditional_expr used with ON is any conditional expression of the form that can be used in a WHERE clause.
					Generally, you should use the ON clause for conditions that specify how to join tables,
					and the WHERE clause to restrict which rows you want in the result set.</p>
			</li>
			<li>
				<p>If there is no matching row for the right table in the ON or USING part in a LEFT JOIN,
					a row with all columns set to NULL is used for the right table.
					You can use this fact to find rows in a table that have no counterpart in another table:</p>
					
				<pre>(sql sqlHandle {
SELECT left_tbl.*
  FROM left_tbl LEFT JOIN right_tbl ON left_tbl.id = right_tbl.id
  WHERE right_tbl.id IS NULL})</pre>
  
				<p>This example finds all rows in left_tbl with an id value that is not present in right_tbl 
					(that is, all rows in left_tbl with no corresponding row in right_tbl).
					This assumes that right_tbl.id is declared NOT NULL.</p>
			</li>
			<li>
				<p>The USING(column_list) clause names a list of columns that must exist in both tables.
					If tables a and b both contain columns c1, c2, and c3, the following join compares corresponding columns from the two tables:</p>
					
				<pre>a LEFT JOIN b USING (c1,c2,c3)</pre>
			</li>
			<li>
				<p>The NATURAL [LEFT] JOIN of two tables is defined to be semantically equivalent to an INNER JOIN or
					a LEFT JOIN with a USING clause that names all columns that exist in both tables.</p>
			</li>
			<li>
				<p>RIGHT JOIN works analogously to LEFT JOIN. To keep code portable across databases,
					it is recommended that you use LEFT JOIN instead of RIGHT JOIN.</p>
			</li>
			<li>
				<p>The { OJ ... LEFT OUTER JOIN ...} syntax shown in the join syntax description exists only for compatibility with ODBC.
					The curly braces in the syntax should be written literally;
					they are not metasyntax as used elsewhere in syntax descriptions.</p>
			
				<p>You can use other types of joins within { OJ ... }, such as INNER JOIN or RIGHT OUTER JOIN.
					This helps with compatibility with some third-party applications, but is not official ODBC syntax.</p>
			</li>
			<li>
				<p>STRAIGHT_JOIN is similar to JOIN, except that the left table is always read before the right table.
					This can be used for those (few) cases for which the join optimizer puts the tables in the wrong order.</p>
			</li>
		</ul>
		
		<p>Some join examples:</p>
		
		<pre>(sql sqlHandle {SELECT * FROM table1, table2})</pre>
		<pre>(sql sqlHandle {SELECT * FROM table1 INNER JOIN table2 ON table1.id=table2.id})</pre>
		<pre>(sql sqlHandle {SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id})</pre>
		<pre>(sql sqlHandle {SELECT * FROM table1 LEFT JOIN table2 USING (id)})</pre>
		<pre>(sql sqlHandle {SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id LEFT JOIN table3 ON table2.id=table3.id})</pre>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SUNION Syntax"></A>UNION Syntax</H2></P>
		<pre>SELECT ...
UNION [ALL | DISTINCT] SELECT ...
[UNION [ALL | DISTINCT] SELECT ...]</pre>

		<p>UNION is used to combine the result from multiple SELECT statements into a single result set.</p>
		
		<p>The column names from the first SELECT statement are used as the column names for the results returned.
			Selected columns listed in corresponding positions of each SELECT statement should have the same data type.
			(For example, the first column selected by the first statement should have
			the same type as the first column selected by the other statements.)</p>
			
		<p>If the data types of corresponding SELECT columns do not match,
			the types and lengths of the columns in the UNION result take into
			account the values retrieved by all of the SELECT statements. For example, consider the following:</p>
			
		<pre>(sql sqlHandle {SELECT REPEAT('a',1) UNION SELECT REPEAT('b',10)}) <b>Returns</b>
#(rec(2 |REPEAT('a',1)|:Character:10)| [0](|REPEAT('a',1)|:"a") [1](|REPEAT('a',1)|:"bbbbbbbbbb"))</pre>

		<p>The SELECT statements are normal select statements, but with the following restrictions:</p>
		<ul>
			<li>
				<p>Only the last SELECT statement can use INTO OUTFILE. (However, the entire UNION result is written to the file.)</p>
			</li>
			<li>
				<p>HIGH_PRIORITY cannot be used with SELECT statements that are part of a UNION.
					If you specify it for the first SELECT, it has no effect.
					If you specify it for any subsequent SELECT statements, a syntax error results.</p>
			</li>
		</ul>
		
		<p>The default behavior for UNION is that duplicate rows are removed from the result.
			The optional DISTINCT keyword has no effect other than the default because it also specifies duplicate-row removal.
			With the optional ALL keyword, duplicate-row removal does not occur and the
			result includes all matching rows from all the SELECT statements.</p>
			
		<p>You can mix UNION ALL and UNION DISTINCT in the same query.
			Mixed UNION types are treated such that a DISTINCT union overrides any ALL union to its left.
			A DISTINCT union can be produced explicitly by using UNION DISTINCT or
			implicitly by using UNION with no following DISTINCT or ALL keyword.</p>
			
		<p>To use an ORDER BY or LIMIT clause to sort or limit the entire UNION result,
			parenthesize the individual SELECT statements and place the ORDER BY or LIMIT after the last one.
			The following example uses both clauses:</p>
			
		<pre>(sql sqlHandle {
(SELECT a FROM t1 WHERE a=10 AND B=1)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2)
ORDER BY a LIMIT 10})</pre>

		<p>This kind of ORDER BY cannot use column references that include a
			table name (that is, names in tbl_name.col_name format).
			Instead, provide a column alias in the first SELECT statement and refer to the alias in the ORDER BY.
			(Alternatively, refer to the column in the ORDER BY using its column position. However, use of column positions is deprecated.)</p>
			
		<p>Also, if a column to be sorted is aliased, the ORDER BY clause must refer to the alias, not the column name.
			The first of the following statements will work, but the second will fail with an Unknown column 'a' in 'order clause' error:</p>
			
		<pre>(sql sqlHandle {
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY b;
(SELECT a AS b FROM t) UNION (SELECT ...) ORDER BY a;})</pre>

		<p>To apply ORDER BY or LIMIT to an individual SELECT, place the clause inside the parentheses that enclose the SELECT:</p>
		
		<pre>(sql sqlHandle {
(SELECT a FROM t1 WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM t2 WHERE a=11 AND B=2 ORDER BY a LIMIT 10);})</pre>

		<p>However, use of ORDER BY for individual SELECT statements implies nothing about the order in which the rows appear
			in the final result because UNION by default produces an unordered set of rows.
			Therefore, the use of ORDER BY in this context is typically in conjunction with LIMIT,
			so that it is used to determine the subset of the selected rows to retrieve for the SELECT,
			even though it does not necessarily affect the order of those rows in the final UNION result.
			If ORDER BY appears without LIMIT in a SELECT, it is optimized away because it will have no effect anyway.</p>
			
		<p>To cause rows in a UNION result to consist of the sets of rows retrieved by each SELECT one after the other,
			select an additional column in each SELECT to use as a sort column and add an ORDER BY following the last SELECT:</p>
			
		<pre>(sql sqlHandle {
(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col;})</pre>

		<p>To additionally maintain sort order within individual SELECT results, add a secondary column to the ORDER BY clause:</p>
		
		<pre>(sql sqlHandle {
(SELECT 1 AS sort_col, col1a, col1b, ... FROM t1)
UNION
(SELECT 2, col2a, col2b, ... FROM t2) ORDER BY sort_col, col1a;})</pre>

		<p>Use of an additional column also enables you to determine which SELECT each row comes from.
			Extra columns can provide other identifying information as well, such as a string that indicates a table name.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSubquery Syntax"></A>Subquery Syntax</H2></P>
		<p>A subquery is a SELECT statement within another statement.</p>
		
		<p>All subquery forms and operations that the SQL standard requires are supported, as well as a few features that are MySQL-specific.</p>
		
		<p>Here is an example of a subquery:</p>
		
		<pre>(sql sqlHandle {SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2)})</pre>
		
		<p>In this example, SELECT * FROM t1 ... is the outer query (or outer statement), and (SELECT column1 FROM t2) is the subquery.
			We say that the subquery is nested within the outer query, and in fact it is possible to nest subqueries within other subqueries,
			to a considerable depth. A subquery must always appear within parentheses.</p>
			
		<p>The main advantages of subqueries are:</p>
		
		<ul>
			<li>
				<p>They allow queries that are structured so that it is possible to isolate each part of a statement.</p>
			</li>
			<li>
				<p>They provide alternative ways to perform operations that would otherwise require complex joins and unions.</p>
			</li>
			<li>
				<p>They are, in many people's opinion, more readable than complex joins or unions.
					Indeed, it was the innovation of subqueries that gave people the original idea of calling the early SQL "Structured Query Language."</p>
			</li>
		</ul>
		
		<p>Here is an example statement that shows the major points about subquery syntax as specified by the SQL standard and supported in MySQL:</p>
		
		<pre>(sql sqlHandle {
DELETE FROM t1
WHERE s11 > ANY
 (SELECT COUNT(*) /* no hint */ FROM t2
  WHERE NOT EXISTS
   (SELECT * FROM t3
    WHERE ROW(5*t2.s1,77)=
     (SELECT 50,11*s1 FROM t4 UNION SELECT 50,77 FROM
      (SELECT * FROM t5) AS t5)))})</pre>
	  
		<p>A subquery can return a scalar (a single value), a single row, a single column, or a table (one or more rows of one or more columns).
			These are called scalar, column, row, and table subqueries.
			Subqueries that return a particular kind of result often can be used only in certain contexts, as described in the following sections.</p>
			
		<p>There are few restrictions on the type of statements in which subqueries can be used.
			A subquery can contain any of the keywords or clauses that an ordinary SELECT can contain:
			DISTINCT, GROUP BY, ORDER BY, LIMIT, joins, index hints, UNION constructs, comments, functions, and so on.</p>
			
		<p>One restriction is that a subquery's outer statement must be one of:
			SELECT, INSERT, UPDATE, DELETE, SET, or DO.
			Another restriction is that currently you cannot modify a table and select from the same table in a subquery.
			This applies to statements such as DELETE, INSERT, REPLACE, UPDATE, and 
			(because subqueries can be used in the SET clause) LOAD DATA INFILE.</p>
			
		<b>The Subquery as Scalar Operand</b>
		<p>In its simplest form, a subquery is a scalar subquery that returns a single value.
			A scalar subquery is a simple operand, and you can use it almost anywhere a single column value or literal is legal,
			and you can expect it to have those characteristics that all operands have:
			a data type,a length, an indication whether it can be NULL, and so on. For example:</p>
			
		<pre>(sql sqlHandle {
CREATE TABLE t1 (s1 INT, s2 CHAR(5) NOT NULL);
INSERT INTO t1 VALUES(100, 'abcde');
SELECT (SELECT s2 FROM t1)})</pre>

		<p>The subquery in this SELECT returns a single value ('abcde') that has a data type of CHAR,
			a length of 5, a character set and collation equal to the defaults in effect at CREATE TABLE time,
			and an indication that the value in the column can be NULL. In fact, almost all subqueries can be NULL.
			If the table used in the example were empty, the value of the subquery would be NULL.</p>
			
		<p>There are a few contexts in which a scalar subquery cannot be used.
			If a statement allows only a literal value, you cannot use a subquery.
			For example, LIMIT requires literal integer arguments, and LOAD DATA INFILE requires a literal string filename.
			You cannot use subqueries to supply these values.</p>
			
		<p>When you see examples in the following sections that contain the rather spartan construct (SELECT column1 FROM t1),
			imagine that your own code contains much more diverse and complex constructions.</p>
			
		<p>Suppose that we make two tables:</p>
		
		<pre>(sql sqlHandle {
CREATE TABLE t1 (s1 INT);
INSERT INTO t1 VALUES (1);
CREATE TABLE t2 (s1 INT);
INSERT INTO t2 VALUES (2);})</pre>

		<p>Then perform a SELECT:</p>
		
		<pre>(sql sqlHandle {
SELECT (SELECT s1 FROM t2) FROM t1})</pre>

		<p>The result is 2 because there is a row in t2 containing a column s1 that has a value of 2.</p>
		
		<p>A scalar subquery can be part of an expression, but remember the parentheses,
			even if the subquery is an operand that provides an argument for a function. For example:</p>
			
		<pre>(sql sqlHandle {SELECT UPPER((SELECT s1 FROM t1)) FROM t2;})</pre>
		
		<b>Comparisons Using Subqueries</b>
		<p>The most common use of a subquery is in the form:</p>
		
		<pre>non_subquery_operand comparison_operator (subquery)</pre>
		
		<p>Where comparison_operator is one of these operators:</p>
		
		<pre>=  >  <  >=  <=  <></pre>
		
		<p>For example:</p>
		
		<pre>... 'a' = (SELECT column1 FROM t1)</pre>
		
		<p>At one time the only legal place for a subquery was on the right side of a comparison,
			and you might still find some old DBMSs that insist on this.</p>
			
		<p>Here is an example of a common-form subquery comparison that you cannot do with a join.
			It finds all the values in table t1 that are equal to a maximum value in table t2:</p>
			
		<pre>(sql sqlHandle {
SELECT column1 FROM t1
WHERE column1 = (SELECT MAX(column2) FROM t2);})</pre>

		<p>Here is another example, which again is impossible with a join because it involves aggregating for one of the tables.
			It finds all rows in table t1 containing a value that occurs twice in a given column:</p>
			
		<pre>(sql sqlHandle {
SELECT * FROM t1 AS t
WHERE 2 = (SELECT COUNT(*) FROM t1 WHERE t1.id = t.id);})</pre>

		<p>For a comparison performed with one of these operators,
			the subquery must return a scalar, with the exception that = can be used with row subqueries.</p>
			
		<b>Subqueries with ANY, IN, and SOME</b>
		
		<p>Syntax:</p>
		
		<pre>operand comparison_operator ANY (subquery)
operand IN (subquery)
operand comparison_operator SOME (subquery)</pre>

		<p>The ANY keyword, which must follow a comparison operator,
			means "return TRUE if the comparison is TRUE for ANY of the values in the column that the subquery returns." For example:</p>
			
		<pre>(sql sqlHandle {SELECT s1 FROM t1 WHERE s1 > ANY (SELECT s1 FROM t2)})</pre>
		
		<p>Suppose that there is a row in table t1 containing (10).
			The expression is TRUE if table t2 contains (21,14,7) because there is a value 7 in t2 that is less than 10.
			The expression is FALSE if table t2 contains (20,10), or if table t2 is empty.
			The expression is unknown if table t2 contains (NULL,NULL,NULL).</p>
			
		<p>When used with a subquery, the word IN is an alias for = ANY. Thus, these two statements are the same:</p>
		
		<pre>(sql sqlHandle {
SELECT s1 FROM t1 WHERE s1 = ANY (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 IN    (SELECT s1 FROM t2);})</pre>

		<p>IN and = ANY are not synonyms when used with an expression list.
			IN can take an expression list, but = ANY cannot.</p>

		<p>NOT IN is not an alias for <> ANY, but for <> ALL.</p>
		
		<p>The word SOME is an alias for ANY. Thus, these two statements are the same:</p>
		
		<pre>(sql sqlHandle {
SELECT s1 FROM t1 WHERE s1 <> ANY  (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 <> SOME (SELECT s1 FROM t2);})</pre>

		<p>Use of the word SOME is rare, but this example shows why it might be useful.
			To most people's ears, the English phrase "a is not equal to any b" means "there is no b which is equal to a,"
			but that is not what is meant by the SQL syntax. The syntax means "there is some b to which a is not equal."
			Using <> SOME instead helps ensure that everyone understands the true meaning of the query.</p>
			
		<b>Subqueries with ALL</b>
		
		<p>Syntax:</p>
		
		<pre>operand comparison_operator ALL (subquery)</pre>
		
		<p>The word ALL, which must follow a comparison operator,
			means "return TRUE if the comparison is TRUE for ALL of the values in the column that the subquery returns." For example:</p>
			
		<pre>(sql sqlHandle {SELECT s1 FROM t1 WHERE s1 > ALL (SELECT s1 FROM t2);})</pre>
		
		<p>Suppose that there is a row in table t1 containing (10).
			The expression is TRUE if table t2 contains (-5,0,+5) because 10 is greater than all three values in t2.
			The expression is FALSE if table t2 contains (12,6,NULL,-100) because there is a single value 12 in table t2 that is greater than 10.
			The expression is unknown (that is, NULL) if table t2 contains (0,NULL,1).</p>
			
		<p>Finally, if table t2 is empty, the result is TRUE.
			So, the following statement is TRUE when table t2 is empty:</p>
			
		<pre>(sql sqlHandle {SELECT * FROM t1 WHERE 1 > ALL (SELECT s1 FROM t2);})</pre>
		
		<p>But this statement is NULL when table t2 is empty:</p>
		
		<pre>(sql sqlHandle {SELECT * FROM t1 WHERE 1 > (SELECT s1 FROM t2);})</pre>
		
		<p>In addition, the following statement is NULL when table t2 is empty:</p>
		
		<pre>(sql sqlHandle {SELECT * FROM t1 WHERE 1 > ALL (SELECT MAX(s1) FROM t2);})</pre>
		
		<p>In general, tables containing NULL values and empty tables are "edge cases."
			When writing subquery code, always consider whether you have taken those two possibilities into account.</p>
			
		<p>NOT IN is an alias for <> ALL. Thus, these two statements are the same:</p>
		
		<pre>(sql sqlHandle {
SELECT s1 FROM t1 WHERE s1 <> ALL (SELECT s1 FROM t2);
SELECT s1 FROM t1 WHERE s1 NOT IN (SELECT s1 FROM t2);})</pre>

		<b>Row Subqueries</b>
		
		<p>The discussion to this point has been of scalar or column subqueries;
			that is, subqueries that return a single value or a column of values.
			A row subquery is a subquery variant that returns a single row and can thus return more than one column value.
			Here are two examples:</p>
			
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE (1,2) = (SELECT column1, column2 FROM t2);
SELECT * FROM t1 WHERE ROW(1,2) = (SELECT column1, column2 FROM t2);})</pre>

		<p>The queries here are both TRUE if table t2 has a row where column1 = 1 and column2 = 2.</p>
		
		<p>The expressions (1,2) and ROW(1,2) are sometimes called row constructors.
			The two are equivalent. They are legal in other contexts as well.
			For example, the following two statements are semantically equivalent:</p>
			
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;})</pre>

		<p>The normal use of row constructors is for comparisons with subqueries that return two or more columns.
			For example, the following query answers the request, "find all rows in table t1 that also exist in table t2":</p>
			
		<pre>(sql sqlHandle {
SELECT column1,column2,column3
       FROM t1
       WHERE (column1,column2,column3) IN
             (SELECT column1,column2,column3 FROM t2);})</pre>
			 
		<b>EXISTS and NOT EXISTS</b>
		
		<p>If a subquery returns any rows at all, EXISTS subquery is TRUE, and NOT EXISTS subquery is FALSE. For example:</p>
		
		<pre>(sql sqlHandle {SELECT column1 FROM t1 WHERE EXISTS (SELECT * FROM t2)})</pre>
		
		<p>Traditionally, an EXISTS subquery starts with SELECT *,
			but it could begin with SELECT 5 or SELECT column1 or anything at all.
			SQL ignores the SELECT list in such a subquery, so it makes no difference.</p>
			
		<p>For the preceding example, if t2 contains any rows,
			even rows with nothing but NULL values, the EXISTS condition is TRUE.
			This is actually an unlikely example because a [NOT] EXISTS subquery almost always contains correlations.
			Here are some more realistic examples:</p>
	
		<ul>
			<li>
				<p>What kind of store is present in one or more cities?</p>
	
				<pre>(sql sqlHandle {
SELECT DISTINCT store_type FROM stores
  WHERE EXISTS (SELECT * FROM cities_stores
                WHERE cities_stores.store_type = stores.store_type);})</pre>
			</li>
			<li>
				<p>What kind of store is present in no cities?</p>
				<pre>(sql sqlHandle {
SELECT DISTINCT store_type FROM stores
  WHERE NOT EXISTS (SELECT * FROM cities_stores
                    WHERE cities_stores.store_type = stores.store_type);})</pre>
			</li>
			<li>
				<p>What kind of store is present in all cities?</p>
				<pre>(sql sqlHandle {
SELECT DISTINCT store_type FROM stores s1
  WHERE NOT EXISTS (
    SELECT * FROM cities WHERE NOT EXISTS (
      SELECT * FROM cities_stores
       WHERE cities_stores.city = cities.city
       AND cities_stores.store_type = stores.store_type));})</pre>
			</li>
		</ul>
		
		<p>The last example is a double-nested NOT EXISTS query.
			That is, it has a NOT EXISTS clause within a NOT EXISTS clause.
			Formally, it answers the question "does a city exist with a store that is not in Stores"?
			But it is easier to say that a nested NOT EXISTS answers the question "is x TRUE for all y?"</p>
			
		<b>Correlated Subqueries</b>
		
		<p>A correlated subquery is a subquery that contains a reference to a table that also appears in the outer query. For example:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE column1 = ANY
       (SELECT column1 FROM t2 WHERE t2.column2 = t1.column2);})</pre>
	   
		<p>Notice that the subquery contains a reference to a column of t1,
			even though the subquery's FROM clause does not mention a table t1.
			So, SQL looks outside the subquery, and finds t1 in the outer query.</p>
			
		<p>Suppose that table t1 contains a row where column1 = 5 and column2 = 6;
			meanwhile, table t2 contains a row where column1 = 5 and column2 = 7.
			The simple expression ... WHERE column1 = ANY (SELECT column1 FROM t2) would be TRUE,
			but in this example, the WHERE clause within the subquery is FALSE (because (5,6) is not equal to (5,7)),
			so the subquery as a whole is FALSE.</p>
			
		<p>Scoping rule: SQL evaluates from inside to outside. For example:</p>
		
		<pre>(sql sqlHandle {
SELECT column1 FROM t1 AS x
  WHERE x.column1 = (SELECT column1 FROM t2 AS x
    WHERE x.column1 = (SELECT column1 FROM t3
      WHERE x.column2 = t3.column1));})</pre>
	  
		<p>In this statement, x.column2 must be a column in table t2 because SELECT column1 FROM t2 AS x ... renames t2.
			It is not a column in table t1 because SELECT column1 FROM t1 ... is an outer query that is farther out.</p>
			
		<p>For subqueries in HAVING or ORDER BY clauses, SQL also looks for column names in the outer select list.</p>

		<p>For certain cases, a correlated subquery is optimized. For example:</p>
		
		<pre>val IN (SELECT key_val FROM tbl_name WHERE correlated_condition)</pre>
		
		<p>Otherwise, they are inefficient and likely to be slow. Rewriting the query as a join might improve performance.</p>
		
		<p>Aggregate functions in correlated subqueries may contain outer references,
			provided the function contains nothing but outer references,
			and provided the function is not contained in another function or expression.</p>
			
		<b>Subqueries in the FROM clause</b>
		
		<p>Subqueries are legal in a SELECT statement's FROM clause. The actual syntax is:</p>
		
		<pre>SELECT ... FROM (subquery) [AS] name ...</pre>
		
		<p>The [AS] name clause is mandatory, because every table in a FROM clause must have a name.
			Any columns in the subquery select list must have unique names.</p>
			
		<p>For the sake of illustration, assume that you have this table:</p>
		
		<pre>(sql sqlHandle {CREATE TABLE t1 (s1 INT, s2 CHAR(5), s3 FLOAT);})</pre>
		
		<p>Here is how to use a subquery in the FROM clause, using the example table:</p>
		
		<pre>(sql sqlHandle {INSERT INTO t1 VALUES (1,'1',1.0)})</pre>
		<pre>(sql sqlHandle {INSERT INTO t1 VALUES (2,'2',2.0)})</pre>
		<pre>(sql sqlHandle {SELECT sb1,sb2,sb3 FROM (SELECT s1 AS sb1, s2 AS sb2, s3*2 AS sb3 FROM t1) AS sb WHERE sb1 > 1}) <b>Returns</b>
#(rec(sb1:Long:1 sb2:Character:5 sb3:Number:1)| sb1:2 sb2:"2" sb3:4.0)		
		</pre>
		
		<p>Here is another example: Suppose that you want to know the average of a set of sums for a grouped table. This does not work:</p>
		
		<pre>(sql sqlHandle {SELECT AVG(SUM(column1)) FROM t1 GROUP BY column1})</pre>
		
		<p>However, this query provides the desired information:</p>
		
		<pre>(sql sqlHandle {
SELECT AVG(sum_column1)
       FROM (SELECT SUM(column1) AS sum_column1
             FROM t1 GROUP BY column1) AS t1;})</pre>
			 
		<p>Notice that the column name used within the subquery (sum_column1) is recognized in the outer query.</p>
		
		<p>Subqueries in the FROM clause can return a scalar, column, row, or table.
			Subqueries in the FROM clause cannot be correlated subqueries, unless used within the ON clause of a JOIN operation.</p>
			
		<p>Subqueries in the FROM clause are executed even for the EXPLAIN statement (that is, derived temporary tables are built).
			This occurs because upper-level queries need information about all tables during the optimization phase,
			and the table represented by a subquery in the FROM clause is unavailable unless the subquery is executed.</p>
			
		<p>It is possible under certain circumstances to modify table data using EXPLAIN SELECT.
			This can occur if the outer query accesses any tables and an inner query invokes a stored function that
			changes one or more rows of a table. For example, 
			suppose there are two tables t1 and t2 in database d1, created as shown here:</p>
			
		<pre>(sql sqlHandle {CREATE DATABASE d1})</pre>
		<pre>(sql sqlHandle {USE d1})</pre>
		<pre>(sql sqlHandle {CREATE TABLE t1 (c1 INT)})</pre>
		<pre>(sql sqlHandle {CREATE TABLE t2 (c1 INT)})</pre>
		
		<p>Now we create a stored function f1 which modifies t2:</p>
		
		<pre>(sql sqlHandle {CREATE FUNCTION f1(p1 INT) RETURNS INT 
BEGIN 
	INSERT INTO t2 VALUES (p1); 
	RETURN p1; 
END</pre>

		<p>Referencing the function directly in an EXPLAIN SELECT does not have any affect on t2.</p>

		<pre>(sql sqlHandle {EXPLAIN SELECT f1(5)}) <b>Returns</b>
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</pre>

		<p>This is because the SELECT statement did not reference any tables,
			as can be seen in the table and Extra columns of the output. This is also true of the following nested SELECT:</p>
			
		<pre>(sql sqlHandle {EXPLAIN SELECT NOW() AS a1, (SELECT f1(5)) AS a2}) <b>Returns</b>
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+
|  1 | PRIMARY     | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used |
+----+-------------+-------+------+---------------+------+---------+------+------+----------------+</pre>

		<pre>(sql sqlHandle {SHOW WARNINGS}) <b>Returns</b>
+-------+------+------------------------------------------+
| Level | Code | Message                                  |
+-------+------+------------------------------------------+
| Note  | 1249 | Select 2 was reduced during optimization |
+-------+------+------------------------------------------+</pre>

		<p>However, if the outer SELECT references any tables,
			then the optimizer executes the statement in the subquery as well:</p>

		<pre>(sql sqlHandle {EXPLAIN SELECT * FROM t1 AS a1, (SELECT f1(5)) AS a2}) <b>Returns</b>
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+
| id | select_type | table      | type   | possible_keys | key  | key_len | ref  | rows | Extra               |
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+
|  1 | PRIMARY     | a1         | system | NULL          | NULL | NULL    | NULL |    0 | const row not found |
|  1 | PRIMARY     | <derived2> | system | NULL          | NULL | NULL    | NULL |    1 |                     |
|  2 | DERIVED     | NULL       | NULL   | NULL          | NULL | NULL    | NULL | NULL | No tables used      |
+----+-------------+------------+--------+---------------+------+---------+------+------+---------------------+</pre>

		<pre>(sql sqlHandle {SELECT * FROM t2}) <b>Returns</b>
+------+
| c1   |
+------+
|    5 |
+------+</pre>

		<p>This also means that an EXPLAIN SELECT statement such as the one shown here may take a long time to execute:</p>
		
		<pre>(sql sqlHandle {EXPLAIN SELECT * FROM t1 AS a1, (SELECT BENCHMARK(1000000, MD5(NOW())))})</pre>
		
		<p>This is because the BENCHMARK() function is executed once for each row in t1.</p>
		
		<b>Subquery Errors</b>
		
		<p>There are some errors that apply only to subqueries. This section describes them.</p>
		
		<ul>
			<li>
				<p>Unsupported subquery syntax:</p>
				
				<pre>ERROR 1235 (ER_NOT_SUPPORTED_YET)
SQLSTATE = 42000
Message = "This version of MySQL does not yet support
'LIMIT & IN/ALL/ANY/SOME subquery'"</pre>

				<p>This means that statements of the following form do not work yet:</p>
				
				<pre>(sql sqlHandle {SELECT * FROM t1 WHERE s1 IN (SELECT s2 FROM t2 ORDER BY s1 LIMIT 1)})</pre>
			</li>
			<li>
				<p>Incorrect number of columns from subquery:</p>
				
				<pre>ERROR 1241 (ER_OPERAND_COL)
SQLSTATE = 21000
Message = "Operand should contain 1 column(s)"</pre>

				<p>This error occurs in cases like this:</p>
				
				<pre>(sql sqlHandle {SELECT (SELECT column1, column2 FROM t2) FROM t1})</pre>
				
				<p>You may use a subquery that returns multiple columns, if the purpose is comparison.
					In other contexts, the subquery must be a scalar operand.</p>
			</li>
			<li>
				<p>Incorrect number of rows from subquery:</p>
				
				<pre>ERROR 1242 (ER_SUBSELECT_NO_1_ROW)
SQLSTATE = 21000
Message = "Subquery returns more than 1 row"</pre>

				<p>This error occurs for statements where the subquery returns more than one row.
					Consider the following example:</p>
					
				<pre>(sql sqlHandle {SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2)})</pre>
				
				<p>If SELECT column1 FROM t2 returns just one row, the previous query will work.
					If the subquery returns more than one row, error 1242 will occur.
					In that case, the query should be rewritten as:</p>
					
				<pre>(sql sqlHandle {SELECT * FROM t1 WHERE column1 = ANY (SELECT column1 FROM t2)})</pre>
			</li>
			<li>
				<p>Incorrectly used table in subquery:</p>
				
				<pre>Error 1093 (ER_UPDATE_TABLE_USED)
SQLSTATE = HY000
Message = "You can't specify target table 'x'
for update in FROM clause"</pre>

				<p>This error occurs in cases such as the following:</p>
				
				<pre>(sql sqlHandle {UPDATE t1 SET column2 = (SELECT MAX(column1) FROM t1)})</pre>
				
				<p>You can use a subquery for assignment within an UPDATE statement because subqueries are
					legal in UPDATE and DELETE statements as well as in SELECT statements.
					However, you cannot use the same table (in this case, table t1) for both the subquery's FROM clause and the update target.</p>
					
				<p>For transactional storage engines, the failure of a subquery causes the entire statement to fail.
					For non-transactional storage engines, data modifications made before the error was encountered are preserved.</p>
			</li>
		</ul>
		
		<b>Optimizing Subqueries</b>
		
		<p>Development is ongoing, so no optimization tip is reliable for the long term.
			The following list provides some interesting tricks that you might want to play with:</p>
		
		<ul>
		<li>
		<p>Use subquery clauses that affect the number or order of the rows in the subquery. For example:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT column1 FROM t2 ORDER BY column1);})</pre>
  
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE t1.column1 IN
  (SELECT DISTINCT column1 FROM t2);})</pre>
  
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE EXISTS
  (SELECT * FROM t2 LIMIT 1);})</pre>
		</li>
		<li>
		<p>Replace a join with a subquery. For example, try this:</p>
		
		<pre>(sql sqlHandle {
SELECT DISTINCT column1 FROM t1 WHERE t1.column1 IN (
  SELECT column1 FROM t2);})</pre>
  
		<p>Instead of this:</p>
		
		<pre>(sql sqlHandle {
SELECT DISTINCT t1.column1 FROM t1, t2
  WHERE t1.column1 = t2.column1;})</pre>
		</li>
		<li>
		<p>Move clauses from outside to inside the subquery. For example, use this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1 UNION ALL SELECT s1 FROM t2);})</pre>
  
		<p>Instead of this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1
  WHERE s1 IN (SELECT s1 FROM t1) OR s1 IN (SELECT s1 FROM t2);})</pre>
  
		<p>For another example, use this query:</p>
		
		<pre>(sql sqlHandle {
SELECT (SELECT column1 + 5 FROM t1) FROM t2;})</pre>

		<p>Instead of this query:</p>
		
		<pre>(sql sqlHandle {
SELECT (SELECT column1 FROM t1) + 5 FROM t2;})</pre>
		</li>
		<li>
		<p>Use a row subquery instead of a correlated subquery. For example, use this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1
  WHERE (column1,column2) IN (SELECT column1,column2 FROM t2);})</pre>
  
		<p>Instead of this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1
  WHERE EXISTS (SELECT * FROM t2 WHERE t2.column1=t1.column1
  AND t2.column2=t1.column2);})</pre>
		</li>
		<li>
		<p>Use NOT (a = ANY (...)) rather than a <> ALL (...).</p>
		</li>
		<li>
		<p>Use x = ANY (table containing (1,2)) rather than x=1 OR x=2.</p>
		</li>
		<li>
		<p>Use = ANY rather than EXISTS.</p>
		</li>
		<li>
		<p>For uncorrelated subqueries that always return one row, IN is always slower than =. For example, use this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE t1.col_name
  = (SELECT a FROM t2 WHERE b = some_const);})</pre>
  
		<p>Instead of this query:</p>
		
		<pre>(sql sqlHandle {
SELECT * FROM t1 WHERE t1.col_name
  IN (SELECT a FROM t2 WHERE b = some_const);})</pre>
		</li>
		</ul>

		<p>These tricks might cause programs to go faster or slower.
			Using SQL facilities like the BENCHMARK() function, you can get an idea about what helps in your own situation.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="STRUNCATE Syntax"></A>TRUNCATE Syntax</H2></P>
		<pre>TRUNCATE [TABLE] tbl_name</pre>
		
		<p>TRUNCATE TABLE empties a table completely.
			Logically, this is equivalent to a DELETE statement that deletes all rows, but there are practical differences under some circumstances.</p>
			
		<p>For an InnoDB table, InnoDB processes TRUNCATE TABLE by deleting rows one by one if there are any FOREIGN KEY constraints that reference the table.
			If there are no FOREIGN KEY constraints, InnoDB performs fast truncation by dropping the original table and creating an empty one with the same definition,
			which is much faster than deleting rows one by one. The AUTO_INCREMENT counter is reset by TRUNCATE TABLE, regardless of whether there is a FOREIGN KEY constraint.</p>
			
		<p>In the case that FOREIGN KEY constraints reference the table, InnoDB deletes rows one by one and processes the constraints on each one.
			If the FOREIGN KEY constraint specifies DELETE CASCADE, rows from the child (referenced) table are deleted, and the truncated table becomes empty.
			If the FOREIGN KEY constraint does not specify CASCADE, the TRUNCATE statement deletes rows one by one and stops if it encounters a parent row that is referenced by the child, returning this error:</p>

		<pre>ERROR 1451 (23000): Cannot delete or update a parent row: a foreign
key constraint fails (`test`.`child`, CONSTRAINT `child_ibfk_1`
FOREIGN KEY (`parent_id`) REFERENCES `parent` (`id`))</pre>

		<p>This is the same as a DELETE statement with no WHERE clause.</p>
		
		<p>The count of rows affected by TRUNCATE TABLE is accurate only when it is mapped to a DELETE statement.</p>

		<p>For other storage engines, TRUNCATE TABLE differs from DELETE in the following ways in SQL:</p>

		<ul>
			<li>
				<p>Truncate operations drop and re-create the table, which is much faster than deleting rows one by one, particularly for large tables.</p>
			</li>
			<li>
				<p>Truncate operations are not transaction-safe; an error occurs when attempting one in the course of an active transaction or active table lock.</p>
			</li>
			<li>
				<p>Truncation operations do not return the number of deleted rows.</p>
			</li>
			<li>
				<p>As long as the table format file tbl_name.frm is valid, the table can be re-created as an empty table with TRUNCATE TABLE,
					even if the data or index files have become corrupted.</p>
			</li>
			<li>
				<p>The table handler does not remember the last used AUTO_INCREMENT value, but starts counting from the beginning.
					This is true even for MyISAM and InnoDB, which normally do not reuse sequence values.</p>
			</li>
			<li>
				<p>When used with partitioned tables, TRUNCATE TABLE preserves the partitioning;
					that is, the data and index files are dropped and re-created, while the partition definitions (.par) file is unaffected.</p>
			</li>
			<li>
				<p>Since truncation of a table does not make any use of DELETE, the TRUNCATE statement does not invoke ON DELETE triggers.</p>
			</li>
		</ul>
		
		<p>TRUNCATE TABLE requires the DROP privilege as of MySQL 5.1.16. (Before 5.1.16, it requires the DELETE privilege.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SUPDATE Syntax"></A>UPDATE Syntax</H2></P>
		<p>Single-table syntax:</p>
		
		<pre>UPDATE [LOW_PRIORITY] [IGNORE] tbl_name
    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]</pre>
	
		<p>Multiple-table syntax:</p>
		
		<pre>UPDATE [LOW_PRIORITY] [IGNORE] table_references
    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    [WHERE where_condition]</pre>
	
		<p>For the single-table syntax, the UPDATE statement updates columns of existing rows in tbl_name with new values.
			The SET clause indicates which columns to modify and the values they should be given.
			Each value can be given as an expression, or the keyword DEFAULT to set a column explicitly to its default value.
			The WHERE clause, if given, specifies the conditions that identify which rows to update. With no WHERE clause, all rows are updated.
			If the ORDER BY clause is specified, the rows are updated in the order that is specified. The LIMIT clause places a limit on the number of rows that can be updated.</p>
			
		<p>For the multiple-table syntax, UPDATE updates rows in each table named in table_references that satisfy the conditions.
			In this case, ORDER BY and LIMIT cannot be used.</p>
			
		<p>where_condition is an expression that evaluates to true for each row to be updated.</p>
		
		<p>The UPDATE statement supports the following modifiers:</p>
		
		<ul>
			<li>
				<p>If you use the LOW_PRIORITY keyword, execution of the UPDATE is delayed until no other clients are reading from the table.
					This affects only storage engines that use only table-level locking (MyISAM, MEMORY, MERGE).</p>
			</li>
			<li>
				<p>If you use the IGNORE keyword, the update statement does not abort even if errors occur during the update.
					Rows for which duplicate-key conflicts occur are not updated. Rows for which columns are updated to values that would cause data conversion errors are updated to the closest valid values instead.</p>
			</li>
		</ul>
		
		<p>If you access a column from tbl_name in an expression, UPDATE uses the current value of the column.
			For example, the following statement sets the age column to one more than its current value:</p>
			
		<pre>(sql sqlHandle {UPDATE persondata SET age=age+1;})</pre>
		
		<p>Single-table UPDATE assignments are generally evaluated from left to right.
			For multiple-table updates, there is no guarantee that assignments are carried out in any particular order.</p>
			
		<p>If you set a column to the value it currently has, MySQL notices this and does not update it.</p>
		
		<p>If you update a column that has been declared NOT NULL by setting to NULL, the column is set to the default value appropriate for the data type and the warning count is incremented.
			The default value is 0 for numeric types, the empty string ('') for string types, and the "zero" value for date and time types.</p>
			
		<p>UPDATE returns the number of rows that were actually changed.</p>
		
		<p>You can use LIMIT row_count to restrict the scope of the UPDATE.
			A LIMIT clause is a rows-matched restriction. The statement stops as soon as it has found row_count rows that satisfy the WHERE clause, whether or not they actually were changed.</p>
			
		<p>If an UPDATE statement includes an ORDER BY clause, the rows are updated in the order specified by the clause.
			This can be useful in certain situations that might otherwise result in an error.
			Suppose that a table t contains a column id that has a unique index.
			The following statement could fail with a duplicate-key error, depending on the order in which rows are updated:</p>
			
		<pre>(sql sqlHandle {UPDATE t SET id = id + 1})</pre>
		
		<p>For example, if the table contains 1 and 2 in the id column and 1 is updated to 2 before 2 is updated to 3, an error occurs.
			To avoid this problem, add an ORDER BY clause to cause the rows with larger id values to be updated before those with smaller values:</p>
			
		<pre>(sql sqlHandle {UPDATE t SET id = id + 1 ORDER BY id DESC})</pre>
		
		<p>You can also perform UPDATE operations covering multiple tables.
			However, you cannot use ORDER BY or LIMIT with a multiple-table UPDATE.
			The table_references clause lists the tables involved in the join.</p>
			
		<pre>(sql sqlHandle {UPDATE items,month SET items.price=month.price WHERE items.id=month.id})</pre>
		
		<p>The preceding example shows an inner join that uses the comma operator,
			but multiple-table UPDATE statements can use any type of join allowed in SELECT statements, such as LEFT JOIN.</p>
			
		<p>You need the UPDATE privilege only for columns referenced in a multiple-table UPDATE that are actually updated.
			You need only the SELECT privilege for any columns that are read but not modified.</p>
			
		<p>If you use a multiple-table UPDATE statement involving InnoDB tables for which there are foreign key constraints,
			the SQL optimizer might process tables in an order that differs from that of their parent/child relationship.
			In this case, the statement fails and rolls back. Instead, 
			update a single table and rely on the ON UPDATE capabilities that InnoDB provides to cause the other tables to be modified accordingly.</p>

		<p>Currently, you cannot update a table and select from the same table in a subquery.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDESCRIBE Syntax"></A>DESCRIBE Syntax</H2></P>
		<pre>{DESCRIBE | DESC} tbl_name [col_name | wild]</pre>
		
		<p>DESCRIBE provides information about the columns in a table.
			It is a shortcut for SHOW COLUMNS FROM. These statements also display information for views.</p>
			
		<p>col_name can be a column name, or a string containing the SQL "%" and "_" wildcard characters to obtain output only for the columns with names matching the string.
			There is no need to enclose the string within quotes unless it contains spaces or other special characters.</p>
			
		<pre>(sql sqlHandle {DESCRIBE City}) <b>Returns</b>
#(rec(5 Field:Character:64 Type:Object:1 Null:Character:3 Key:Character:3 Default:Object:1 Extra:Character:27)| 
[0](Field:"Id" Type:"int(11)" Null:"NO" Key:"PRI" Default:"NULL" Extra:"auto_increment") 
[1](Field:"Name" Type:"char(35)" Null:"NO" Key:"" Default:#void Extra:"") 
[2](Field:"Country" Type:"char(3)" Null:"NO" Key:"UNI" Default:#void Extra:"") 
[3](Field:"District" Type:"char(20)" Null:"YES" Key:"MUL" Default:#void Extra:"") 
[4](Field:"Population" Type:"int(11)" Null:"NO" Key:"" Default:"0" Extra:""))

or

+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+</pre>

		<p>The description for SHOW COLUMNS provides more information about the output columns.</p>
		
		<p>If the data types differ from what you expect them to be based on a CREATE TABLE statement,
			note that SQL sometimes changes data types when you create or alter a table.</p>
			
		<p>The DESCRIBE statement is provided for compatibility with Oracle.</p>

		<p>The SHOW CREATE TABLE, SHOW TABLE STATUS, and SHOW INDEX statements also provide information about tables.</p> 
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SEXPLAIN Syntax"></A>EXPLAIN Syntax</H2></P>
		<pre>EXPLAIN tbl_name</pre>
		<p>Or:</p>
		<pre>EXPLAIN [EXTENDED | PARTITIONS] SELECT select_options</pre>
		
		<p>The EXPLAIN statement can be used either as a synonym for DESCRIBE or as a way to obtain information about how SQL executes a SELECT statement:</p>
		
		<p>EXPLAIN tbl_name is synonymous with DESCRIBE tbl_name or SHOW COLUMNS FROM tbl_name.</p>
		
		<p>When you precede a SELECT statement with the keyword EXPLAIN, SQL displays information from the optimizer about the query execution plan.
			That is, SQL explains how it would process the SELECT, including information about how tables are joined and in which order.</p>
			
		<p>EXPLAIN PARTITIONS is useful only when examining queries involving partitioned tables.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SUSE Syntax"></A>USE Syntax</H2></P>
		<pre>USE db_name</pre>
		
		<p>The USE db_name statement tells SQL to use the db_name database as the default (current) database for subsequent statements.
			The database remains the default until the end of the session or another USE statement is issued:</p>
			
		<pre>(sql sqlHandle {USE db1;})</pre>
		<pre>(sql sqlHandle {SELECT COUNT(*) FROM mytable;   # selects from db1.mytable})</pre>
		<pre>(sql sqlHandle {USE db2;})</pre>
		<pre>(sql sqlHandle {SELECT COUNT(*) FROM mytable;   # selects from db2.mytable})</pre>

		<p>Making a particular database the default by means of the USE statement does not preclude you from accessing tables in other databases.
			The following example accesses the author table from the db1 database and the editor table from the db2 database:</p>
			
		<pre>(sql sqlHandle {USE db1;})</pre>
		<pre>(sql sqlHandle {SELECT author_name,editor_name FROM author,db2.editor WHERE author.editor_id = db2.editor.editor_id;})</pre>
		
		<p>The USE statement is provided for compatibility with Sybase.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SCREATE USER Syntax"></A>CREATE USER Syntax</H2></P>
		<pre>CREATE USER user [IDENTIFIED BY [PASSWORD] 'password']
    [, user [IDENTIFIED BY [PASSWORD] 'password']] ...</pre>
	
		<p>The CREATE USER statement creates new SQL accounts.
			To use it, you must have the global CREATE USER privilege or the INSERT privilege for the sql database.
			For each account, CREATE USER creates a new row in the mysql.user table that has no privileges. An error occurs if the account already exists.
			Each account is named using the same format as for the GRANT statement; for example, 'jeffrey'@'localhost'.
			If you specify only the username part of the account name, a hostname part of '%' is used.</p>
			
		<p>The account can be given a password with the optional IDENTIFIED BY clause.
			The user value and the password are given the same way as for the GRANT statement.
			In particular, to specify the password in plain text, omit the PASSWORD keyword.
			To specify the password as the hashed value as returned by the PASSWORD() function, include the PASSWORD keyword.</p>
			
		<p>Important: This statement may be recorded in a history file such as ~/.mysql_history,
			which means that plaintext passwords may be read by anyone having read access to such files.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDROP USER Syntax"></A>DROP USER Syntax</H2></P>
		<pre>DROP USER user [, user] ...</pre>
		
		<p>The DROP USER statement removes one or more SQL accounts.
			It removes privilege rows for the account from all grant tables.
			To use this statement, you must have the global CREATE USER privilege or the DELETE privilege for the sql database.
			Each account is named using the same format as for the GRANT statement; for example, 'jeffrey'@'localhost'.
			If you specify only the username part of the account name, a hostname part of '%' is used.</p>
			
		<p>With DROP USER, you can remove an account and its privileges as follows:</p>
		
		<pre>(sql sqlHandle {DROP USER user;})</pre>
		
		<p>Important: DROP USER does not automatically close any open user sessions.
			Rather, in the event that a user with an open session is dropped, the statement does not take effect until that user's session is closed.
			Once the session is closed, the user is dropped, and that user's next attempt to log in will fail. This is by design.</p>
			
		<p>DROP USER does not automatically delete or invalidate any database objects that the user created.
			This applies to tables, views, stored routines, triggers, and events.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SGRANT Syntax"></A>GRANT Syntax</H2></P>
		<pre>GRANT
    priv_type [(column_list)]
      [, priv_type [(column_list)]] ...
    ON [object_type]
        {
            *
          | *.*
          | db_name.*
          | db_name.tbl_name
          | tbl_name
          | db_name.routine_name

        }
    TO user [IDENTIFIED BY [PASSWORD] 'password']
        [, user [IDENTIFIED BY [PASSWORD] 'password']] ...
    [REQUIRE
        NONE |
        [{SSL| X509}]
        [CIPHER 'cipher' [AND]]
        [ISSUER 'issuer' [AND]]
        [SUBJECT 'subject']]
    [WITH with_option [with_option] ...]

object_type =
    TABLE
  | FUNCTION
  | PROCEDURE

with_option =
    GRANT OPTION
  | MAX_QUERIES_PER_HOUR count
  | MAX_UPDATES_PER_HOUR count
  | MAX_CONNECTIONS_PER_HOUR count
  | MAX_USER_CONNECTIONS count</pre>
  
		<p>The GRANT statement enables system administrators to create SQL user accounts and to grant rights to accounts.
			To use GRANT, you must have the GRANT OPTION privilege, and you must have the privileges that you are granting.
			The REVOKE statement is related and enables administrators to remove account privileges.</p>
		<p>SQL account information is stored in the tables of the mysql database.</p>
		
		<p>If the grant tables hold privilege rows that contain mixed-case database or table names and the lower_case_table_names system variable is set to a non-zero value,
			REVOKE cannot be used to revoke these privileges. It will be necessary to manipulate the grant tables directly. 
			(GRANT will not create such rows when lower_case_table_names is set, but such rows might have been created prior to setting the variable.)</p>
			
		<p>Privileges can be granted at several levels. The examples shown here include no IDENTIFIED BY 'password' clause for brevity,
			but you should include one if the account does not already exist to avoid creating an account with no password.</p>
			
		<ul>
			<li>
				<p>Global level</p>
				
				<p>Global privileges apply to all databases on a given server.
					These privileges are stored in the mysql.user table. GRANT ALL ON *.* and REVOKE ALL ON *.* grant and revoke only global privileges.</p>
				<pre>GRANT ALL ON *.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON *.* TO 'someuser'@'somehost';</pre>
			</li>
			<li>
				<p>Database level</p>
				
				<p>Database privileges apply to all objects in a given database.
					These privileges are stored in the mysql.db and mysql.host tables.
					GRANT ALL ON db_name.* and REVOKE ALL ON db_name.* grant and revoke only database privileges.</p>
					
				<pre>GRANT ALL ON mydb.* TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.* TO 'someuser'@'somehost';</pre>
			</li>
			<li>
				<p>Table level</p>
				
				<p>Table privileges apply to all columns in a given table.
					These privileges are stored in the mysql.tables_priv table.
					GRANT ALL ON db_name.tbl_name and REVOKE ALL ON db_name.tbl_name grant and revoke only table privileges.</p>
			
				<pre>GRANT ALL ON mydb.mytbl TO 'someuser'@'somehost';
GRANT SELECT, INSERT ON mydb.mytbl TO 'someuser'@'somehost';</pre>

				<p>If you specify tbl_name rather than db_name.tbl_name, the statement applies to tbl_name in the default database.</p>
			</li>
			<li>
				<p>Column level</p>
				
				<p>Column privileges apply to single columns in a given table.
					These privileges are stored in the mysql.columns_priv table.
					When using REVOKE, you must specify the same columns that were granted.
					The column or columns for which the privileges are to be granted must be enclosed within parentheses.</p>
					
				<pre>GRANT SELECT (col1), INSERT (col1,col2) ON mydb.mytbl TO 'someuser'@'somehost';</pre>
			</li>
			<li>
				<p>Routine level</p>
				
				<p>The CREATE ROUTINE, ALTER ROUTINE, EXECUTE, and GRANT privileges apply to stored routines (functions and procedures).
					They can be granted at the global and database levels. Also, except for CREATE ROUTINE,
					these privileges can be granted at the routine level for individual routines and are stored in the mysql.procs_priv table.</p>
					
				<pre>GRANT CREATE ROUTINE ON mydb.* TO 'someuser'@'somehost';
GRANT EXECUTE ON PROCEDURE mydb.myproc TO 'someuser'@'somehost';</pre>
			</li>
		</ul>
		
		<p>The object_type clause should be specified as TABLE, FUNCTION, or PROCEDURE when the following object is a table, a stored function, or a stored procedure.</p>
		
		<p>Warning: If you specify ON * and you have not selected a default database, the privileges granted are global.</p>
		
		<p>For the GRANT and REVOKE statements, priv_type can be specified as any of the following:</p>
		
		<table border="3">
			<tr>
				<th align="left">Privilege</th>
				<th align="left">Meaning</th>
			</tr>
			<tr>
				<td>ALL [PRIVILEGES]</td>
				<td>Grants all privileges at specified access level except GRANT OPTION</td>
			</tr>
			<tr>
				<td>ALTER</td>
				<td>Enables use of ALTER TABLE</td>
			</tr>
			<tr>
				<td>ALTER ROUTINE</td>
				<td>Enables stored routines to be altered or dropped</td>
			</tr>
			<tr>
				<td>CREATE</td>
				<td>Enables use of CREATE TABLE</td>
			</tr>
			<tr>
				<td>CREATE ROUTINE</td>
				<td>Enables creation of stored routines</td>
			</tr>
			<tr>
				<td>CREATE TEMPORARY TABLES</td>
				<td>Enables use of CREATE TEMPORARY TABLE</td>
			</tr>
			<tr>
				<td>CREATE USER</td>
				<td>Enables use of CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES.</td>
			</tr>
			<tr>
				<td>CREATE VIEW</td>
				<td>Enables use of CREATE VIEW</td>
			</tr>
			<tr>
				<td>DELETE</td>
				<td>Enables use of DELETE</td>
			</tr>
			<tr>
				<td>DROP</td>
				<td>Enables use of DROP TABLE</td>
			</tr>
			<tr>
				<td>EVENT</td>
				<td>Enables creation of events for the event scheduler</td>
			</tr>
			<tr>
				<td>EXECUTE</td>
				<td>Enables the user to run stored routines</td>
			</tr>
			<tr>
				<td>FILE</td>
				<td>Enables use of SELECT ... INTO OUTFILE and LOAD DATA INFILE</td>
			</tr>
			<tr>
				<td>INDEX</td>
				<td>Enables use of CREATE INDEX and DROP INDEX</td>
			</tr>
			<tr>
				<td>INSERT</td>
				<td>Enables use of INSERT</td>
			</tr>
			<tr>
				<td>LOCK TABLES</td>
				<td>Enables use of LOCK TABLES on tables for which you have the SELECT privilege</td>
			</tr>
			<tr>
				<td>PROCESS</td>
				<td>Enables the user to see all processes with SHOW PROCESSLIST</td>
			</tr>
			<tr>
				<td>REFERENCES</td>
				<td>Not implemented</td>
			</tr>
			<tr>
				<td>RELOAD</td>
				<td>Enables use of FLUSH</td>
			</tr>
			<tr>
				<td>REPLICATION CLIENT</td>
				<td>Enables the user to ask where slave or master servers are</td>
			</tr>
			<tr>
				<td>REPLICATION SLAVE</td>
				<td>Needed for replication slaves (to read binary log events from the master)</td>
			</tr>
			<tr>
				<td>SELECT</td>
				<td>Enables use of SELECT</td>
			</tr>
			<tr>
				<td>SHOW DATABASES</td>
				<td>SHOW DATABASES shows all databases</td>
			</tr>
			<tr>
				<td>SHOW VIEW</td>
				<td>Enables use of SHOW CREATE VIEW</td>
			</tr>
			<tr>
				<td>SHUTDOWN</td>
				<td>Enables use of mysqladmin shutdown</td>
			</tr>
			<tr>
				<td>SUPER</td>
				<td>Enables use of CHANGE MASTER, KILL, PURGE MASTER LOGS, and SET GLOBAL statements, the mysqladmin debug command; allows you to connect (once) even if max_connections is reached</td>
			</tr>
			<tr>
				<td>TRIGGER</td>
				<td>Enables the user to create or drop triggers</td>
			</tr>
			<tr>
				<td>UPDATE</td>
				<td>Enables use of UPDATE</td>
			</tr>
			<tr>
				<td>USAGE</td>
				<td>Synonym for "no privileges"</td>
			</tr>
			<tr>
				<td>GRANT OPTION</td>
				<td>Enables privileges to be granted</td>
			</tr>
		</table>
		
		<p>A trigger is associated with a table, so to create or drop a trigger, you must have the TRIGGER privilege for the table, not the trigger.</p>
		<p>The REFERENCES privilege currently is unused.</p>
		<p>USAGE can be specified when you want to create a user that has no privileges.</p>
		<p>Use SHOW GRANTS to determine what privileges an account has.</p>
		<p>You can assign global privileges by using ON *.* syntax or database-level privileges by using ON db_name.* syntax.
			If you specify ON * and you have selected a default database, the privileges are granted in that database.</p>
		<p>The FILE, PROCESS, RELOAD, REPLICATION CLIENT, REPLICATION SLAVE, SHOW DATABASES, SHUTDOWN, SUPER,
			and CREATE USER privileges are administrative privileges that can only be granted globally (using ON *.* syntax).</p>
		<p>Other privileges can be granted globally or at more specific levels.</p>
		<p>The priv_type values that you can specify for a table are SELECT, INSERT, UPDATE, DELETE,
			CREATE, DROP, GRANT OPTION, INDEX, ALTER, CREATE VIEW, SHOW VIEW and TRIGGER.</p>
		<p>The priv_type values that you can specify for a column (that is, when you use a column_list clause) are SELECT, INSERT, and UPDATE.</p>
		<p>The priv_type values that you can specify at the routine level are ALTER ROUTINE, EXECUTE, and GRANT OPTION.
			CREATE ROUTINE is not a routine-level privilege because you must have this privilege to create a routine in the first place.</p>
		<p>For the global, database, table, and routine levels, GRANT ALL assigns only the privileges that exist at the level you are granting.
			For example, GRANT ALL ON db_name.* is a database-level statement, so it does not grant any global-only privileges such as FILE.</p>
		<p>SQL allows you to grant privileges even on database objects that do not exist. In such cases, the privileges to be granted must include the CREATE privilege.
			This behavior is by design, and is intended to enable the database administrator to prepare user accounts and privileges for database objects that are to be created at a later time.</p>
			
		<p>Important: SQL does not automatically revoke any privileges when you drop a table or database. However, if you drop a routine, any routine-level privileges granted for that routine are revoked.</p>
		<p>Note: The "_" and "%" wildcards are allowed when specifying database names in GRANT statements that grant privileges at the global or database levels.
			This means, for example, that if you want to use a "_" character as part of a database name, you should specify it as "\_" in the GRANT statement,
			to prevent the user from being able to access additional databases matching the wildcard pattern; for example, GRANT ... ON `foo\_bar`.* TO ....</p>
			
		<p>To accommodate granting rights to users from arbitrary hosts, SQL supports specifying the user value in the form user_name@host_name.
			If a user_name or host_name value is legal as an unquoted identifier, you need not quote it.
			However, quotes are necessary to specify a user_name string containing special characters (such as "-"),
			or a host_name string containing special characters or wildcard characters (such as "%");
			for example, 'test-user'@'test-hostname'. Quote the username and hostname separately.</p>
			
		<p>You can specify wildcards in the hostname. For example, user_name@'%.loc.gov' applies to user_name for any host in the loc.gov domain,
			and user_name@'144.155.166.%' applies to user_name for any host in the 144.155.166 class C subnet.</p>
			
		<p>The simple form user_name is a synonym for user_name@'%'.</p>
		
		<p>SQL does not support wildcards in usernames.
			Anonymous users are defined by inserting entries with User='' into the mysql.user table or by creating a user with an empty name with the GRANT statement:</p>
			
		<pre>GRANT ALL ON test.* TO ''@'localhost' ...</pre>
		
		<p>When specifying quoted values, quote database, table, column, and routine names as identifiers, using backticks ("`").
			Quote hostnames, usernames, and passwords as strings, using single quotes ("'").</p>
			
		<p>Warning: If you allow anonymous users to connect to the SQL server, you should also grant privileges to all local users as user_name@localhost.
			Otherwise, the anonymous user account for localhost in the mysql.user table (created during SQL installation) is used when named users try to log in to the SQL server from the local machine.</p>
			
		<p>You can determine whether this applies to you by executing the following query, which lists any anonymous users:</p>
		
		<pre>SELECT Host, User FROM mysql.user WHERE User='';</pre>
		
		<p>If you want to delete the local anonymous user account to avoid the problem just described, use these statements:</p>
		
		<pre>DELETE FROM mysql.user WHERE Host='localhost' AND User='';
FLUSH PRIVILEGES;</pre>

		<p>GRANT supports hostnames up to 60 characters long. Database, table, column, and routine names can be up to 64 characters. Usernames can be up to 16 characters.</p>
		
		<p>Note: The allowable length for usernames cannot be changed by altering the mysql.user table,
			and attempting to do so results in unpredictable behavior which may even make it impossible for users to log in to the SQL server.</p>
			
		<p>The privileges for a table, column, or routine are formed additively as the logical OR of the privileges at each of the privilege levels.
			For example, if the mysql.user table specifies that a user has a global SELECT privilege, the privilege cannot be denied by an entry at the database, table, or column level.</p>
			
		<p>The privileges for a column can be calculated as follows:</p>

		<pre>global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
OR routine privileges</pre>

		<p>In most cases, you grant rights to a user at only one of the privilege levels, so life is not normally this complicated.</p>
		
		<p>If you grant privileges for a username/hostname combination that does not exist in the mysql.user table,
			an entry is added and remains there until deleted with a DELETE statement.
			In other words, GRANT may create user table entries, but REVOKE does not remove them; you must do that explicitly using DROP USER or DELETE.</p>
			
		<p>If the account does not already exist, GRANT creates it.
			In the case that you create a new account or if you have global grant privileges,
			the account's password is set to the password specified by the IDENTIFIED BY clause, if one is given.
			If the account already had a password, it is replaced by the new one.</p>
			
		<p>Warning: If you create a new user but do not specify an IDENTIFIED BY clause, the user has no password.
			This is very insecure. However, you can enable the NO_AUTO_CREATE_USER SQL mode to prevent GRANT from creating a new user if it would otherwise do so,
			unless IDENTIFIED BY is given to provide the new user a non-empty password.</p>
			
		<p>Passwords can also be set with the SET PASSWORD statement.</p>
		
		<p>In the IDENTIFIED BY clause, the password should be given as the literal password value.
			It is unnecessary to use the PASSWORD() function as it is for the SET PASSWORD statement. For example:</p>
			
		<pre>GRANT ... IDENTIFIED BY 'mypass';</pre>
		
		<p>If you do not want to send the password in clear text and you know the hashed value that PASSWORD() would return for the password,
			you can specify the hashed value preceded by the keyword PASSWORD:</p>
			
		<pre>GRANT ...
IDENTIFIED BY PASSWORD '*6C8989366EAF75BB670AD8EA7A7FC1176A95CEF4';</pre>

		<p>If you grant privileges for a database, an entry in the mysql.db table is created if needed.
			If all privileges for the database are removed with REVOKE, this entry is deleted.</p>
			
		<p>The SHOW DATABASES privilege enables the account to see database names by issuing the SHOW DATABASE statement.
			Accounts that do not have this privilege see only databases for which they have some privileges, and cannot use the statement at all if the server was started with the --skip-show-database option.</p>
			
		<p>If a user has no privileges for a table, the table name is not displayed when the user requests a list of tables (for example, with a SHOW TABLES statement).</p>
		
		<p>The WITH GRANT OPTION clause gives the user the ability to give to other users any privileges the user has at the specified privilege level.
			You should be careful to whom you give the GRANT OPTION privilege, because two users with different privileges may be able to join privileges!</p>
			
		<p>You cannot grant another user a privilege which you yourself do not have; the GRANT OPTION privilege enables you to assign only those privileges which you yourself possess.</p>
		
		<p>Be aware that when you grant a user the GRANT OPTION privilege at a particular privilege level,
			any privileges the user possesses (or may be given in the future) at that level can also be granted by that user to other users.
			Suppose that you grant a user the INSERT privilege on a database.
			If you then grant the SELECT privilege on the database and specify WITH GRANT OPTION,
			that user can give to other users not only the SELECT privilege, but also INSERT.
			If you then grant the UPDATE privilege to the user on the database, the user can grant INSERT, SELECT, and UPDATE.</p>
			
		<p>For a non-administrative user, you should not grant the ALTER privilege globally or for the mysql database.
			If you do that, the user can try to subvert the privilege system by renaming tables!</p>
			
		<p>The MAX_QUERIES_PER_HOUR count, MAX_UPDATES_PER_HOUR count, and MAX_CONNECTIONS_PER_HOUR count options limit the number of queries,
			updates, and logins a user can perform during any given one-hour period.
			(Queries for which results are served from the query cache do not count against the MAX_QUERIES_PER_HOUR limit.)
			If count is 0 (the default), this means that there is no limitation for that user.</p>
			
		<p>The MAX_USER_CONNECTIONS count option limits the maximum number of simultaneous connections that the account can make.
			If count is 0 (the default), the max_user_connections system variable determines the number of simultaneous connections for the account.</p>
			
		<p>Note: To specify any of these resource-limit options for an existing user without affecting existing privileges, use GRANT USAGE ON *.* ... WITH MAX_....</p>

		<p>The biggest differences between the standard SQL and MySQL versions of GRANT are:</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRENAME USER Syntax"></A>RENAME USER Syntax</H2></P>
		<pre>RENAME USER old_user TO new_user
    [, old_user TO new_user] ...</pre>
	
		<p>The RENAME USER statement renames existing SQL accounts.
			To use it, you must have the global CREATE USER privilege or the UPDATE privilege for the mysql database.
			An error occurs if any old account does not exist or any new account exists.
			Each account is named using the same format as for the GRANT statement;
			for example, 'jeffrey'@'localhost'. If you specify only the username part of the account name, a hostname part of '%' is used.</p>
			
		<p>RENAME USER does not automatically migrate any database objects that the user created,
			nor does it migrate any privileges that the user had prior to the renaming.
			This applies to tables, views, stored routines, triggers, and events.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SREVOKE Syntax"></A>REVOKE Syntax</H2></P>
		<pre>REVOKE
    priv_type [(column_list)]
      [, priv_type [(column_list)]] ...
    ON [object_type]
        {
            *
          | *.*
          | db_name.*
          | db_name.tbl_name
          | tbl_name
          | db_name.routine_name

        }
    FROM user [, user] ...

REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...</pre>

		<p>The REVOKE statement enables system administrators to revoke privileges from SQL accounts.
			Each account is named using the same format as for the GRANT statement; for example, 'jeffrey'@'localhost'.
			If you specify only the username part of the account name, a hostname part of '%' is used.</p>
			
		<p>To use the first REVOKE syntax, you must have the GRANT OPTION privilege, and you must have the privileges that you are revoking.</p>
		
		<p>If the grant tables hold privilege rows that contain mixed-case database or table names and the lower_case_table_names system variable is set to a non-zero value,
			REVOKE cannot be used to revoke these privileges. It will be necessary to manipulate the grant tables directly.
			(GRANT will not create such rows when lower_case_table_names is set, but such rows might have been created prior to setting the variable.)</p>
			
		<p>To revoke all privileges, use the following syntax, which drops all global, database-, table-, column-, and routine-level privileges for the named user or users:</p>

		<pre>REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...</pre>
		
		<p>To use this REVOKE syntax, you must have the global CREATE USER privilege or the UPDATE privilege for the mysql database.</p>
		
		<p>REVOKE removes privileges, but does not drop user table entries. You must do that explicitly using DELETE or DROP USER.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSET PASSWORD Syntax"></A>SET PASSWORD Syntax</H2></P>
		<pre>SET PASSWORD [FOR user] =
    {
        PASSWORD('some password')
      | OLD_PASSWORD('some password')
      | 'encrypted password'
    }</pre>
	
		<p>The SET PASSWORD statement assigns a password to an existing SQL user account.</p>

		<p>If the password is specified using the PASSWORD() or OLD_PASSWORD() function, the literal text of the password should be given.
			If the password is specified without using either function, the password should be the already-encrypted password value as returned by PASSWORD().</p>
			
		<p>With no FOR clause, this statement sets the password for the current user.
			Any client that has connected to the server using a non-anonymous account can change the password for that account.</p>
			
		<p>With a FOR clause, this statement sets the password for a specific account on the current server host.
			Only clients that have the UPDATE privilege for the mysql database can do this.
			The user value should be given in user_name@host_name format, where user_name and host_name are exactly as they are listed in the User and Host columns of the mysql.user table entry.
			For example, if you had an entry with User and Host column values of 'bob' and '%.loc.gov', you would write the statement like this:</p>
			
		<pre>SET PASSWORD FOR 'bob'@'%.loc.gov' = PASSWORD('newpass');</pre>
		
		<p>That is equivalent to the following statements:</p>
		
		<pre>UPDATE mysql.user SET Password=PASSWORD('newpass')
  WHERE User='bob' AND Host='%.loc.gov';
FLUSH PRIVILEGES;</pre>

		<p>You can see which account the server authenticated you as by executing SELECT CURRENT_USER().</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSET Syntax"></A>SET Syntax</H2></P>
		<pre>SET variable_assignment [, variable_assignment] ...

variable_assignment:
      user_var_name = expr
    | [GLOBAL | SESSION] system_var_name = expr
    | [@@global. | @@session. | @@]system_var_name = expr</pre>
	
		<p>The SET statement assigns values to different types of variables that affect the operation of the server or your client.</p>
		
		<p>This section describes use of SET for assigning values to system variables or user variables.</p>
		
		<p>Some variants of SET syntax are used in other contexts:</p>
		<ul>
			<li>
				<p>SET CHARACTER SET and SET NAMES assign values to character set and collation variables associated with the connection to the server.
					SET ONESHOT is used for replication. These variants are described later in this section.</p>
			</li>
			<li>
				<p>SET PASSWORD assigns account passwords.</p>
			</li>
			<li>
				<p>SET TRANSACTION ISOLATION LEVEL sets the isolation level for transaction processing.</p>
			</li>
			<li>
				<p>SET is used within stored routines to assign values to local routine variables.</p>
			</li>
		</ul>
		
		<p>The following discussion shows the different SET syntaxes that you can use to set variables.
			The examples use the = assignment operator, but the := operator also is allowable.</p>
			
		<p>A user variable is written as @var_name and can be set as follows:</p>
		
		<pre>SET @var_name = expr;</pre>
		
		<p>Many system variables are dynamic and can be changed while the server runs by using the SET statement.
			To change a system variable with SET, refer to it as var_name, optionally preceded by a modifier:</p>
		<ul>
			<li>
				<p>To indicate explicitly that a variable is a global variable, precede its name by GLOBAL or @@global.. The SUPER privilege is required to set global variables.</p>
			</li>
			<li>
				<p>To indicate explicitly that a variable is a session variable, precede its name by SESSION, @@session., or @@.
					Setting a session variable requires no special privilege, but a client can change only its own session variables, not those of any other client.</p>
			</li>
			<li>
				<p>LOCAL and @@local. are synonyms for SESSION and @@session..</p>
			</li>
			<li>
				<p>If no modifier is present, SET changes the session variable.</p>
			</li>
		</ul>
		
		<p>A SET statement can contain multiple variable assignments, separated by commas.
			If you set several system variables, the most recent GLOBAL or SESSION modifier in the statement is used for following variables that have no modifier specified.</p>
			
		<p>Examples:</p>
		
		<pre>SET sort_buffer_size=10000;
SET @@local.sort_buffer_size=10000;
SET GLOBAL sort_buffer_size=1000000, SESSION sort_buffer_size=1000000;
SET @@sort_buffer_size=1000000;
SET @@global.sort_buffer_size=1000000, @@local.sort_buffer_size=1000000;</pre>

		<p>The @@var_name syntax for system variables is supported for compatibility with some other database systems.</p>
		
		<p>If you change a session system variable, the value remains in effect until your session ends or until you change the variable to a different value.
			The change is not visible to other clients.</p>
			
		<p>If you change a global system variable, the value is remembered and used for new connections until the server restarts.
			(To make a global system variable setting permanent, you should set it in an option file.)
			The change is visible to any client that accesses that global variable.
			However, the change affects the corresponding session variable only for clients that connect after the change.
			The global variable change does not affect the session variable for any client that is currently connected (not even that of the client that issues the SET GLOBAL statement).</p>
			
		<p>To prevent incorrect usage, SQL produces an error if you use SET GLOBAL with a variable that can only be used with
			SET SESSION or if you do not specify GLOBAL (or @@global.) when setting a global variable.</p>
			
		<p>To set a SESSION variable to the GLOBAL value or a GLOBAL value to the compiled-in SQL default value,
			use the DEFAULT keyword. For example, the following two statements are identical in setting the session value of max_join_size to the global value:</p>
			
		<pre>SET max_join_size=DEFAULT;
SET @@session.max_join_size=@@global.max_join_size;</pre>

		<p>Not all system variables can be set to DEFAULT. In such cases, use of DEFAULT results in an error.</p>
		
		<p>You can refer to the values of specific global or sesson system variables in expressions by using one of the @@-modifiers.
			For example, you can retrieve values in a SELECT statement like this:</p>

		<pre>SELECT @@global.sql_mode, @@session.sql_mode, @@sql_mode;</pre>
		
		<p>When you refer to a system variable in an expression as @@var_name (that is, when you do not specify @@global. or @@session.),
			SQL returns the session value if it exists and the global value otherwise. (This differs from SET @@var_name = value, which always refers to the session value.)</p>
			
		<p>Suffixes for specifying a value multiplier can be used when setting a variable at server startup,
			but not to set the value with SET at runtime. On the other hand, with SET you can assign a variable's value using an expression,
			which is not true when you set a variable at server startup. For example, the first of the following lines is legal at server startup, but the second is not:</p>
			
		<pre>shell> mysql --max_allowed_packet=16M
shell> mysql --max_allowed_packet=16*1024*1024</pre>

		<p>Conversely, the second of the following lines is legal at runtime, but the first is not:</p>
		
		<pre>mysql> SET GLOBAL max_allowed_packet=16M;
mysql> SET GLOBAL max_allowed_packet=16*1024*1024;</pre>

		<p>To display system variables names and values, use the SHOW VARIABLES statement.</p>
		
		<p>The following list describes SET options that have non-standard syntax (that is, options that are not set with name = value syntax).</p>
		
		<ul>
			<li>
				<p>CHARACTER SET {charset_name | DEFAULT}</p>
				<p>This maps all strings from and to the client with the given mapping.
					You can add new mappings by editing sql/convert.cc in the MySQL source distribution.
					SET CHARACTER SET sets three session system variables: character_set_client and character_set_results are set to the given character set,
					and character_set_connection to the value of character_set_database.</p>
				<p>The default mapping can be restored by using the value DEFAULT. The default depends on the server configuration.</p>
				<p>ucs2 cannot be used as a client character set, which means that it does not work for SET CHARACTER SET.</p>
			</li>
			<li>
				<p>NAMES {'charset_name' [COLLATE 'collation_name'] | DEFAULT}</p>
				<p>SET NAMES sets the three session system variables character_set_client, character_set_connection, and character_set_results to the given character set.
					Setting character_set_connection to charset_name also sets collation_connection to the default collation for charset_name.
					The optional COLLATE clause may be used to specify a collation explicitly.</p>
				<p>The default mapping can be restored by using a value of DEFAULT. The default depends on the server configuration.</p>
				<p>ucs2 cannot be used as a client character set, which means that it does not work for SET NAMES.</p>
			</li>
		</ul>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSHOW Syntax"></A>SHOW Syntax</H2></P>
		<p>SHOW has many forms that provide information about databases, tables, columns, or status information about the server. This section describes those following:</p>
		
		<pre>SHOW CHARACTER SET [like_or_where]
SHOW COLLATION [like_or_where]
SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]

SHOW CREATE DATABASE db_name
SHOW CREATE EVENT event_name
SHOW CREATE FUNCTION funcname
SHOW CREATE PROCEDURE procname
SHOW CREATE TABLE tbl_name
SHOW CREATE TRIGGER trigger_name
SHOW CREATE VIEW view_name
SHOW DATABASES [like_or_where]
SHOW ENGINE engine_name {STATUS | MUTEX}
SHOW [STORAGE] ENGINES
SHOW ERRORS [LIMIT [offset,] row_count]
SHOW [FULL] EVENTS
SHOW GRANTS FOR user
SHOW INDEX FROM tbl_name [FROM db_name]
SHOW INNODB STATUS
SHOW OPEN TABLES [FROM db_name] [like_or_where]
SHOW PRIVILEGES
SHOW SCHEDULER STATUS
SHOW [GLOBAL | SESSION] STATUS [like_or_where]
SHOW TABLE STATUS [FROM db_name] [like_or_where]
SHOW TABLES [FROM db_name] [like_or_where]
SHOW TRIGGERS [FROM db_name] [like_or_where]
SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]
SHOW WARNINGS [LIMIT [offset,] row_count]

like_or_where:
    LIKE 'pattern'
  | WHERE expr</pre>
  
		<p>If the syntax for a given SHOW statement includes a LIKE 'pattern' part, 'pattern' is a string that can contain the SQL "%" and "_" wildcard characters.
			The pattern is useful for restricting statement output to matching values.</p>
			
		<p>Several SHOW statements also accept a WHERE clause that provides more flexibility in specifying which rows to display.</p>
		
		<p>Many SQL APIs allow you to treat the result returned from a SHOW statement as you would a result set from a SELECT;
			In addition, you can work in SQL with results from queries on tables in the INFORMATION_SCHEMA database, which you cannot easily do with results from SHOW statements.</p>
		
		<b>SHOW CHARACTER SET Syntax</b>
		<pre>SHOW CHARACTER SET
    [LIKE 'pattern' | WHERE expr]</pre>
	
		<p>The SHOW CHARACTER SET statement shows all available character sets.
			The LIKE clause, if present, indicates which character set names to match.
			The WHERE clause can be given to select rows using more general conditions. For example:</p>
			
		<pre>(sql sqlHandle {SHOW CHARACTER SET LIKE 'latin%'}) <b>Returns</b>
+---------+-----------------------------+-------------------+--------+
| Charset | Description                 | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1  | cp1252 West European        | latin1_swedish_ci |      1 |
| latin2  | ISO 8859-2 Central European | latin2_general_ci |      1 |
| latin5  | ISO 8859-9 Turkish          | latin5_turkish_ci |      1 |
| latin7  | ISO 8859-13 Baltic          | latin7_general_ci |      1 |
+---------+-----------------------------+-------------------+--------+</pre>

		<p>The Maxlen column shows the maximum number of bytes required to store one character.</p>
		
		<b>SHOW COLLATION Syntax</b>
		<pre>SHOW COLLATION
    [LIKE 'pattern' | WHERE expr]</pre>
	
		<p>The output from SHOW COLLATION includes all available character sets.
			The LIKE clause, if present, indicates which collation names to match.
			The WHERE clause can be given to select rows using more general conditions. For example:</p>
			
		<pre>(sql sqlHandle {SHOW COLLATION LIKE 'latin1%'}) <b>Returns</b>
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         |          |       0 |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      |       0 |
| latin1_danish_ci  | latin1  | 15 |         |          |       0 |
| latin1_german2_ci | latin1  | 31 |         | Yes      |       2 |
| latin1_bin        | latin1  | 47 |         | Yes      |       0 |
| latin1_general_ci | latin1  | 48 |         |          |       0 |
| latin1_general_cs | latin1  | 49 |         |          |       0 |
| latin1_spanish_ci | latin1  | 94 |         |          |       0 |
+-------------------+---------+----+---------+----------+---------+</pre>

		<p>The Default column indicates whether a collation is the default for its character set.
			Compiled indicates whether the character set is compiled into the server.
			Sortlen is related to the amount of memory required to sort strings expressed in the character set.</p>
		
		<b>SHOW COLUMNS Syntax</b>
		<pre>SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name]
    [LIKE 'pattern' | WHERE expr]</pre>
	
		<p>SHOW COLUMNS displays information about the columns in a given table. It also works for views.
			The LIKE clause, if present, indicates which column names to match.
			The WHERE clause can be given to select rows using more general conditions.</p>
			
		<pre>(sql sqlHandle {SHOW COLUMNS FROM City}) <b>Returns</b>
+------------+----------+------+-----+---------+----------------+
| Field      | Type     | Null | Key | Default | Extra          |
+------------+----------+------+-----+---------+----------------+
| Id         | int(11)  | NO   | PRI | NULL    | auto_increment |
| Name       | char(35) | NO   |     |         |                |
| Country    | char(3)  | NO   | UNI |         |                |
| District   | char(20) | YES  | MUL |         |                |
| Population | int(11)  | NO   |     | 0       |                |
+------------+----------+------+-----+---------+----------------+</pre>

		<p>If the data types differ from what you expect them to be based on a CREATE TABLE statement,
			note that SQL sometimes changes data types when you create or alter a table.</p>
			
		<p>The FULL keyword causes the output to include the column collation and comments, as well as the privileges you have for each column.</p>
		
		<p>You can use db_name.tbl_name as an alternative to the tbl_name FROM db_name syntax. In other words, these two statements are equivalent:</p>
		
		<pre>(sql sqlHandle {SHOW COLUMNS FROM mytable FROM mydb})</pre>
		<pre>(sql sqlHandle {SHOW COLUMNS FROM mydb.mytable})</pre>
		
		<p>SHOW COLUMNS displays the following values for each table column:</p>
		<p>Field indicates the column name.</p>
		<p>Type indicates the column data type.</p>
		<p>Collation indicates the collation for non-binary string columns, or NULL for other columns. This value is displayed only if you use the FULL keyword.</p>
		<p>The Null field contains YES if NULL values can be stored in the column, NO if not.</p>
		<p>The Key field indicates whether the column is indexed:</p>
		<ul>
			<li>
				<p>If Key is empty, the column either is not indexed or is indexed only as a secondary column in a multiple-column, non-unique index.</p>
			</li>
			<li>
				<p>If Key is PRI, the column is a PRIMARY KEY or is one of the columns in a multiple-column PRIMARY KEY.</p>
			</li>
			<li>
				<p>If Key is UNI, the column is the first column of a unique-valued index that cannot contain NULL values.</p>
			</li>
			<li>
				<p>If Key is MUL, multiple occurrences of a given value are allowed within the column. The column is the first column of a non-unique index or a unique-valued index that can contain NULL values.</p>
			</li>
		</ul>
		
		<p>If more than one of the Key values applies to a given column of a table, Key displays the one with the highest priority, in the order PRI, UNI, MUL.</p>
		
		<p>A UNIQUE index may be displayed as PRI if it cannot contain NULL values and there is no PRIMARY KEY in the table.
			A UNIQUE index may display as MUL if several columns form a composite UNIQUE index; although the combination of the columns is unique, each column can still hold multiple occurrences of a given value.</p>
		
		<p>The Default field indicates the default value that is assigned to the column.</p>
		
		<p>The Extra field contains any additional information that is available about a given column.
			In the example shown, the Extra field indicates that the Id column was created with the AUTO_INCREMENT keyword.</p>
			
		<p>Privileges indicates the privileges you have for the column. This value is displayed only if you use the FULL keyword.</p>
		
		<p>Comment indicates any comment the column has. This value is displayed only if you use the FULL keyword.</p>
		
		<p>SHOW FIELDS is a synonym for SHOW COLUMNS. You can also list a table's columns with the mysqlshow db_name tbl_name command.</p>
		
		<p>The DESCRIBE statement provides information similar to SHOW COLUMNS.</p>

		<p>The SHOW CREATE TABLE, SHOW TABLE STATUS, and SHOW INDEX statements also provide information about tables.</p>
		
		<b>SHOW CREATE DATABASE Syntax</b>
		
		<pre>SHOW CREATE {DATABASE | SCHEMA} db_name</pre>
		
		<p>Shows the CREATE DATABASE statement that creates the given database. SHOW CREATE SCHEMA is a synonym for SHOW CREATE DATABASE.</p>
		
		<pre>(sql sqlHandle {SHOW CREATE DATABASE test}) <b>Returns</b>
#(rec(Database:Character:64 |Create Database|:Object:1)| Database:"ais" |Create Database|:"CREATE DATABASE `ais` /*!40100 DEFAULT CHARACTER SET latin1 */")</pre>

		<pre>(sql sqlHandle {SHOW CREATE SCHEMA test}) <b>Returns</b>
#(rec(Database:Character:64 |Create Database|:Object:1)| Database:"ais" |Create Database|:"CREATE DATABASE `ais` /*!40100 DEFAULT CHARACTER SET latin1 */")</pre>

		<p>SHOW CREATE DATABASE quotes table and column names according to the value of the SQL_QUOTE_SHOW_CREATE option.</p>
		
		<b>SHOW CREATE EVENT</b>
		<pre>SHOW CREATE EVENT event_name</pre>
		<p>This statement displays the CREATE EVENT statement needed to re-create a given event.</p>
		
		<b>SHOW CREATE PROCEDURE and SHOW CREATE FUNCTION Syntax</b>
		<pre>SHOW CREATE {PROCEDURE | FUNCTION} sp_name</pre>
		<p>These statements are SQL extensions. Similar to SHOW CREATE TABLE, they return the exact string that can be used to re-create the named routine.
			The statements require that you be the owner of the routine or have SELECT access to the mysql.proc table.
			If you do not have privileges for the routine itself, the value displayed for the Create Procedure or Create Function field will be NULL.</p>

		<b>SHOW CREATE TABLE Syntax</b>
		<pre>SHOW CREATE TABLE tbl_name</pre>
		<p>Shows the CREATE TABLE statement that creates the given table. This statement also works with views.</p>
		<pre>(sql sqlHandle {SHOW CREATE TABLE t}) <b>Returns</b>
#(rec(Table:Character:64 |Create Table|:Object:1)| Table:"t" |Create Table|:"CREATE TABLE `t` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `s` char(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1")</pre>

		<p>SHOW CREATE TABLE quotes table and column names according to the value of the SQL_QUOTE_SHOW_CREATE option.</p>

		<b>SHOW CREATE TRIGGER Syntax</b>
		<pre>SHOW CREATE TRIGGER trigger_name</pre>
		<p>This statement shows a CREATE TRIGGER statement that creates the given trigger.</p>
		<p>You can also obtain information about trigger objects from INFORMATION_SCHEMA, which contains a TRIGGERS table.</p>
		
		<b>SHOW CREATE VIEW Syntax</b>
		<pre>SHOW CREATE VIEW view_name</pre>
		<p>This statement shows a CREATE VIEW statement that creates the given view.</p>
		<p>Use of SHOW CREATE VIEW requires the SHOW VIEW privilege and the SELECT privilege for the view in question.</p>
		<p>You can also obtain information about view objects from INFORMATION_SCHEMA, which contains a VIEWS table.</p>
		
		<b>SHOW DATABASES Syntax</b>
		<pre>SHOW {DATABASES | SCHEMAS}
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW DATABASES lists the databases on the MySQL server host. SHOW SCHEMAS is a synonym for SHOW DATABASES.
			The LIKE clause, if present, indicates which database names to match.
			The WHERE clause can be given to select rows using more general conditions.</p>
		<p>You see only those databases for which you have some kind of privilege, unless you have the global SHOW DATABASES privilege.
			You can also get this list using the mysqlshow command.</p>
		<p>If the server was started with the --skip-show-database option, you cannot use this statement at all unless you have the SHOW DATABASES privilege.</p>
		<p>SHOW SCHEMAS can also be used.</p>
		
		<b>SHOW ENGINE Syntax</b>
		<pre>SHOW ENGINE engine_name {STATUS | MUTEX}</pre>
		<p>SHOW ENGINE displays operational information about a storage engine. The following statements currently are supported:</p>
		<pre>SHOW ENGINE INNODB STATUS
SHOW ENGINE INNODB MUTEX
SHOW ENGINE {NDB | NDBCLUSTER} STATUS</pre>

		<b>SHOW ERRORS Syntax</b>
		<pre>SHOW ERRORS [LIMIT [offset,] row_count]
SHOW COUNT(*) ERRORS</pre>
		<p>This statement is similar to SHOW WARNINGS, except that instead of displaying errors, warnings, and notes, it displays only errors.</p>
		<p>The LIMIT clause has the same syntax as for the SELECT statement.</p>
		<p>The SHOW COUNT(*) ERRORS statement displays the number of errors. You can also retrieve this number from the error_count variable:</p>
		<pre>SHOW COUNT(*) ERRORS;
SELECT @@error_count;</pre>

		<b>SHOW EVENTS</b>
		<pre>SHOW EVENTS [FROM schema_name]
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>In its simplest form, SHOW EVENTS lists all of the events in the current schema:</p>
		<pre>(sql sqlHandle {SELECT CURRENT_USER(), SCHEMA()}) <b>Returns</b>
#(rec(|CURRENT_USER()|:Object:1 |SCHEMA()|:Character:34)| |CURRENT_USER()|:"jon@ghidora" |SCHEMA()|:"myschema")</pre>
		<p>The LIKE clause, if present, indicates which event names to match. The WHERE clause can be given to select rows using more general conditions.</p>
		<p>The columns in the output of SHOW EVENTS  which are similar to, but not identical to the columns in the INFORMATION_SCHEMA.EVENTS table  are shown here:</p>
		<ul>
			<li>
				<p>Db: The schema (database) on which the event is defined.</p>
			</li>
			<li>
				<p>Name: The name of the event.</p>
			</li>
			<li>
				<p>Time zone: The time zone in effect when schedule for the event was last modified.
					If the event's schedule has not been modified since the event was created, then this is the time zone that was in effect at the event's creation. The default value is SYSTEM.</p>
			</li>
			<li>
				<p>Definer: The user account (username@hostname) which created the event.</p>
			</li>
			<li>
				<p>Type: One of the two values ONE TIME (transient) or RECURRING.</p>
			</li>
			<li>
				<p>Execute At: The date and time when a transient event is set to execute. Shown as a DATETIME value.</p>
				<p>For a recurring event, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>Interval Value: For a recurring event, the number of intervals to wait between event executions.</p>
				<p>For a transient event, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>Interval Field: The time units used for the interval which a recurring event waits before repeating.</p>
				<p>For a transient event, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>Starts: The start date and time for a recurring event. This is displayed as a DATETIME value, and is empty if no start date and time are defined for the event.</p>
				<p>For a transient event, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>Ends: The end date and time for a recurring event. This is displayed as a DATETIME value, and defaults to '0000-00-00 00:00:00' if no end date and time is defined for the event.</p>
				<p>For a transient event, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>Status: The event status. One of ENABLED, DISABLED, or SLAVESIDE_DISABLED.</p>
				The SLAVESIDE_DISABLED value indicates that the creation of the event occurred on another MySQL server acting as a replication master and
				replicated to the current MySQL server which is acting as a slave, but the event is not presently being executed on the slave.</p>
			</li>
			<li>
				<p>Originator: The server ID of the MySQL server on which the event was created. Defaults to 0.</p>
			</li>
			<li>
				<p>character_set_client is the session value of the character_set_client system variable when the routine was created.
					collation_connection is the session value of the collation_connection system variable when the routine was created.
					Database Collation is the collation of the database with which the routine is associated.</p>
			</li>
		</ul>
		<p>To see events for a different schema, you can use the FROM clause.
			For example, if the test schema had been selected in the preceding example, you could view events defined on myschema using the following statement:</p>
		<pre>(sql sqlHandle {SHOW EVENTS FROM myschema})</pre>
		<p>You can filter the list returned by this statement on the event name using LIKE plus a pattern.</pre>
		
		<b>SHOW GRANTS Syntax</b>
		<pre>SHOW GRANTS [FOR user]</pre>
		<p>This statement lists the GRANT statement or statements that must be issued to duplicate the privileges that are granted to a SQL user account.
			The account is named using the same format as for the GRANT statement; for example, 'jeffrey'@'localhost'.
			If you specify only the username part of the account name, a hostname part of '%' is used.</p>
		<pre>(sql sqlHandle {SHOW GRANTS FOR 'root'@'localhost'}) <b>Returns</b>
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+</pre>
		<p>To list the privileges granted to the account that you are using to connect to the server, you can use any of the following statements:</p>
		<pre>SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER;
SHOW GRANTS FOR CURRENT_USER();</pre>
		<p>If SHOW GRANTS FOR CURRENT_USER (or any of the equivalent syntaxes) is used in DEFINER context,
			such as within a stored procedure that is defined with SQL SECURITY DEFINER), the grants displayed are those of the definer and not the invoker.</p>
		<p>SHOW GRANTS displays only the privileges granted explicitly to the named account. Other privileges might be available to the account, but they are not displayed.
			For example, if an anonymous account exists, the named account might be able to use its privileges, but SHOW GRANTS will not display them.</p>
			
		<b>SHOW INDEX Syntax</b>
		<pre>SHOW INDEX FROM tbl_name [FROM db_name]</pre>
		<p>SHOW INDEX returns table index information. The format resembles that of the SQLStatistics call in ODBC.</p>
		<p>SHOW INDEX returns the following fields:</p>
		<ul>
			<li>
				<p>Table</p>
				<p>The name of the table.</p>
			</li>
			<li>
				<p>Non_unique</p>
				<p>0 if the index cannot contain duplicates, 1 if it can.</p>
			</li>
			<li>
				<p>Key_name</p>
				<p>The name of the index.</p>
			</li>
			<li>
				<p>Seq_in_index</p>
				<p>The column sequence number in the index, starting with 1.</p>
			</li>
			<li>
				<p>Column_name</p>
				<p>The column name.</p>
			</li>
			<li>
				<p>Collation</p>
				<p>How the column is sorted in the index. In SQL, this can have values "A" (Ascending) or NULL (Not sorted).</p>
			</li>
			<li>
				<p>Cardinality</p>
				<p>An estimate of the number of unique values in the index. This is updated by running ANALYZE TABLE or myisamchk -a.
					Cardinality is counted based on statistics stored as integers, so the value is not necessarily exact even for small tables.
					The higher the cardinality, the greater the chance that MySQL uses the index when doing joins.</p>
			</li>
			<li>
				<p>Sub_part</p>
				<p>The number of indexed characters if the column is only partly indexed, NULL if the entire column is indexed.</p>
			</li>
			<li>
				<p>Packed</p>
				<p>Indicates how the key is packed. NULL if it is not.</p>
			</li>
			<li>
				<p>Null</p>
				<p>Contains YES if the column may contain NULL. If not, the column contains NO.</p>
				<p>Contains YES if the column may contain NULL values and '' if not.</p>
			</li>
			<li>
				<p>Index_type</p>
				<p>The index method used (BTREE, FULLTEXT, HASH, RTREE).</p>
			</li>
			<li>
				<p>Comment</p>
				<p>Various remarks.</p>
			</li>
		</ul>
		<p>You can use db_name.tbl_name as an alternative to the tbl_name FROM db_name syntax. These two statements are equivalent:</p>
		<pre>SHOW INDEX FROM mytable FROM mydb;
SHOW INDEX FROM mydb.mytable;</pre>
		<p>SHOW KEYS is a synonym for SHOW INDEX. You can also list a table's indexes with the mysqlshow -k db_name tbl_name command.</p>
		
		<b>SHOW OPEN TABLES Syntax</b>
		<pre>SHOW OPEN TABLES [FROM db_name]
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW OPEN TABLES lists the non-TEMPORARY tables that are currently open in the table cache.
			The WHERE clause can be given to select rows using more general conditions.</p>
		<p>The LIKE clause, if present, indicates which table names to match.
			The FROM clause, if present, restricts the tables shown to those present in the db_name database.</p>
		<p>SHOW OPEN TABLES returns the following columns:</p>
		<ul>
			<li>
				<p>Database</p>
				<p>The database containing the table.</p>
			</li>
			<li>
				<p>Table</p>
				<p>The table name.</p>
			</li>
			<li>
				<p>In_use</p>
				<p>The number of table locks or lock requests there are for the table.
					For example, if one client acquires a lock for a table using LOCK TABLE t1 WRITE, In_use will be 1.
					If another client issues LOCK TABLE t1 WRITE while the table remains locked, the client will block waiting for the lock, but the lock request causes In_use to be 2.
					If the count is zero, the table is open but not currently being used.</p>
			</li>
			<li>
				<p>Name_locked</p>
				<p>Whether the table name is locked. Name locking is used for operations such as dropping or renaming tables.</p>
			</li>
		</ul>
		
		<b>SHOW PRIVILEGES Syntax</b>
		<pre>SHOW PRIVILEGES</pre>
		<p>SHOW PRIVILEGES shows the list of system privileges that the SQL server supports. The exact list of privileges depends on the version of your server.</p>
		<p>Privileges belonging to a specific user are displayed by the SHOW GRANTS statement.</p>

		<b>SHOW TABLE STATUS Syntax</b>
		<pre>SHOW TABLE STATUS [FROM db_name]
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW TABLE STATUS works likes SHOW TABLES, but provides a lot of information about each non-TEMPORARY table.
			You can also get this list using the mysqlshow --status db_name command.
			The LIKE clause, if present, indicates which table names to match.
			The WHERE clause can be given to select rows using more general conditions.</p>
		<p>This statement also displays information about views.</p>
		<p>SHOW TABLE STATUS returns the following fields:</p>
		<ul>
			<li>
				<p>Name</p>
				<p>The name of the table.</p>
			</li>
			<li>
				<p>Engine</p>
				<p>The storage engine for the table. See Chapter 13, Storage Engines.</p>
			</li>
			<li>
				<p>Version</p>
				<p>The version number of the table's .frm file.</p>
			</li>
			<li>
				<p>Row_format</p>
				<p>The row storage format (Fixed, Dynamic, Compressed, Redundant, Compact). The format of InnoDB tables is reported as Redundant or Compact.</p>
			</li>
			<li>
				<p>Rows</p>
				<p>The number of rows. Some storage engines, such as MyISAM, store the exact count.
					For other storage engines, such as InnoDB, this value is an approximation, and may vary from the actual value by as much as 40 to 50%.
					In such cases, use SELECT COUNT(*) to obtain an accurate count.</p>
				<p>The Rows value is NULL for tables in the INFORMATION_SCHEMA database.</p>
			</li>
			<li>
				<p>Avg_row_length</p>
				<p>The average row length.</p>
			</li>
			<li>
				<p>Data_length</p>
				<p>The length of the data file.</p>
			</li>
			<li>
				<p>Max_data_length</p>
				<p>The maximum length of the data file.
					This is the total number of bytes of data that can be stored in the table, given the data pointer size used.</p>
			</li>
			<li>
				<p>Index_length</p>
				<p>The length of the index file.</p>
			</li>
			<li>
				<p>Data_free</p>
				<p>The number of allocated but unused bytes. This information is also shown for InnoDB tables.</p>
			</li>
			<li>
				<p>Auto_increment</p>
				<p>The next AUTO_INCREMENT value.</p>
			</li>
			<li>
				<p>Create_time</p>
				<p>When the table was created.</p>
			</li>
			<li>
				<p>Update_time</p>
				<p>When the data file was last updated. For some storage engines, this value is NULL.
					For example, InnoDB stores multiple tables in its tablespace and the data file timestamp does not apply.</p>
			</li>
			<li>
				<p>Check_time</p>
				<p>When the table was last checked. Not all storage engines update this time, in which case the value is always NULL.</p>
			</li>
			<li>
				<p>Collation</p>
				<p>The table's character set and collation.</p>
			</li>
			<li>
				<p>Checksum</p>
				<p>The live checksum value (if any).</p>
			</li>
			<li>
				<p>Create_options</p>
				<p>Extra options used with CREATE TABLE.
					The original options supplied when CREATE TABLE is called are retained and the options reported here may differ from the active table settings and options.</p>
			</li>
			<li>
				<p>Comment</p>
				<p>The comment used when creating the table (or information as to why SQL could not access the table information).</p>
			</li>
		</ul>
		
		<p>In the table comment, InnoDB tables report the free space of the tablespace to which the table belongs.
			For a table located in the shared tablespace, this is the free space of the shared tablespace.
			If you are using multiple tablespaces and the table has its own tablespace, the free space is for only that table.
			Free space means the number of completely free 1MB extents minus a safety margin.
			Even if free space displays as 0, it may be possible to insert rows as long as new extents need not be allocated.</p>
		<p>For MEMORY tables, the Data_length, Max_data_length, and Index_length values approximate the actual amount of allocated memory.
			The allocation algorithm reserves memory in large amounts to reduce the number of allocation operations.</p>
		<p>For NDBCLUSTER tables, the output of this statement shows appropriate values for the Avg_row_length and Data_length columns,
			with the exception that BLOB columns are not taken into account. In addition, the number of replicas is shown in the Comment column (as number_of_replicas).</p>
		<p>For views, all the fields displayed by SHOW TABLE STATUS are NULL except that Name indicates the view name and Comment says view.</p>
		
		<b>SHOW TABLES Syntax</b>
		<pre>SHOW [FULL] TABLES [FROM db_name]
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW TABLES lists the non-TEMPORARY tables in a given database. You can also get this list using the mysqlshow db_name command.
			The LIKE clause, if present, indicates which table names to match.
				The WHERE clause can be given to select rows using more general conditions.</p>
		<p>This statement also lists any views in the database. The FULL modifier is supported such that SHOW FULL TABLES displays a second output column.
			Values for the second column are BASE TABLE for a table and VIEW for a view.</p>
		<p>If you have no privileges for a base table or view, it does not show up in the output from SHOW TABLES or mysqlshow db_name.</p>
		
		<b>SHOW TRIGGERS Syntax</b>
		<pre>SHOW TRIGGERS [FROM db_name]
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW TRIGGERS lists the triggers currently defined for tables in a database (the default database unless a FROM clause is given).
			This statement requires the TRIGGER privilege (prior to MySQL 5.1.22, it requires the SUPER privilege).
			The LIKE clause, if present, indicates which table names to match and causes the statement to display triggers for those tables.
			The WHERE clause can be given to select rows using more general conditions.</p>
		<p>Note: When using a LIKE clause with SHOW TRIGGERS, the expression to be matched (expr) is compared with the name of the table on which the trigger is declared, and not with the name of the trigger:</p>
		<pre>SHOW TRIGGERS LIKE 'ins%';</pre>
		<p>A brief explanation of the columns in the output of this statement is shown here:</p>
		<ul>
			<li>
				<p>Trigger</p>
				<p>The name of the trigger.</p>
			</li>
			<li>
				<p>Event</p>
				<p>The event that causes trigger activation: one of 'INSERT', 'UPDATE', or 'DELETE'.</p>
			</li>
			<li>
				<p>Table</p>
				<p>The table for which the trigger is defined.</p>
			</li>
			<li>
				<p>Statement</p>
				<p>The statement to be executed when the trigger is activated. This is the same as the text shown in the ACTION_STATEMENT column of INFORMATION_SCHEMA.TRIGGERS.</p>
			</li>
			<li>
				<p>Timing</p>
				<p>One of the two values 'BEFORE' or 'AFTER'.</p>
			</li>
			<li>
				<p>Created</p>
				<p>Currently, the value of this column is always NULL.</p>
			</li>
			<li>
				<p>sql_mode</p>
				<p>The SQL mode in effect when the trigger executes.</p>
			</li>
			<li>
				<p>Definer</p>
				<p>The account that created the trigger.</p>
			</li>
		</ul>
		
		<b>SHOW VARIABLES Syntax</b>
		<pre>SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE 'pattern' | WHERE expr]</pre>
		<p>SHOW VARIABLES shows the values of SQL system variables.
			This information also can be obtained using the mysqladmin variables command.
			The LIKE clause, if present, indicates which variable names to match. The WHERE clause can be given to select rows using more general conditions.</p>
		<p>With the GLOBAL modifier, SHOW VARIABLES displays the values that are used for new connections to SQL.
			With SESSION, it displays the values that are in effect for the current connection.
			If no modifier is present, the default is SESSION. LOCAL is a synonym for SESSION.</p>
		<p>If the default system variable values are unsuitable, you can set them using command options when mysqld starts, and most can be changed at runtime with the SET statement.</p>
		<p>With a LIKE clause, the statement displays only rows for those variables with names that match the pattern. To obtain the row for a specific variable, use a LIKE clause as shown:</p>
		<pre>SHOW VARIABLES LIKE 'max_join_size';
SHOW SESSION VARIABLES LIKE 'max_join_size';</pre>
		<p>To get a list of variables whose name match a pattern, use the "%" wildcard character in a LIKE clause:</p>
		<pre>SHOW VARIABLES LIKE '%size%';
SHOW GLOBAL VARIABLES LIKE '%size%';</pre>
		<p>Wildcard characters can be used in any position within the pattern to be matched.
			Strictly speaking, because "_" is a wildcard that matches any single character, you should escape it as "\_" to match it literally. In practice, this is rarely necessary.</p>
			
		<b>SHOW WARNINGS Syntax</b>
		<pre>SHOW WARNINGS [LIMIT [offset,] row_count]
SHOW COUNT(*) WARNINGS</pre>
		<p>SHOW WARNINGS shows the error, warning, and note messages that resulted from the last statement that generated messages.
			It shows nothing if the last statement used a table and generated no messages.
			(That is, a statement that uses a table but generates no messages clears the message list.)
			Statements that do not use tables and do not generate messages have no effect on the message list.</p>
		<p>A related statement, SHOW ERRORS, shows only the errors.</p>
		<p>The SHOW COUNT(*) WARNINGS statement displays the total number of errors, warnings, and notes. You can also retrieve this number from the warning_count variable:</p>
		<pre>SHOW COUNT(*) WARNINGS;
SELECT @@warning_count;</pre>
		<p>The value of warning_count might be greater than the number of messages displayed by SHOW WARNINGS if the max_error_count system variable is set so low that not all messages are stored.
			An example shown later in this section demonstrates how this can happen.</p>
		<p>The LIMIT clause has the same syntax as for the SELECT statement.</p>
		<p>The SQL server sends back the total number of errors, warnings, and notes resulting from the last statement.</p>
		<p>Warnings are generated for statements such as LOAD DATA INFILE and DML statements such as INSERT, UPDATE, CREATE TABLE, and ALTER TABLE.</p>
		<p>The maximum number of error, warning, and note messages to store is controlled by the max_error_count system variable.
			By default, its value is 64. To change the number of messages you want stored, change the value of max_error_count.
			In the following example, the ALTER TABLE statement produces three warning messages, but only one is stored because max_error_count has been set to 1:</p>
		<pre>SHOW VARIABLES LIKE 'max_error_count'; <b>Returns</b>
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_error_count | 64    |
+-----------------+-------+</pre>

		<pre>SET max_error_count=1;</pre>
		<pre>ALTER TABLE t1 MODIFY b CHAR;</pre>
		<pre>SELECT @@warning_count; <b>Returns</b>
+-----------------+
| @@warning_count |
+-----------------+
|               3 |
+-----------------+</pre>

		<pre>SHOW WARNINGS; <b>Returns</b>
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1263 | Data truncated for column 'b' at row 1 |
+---------+------+----------------------------------------+</pre>

		<p>To disable warnings, set max_error_count to 0. In this case, warning_count still indicates how many warnings have occurred, but none of the messages are stored.</p>
		<p>You can set the SQL_NOTES session variable to 0 to cause Note-level warnings not to be recorded.</p>
		<P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P>

 

</BODY>
</HTML>