/**********************************************************************************
    Copyright (C) 2008 Investment Science Corp.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

***********************************************************************************/
/*	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
aisdev/aforms/aeditpage.cpp
														  Editor Tab
AEditorTab provides a tab container for multiple edit subpages. Each subpage contains an AEditor widget.
AEditorTab implements the functions that are required for a SessionForm Page.  Actions created in SessionForm generate an
activated signal when menu or toolbar item is selected.  The signal is caught by ASessionForm which generates a call to the
relevant method for the current page.  The current page, in turn, calls the relevant method for the current TextEdit subpage.

CHANGE HISTORY
Version	Date		Who		Change
4.0003	 7/12/2008	rca  	[CR-125] Removed compile on/off actions.
3.2008	 4/08/2008	fchua	Updated addPage to use ATextEdit parameters.
3.2008	 4/08/2008	fchua	Added setParameters function.
3.2006	 3/10/2008	fchua	Modified onShowAgents. Used new dialog implementation.
3.2006	 3/10/2008	fchua	Removed find and replace functions. Added getTextEdit.
1.0120	12/19/2006	tlw		returnOutput. Add ipData and iDataSize arguments.
1.0116	11/29/2006	tlw		returnOutput. Use fullNodeName in iClientData to find current page.
1.0116	11/28/2006	tlw		onClose. Call onCurrentTabChanged in case no signal is generated by Qt.
1.0115	11/19/2006	tlw		returnOutput, geOpenNode. Don't replace CRs. It takes too long for large files.
1.0113	11/9/2006	tlw		onCursorStackChanged.  Add slot to save changes to stack enables and restore when switching tabs.
1.0107	9/21/2006	tlw		Add move method to catch calls from onPrev and onNext for cursor stack.
1.0106	9/14/2006	tlw		returnOutput. Redirect error msgs to console. Added stale message flags.
1.0105	9/13/2006	tlw		Change name in cTabList if saving node with different name. Set new page type.
1.0070	10/14/2005	tlw		Convert editor tab to Qt4 format
												--------------- ---------------
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

//	------------------------------------------------------ IMPORTS ------------------------------------------------------------
#include <QtCore/QFileInfo>
#include <QtGui/QAction>
#include <QtGui/QContextMenuEvent>
#include <QtGui/QFileDialog>
#include <QtGui/QMenu>
#include <QtGui/QMessageBox>
#include "appclient.h"
#include "atextedit.h"
#include "aeditortab.h"
#include "asessionform.h"
#include "aoperationsdialog.h"

class APage;

//	------------------------------------------------------ METHODS -------------------------------------------------------------
/*!
\brief AEditorTab - constructor instantiates a tabbed widget whose pages are text-edit pages.
 
\par Args:
\param ipAppClient -> Application client that forwards commands to the AIS server
\param ipParentForm -> Parent form that created this instance of a cabinet page
\param ipParent -> Parent widget that created this instance of a cabinet page
\param ipFormName -> Name assigned to this instance of the cabinet page
\return void
 */
AEditorTab::AEditorTab(AAppClient* ipAppClient, ASessionForm* ipParentForm,
					   QWidget* ipParent, const char* ipFormName):
	QTabWidget(ipParent), cpAppClient(ipAppClient), cpFcnListDialog(NULL),
	cpParentForm(ipParentForm), cSaveAsAgentDialog(ipAppClient, this, "SaveAsAgentDialog")
{
	setObjectName(QString(ipFormName));
	cpCurPage = NULL;
	cStaleAlert = cStaleMsg = false;
	cTask = ceNoTask;
	cTaskIx = -1;
	connect(this, SIGNAL(currentChanged(int)), this, SLOT(onCurrentTabChanged(int)));

	// Menus. Initialize menus and toolbar
	createActions();
	createMenus();
}

/*	---------------------------------------------------------------------------------------------------------------------------
addpage - Add new text edit page with tab at top
Args:
	irFileSpec	FilePath/FileName
Returns:
	aNew		true iff new page created
Notes:
 1.	Set the name of this new page to the entire file spec to avoid name collisions.
 2.	If an empty new page is currently open, close it.
 3.	If one new page is opened, a second new page cannot be opened until the first one is renamed.
	------------------------------------------------------------------------------------------------------------------------ */
bool AEditorTab::addPage(QString& irFileSpec, AEditPage::APageType iPageType)
{
	// Existing. Switch pages if this file is already open.
	AEditPage* apExisting = NULL;
	if (irFileSpec.isEmpty()) irFileSpec = "Untitled";
	if (cTabList.contains(irFileSpec))
	{	apExisting = cTabList.value(irFileSpec);
		if (cpCurPage != apExisting)
		{	cpCurPage = apExisting;
			setCurrentWidget(cpCurPage);
			if (cpParentForm != NULL)
				cpParentForm->cursorStackChanged(cpCurPage->mForward, cpCurPage->mPrevious);
		}
	}
	else
	{	// Untitled. If an empty new page exists, close it.
		if (cTabList.contains("Untitled"))
		{	AEditPage* apUntitled = cTabList.value("Untitled");
			if (apUntitled->editTextLength() <= 1)
			{	cTabList.remove("Untitled");
				removeTab(indexOf(apUntitled));
				apUntitled->deleteLater();
			}
		}
		// New. Add a new tab
		QString aTabLabel(QFileInfo(irFileSpec).fileName());		// fileName is FileSpec w/ path stripped off
		QString aExtentName = cpAppClient->getCurrentExtentName();
		// Language. EditRead will overwrite this setting based upon the extension of the file name.
		ALanguageType aLanguage = (iPageType == AEditPage::meAgent) ? eLisp : eText;
		cpCurPage = new AEditPage(this, iPageType, aExtentName, irFileSpec, aLanguage);
		
		AParameters *apEditParams = cpParentForm->getEditorParameters();
		if (apEditParams != NULL)
		{
			cpCurPage->editSetParameter("Font", QVariant(apEditParams->mFont));
			cpCurPage->editSetParameter("FontSize", QVariant((int)apEditParams->mFontSize));
			cpCurPage->editSetParameter("TabWidth", QVariant((int)apEditParams->mTabWidth));
			cpCurPage->editSetParameter("LineNumbers", QVariant(apEditParams->mLineNumbers));
			cpCurPage->editSetParameter("ShowWhiteSpace", QVariant(apEditParams->mShowWhiteSpace));
			cpCurPage->editSetParameter("WordWrap", QVariant(apEditParams->mWrap));
			cpCurPage->editSetParameter("MaxRowLgth", QVariant((int)apEditParams->mMaxRowWidth));
			cpCurPage->editSetParameter("MaxUndoDepth", QVariant((int)apEditParams->mMaxUndoDepth));
		}

		addTab(cpCurPage, aTabLabel + ' ');
		setCurrentWidget(cpCurPage);
		cpCurPage->setFocus();
		cTabList[irFileSpec] = cpCurPage;
		if (cpParentForm != NULL)
			cpParentForm->cursorStackChanged(cpCurPage->mForward, cpCurPage->mPrevious);

		// Connections. Connect up TextEdit signals
		connect(cpCurPage, SIGNAL(cursorPositionChanged(long, long)), this, SLOT(onCursorPositionChanged(long, long)));
		connect(cpCurPage, SIGNAL(cursorStackChanged(bool, bool)), this, SLOT(onCursorStackChanged(bool, bool)));
		connect(cpCurPage, SIGNAL(statusAlert(const QString&)), this, SLOT(onStatusAlert(const QString&)));
		connect(cpCurPage, SIGNAL(textModified(bool)), this, SLOT(onTextModified(bool)));
	}
	return (apExisting == NULL);
}

void AEditorTab::compile(AEditPage* ipPage)
{
	QString apCmdOff;
	QString aAisOut("");

	apCmdOff = "_ais\177eval\177exp\177(debug compileoff:)";
    cpAppClient->submit(this, apCmdOff, aAisOut, 0, NULL/*Data*/, 0/*DataSize*/);

	if (ipPage == NULL || ipPage->pageType() != AEditPage::meAgent)
		onStatusAlert("Compile: Not a Lambda");
	else
	{	QStringList aAgentInfo;
		aAgentInfo += ipPage->extentName();
		aAgentInfo += ipPage->objectName();
		setEnabled(false);
		cpAppClient->compileLambda(this, aAgentInfo);
	}
}

void AEditorTab::compileDebug(AEditPage* ipPage)
{
	QString apCmdOn;
	QString apCmdOff;
	QString aAisOut("");
	apCmdOn = "_ais\177eval\177exp\177(debug compileon:)";
	apCmdOff = "_ais\177eval\177exp\177(debug compileoff:)";

    cpAppClient->submit(this, apCmdOn, aAisOut, 0, NULL/*Data*/, 0/*DataSize*/);

	if (ipPage == NULL || ipPage->pageType() != AEditPage::meAgent)
		onStatusAlert("Compile: Not a Lambda");
	else
	{	QStringList aAgentInfo;
		aAgentInfo += ipPage->extentName();
		aAgentInfo += ipPage->objectName();
		setEnabled(false);
		cpAppClient->compileLambda(this, aAgentInfo);
	}

    cpAppClient->submit(this, apCmdOff, aAisOut, 0, NULL/*Data*/, 0/*DataSize*/);
}

/*!
\brief connectionClosed - Inherited from the AReturnRcvr abstract base class.

\param iConnectId  - The ID of the connection that was closed.
\return false
*/
bool AEditorTab::connectionClosed(long iConnectId)
{
    Q_UNUSED(iConnectId);

	return false;
}

void AEditorTab::contextMenuEvent(QContextMenuEvent* ipContextEvent)
{
	if (ipContextEvent != NULL && cpEditorContextMenu != NULL)
		cpEditorContextMenu->exec(ipContextEvent->globalPos());
}

/*!
\brief copy - Copy the currently selected text to the clipboard

\return void
\par Notes:
-# Inherited from the APage base class.
*/
void AEditorTab::copy()
{
	if (cpCurPage != NULL)
		cpCurPage->editCopy();
	else
		onStatusAlert("Copy: No page is currently selected");
}

void AEditorTab::createActions()
{
	cpCloseAct = new QAction(QIcon(":/images/fileclose.png"), tr("Close"), this);
	cpCloseAct->setShortcut(tr("Alt+C"));
	cpCloseAct->setToolTip("Close Document");
	cpCloseAct->setStatusTip("Close this document");
	connect(cpCloseAct, SIGNAL(triggered()), this, SLOT(onClose()));

	cpCloseAllAct = new QAction(tr("CloseAll"), this);
	connect(cpCloseAllAct, SIGNAL(triggered()), this, SLOT(onCloseAll()));

	cpCommentAct = new QAction(QIcon(":/images/codecomment.png"), tr("Comment"), this);
	cpCommentAct->setToolTip("Comment Out Selected Lines");
	cpCommentAct->setStatusTip("Prefix comment delimiter to highlighted lines");
	connect(cpCommentAct, SIGNAL(triggered()), this, SLOT(onComment()));

	cpIndentAct = new QAction(QIcon(":/images/codeindent.png"), tr("Indent"), this);
	cpIndentAct->setToolTip("Indent Selected Lines");
	cpIndentAct->setStatusTip("Prefix tab to highlighted lines");
	connect(cpIndentAct, SIGNAL(triggered()), this, SLOT(onIndent()));

	cpNewAct = new QAction(QIcon(":/images/filenew.png"), tr("New"), this);
	cpNewAct->setShortcut(tr("Alt+N"));
	cpNewAct->setToolTip("New Document");
	cpNewAct->setStatusTip("Start edit of an empty document named 'Untitled'");
	connect(cpNewAct, SIGNAL(triggered()), this, SLOT(onNew()));

	cpOpenAct = new QAction(QIcon(":/images/fileopen.png"), tr("Open..."), this);
	cpOpenAct->setShortcut(tr("Alt+O"));
	cpOpenAct->setToolTip(tr("Open an existing file"));
	cpOpenAct->setStatusTip(tr("Open an existing file"));
	connect(cpOpenAct, SIGNAL(triggered()), this, SLOT(onOpen()));

	cpOutdentAct = new QAction(QIcon(":/images/codeoutdent.png"), tr("Outdent"), this);
	cpOutdentAct->setToolTip("Unindent Selected Lines");
	cpOutdentAct->setStatusTip("Remove leading tab from highlighted lines");
	connect(cpOutdentAct, SIGNAL(triggered()), this, SLOT(onOutdent()));

	cpSaveAct = new QAction(QIcon(":/images/filesave.png"), tr("Save"), this);
	cpSaveAct->setShortcut(tr("Ctrl+S"));
	cpSaveAct->setToolTip("Save Document on disk");
	cpSaveAct->setStatusTip("Save Document on disk");
	connect(cpSaveAct, SIGNAL(triggered()), this, SLOT(onSave()));

	cpSaveAllAct = new QAction(QIcon(":/images/filesaveall.png"), tr("SaveAll"), this);
	cpSaveAllAct->setShortcut(tr("Ctrl+Shift+S"));
	cpSaveAllAct->setToolTip("Save All Documents");
	cpSaveAllAct->setStatusTip("Save all open documents as files");
	connect(cpSaveAllAct, SIGNAL(triggered()), this, SLOT(onSaveAll()));

	cpSaveAsAgentAct = new QAction(tr("Lambda..."), this);
	connect(cpSaveAsAgentAct, SIGNAL(triggered()), this, SLOT(onSaveAsAgent()));

	cpSaveAsExportAct = new QAction(tr("Export..."), this);
	connect(cpSaveAsExportAct, SIGNAL(triggered()), this, SLOT(onSaveAsExport()));

	cpSaveAsLocalFileAct = new QAction(tr("Local File..."), this);
	connect(cpSaveAsLocalFileAct, SIGNAL(triggered()), this, SLOT(onSaveAsLocalFile()));

	cpSaveAsRemoteFileAct = new QAction(tr("Remote File..."), this);
	connect(cpSaveAsRemoteFileAct, SIGNAL(triggered()), this, SLOT(onSaveAsRemoteFile()));

	cpCompileDebug = new QAction(QIcon(":/images/compileoff.png"), tr("Save and Compile w/ Dbg"), this);
	cpCompileDebug->setToolTip("Compile Lambda with Debug");
	cpCompileDebug->setStatusTip("Save and then compile Lambda with Debug");
	connect(cpCompileDebug, SIGNAL(triggered()), this, SLOT(onSaveCompileDebug()));

	cpSaveCompileAct = new QAction(QIcon(":/images/filecompile.png"), tr("Save and Compile"), this);
	cpSaveCompileAct->setToolTip("Compile Lambda");
	cpSaveCompileAct->setStatusTip("Save and then compile Lambda");
	connect(cpSaveCompileAct, SIGNAL(triggered()), this, SLOT(onSaveCompile()));

	cpSaveCompileAllAct = new QAction(tr("Save and Compile All"), this);
	connect(cpSaveCompileAllAct, SIGNAL(triggered()), this, SLOT(onSaveCompileAll()));

	cpSeparatorAct = new QAction(this);
	cpSeparatorAct->setSeparator(true);

	cpShowAgentsAct = new QAction(QIcon(":/images/codeshowagents.png"), tr("Show Lambda List"), this);
	cpShowAgentsAct->setShortcut(tr("Alt+L"));
	cpShowAgentsAct->setToolTip("Show Lambda List.");
	cpShowAgentsAct->setStatusTip("Show list of agents and their line numbers.");
	connect(cpShowAgentsAct, SIGNAL(triggered()), this, SLOT(onShowAgents()));

	cpUncommentAct = new QAction(QIcon(":/images/codeuncomment.png"), tr("Uncomment"), this);
	cpUncommentAct->setToolTip("Uncomment Selected Lines");
	cpUncommentAct->setStatusTip("Remove leading comment delimieter from highlighed lines");
	connect(cpUncommentAct, SIGNAL(triggered()), this, SLOT(onUncomment()));
}

void AEditorTab::createMenus()
{
	// SubMenus.
	cpSaveAsMenu = new QMenu("SaveAs", this);
	cpSaveAsMenu->addAction(cpSaveAsLocalFileAct);
	cpSaveAsMenu->addAction(cpSaveAsRemoteFileAct);
	cpSaveAsMenu->addAction(cpSaveAsAgentAct);
	cpSaveAsMenu->addAction(cpSaveAsExportAct);

	// File Menu.
	cpFileMenu = new QMenu(QString("Editor"), this);
	cpFileMenu->addAction(cpNewAct);
	cpFileMenu->addAction(cpOpenAct);
	cpFileMenu->addAction(cpCloseAct);
	cpFileMenu->addAction(cpCloseAllAct);
	cpFileMenu->addAction(cpSeparatorAct);
	cpFileMenu->addAction(cpSaveAct);
	cpFileMenu->addAction(cpSaveAllAct);
	cpFileMenu->addMenu(cpSaveAsMenu);
	cpFileMenu->addAction(cpCompileDebug);
	cpFileMenu->addAction(cpSaveCompileAct);
	cpFileMenu->addAction(cpSaveCompileAllAct);

	// Code Menu.
	cpCodeMenu = new QMenu(QString("Code"), this);
	cpCodeMenu->addAction(cpShowAgentsAct);
	cpCodeMenu->addAction(cpIndentAct);
	cpCodeMenu->addAction(cpOutdentAct);
	cpCodeMenu->addAction(cpCommentAct);
	cpCodeMenu->addAction(cpUncommentAct);

	// Toolbar. Set the tool bar list too.
	cToolList << cpNewAct << cpOpenAct << cpCloseAct << cpSaveAct << cpSaveAllAct << cpCompileDebug << cpSaveCompileAct;
	cToolList << cpShowAgentsAct << cpIndentAct << cpOutdentAct << cpCommentAct << cpUncommentAct;

	// Hide. Initially, hide menus and tools
	QAction* apAction;
	apAction = cpFileMenu->menuAction();
	apAction->setVisible(false);
	apAction = cpCodeMenu->menuAction();
	apAction->setVisible(false);

	foreach (apAction, cToolList)
		apAction->setVisible(false);

	cpEditorContextMenu = new QMenu("Console Context Menu", this);
	cpEditorContextMenu->addAction(cpNewAct);
	cpEditorContextMenu->addAction(cpOpenAct);
	cpEditorContextMenu->addAction(cpCloseAct);
	cpEditorContextMenu->addAction(cpCloseAllAct);
	cpEditorContextMenu->addAction(cpSeparatorAct);
	cpEditorContextMenu->addAction(cpSaveAct);
	cpEditorContextMenu->addAction(cpSaveAllAct);
	cpEditorContextMenu->addMenu(cpSaveAsMenu);
	cpEditorContextMenu->addAction(cpCompileDebug);
	cpEditorContextMenu->addAction(cpSaveCompileAct);
	cpEditorContextMenu->addAction(cpSaveCompileAllAct);
	cpEditorContextMenu->addSeparator();
	cpEditorContextMenu->addAction(cpShowAgentsAct);
	cpEditorContextMenu->addAction(cpIndentAct);
	cpEditorContextMenu->addAction(cpOutdentAct);
	cpEditorContextMenu->addAction(cpCommentAct);
	cpEditorContextMenu->addAction(cpUncommentAct);
}

/*!
\brief cut - Move the currently selected text to the clipboard

\return void
\par Notes:
-# Inherited from the APage base class.
-# Some text must be currently selected (highlighted)
*/
void AEditorTab::cut()
{
	if (cpCurPage != NULL)
		cpCurPage->editCut();
	else
		onStatusAlert("EditCut: No page is currently selected");

}

/*!
\brief getFocusWidget - Returns the widget that currently has focus.

\return apFocus - The widget that currently has focus
\par Notes:
-# Inherited from the APage base class.
-# The widget that has focus receives keyboard and mouse input.
*/
QWidget* AEditorTab::getFocusWidget()
{
	return cpCurPage;
}

/*!
\brief getTabMenus - Returns the menus and the toolbar actions for the console page

\param orTabMenus - Reference to place to put the console page menu list.
\param orTabTools - Reference to place to put the console page tool list.
\param iSelected - True iff this tab is currently selected.
\return void
\par Notes:
-# Inherited from the APage base class.
-# Used to update the Session Form menus and toolbar list.
*/
void AEditorTab::getTabMenus(AMenuList& orTabMenus, AToolList& orTabTools, bool iSelected)
{
    Q_UNUSED(iSelected);

	orTabMenus.clear();
	orTabMenus << cpFileMenu << cpCodeMenu;
	orTabTools = cToolList;

	// Erase stale messages.
	if (cStaleAlert)
		cpParentForm->statusAlert(""), cStaleAlert = false;
	if (cStaleMsg)
		cpParentForm->statusMsg(""), cStaleMsg = false;
}

/*!
 * \brief Returns a pointer to the underlying ATextEdit object.
 */
ATextEdit* AEditorTab::getTextEdit()
{
	return dynamic_cast<ATextEdit*>(cpCurPage);
}

/*
launchNext Save - Launch the next save operation
Args:
	iTabIx	The starting offset in the list of tabs (edit pages) from left to right on the screen
	iTask	The type of task (ceNoTask, ceSaveAsAgent, ceSaveAll, ceSaveCompile, ceSaveCompileAll)
Returns:
	aLaunched	True iff another task launched
Notes:
 1.	iTask is limited to ceSaveAll and ceSaveCompileAll. Other cases are launched directly from their slot.
*/
bool AEditorTab::launchNextSave(long iTabIx, ATask iTask)
{
	bool aLaunched = false;
	long aIx, aSize = count();
	for (aIx = iTabIx; aIx < aSize; ++aIx)
	{	AEditPage* apPage = qobject_cast<AEditPage*>(widget(aIx));
		if (apPage != NULL && (iTask == ceSaveAll || iTask == ceSaveCompileAll) && apPage->editIsModified() && apPage->pageType() == AEditPage::meAgent)
		{	cTaskIx = aIx;
			cTask = iTask;
			save(apPage);
			aLaunched = true;
			break;
		}
		else if (iTask == ceSaveAll)
			onStatusAlert("onSaveAll: Page has not been modified since last save");
		else
			onStatusAlert("onSaveCompileAll: File must be saved as an agent in order to compile it.");
	}
	if (!aLaunched)
	{	cTask = ceNoTask;
		cTaskIx = -1;
	}
	return aLaunched;
}

/*!
\brief move - Move to the next 

\return void
\par Notes:
-# Inherited from the APage base class.
*/
void AEditorTab::move(bool iNext)
{
	cpCurPage->editMove(iNext ? ATextEdit::eNextCur : ATextEdit::ePrevCur, false/*Select*/);
}

void AEditorTab::onClose()
{
	if (cpCurPage != NULL)
	{	// Save. Ask user and then save.
		QString aFileSpec(cpCurPage->objectName());
		if (cpCurPage->editIsModified())
		{	QString aFileName(QFileInfo(aFileSpec).fileName());
			QString aCaption = QString("Closing %1").arg(aFileSpec);
			QString aText = QString("%1 has been modified.\nDo you wish to save the changes?").arg(aFileName);
			switch (QMessageBox::information(this, aCaption, aText, QMessageBox::Yes, QMessageBox::No, QMessageBox::Cancel))
			{
			case QMessageBox::Yes:
				save(cpCurPage);
				break;
			case QMessageBox::No:
				break;
			case QMessageBox::Cancel:
				return;
			}
		}
		// Remove. removeTab only triggers a call to onCurrentTabChanged if aTabIdx is changed. Thus, a delete of the rightmost
		// tab triggers a call, but a delete of any other tab does not.  To compensate, we call onCurrentTabChanged in any case.
		// An extra call to onCurrentTabChanged is harmless.
		long aTabIdx = currentIndex();
		cTabList.remove(aFileSpec);
		cpCurPage->deleteLater();
		removeTab(aTabIdx);
		aTabIdx = currentIndex();
		onCurrentTabChanged(aTabIdx);
	}
	else
		onStatusAlert("onClose: No page is currently selected");

}

void AEditorTab::onCloseAll()
{
	APageMap::iterator aItp;
	bool aFoundOne = false;
	while ((aItp = cTabList.begin()) != cTabList.end())
	{	if ((cpCurPage = aItp.value()) != NULL)
		{	aFoundOne = true;
			onClose();
		}
	}
	if (!aFoundOne)
		onStatusAlert("onCloseAll: No page is currently selected");
}

void AEditorTab::onComment()
{
	if (cpCurPage != NULL)
		cpCurPage->editComment();
	else
		onStatusAlert("onComment: No page is currently selected");
}

void AEditorTab::onSaveCompileDebug()
{
	if (cpCurPage != NULL)
	{	if (cpCurPage->pageType() == AEditPage::meAgent)
		{	cTask = ceSaveCompileDebug;
			cTaskIx = currentIndex();
			save(cpCurPage);
		}
		else
			onStatusAlert("onSaveCompileDebug: File must be saved as an agent in order to compile it.");
	}
	else
		onStatusAlert("onSaveCompileDebug: No page is currently selected");
}

void AEditorTab::onCurrentTabChanged(int iTabIdx)
{
	AEditPage* apCurPage = qobject_cast<AEditPage*>(widget(iTabIdx));
	if (cStaleAlert)
		cpParentForm->statusAlert(""), cStaleAlert = false;
	if (cStaleMsg)
		cpParentForm->statusMsg(""), cStaleMsg = false;
	if (apCurPage != NULL)
	{	if (apCurPage != cpCurPage)
		{	cpCurPage = apCurPage;
			if (cpParentForm != NULL)
				cpParentForm->cursorStackChanged(cpCurPage->mForward, cpCurPage->mPrevious);
		}
		// else, No change in tab, so return quietly.
	}
	else
	{	cpCurPage = apCurPage;
		cpParentForm->statusMsg("onCurrentTabChanged: No page is currently selected"), cStaleMsg = true;
	}
}

void AEditorTab::onCursorPositionChanged(long iCol, long iRow)
{
	if (cpParentForm != NULL)
	{	cpParentForm->setCursorLabel(iCol, iRow);
		if (cStaleAlert)
			cpParentForm->statusAlert(""), cStaleAlert = false;
		if (cStaleMsg)
			cpParentForm->statusMsg(""), cStaleMsg = false;
	}
}

void AEditorTab::onCursorStackChanged(bool iForward, bool iPrevious)
{
	if (cpCurPage != NULL)
	{	cpCurPage->mForward = iForward;
		cpCurPage->mPrevious = iPrevious;
	}
	if (cpParentForm != NULL)
		cpParentForm->cursorStackChanged(iForward, iPrevious);
}

void AEditorTab::onIndent()
{
	if (cpCurPage != NULL)
		cpCurPage->editIndent(true/*Insert*/);
	else
		onStatusAlert("onIndent: No page is currently selected");
}

void AEditorTab::onNew()
{
	QString aFileSpec("Untitled");
	addPage(aFileSpec, AEditPage::meDefault);
}

void AEditorTab::onOpen()
{
	QString aCaption("Open new or existing file");
	QString aDir(".");
	QString aFilters("All Files (*);;Text Files (*.txt *.log *.ini);;Source Files (*.c *.cpp *.h *.js *.sl)");
	QString aFileSpec = QFileDialog::getOpenFileName(this, aCaption, aDir, aFilters);
	if (!aFileSpec.isEmpty() && addPage(aFileSpec, AEditPage::meLocalFile))
		cpCurPage->editRead(aFileSpec);
}

void AEditorTab::onOutdent()
{
	if (cpCurPage != NULL)
		cpCurPage->editIndent(false);
	else
		onStatusAlert("onOutdent: No page is currently selected");
}

void AEditorTab::onSave()
{
	if (cpCurPage != NULL)
	{	if (cpCurPage->editIsModified())
		{	cTaskIx = currentIndex();
			save(cpCurPage);
		}
		else
		{	cpParentForm->statusMsg("onSave: Page has not been modified since last save");
			cStaleMsg = true;
		}
	}
	else
		onStatusAlert("onSave: No page is currently selected");
}

void AEditorTab::onSaveAll()
{
	if (cpCurPage != NULL)
	{	launchNextSave(0/*TabIx*/, ceSaveAll);
	}
	else
		onStatusAlert("onSaveAll: No page is currently selected");
}

void AEditorTab::onSaveAsAgent()
{
	if (cpCurPage != NULL)
		saveAsAgent(cpCurPage);
	else
		onStatusAlert("onSaveAsAgent: No page is currently selected");
}

void AEditorTab::onSaveAsExport()
{
	if (cpCurPage != NULL)
	{	QString aFileSpec(cpCurPage->objectName());
		AEditPage::APageType aType = cpCurPage->pageType();
		if (!aFileSpec.contains('.'))
			aFileSpec += (aType == AEditPage::meAgent) ? ".sl" : ".txt";
		aFileSpec = QFileDialog::getSaveFileName(this, "Select a name for the export file", aFileSpec, "Any (*.*)");
		if (!aFileSpec.isEmpty())
			cpCurPage->editWrite(aFileSpec);
	}
	else
		onStatusAlert("onSaveAsExport: No page is currently selected");
}

void AEditorTab::onSaveAsLocalFile()
{
	if (cpCurPage != NULL)
		saveAsLocal(cpCurPage);
	else
		onStatusAlert("onSaveAsLocalFile: No page is currently selected");

}

void AEditorTab::onSaveAsRemoteFile()
{
	if (cpCurPage != NULL)
		saveAsRemote(cpCurPage);
	else
		onStatusAlert("onSaveAsRemote: No page is currently selected");
}

void AEditorTab::onSaveCompile()
{
	if (cpCurPage != NULL)
	{	if (cpCurPage->pageType() == AEditPage::meAgent)
		{	cTask = ceSaveCompile;
			cTaskIx = currentIndex();
			save(cpCurPage);
		}
		else
			onStatusAlert("onSaveCompile: File must be saved as an agent in order to compile it.");
	}
	else
		onStatusAlert("onSaveCompile: No page is currently selected");
}

void AEditorTab::onSaveCompileAll()
{
	long aSize = count();
	if (aSize > 0)
		launchNextSave(0/*TabIx*/, ceSaveCompileAll);
	else
		onStatusAlert("onSaveCompileAll: No page is currently selected");
}

void AEditorTab::onShowAgents()
{
	if (cpCurPage != NULL)
	{
		// Load the Function List Dialog
		if (cpFcnListDialog == NULL)
			cpFcnListDialog = ATextEdit::createFcnListDialog(this, "Lambda List Dialog");

		// Get list of agents or functions
		ATextEdit* apTextEdit = getTextEdit();
		if (apTextEdit != NULL)
		{
			QStringList aFcnList = apTextEdit->editFunctionList();
			if (aFcnList.isEmpty())
			{
				onStatusAlert("Function List: No functions / agents found");
			}
			else
			{
				// List is not empty, display it
				cpFcnListDialog->init(apTextEdit, aFcnList);
				cpFcnListDialog->showOnTop();
			}
		}
	}
	else
		onStatusAlert("onShowAgents: No page is currently selected");
}

void AEditorTab::onStatusAlert(const QString& irMsg)
{
	cpParentForm->statusAlert(irMsg);
	cStaleAlert = true;
}

void AEditorTab::onTextModified(bool iModified)
{
	setTabModified(iModified, currentIndex());
}

void AEditorTab::onUncomment()
{
	if (cpCurPage != NULL)
		cpCurPage->editComment(false/*Insert*/);
	else
		onStatusAlert("onUncomment: No page is currently selected");
}

/*!
\brief openPage - Add a new page to this tabbed-widget

\param irExtentName - The extent that holds the text for this new page.
\param irPageName - The name of the file or agent
\param iPageType - Contents of this new page (meDefault, meLocalFile, meRemoteFile, meAgent);
\return void
\par Notes:
-# openNode passes the page name to returnOutput. It is used to identify the page originating this request.
*/
void AEditorTab::openPage(const QString& irExtentName, const QString& irPageName, AEditPage::APageType iPageType)
{
	QString aPageName(irPageName);
	if (aPageName.isEmpty())
	{	if (count() == 0)
			addPage(aPageName, iPageType);
	}
	else if (addPage(aPageName, iPageType))
		cpAppClient->openNode(this, irExtentName, aPageName);
}

/*!
\brief paste - Insert the text from the clipboard into the text at the cursor.

\return void
\par Notes:
-# Inherited from the APage base class.
-# The clipboard is not modified.
*/
void AEditorTab::paste()
{
	cpCurPage->editPaste();
}

/*!
\brief print - Print the text in the console pane to the default printer

\return void
\par Notes:
-# Inherited from the APage base class.
-# Requires that a printer be available to this machine.
*/
void AEditorTab::print()
{
	if (cpCurPage != NULL)
		cpCurPage->editPrint();
	else
		onStatusAlert("print: No page is currently selected");
}

/*!
\brief redo - Redo the last undo operation

\return void
\par Notes:
-# Inherited from the APage base class.
-# Requires that at least one undo operation was performed after the last edit operation.
*/
void AEditorTab::redo()
{
	if (cpCurPage != NULL)
		cpCurPage->editRedo(true/*ToMark*/);
	else
		onStatusAlert("redo: No page is currently selected");
}

/*!
\brief returnOutput - Update the task state and then process the returned information from the AIS server.

\param iConnectId - Placeholder (used in other parts of AIS for the connectID).
\param iRqId - an incrementing integer assigned by appclient to each outgoing request to the server.
\param iStatus - Zero or a positive error code if an error was generated by the server
\param iReqType - Enum describing the type of response or pushed data from the server.
\param iRetValue - Integer return value (defaults to zero).
\param irOut - Returned message (defaults to an empty string).
\param ipData - Binary buffer used to hold serialized object closure (not used here)
\param iDataSize - Binary buffer size in bytes (not used here)
\param irDisplay - Return from writeln and display (defaults to an empty string).
\param irError - Returned error message (defaults to an empty string).
\param iClientData - Optional string submitted with a request and returned verbatim with the response
\return void
\par Notes:
 -# If completing a request for a task, move to the next request in the task.
 -# If last request of a task is completed, move to next task for this job.
-# Process results returned or forward results to requesting form for processing.
*/
void AEditorTab::returnOutput(long iConnectId, long iRqId, long iStatus, AReqType iReqType, long iRetValue, const QString& irOut,
    char* ipData, long iDataSize, const QString& irDisplay, const QString& irError, const QString iClientData)
{
    Q_UNUSED(iConnectId);
    Q_UNUSED(iRqId);
    Q_UNUSED(iStatus);
    Q_UNUSED(iRetValue);
    Q_UNUSED(ipData);
    Q_UNUSED(iDataSize);
    Q_UNUSED(irDisplay);
    Q_UNUSED(irError);

	if (cStaleMsg)
		cpParentForm->statusMsg(""), cStaleMsg = false;
	if (cStaleAlert)
		cpParentForm->statusAlert(""), cStaleAlert = false;
	if (!irOut.isEmpty() && irOut[0] == '!')
	{	cpParentForm->consoleOutput(irOut);
		onStatusAlert("Engine error! See Console page for details");
		setEnabled(true);
		cTaskIx = -1;
		cTask = ceNoTask;
	}
	else
	{	switch (iReqType)
		{
		case geCompileLambda:
			setEnabled(true);
			if (cTask == ceSaveCompileAll)
				launchNextSave(++cTaskIx, cTask);
			else
			{	cTaskIx = -1;
				cTask = ceNoTask;
			}
			if (cTaskIx == -1)
				cpParentForm->consoleOutput(irOut + '\n');
			break;
		case geGetNextLevel:
			setEnabled(true);
			break;
		case geOpenNode:
			// iClientData contains the full node name
			setEnabled(true);
			if (cTabList.contains(iClientData))
			{	AEditPage* apCurPage = cTabList.value(iClientData);
				apCurPage->editAppend(irOut, false/*MoveToEnd*/);
			}
			else
				qDebug("AEditorTab:returnOutput, openNode unable to locate node name");
			break;
		case geSaveNode:
		{	// Modified. Reset modified flag.
			AEditPage* apPage = (cTaskIx >= 0) ? qobject_cast<AEditPage*>(widget(cTaskIx)) : NULL;
			if (apPage != NULL)
			{	// Refresh. Force a refresh of agent names in node tab.
				setEnabled(true);
				setTabModified(false,cTaskIx);
				if (cTask == ceSaveAsAgent)
				{	cpAppClient->getNextLevel(this);
					cTask = ceNoTask;
				}
				else if (cTask == ceSaveCompileAll || cTask == ceSaveCompile)
					compile(apPage);
				else if (cTask == ceSaveCompileDebug)
					compileDebug(apPage);
				else if (cTask == ceSaveAll)
					launchNextSave(++cTaskIx, cTask);
				else
				{	cTaskIx = -1;
					cTask = ceNoTask;
				}
			}
			else
			{	onStatusAlert("returnOutput: Internal error (null page)");
				cTaskIx = -1;
				cTask = ceNoTask;
				setEnabled(true);
			}
			break;
		}
		case geExportCabinet:
			// This is a special case when modifying the source using the editor tab.  
			// Enable all tabs and set back the focus to the editor tab.
			// For some reason, if this is not done, the focus does not return to the editor tab.
			cpParentForm->enable(true);
			setFocus();
			break;
		default:
			break;
		}
	}
}

void AEditorTab::save(AEditPage* ipPage)
{
	if (ipPage == NULL)
		onStatusAlert("Save, no page currently selected");
	else
	{	switch (ipPage->pageType())
		{
		case AEditPage::meLocalFile:
			saveLocal(ipPage);
			break;
		case AEditPage::meRemoteFile:
			saveRemote(ipPage);
			break;
		case AEditPage::meAgent:
			saveAgent(ipPage);
			return;
		default:
			saveAsLocal(ipPage);
			break;
		}
		if (cTask == ceSaveAll || cTask == ceSaveCompileAll)
			launchNextSave(++cTaskIx, cTask);
	}
}

void AEditorTab::saveAgent(AEditPage* ipPage)
{
	if (ipPage != NULL)
	{	QByteArray aText(ipPage->editText());
		QString aExtentName(ipPage->extentName());
		QString aFileSpec(ipPage->objectName());
		cTaskIx = indexOf(ipPage);
		setEnabled(false);
		cpAppClient->saveNode(this, aExtentName, aFileSpec, aText);
		ipPage->editSetModified(false/*Saved*/);
	}
	else
		onStatusAlert("SaveAgent: No page selected");
}

void AEditorTab::saveAsAgent(AEditPage* ipPage)
{
	if (ipPage != NULL)
	{	QString aAgentName(QFileInfo(ipPage->objectName()).baseName());
		cSaveAsAgentDialog.refreshTargets(aAgentName);
		cSaveAsAgentDialog.setWindowTitle(QString("Save As Lambda: ").append(tabText(currentIndex())));
		if (cSaveAsAgentDialog.exec() == QDialog::Accepted)
		{	// Switch. If already open, switch to this page
			QString aFilePath = cSaveAsAgentDialog.agentName();
			QString aExtentName = cSaveAsAgentDialog.extent();
			bool aSameExtent = aExtentName == ipPage->extentName();
			bool aSameName = aFilePath == ipPage->objectName();
			if (cTabList.contains(aFilePath) && aSameExtent)
			{	ipPage = cTabList.value(aFilePath);
				setCurrentWidget(ipPage);
			if (cpParentForm != NULL)
				cpParentForm->cursorStackChanged(cpCurPage->mForward, cpCurPage->mPrevious);
			}
			else // Rename. Rename to new agent name, new extent name.
			{	QString aTabLabel(QFileInfo(aFilePath).fileName());	// fileName strips off path.
				if (!aSameExtent)
					ipPage->setExtentName(aExtentName);
				if (!aSameName)
				{	cTabList.remove(ipPage->objectName());
					cTabList[aFilePath] = ipPage;
					ipPage->setObjectName(aFilePath);
					setTabText(currentIndex(), aTabLabel + ' ');
				}
				ipPage->setPageType(AEditPage::meAgent);

				// Save. Save the agent to the named extent
				cTask = ceSaveAsAgent;
				cTaskIx = indexOf(ipPage);
				saveAgent(ipPage);
			}
		}
	}
	else
		onStatusAlert("saveAsAgent: No page is currently selected");
}

void AEditorTab::saveAsLocal(AEditPage* ipPage)
{
	if (ipPage != NULL)
	{	QString aFileSpec(ipPage->objectName());
		AEditPage::APageType aType = ipPage->pageType();
		if (!aFileSpec.contains('.'))
			aFileSpec += (aType == AEditPage::meAgent) ? ".sl" : ".txt";
		aFileSpec = QFileDialog::getSaveFileName(this, "Select a name for the local file", aFileSpec, "Any (*.*)");
		if (!aFileSpec.isEmpty())
		{	// Switch. Switch pages if name is already opened.
			if (cTabList.contains(aFileSpec))
			{	ipPage = cTabList.value(aFileSpec);
				setCurrentWidget(ipPage);
				onStatusAlert("SaveAsLocal: Switching to existing page");
				if (cpParentForm != NULL)
					cpParentForm->cursorStackChanged(cpCurPage->mForward, cpCurPage->mPrevious);
			}
			else // Rename. Rename to new agent name.
			{	QString aTabLabel(QFileInfo(aFileSpec).fileName());	// fileName strips off path.
				cTabList.remove(ipPage->objectName());
				cTabList[aFileSpec] = ipPage;
				ipPage->setObjectName(aFileSpec);
				setTabText(currentIndex(), aTabLabel + ' ');
				ipPage->setPageType(AEditPage::meLocalFile);
				saveLocal(ipPage);
			}
		}
	}
	else
		onStatusAlert("saveAsLocal: No page is currently selected");
}

void AEditorTab::saveAsRemote(AEditPage* ipPage)
{
	if (ipPage != NULL)
		onStatusAlert("saveAsRemote: Not yet implemented");
	else
		onStatusAlert("print: No page is currently selected");
}

void AEditorTab::saveLocal(AEditPage* ipPage)
{
	if (ipPage == NULL)
		onStatusAlert("SaveLocal, No page currently selected");
	else
	{	QString aFileSpec = ipPage->objectName();
		QString aFileName = QFileInfo(aFileSpec).fileName();
		if (aFileName.isEmpty() || aFileName == "Untitled")
		{	onStatusAlert("Please choose a file name (may not be \"Untitled\")");
			saveAsLocal(ipPage);
		}
		else
			ipPage->save();
	}
}

void AEditorTab::saveRemote(AEditPage* ipPage)
{
	if (ipPage != NULL)
		onStatusAlert("SaveRemote. Save remote not yet implemented");
	else
		onStatusAlert("saveRemote: No page is currently selected");
}

/*!
\brief setContextName - Inherited from the AReturnRcvr abstract base class.

\param iConnectId  - The ID of the connection for this context.
\param irContextName - The new context name
\return void
*/
void AEditorTab::setContextName(long iConnectId, const QString& irContextName)
{
    Q_UNUSED(iConnectId);
    Q_UNUSED(irContextName);
}

/*!
 * \brief Update the look and feel of all editor pages.
 *
 * \param[in] ipEditorParams New editor parameters.
 */
void AEditorTab::setParameters(AParameters* ipEditorParams)
{
	// Get original console parameter
	AParameters* apEditorParams = cpParentForm->getEditorParameters();
	ATextEdit* apTextEdit = 0;
	// get tabbed widget count
	long aSz = count(); 

	if (ipEditorParams != NULL && apEditorParams != NULL)
	{
		for (long i = 0; i < aSz; i++)
		{
			apTextEdit = qobject_cast<ATextEdit*>(widget(i));
			if (apTextEdit != NULL)
			{
				// update modified parameters only
				if (apEditorParams->mFont != ipEditorParams->mFont)
					apTextEdit->editSetParameter("Font", QVariant(ipEditorParams->mFont));

				if (apEditorParams->mFontSize != ipEditorParams->mFontSize)
					apTextEdit->editSetParameter("FontSize", QVariant((int)ipEditorParams->mFontSize));

				if (apEditorParams->mTabWidth != ipEditorParams->mTabWidth)
					apTextEdit->editSetParameter("TabWidth", QVariant((int)ipEditorParams->mTabWidth));

				if (apEditorParams->mLineNumbers != ipEditorParams->mLineNumbers)
					apTextEdit->editSetParameter("LineNumbers", QVariant(ipEditorParams->mLineNumbers));

				if (apEditorParams->mShowWhiteSpace != ipEditorParams->mShowWhiteSpace)
					apTextEdit->editSetParameter("ShowWhiteSpace", QVariant(ipEditorParams->mShowWhiteSpace));

				if (apEditorParams->mWrap != ipEditorParams->mWrap)
					apTextEdit->editSetParameter("WordWrap", QVariant(ipEditorParams->mWrap));
			}
		}
	}
}

void AEditorTab::setTabModified(bool iModified, long iTabIx)
{
	QChar aCh(iModified ? '*' : ' ');
	QString aLabel(tabText(iTabIx));
	long aEnd = aLabel.length() - 1;
	if (aLabel[(int)aEnd] != aCh)
	{	aLabel[(int)aEnd] = aCh;
		setTabText(iTabIx, aLabel);
		// Maybe change caption??
	}
}

/*!
\brief undo - Undo the last edit operation on the console output pane

\return void
\par Notes:
-# Inherited from the APage base class.
-# Requires at least one prior edit operation on the console output pane.
*/
void AEditorTab::undo()
{
	if (cpCurPage != NULL)
		cpCurPage->editUndo(true/*ToMark*/);
	else
		onStatusAlert("undo: No page is currently selected");
}

/*!
\brief exportCabinet - RCA

\return void
\par Notes:
-# Export Cabinet - RCA
*/
void AEditorTab::exportCabinet(const QString& aExportSync,
							   const QString& aMessage, 
							   const QString& aName, 
							   const QString& aLocation,
							   const QString& aStorageScope)
{
	QString tempName = aName;
	QString tempLocation = aLocation;
	if( aExportSync == "ask" )
	{
		if( QMessageBox::question( this,
			"Export",
			QString( aMessage + "\nWould you like to export the source file now?"),
			(QMessageBox::Yes | QMessageBox::No)) == QMessageBox::Yes)
		{
			tempLocation = "..Lambda location..";
			cpParentForm->enable(false);
			if( aStorageScope == "file" )
				cpAppClient->exportCabinetRemote( this, tempName, tempLocation );
			else
				cpAppClient->exportCabinetRemoteDir( this, tempName, tempLocation );
			return;
		}
	}
	else
	if( aExportSync == "auto" )
	{
		tempLocation = "..Lambda location..";
		cpParentForm->statusAlert("Automatically exporting source code.");
		cpParentForm->enable(false);
		if( aStorageScope == "file" )
			cpAppClient->exportCabinetRemote( this, tempName, tempLocation );
		else
			cpAppClient->exportCabinetRemoteDir( this, tempName, tempLocation );
		return;
	}
	else
	if( aExportSync == "notify" )
	{
		cpParentForm->statusAlert("Cabinet needs to be exported");
		cpParentForm->enable(true);
		return;
	}
}
// end

