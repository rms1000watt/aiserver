
<HTML>
<HEAD>
<link rel="stylesheet" type="text/css" href="../CoreContent/help.css">
<TITLE>AIS Essay Template</TITLE></HEAD>
<!--Page Parameters -->
<BODY BGCOLOR="#FFFFF0" TEXT="#000000" LINK="#0000ff">

<A NAME="topage"></A>
<A HREF="TOP"></A>



<P>&nbsp;</P>

<FONT COLOR="#000080"><H1>parseLib Syntax Rules</H1></FONT>
<P>&nbsp;</P>

<UL>
<li><a href="#SOverview"><FONT SIZE=2>Overview</font></a></li><li><a href="#SSyntax Features"><FONT SIZE=2>Syntax Features</font></a></li><li><a href="#SSyntax Rule Definitions "><FONT SIZE=2>Syntax Rule Definitions </font></a></li><li><a href="#SBNF Notation  "><FONT SIZE=2>BNF Notation  </font></a></li><li><a href="#S$this"><FONT SIZE=2>$this</font></a></li><li><a href="#SArgument Passing"><FONT SIZE=2>Argument Passing</font></a></li><li><a href="#SIterative Rules "><FONT SIZE=2>Iterative Rules </font></a></li><li><a href="#STerm Conditions "><FONT SIZE=2>Term Conditions </font></a></li><li><a href="#SMAIN Rule"><FONT SIZE=2>MAIN Rule</font></a></li><li><a href="#SSpecial Rule Syntax "><FONT SIZE=2>Special Rule Syntax </font></a></li><li><a href="#SAppend List Function "><FONT SIZE=2>Append List Function </font></a></li><li><a href="#SRule Precedence"><FONT SIZE=2>Rule Precedence</font></a></li>
</UL>

<P><H2><A NAME="SOverview"></A>Overview</H2></P>		
		    <div class="h2section" id="Syntax Overview">
			<p class=MsoBodyText>This section
			contains initial working notes on the design of the syntax rules and features
			definition language. The syntax definition sublanguage is a combination of the
			lexical analysis ideas in [<b style='mso-bidi-font-weight:normal'>1</b>.3.3]
			and the feature based grammar ideas in [<b style='mso-bidi-font-weight:normal'>2</b>.7].
			</p>         
			</div>
	     <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSyntax Features"></A>Syntax Features</H2></P>		
		    <div class="h2section" id="Syntax Features">
		       <p class=MsoBodyText>Reference [<b style='mso-bidi-font-weight:normal'>2</b>.7] uses the concept of attributed
			lexical tokens. The compiler definition language supports the definition of
			syntax features (token attributes for classes of lexical tokens) as follows: </p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>1</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>     [<b style='mso-bidi-font-weight:normal'>t<sub>11</sub>
			t<sub>12</sub> ... t<sub>1n</sub></b>] [<b style='mso-bidi-font-weight:normal'>v<sub>11</sub>
			v<sub>12</sub> ... v<sub>1n</sub></b>]<b style='mso-bidi-font-weight:normal'></b></p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>2</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>     [<b style='mso-bidi-font-weight:normal'>t<sub>21</sub>
			t<sub>22</sub> ... t<sub>2n</sub></b>] [<b style='mso-bidi-font-weight:normal'>v<sub>21</sub>
			v<sub>22</sub> ... v<sub>2n</sub></b>]<b style='mso-bidi-font-weight:normal'></b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>
			.  .  . </b></p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>n</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>    [<b style='mso-bidi-font-weight:normal'>t<sub>n1</sub>
			t<sub>n2</sub> ... t<sub>nn</sub></b>] [<b style='mso-bidi-font-weight:normal'>v<sub>n1</sub>
			v<sub>n2</sub> ... v<sub>nn</sub></b>]<b style='mso-bidi-font-weight:normal'></b></p>
			<p class=MsoBodyText>Where each <b style='mso-bidi-font-weight:normal'>d<sub>i</sub></b> is a distinct attribute
			name, and each [<b style='mso-bidi-font-weight:normal'>t<sub>i1</sub> t<sub>i2</sub>
			... t<sub>in</sub></b>] is a unique list of individual lexical tokens, and each [<b style='mso-bidi-font-weight:normal'>v<sub>i1</sub> v<sub>i2</sub> ... v<sub>in</sub></b>]
			is an optional unique list of individual attribute values (if the optional
			value list is missing, values of <b style='mso-bidi-font-weight:normal'>true</b>
			are assumed). While each list contains unique tokens, different lists may contain
			the same token. In effect, this allows a single lexical token to be associated
			with multiple attributes. The syntax is as follows:</p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>#SyntaxFeatures#</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>RelationalOperator: [== &lt; &gt; != &lt;=
			&gt;=]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>Lisp: [== &lt; &gt; != &lt;= &gt;=]  [= &lt; &gt; &lt;&gt; &lt;= &gt;=]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>ArithmeticOperator: [+ - * / %]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>Operator: [+ - * / % == &lt; &gt; &lt;&gt;
			&lt;= &gt;= = += -= *= /=]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>AssignmentOperator: [= += -= *= /=]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>Lisp: [= += -= *= /=] [setq += -= *= /=]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>IFStatement: [if]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>LeftParen: [|(|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>RightParen: [|)|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>LeftBrace: [|{|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>RightBrace: [|}|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>LeftBracket: [|[|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>RightBracket: [|]|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>Semicolon: [|;|]</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>#End#</b></p>
			<p class=MsoBodyText>For instance, the
			syntax feature definitions, shown above, generate the following attributes for
			the <b style='mso-bidi-font-weight:normal'>=</b> token:</p>
			<p class=code>            <b style='mso-bidi-font-weight:normal'>=</b>          <b style='mso-bidi-font-weight:normal'>#{AssignmentOperator</b>: true <b style='mso-bidi-font-weight:normal'>Operator</b>: true <b style='mso-bidi-font-weight:
			normal'>Lisp</b>: setq <b style='mso-bidi-font-weight:normal'>Value</b>: =<b style='mso-bidi-font-weight:normal'>}</b></p>
			<p class=MsoBodyText>We can assign
			attributes to individual tokens or to whole classes of tokens using the
			attribute assignment syntax.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    All
			attribute names must begin with an uppercase character and must contain at
			least one non uppercase character.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    All
			lexical token, if a symbol, are surrounded by vertical bar symbols. All
			attribute values are left unaltered. For instance,</p>
			<p class=code style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>Boolean: [true  false]  [true false]</b></p>
			<p class=MsoBodyText>generates Lisp
			code as follows:</p>
			<p class=code>            <b style='mso-bidi-font-weight:normal'>(_setSyntaxFeature  Boolean:
			#( |true|  |false| )  #( true
			false) )</b></p>
			<p class=MsoBodyText>Clearly this sets
			the symbol <b style='mso-bidi-font-weight:normal'>|true|</b> with a Boolean
			value of <b style='mso-bidi-font-weight:normal'>true</b> in the compiler's
			token directory.</p>
			<p class=MsoBodyText>&nbsp;</p>
			<p class=MsoBodyText>For natural
			language definition, groups of words can be given multiple common features as
			follows: </p>
			<p class=code style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>WORDS:</b>          [<b style='mso-bidi-font-weight:normal'>...word list...</b>] [<b style='mso-bidi-font-weight:
			normal'>...common features list...</b>]<b style='mso-bidi-font-weight:normal'></b></p>
			<p class=MsoBodyText>Where each word,
			in the word list, may be a single word or a collection. The word list starts
			with the root word and proceeds with all of its synonyms. For instance:</p>
			<p class=MsoBodyText style='text-indent:.5in'><b>[give
			gives gave given giving]</b></p>
			<p class=MsoBodyText>The root word is
			`give'. The words `gives', `gave', `given', and `giving', are all synonyms for
			the root word `give'. Each word may be a single word or a word group, enclosed
			in square brackets, starting with the word and proceeding with all of its
			special features. For instance:</p>
			<p class=code style='text-indent:.5in'><b>[give
			gives gave given [giving Noun]] </b></p>
			<p class=MsoBodyText>Once again, the
			root word is `give', and the words `gives', `gave', `given', and `giving', are
			all synonyms for the root word `give'. However, in this case the word `giving'
			has been given a special feature of <i>Noun</i>. </p>
			<p class=MsoBodyText>The common
			features list describes the features which will be common to all words in the word
			list. Each feature may be a single word or a word group, enclosed in square
			brackets, starting with the feature and proceeding with the value of the
			feature. A singleton feature is assumed to have a value of true.  For instance:   </p>
			<p class=code style='text-indent:.5in'><b>WORDS:
			[sky] [Noun [Color blue]] </b></p>
			<p class=MsoBodyText>In effect, this
			defines the word sky with a feature set of Noun = true and Color = blue. The
			word features definition, shown above, generates compiler initialization Lisp
			code as follows:</p>
			<p class=code>            <b style='mso-bidi-font-weight:normal'>(_setWordFeatures  #( |sky| )
			#( Noun  #(Color blue)) )</b></p>
			<p class=MsoBodyText>which, during
			compiler initialization, generates the following attributes for the <b style='mso-bidi-font-weight:normal'>sky </b>word:</p>
			<p class=code>            <b style='mso-bidi-font-weight:normal'>=</b>          <b style='mso-bidi-font-weight:normal'>#{Value</b>: "sky" <b style='mso-bidi-font-weight:
			normal'>Sky</b>: true <b style='mso-bidi-font-weight:normal'>Noun</b>: true <b style='mso-bidi-font-weight:normal'>Color</b>: blue <b style='mso-bidi-font-weight:
			normal'>}</b></p>
			<p class=MsoBodyText>Some examples of
			the word definition syntax is as follows:</p>
			 <blockquote>
			<p class=code style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>#SyntaxFeatures#</b></p>
			<p class=code style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>WORDS:</b>          <b>[Alice]
			[Noun Name Female]</b><b style='mso-bidi-font-weight:normal'></b></p>
			<p class=code style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>WORDS:</b>          <b>[computer
			[computers Plural] [computing Verb]] [Machine Noun]</b><b style='mso-bidi-font-weight:
			normal'></b></p>
			<p class=code style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>#End#</b></p> 
			</blockquote>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    All
			feature names must begin with an uppercase character and must contain at least
			one non uppercase character.</p>	    
		    </div>
		 <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSyntax Rule Definitions "></A>Syntax Rule Definitions </H2></P> 
            <div class="h2section" id="Syntax Rule Definitions ">
              		<p class=MsoBodyText>Reference [<b style='mso-bidi-font-weight:normal'>1</b>.3.3] uses syntax definition from
			regular definitions of the form: </p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>1</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>     <b style='mso-bidi-font-weight:normal'>r<sub>1</sub>  ||  c<sub>1  </sub>|| :: a<sub>1 </sub>::</b></p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>2</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>     <b style='mso-bidi-font-weight:normal'>r<sub>2</sub>  ||  c<sub>2  </sub>|| :: a<sub>2</sub> ::</b></p>
			<p class=MsoBodyText style='margin-left:.5in'><b style='mso-bidi-font-weight:normal'>
			.  .  . </b></p>
			<p class=MsoBodyText style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>d<sub>n</sub></b>   <b style='mso-bidi-font-weight:normal'>:</b>    <b style='mso-bidi-font-weight:normal'>r<sub>n</sub>  ||  c<sub>n  </sub>|| :: a<sub>1</sub> ::</b></p>
			<p class=MsoBodyText>Where each <b style='mso-bidi-font-weight:normal'>d<sub>i</sub></b> is a rule name, each <b style='mso-bidi-font-weight:normal'>r<sub>i</sub></b> is a rule expression,
			each <b style='mso-bidi-font-weight:normal'>c<sub>i</sub></b> is a Lisp
			conditional expression, and each <b style='mso-bidi-font-weight:normal'>a<sub>i</sub></b>
			is a Lisp action expression. The syntax for rule definition is as follows:</p>     
			<blockquote>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>#SyntaxRules#</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>&nbsp;</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR: + Term || (= $2.Term true) || :: $2
			::</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR: - Term || (= $2.Number true) || ::
			(setq $2.Value (- 0 $2.Value))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR=: - Term :: (setq $2.Value (list |-|:
			0 $2.Value))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR=: Term :: $1</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR=: REXPR RelationalOperator REXPR::
			(setq $0.Value (list $2.Lisp $1 $3))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>REXPR=: LeftParen REXPR RightParen :: $2</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>&nbsp;</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: + Term || (= $2.Term true) || :: $2
			::</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: - Term || (= $2.Number true) || ::
			(setq $2.Value (- 0 $2.Value))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: - Term :: (setq $2.Value (list |-|:
			0 $2.Value))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: Term :: $1</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: SEXPR Operator SEXPR:: (setq
			$0.Value (list $2.Lisp $1 $3))</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>SEXPR: LeftParen SEXPR RightParen :: $2</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>&nbsp;</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>#End#</b></p>
			</blockquote>
			<p class=MsoBodyText>The Lisp
			condition rule is optional. If present, it must be enclosed by the <b style='mso-bidi-font-weight:normal'>||</b> symbol. The Lisp action rule is
			mandatory. It must be enclosed by the <b style='mso-bidi-font-weight:normal'>::</b>
			symbol. The rule variable <b style='mso-bidi-font-weight:normal'>$0</b> is the
			default structure initialized by the rule. The <b style='mso-bidi-font-weight:
			normal'>$0</b> variable always has the attribute of the named rule set to true.
			The rule variables <b style='mso-bidi-font-weight:normal'>$1</b> through <b style='mso-bidi-font-weight:normal'>$9</b> correspond to the respective token
			expressions in the rule body.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note1</b>:  All
			rule names must contain only uppercase characters and must contain no non
			uppercase characters, numerals, or underscores.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note2</b>:  The
			<b style='mso-bidi-font-weight:normal'>$</b> symbol must not be used in an
			argument phrase, action, or condition rule anywhere except as a rule variable
			identifier <b style='mso-bidi-font-weight:normal'>$0</b> through <b style='mso-bidi-font-weight:normal'>$9</b>. If the condition or action rule
			requires a <b style='mso-bidi-font-weight:normal'>$</b> symbol, for instance
			inside a string constant, place the <b style='mso-bidi-font-weight:normal'>$</b>
			symbol in a user defined function which is called by the argument phrase,
			action, or condition rule.</p>  
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SBNF Notation  "></A>BNF Notation  </H2></P> 
            <div class="h2section" id="BNF Notation">
             			<p class=MsoBodyText>Syntax rule
			names, syntax feature names, but not constants, may have trailing BNF operators
			of <b style='mso-bidi-font-weight:normal'>"*"</b> or <b style='mso-bidi-font-weight:
			normal'>"+"</b> or <b style='mso-bidi-font-weight:normal'>"?"</b>. For example:</p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>SEQUENCE: Number+ ::
			(setq $0.Value $1) ::</b></p>
			<p class=MsoBodyText>Any syntax rule
			name and any syntax feature name (other than the special <b style='mso-bidi-font-weight:
			normal'>Eof</b> and <b style='mso-bidi-font-weight:normal'>Nop</b> features)
			may have trailing BNF operators. The user is required to make sure that the
			resulting rule does not cause the new compiler to loop endlessly on the input
			string. The BNF operators have the following meanings:</p>
			<p class=MsoBodyText style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo5;
			tab-stops:list .5in'>??&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			The <b style='mso-bidi-font-weight:normal'>"*"</b>
			operator signifies none or more (<i style='mso-bidi-font-style:normal'>may
			cause endless looping if specified inappropriately</i>). </p>
			<p class=MsoBodyText style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo5;
			tab-stops:list .5in'>??&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			The <b style='mso-bidi-font-weight:normal'>"+"</b>
			operator signifies one or more. </p>
			<p class=MsoBodyText style='margin-left:.5in;text-indent:-.25in;mso-list:l1 level1 lfo5;
			tab-stops:list .5in'>??&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			The <b style='mso-bidi-font-weight:normal'>"?"</b>
			operator signifies none or one.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note1</b>:  For
			syntax features, the BNF operators a vector of each repetition result. </p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note2</b>:  For
			syntax rules, the BNF operators return a vector of each repetition result.</p>
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="S$this"></A>$this</H2></P> 
            <div class="h2section" id="$this">
              	<p class=MsoBodyText>The <b style='mso-bidi-font-weight:normal'>$this</b> variable contains the current
			input character, at each invocation of a syntax rule with the <b style='mso-bidi-font-weight:normal'>+</b> and <b style='mso-bidi-font-weight:
			normal'>*</b> BNF command modifiers, during syntax analysis. The <b style='mso-bidi-font-weight:normal'>$this</b> variable can be used in
			connection with user defined condition rules, for example:</p>
			<p class=code>            <b style='mso-bidi-font-weight:normal'>MAIN:
			Any{(isNumber $this.Value)}*</b></p>
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SArgument Passing"></A>Argument Passing</H2></P> 
            <div class="h2section" id="Argument Passing">
             <p class=MsoBodyText>User defined
			rules may be passed arguments. A Lisp argument phrase, enclosed with the <b style='mso-bidi-font-weight:normal'>( )</b>
			symbol pair, will cause the user defined rule to receive the specified
			argument. Within a user defined rule definition, the <b style='mso-bidi-font-weight:
			normal'>%0</b> thru <b style='mso-bidi-font-weight:normal'>%9</b> variables
			represent any arguments which may have been passed to the rule as follows:</p>
			 <blockquote>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>QUALIFY:  DotOperator
			Name  QUALIFY(  (setq $0.Value (append |ref|: %0.Value
			$2.Value)) )</b></p>
			<p class=code style='margin-left:2.0in;text-indent:.5in'><b style='mso-bidi-font-weight:normal'>::
			$3.Value ::</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>QUALIFY:  DotOperator
			Name  :: (setq $.0.Value (append
			|ref|: %0.Value $2.Value)) ::</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>TERM: Name QUALIFY($1) ::
			$2 ::</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>TERM: Name :: $1 ::</b></p> 
			</blockquote>
			<p class=MsoBodyText>The <b style='mso-bidi-font-weight:normal'>TERM</b> rule will recognize all syntax of
			the form <b style='mso-bidi-font-weight:normal'>Name.Name.Name ...</b>  The rule returns when a Dot Operator no
			longer qualifies the name. The result is a structure with the attribute <b style='mso-bidi-font-weight:normal'>TERM = true</b>, and the <b style='mso-bidi-font-weight:normal'>Value</b> attribute containing the complete
			expression already reformed into a nested <b style='mso-bidi-font-weight:normal'>ref</b>  notation list.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    The
			<b style='mso-bidi-font-weight:normal'>%</b> symbol must not be used in an
			argument phrase, action, or condition rule anywhere except as a rule variable
			identifier <b style='mso-bidi-font-weight:normal'>%0</b> through <b style='mso-bidi-font-weight:normal'>%9</b>. If the argument phrase, action, or
			condition rule requires a <b style='mso-bidi-font-weight:normal'>%</b> symbol,
			for instance inside a string constant, place the <b style='mso-bidi-font-weight:
			normal'>%</b> symbol in a user defined function which is called by the argument
			phrase, action, or condition rule.</p>    
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SIterative Rules "></A>Iterative Rules </H2></P> 
            <div class="h2section" id="Iterative Rules ">
 			<p class=MsoBodyText>User defined
			rules may be repeated iteratively. Two forms of iteration are provided.  Enclose an action rule with <b style='mso-bidi-font-weight:normal'>&lt;&lt;
			&gt;&gt;</b> to cause the user defined rule to repeat. Enclose an action
			rule with &amp;&amp; &amp;&amp; to cause the user defined rule to substitute
			and repeat.</p>
			<p class=MsoBodyText><b>Rule
			repetition using the  &lt;&lt; &gt;&gt;
			rule form</b></p>
			<p class=MsoBodyText>The contents of
			the $0 variable remain intact. The builtin <b style='mso-bidi-font-weight:normal'>Eof</b>
			attribute name allows a rule to test for <u>End Of File</u> in the following
			rule:</p>
			<blockquote>
			<p class=MsoBodyText style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>SEXPR: Term Operator Term
			</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>                        &lt;&lt; (setq $.0.Value
			(appendList $0.Value (list (list $2.Value $1.Value $3.Value)))) &gt;&gt;</b></p>
			<p class=MsoBodyText style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>SEXPR: Operator Term
			&lt;&lt; (setq $.0.Value (list $1.Value $0.Value $2.Value)) &gt;&gt;</b></p>
			<p class=MsoBodyText style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>SEXPR: Eof :: $0 ::</b></p>
			</blockquote>
			<p class=MsoBodyText>The <b style='mso-bidi-font-weight:normal'>SEXPR</b> rule will recognize all syntax of
			the form <b style='mso-bidi-font-weight:normal'>Term Operator Term Operator
			Term Operator ...</b>  The rule returns
			when the End Of File is reached. The result is a structure with the attribute <b style='mso-bidi-font-weight:normal'>SEXPR = true</b>, and the <b style='mso-bidi-font-weight:normal'>Value</b> attribute containing the complete
			expression already reformed into a prefix notation list.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    The
			<b style='mso-bidi-font-weight:normal'>$n</b> symbol contains the repetition
			count for the rule. During the first iteration through the rule, the $n
			variable is set to 1.</p>
			<p class=MsoBodyText>&nbsp;</p>
			<p class=MsoBodyText><b>Rule
			repetition using the  &amp;&amp;
			&amp;&amp; rule form for substitution</b></p>
			<p class=MsoBodyText>Use the
			&amp;&amp; &amp;&amp; action rule form to match and substitute tokens in the
			input. Like the &lt;&lt; &gt;&gt; action rule syntax, &amp;&amp; &amp;&amp;
			causes the rule to repeat until no more matches are found. Using the &amp;&amp;
			&amp;&amp; rule form allows the input stream to be treated like a working set.</p>
			<p class=MsoBodyText>Consider the
			following example.</p>
			<blockquote>   
			<pre>
			<p class=code><b>#SyntaxRules#</b></p>
			<p class=code><b>MAIN: MOVES ::
			$1.Value ::</b></p>
			<p class=code><b>MOVES:
			Direction Number &amp;&amp; (makemove $1.Value $2.Value) &amp;&amp;</b></p>
			<p class=code><b>MOVES: Moves
			Direction Number &amp;&amp; (makemove $1 $2.Value $3.Value)  &amp;&amp;</b></p>
			<p class=code><b>MOVES: Moves
			:: $1 ::</b></p>
			<p class=code><b>#end#</b></p>
			<p class=code><b>#UserDefinedFunctions#</b></p>
			<p class=code><b> (defchild moveCompiler:makemove (...)</b></p>
			<p class=code><b>            vars(moves)</b></p>
			<p class=code><b>            (if (= (argCount) 2) ; Create new
			Moves token structure</b></p>
			<p class=code><b>                        (setq moves (new
			Structure: Moves: true </b></p>
			<p class=code style='margin-left:1.0in;text-indent:.5in'><b>Value: (new Vector: 2 (argFetch 0)
			(argFetch 1)))</b></p>
			<p class=code><b>            else</b></p>
			<p class=code><b>                        (begin ; Add to existing
			Moves token structure</b></p>
			<p class=code><b>                        (setq moves (argFetch
			0))</b></p>
			<p class=code><b>                        (setq
			moves.Value[(length moves.Value)]
			(argFetch 1))</b></p>
			<p class=code><b>                        (setq
			moves.Value[(length moves.Value)] (argFetch 2))</b></p>
			<p class=code><b>                        ))</b></p>
			<p class=code><b>            moves)</b></p>
			<p class=code><b>#end#               </b></p>
			 </pre>
			</blockquote>
			<p class=MsoBodyText>The &amp;&amp;
			&amp;&amp; rule form causes the replacement of the matched tokens with the
			result of the action expression. The result of the action expression is
			normally a structure as shown in the example above.</p>
			<p class=MsoBodyText>From the console,
			calling the moveCompiler would give the following result:</p>
			<p class=code>(writeln
			(moveCompiler "West 2 East 15 West 3 North 5")) ??</p>
			<p class=code>#("West" 2 "East"
			15 "West" 3 "North" 5)</p>  
			<p class=MsoBodyText>It is important
			to understand that the &amp;&amp; &amp;&amp; action rule form modifies the
			input stream in place and parses again from the token position substituted
			into. Consider the following illustration of this process give the source input
			in the example above:</p>
			<p class=MsoBodyText>Lexical output:</p>
			<p class=MsoBodyText style='text-indent:.25in'>n    Token Structure</p>
			<p class=code style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "West" Direction: true Charpos: 0}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 2 Number: true Charpos: 5}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "East" Direction: true Charpos: 7}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 15 Number: true Charpos: 12 }</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "West" Direction: true Charpos: 15}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 3 Number: true Charpos: 20}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "North" Direction: true Charpos: 22}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l9 level1 lfo6;
			tab-stops:list .75in'>7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 5 Number: true Charpos: 28}</p>
			<p class=MsoBodyText>After the first
			firing of the MOVES rule:</p>
			<p class=MsoBodyText style='text-indent:.25in'>n    Token Structure</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: #("West" 2) Moves: true }</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "East" Direction: true Charpos: 7}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 15 Number: true Charpos: 12 }</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "West" Direction: true Charpos: 15}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 3 Number: true Charpos: 20}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "North" Direction: true Charpos: 22}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l2 level1 lfo7;
			tab-stops:list .75in'>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 5 Number: true Charpos: 28}</p>
			<p class=MsoBodyText> After the second firing of the MOVES rule:</p>
			<p class=MsoBodyText style='text-indent:.25in'>n    Token Structure</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l4 level1 lfo8;
			tab-stops:list .75in'>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: #("West" 2 "East" 15) Moves: true }</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l4 level1 lfo8;
			tab-stops:list .75in'>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "West" Direction: true Charpos: 15}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l4 level1 lfo8;
			tab-stops:list .75in'>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 3 Number: true Charpos: 20}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l4 level1 lfo8;
			tab-stops:list .75in'>3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "North" Direction: true Charpos: 22}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l4 level1 lfo8;
			tab-stops:list .75in'>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 5 Number: true Charpos: 28}</p>
			<p class=MsoNormal>&nbsp;</p>
			<p class=MsoNormal>After the third
			firing of the MOVES rule:</p>
			<p class=MsoBodyText style='text-indent:.25in'>n    Token Structure</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l6 level1 lfo9;
			tab-stops:list .75in'>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: #("West" 2 "East" 15 "West" 3) Moves: true }</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l6 level1 lfo9;
			tab-stops:list .75in'>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: "North" Direction: true Charpos: 22}</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l6 level1 lfo9;
			tab-stops:list .75in'>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: 5 Number: true Charpos: 28}</p>
			<p class=MsoNormal>&nbsp;</p>
			<p class=MsoNormal>After the fourth
			firing of the MOVES rule:</p>
			<p class=MsoBodyText style='text-indent:.25in'>n    Token Structure</p>
			<p class=MsoBodyText style='margin-left:.75in;text-indent:-.5in;mso-list:l8 level1 lfo10;
			tab-stops:list .75in'>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			#{Value: #("West" 2 "East" 15 "West" 3 "North" 5) Moves: true
			}</p>        
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="STerm Conditions "></A>Term Conditions </H2></P> 
            <div class="h2section" id="Term Conditions">
            <p class=MsoBodyText>User defined
			rules may be also have user defined conditions attached. A Lisp condition
			phrase, enclosed with the <b style='mso-bidi-font-weight:normal'>{ }</b>  symbol pair, will cause the user defined
			rule to receive the specified condition. Within a user defined rule condition,
			the <b style='mso-bidi-font-weight:normal'>%0</b> thru <b style='mso-bidi-font-weight:
			normal'>%9</b> variables represent any arguments which may have been passed to
			the rule, while the <b style='mso-bidi-font-weight:normal'>$0</b> thru <b style='mso-bidi-font-weight:normal'>$9</b> variables represent any terms which
			may have been recognized by the rule.</p>
			<blockquote>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>STRING:  Quote{(= $n 1)}  &lt;&lt;  true  &gt;&gt;</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>STRING:  Any
			&lt;&lt;  (setq $0.Value
			(appendList $0.Value $1.Value)  &gt;&gt;</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>STRING:  Quote{(&gt; $n 1)}  ::  $0  ::</b></p>
			 </blockquote>
			<p class=MsoBodyText>The <b style='mso-bidi-font-weight:normal'>STRING</b> rule will recognize all syntax
			tokens inclosed within two quotes  The
			rule returns only when the second quote is recognized. User defined rules may
			have both argument passing and user defined conditions attached. The suer
			defined condition is always last, as follows.</p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>TERM:  NAME(%0){(= $1.Term true)}  ::
			$1  ::</b></p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    The
			<b style='mso-bidi-font-weight:normal'>%</b> symbol must not be used in an
			argument phrase, action, or condition rule anywhere except as a rule variable
			identifier <b style='mso-bidi-font-weight:normal'>%0</b> through <b style='mso-bidi-font-weight:normal'>%9</b>. If the argument phrase, action, or
			condition rule requires a <b style='mso-bidi-font-weight:normal'>%</b> symbol,
			for instance inside a string constant, place the <b style='mso-bidi-font-weight:
			normal'>%</b> symbol in a user defined function which is called by the argument
			phrase, action, or condition rule.</p>
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SMAIN Rule"></A>MAIN Rule</H2></P> 
            <div class="h2section" id="MAIN Rule">
 			<p class=MsoBodyText>The user must
			define a <b style='mso-bidi-font-weight:normal'>MAIN</b> rule in the compiler
			definition. The MAIN rule is the rule which the new compiler will invoke to
			start the syntax analysis phase. If there is no MAIN rule defined, no
			syntaxtical analysis will result.</p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>MAIN: STATEMENT Semicolon
			&lt;&lt; (setq $.0.Value (appendList $0.Value $1.Value)) &gt;&gt;</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>MAIN: Eof :: $0 ::</b></p>
			<p class=MsoBodyText>This sample <b style='mso-bidi-font-weight:normal'>MAIN</b> rule will recognize all syntax of
			the form <b style='mso-bidi-font-weight:normal'>statement; statement; statement;
			...</b>  The rule returns when the End Of
			File is reached. </p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    Remember
			to avoid excessive recursion errors by making strategic rules iterative instead
			of right recursive.</p>             
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SSpecial Rule Syntax "></A>Special Rule Syntax </H2></P> 
            <div class="h2section" id="Special Rule Syntax ">
  			<h4> Any </h4>		
			<p class=MsoBodyText>In direct mode,
			if a rule is to accept any token, use the
			<b style='mso-bidi-font-weight:normal'>Any</b>  attribute. This special test works because <b style='mso-bidi-font-weight:
			normal'>Any</b> tests the token directly and does not assume that it is feature
			based. For example:</p>
			<blockquote>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            ;;  This rule recognizes a plus sign between anything</b></p>
			<p class=code><b style='mso-bidi-font-weight:normal'>            RULE:  Any
			Any{(= $2 &quot;+&quot;)}  Any ::
			(setq $0.Value (list '+   $1  $3)) ::</b></p>
			 </blockquote>
			<h4> Eof </h4>
			<p class=MsoBodyText>If a rule is to
			test for end of file, use the  <b style='mso-bidi-font-weight:normal'>Eof</b>
			attribute. For example:</p>
			<p class=code><b style='mso-bidi-font-weight:normal'>
			;;  This rule recognizes an end
			of file condition</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            RULE:  Eof  :: $0 ::</b></p>
			<h4>Nop</h4>
			<p class=MsoBodyText>The special <b style='mso-bidi-font-weight:normal'>Nop</b> attribute always returns a constant
			token of #void. The <b style='mso-bidi-font-weight:normal'>Nop</b> attribute is
			designed to provide a test which always is true, but does not promote the token
			pointer (i.e. a no-operation rule). </p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>MAIN: STATEMENT Semicolon
			&lt;&lt; (setq $.0.Value (appendList $0.Value $1.Value)) &gt;&gt;</b></p>
			<p class=code><b style='mso-bidi-font-weight:normal'>MAIN: Eof
			:: $LIST   ::</b></p>
			<p class=MsoBodyText style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>MAIN: Nop :: (error "If
			we get here we have an invalid token") ::</b></p>
			<p class=MsoBodyText>This sample <b style='mso-bidi-font-weight:normal'>MAIN</b> rule will recognize all syntax of
			the form <b style='mso-bidi-font-weight:normal'>statement; statement;
			statement; ...</b>  However, if the MAIN
			rule encounters anything else (other than <b style='mso-bidi-font-weight:normal'>statement;</b>),
			then an error message will be returned. The rule returns when the End Of File
			is reached, or an error is generated.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>: If the <b style='mso-bidi-font-weight:
			normal'>Nop</b> test is used, <u>user ordering</u> of the specified rule is
			almost always required.</p>
			<h4>$N </h4>
			<p class=MsoBodyText>We may use a
			previously recognized parser variable to indicate a test for equality. For
			example:</p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            ;;  These two rules are equivalent</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            RULE:  Any  $1 :: $0 ::</b></p>
			<p class=code><b style='mso-bidi-font-weight:normal'>            RULE:  Any
			Any{(= $2 $1)}  :: $0 ::</b></p>
			<h4>%N </h4>
			<p class=MsoBodyText>We may use a
			previously passed parser argument variable to indicate a test for equality. For
			example:</p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            ;;  These two rules are equivalent</b></p>
			<p class=code style='mso-outline-level:1'><b style='mso-bidi-font-weight:normal'>            RULE:  Any  %0
			:: $0 ::</b></p>
			<p class=code><b style='mso-bidi-font-weight:normal'>            RULE:  Any
			Any{(= $2 %0)}  :: $0 ::</b></p>
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SAppend List Function "></A>Append List Function </H2></P> 
            <div class="h2section" id="Syntax Rule Definitions ">
   		    <p class=MsoBodyText>The builtin
			appendList function allows multiple arguments to be append together to form a
			list as follows:</p>
			<p class=code style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>(define
			X  '(5 6 7))</b></p>
			<p class=code style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>(define
			Y  '(10 20))</b></p>
			<p class=code style='text-indent:.5in'><b style='mso-bidi-font-weight:normal'>(appendList '+  X  Y)    ==&gt;      (+
			5 6 7 10 20)</b></p>
			<p class=MsoBodyText>The appendList
			function is builtin and may be used in any rule's action expression.<b style='mso-bidi-font-weight:normal'></b></p>
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SRule Precedence"></A>Rule Precedence</H2></P> 
            <div class="h2section" id="Rule Precedence">
        	<p class=MsoBodyText>This Lambda
			supports multiple rule definitions up to the limits of available memory. The
			rule precedence, within a rule, is determined by the parseLib, to maximize
			search speed, and is unpredictable by the user. However any RULE may have
			automatic rule ordering turned off by specifying the following special rule
			statement as the first statement of the rule.</p>
			<p class=code style='mso-outline-level:1'>            <b style='mso-bidi-font-weight:normal'>RULENAME:
			user ordering  ::  true
			::</b></p>
			<p class=MsoBodyText>If automatic rule
			ordering is turned off, the parseLib will attempt to use the rule ordering
			supplied by the programmer in the DEFINITIONS file. <u>If at all possible, the
			rule ordering, specified by the developer, will be closely followed by the
			parseLib in generating the compiler code</u>.</p>
			<p class=MsoBodyText><b style='mso-bidi-font-weight:normal'>Note</b>:    If
			the <b style='mso-bidi-font-weight:normal'><u>Eof</u></b> and/or <b style='mso-bidi-font-weight:normal'><u>Nop</u></b> special feature test are
			used in a rule, user ordering is advisable, because these tend to make it hard
			for parseLib to gues the correct ordering on its own.</p>             
            </div>
        <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P>

 

</BODY>
</HTML>