<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE Essay SYSTEM "../DTD/Essay.dtd">
<Essay>
	<KnowledgeBase>
	    <Title>mathLib Functions</Title>
		<Topic>Lisp</Topic>
		<SubTopic>Machine Learning</SubTopic>
		<HumanKeywords>Lambda  Machine Learning Programming </HumanKeywords>
	</KnowledgeBase>
	<Section>
	    <Heading>math.arrayFillColumn</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.arrayFillColumn">
			  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>arrayFillColumn</b> destructively fills the mth column vector with the new value.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.arrayFillColumn arrayVector A m newValue)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>A</th>
			        <td>The input array whose specified column vector is to be filled.</td>
			      </tr>
			      <tr>
			        <th>m</th>
			        <td>The index of the array column vector to be filled.</td>
			      </tr>
			      <tr>
			        <th>newValue</th>
			        <td>The new value with which the array column vector is to be filled.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The input array after the specified array column vector has been filled..</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>       
	<Section>
	    <Heading>math.arrayRegressionGuestimate</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.arrayRegressionGuestimate">
				    <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>arrayRegressionGuestimate</b> 
			      returns a vector containing the guestimated coefficients 
			      for a multivariable regression. The guestimated coefficients
			      result from averaging a series of simple linear regressions 
			      on pairs of variables, each independent variable paired with
			      the dependent variable.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.arrayRegressionGuestimate A)</pre>
			    <pre>(math.arrayRegressionGuestimate A Y)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>A</th>
			        <td>The N by M+1 array representing the original observations in the matrix form of X Y.</td>
			      </tr>
			      <tr>
			        <th>Y</th>
			        <td>(Optional) The N vector containing the dependent values.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The M+1 coefficient vector with the constant inserted in first position.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.arrayWidrowHoffRegression</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.arrayWidrowHoffRegression">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>arrayWidrowHoffRegression</b> 
		      returns the dense M coefficient vector giving the coefficients
		      with the best least squares fit of the variables with a constant
		      term inserted in the model. The method used is the Widrow-Hoff
		      iterative approximation.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.arrayWidrowHoffRegression X Y Gmax err)</pre>
		    <pre>(math.arrayWidrowHoffRegression X Y Gmax err RfSW)</pre>
		    <pre>(math.arrayWidrowHoffRegression X Y Gmax err RfSW printSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M array representing the original observations of the independent variables..</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The N vector containing the dependent values.</td>
		      </tr>
		      <tr>
		        <th>Gmax</th>
		        <td>The maximum number of optimization trials (generations) to attempt before 
		            returning the best set of coefficients available at that time.</td>
		      </tr>
		      <tr>
		        <th>err</th>
		        <td>A minimum error value which would terminate further optimization 
		            trials and return the best set of coefficients at that time. This
		            minimum error is expressed as the absolute value of the average error.</td>
		      </tr>
		      <tr>
		        <th>RfSW</th>
		        <td>(Optional)If present and true, return a linear regression Lambda, Rf,
		            with coefficient vector, Rf.C, and Rf.Error set to the proper values.</td>
		      </tr>
		      <tr>
		        <th>printSW</th>
		        <td>(Optional)If present and true, display each regression interation on the console.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+2 coefficient vector (with M+1th = error), AND the 0th term being an inserted constant.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.blackScholesDelta</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.blackScholesDelta">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>blackScholesDelta</b> 
		      return the Black-Scholes theoretical delta for an option from the specified data.
		      Note: Computes the option price as a percent of the current stock price,
		      therefore, the stock price is considered to be 1, and the variance is the
		      daily percent difference variance.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.blackScholesDelta optType strikePct daysExp dailyVar stockYield longBondYield)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>optType</th>
		        <td>The option type (either "call" or "put").</td>
		      </tr>
		      <tr>
		        <th>strikePct</th>
		        <td>The strike price as a percent of the current price.</td>
		      </tr>
		      <tr>
		        <th>daysExp</th>
		        <td>The number of days until expiration..</td>
		      </tr>
		      <tr>
		        <th>dailyVar</th>
		        <td>The daily percentage variance of the stock for past 365 days.</td>
		      </tr>
		      <tr>
		        <th>stockYield</th>
		        <td>The annual dividend yield for stock as a percent.</td>
		      </tr>
		      <tr>
		        <th>longBondYield</th>
		        <td>The annual long bond interest rate.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The Black-Scholes theoretical delta for an option, as a percent of the current price.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.blackScholesPrice</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.blackScholesPrice">
		    <p class=description>The <b>blackScholesPrice</b> 
		      return the Black-Scholes theoretical price for an option from the specified data.
		      Note: Computes the option price as a percent of the current stock price,
		      therefore, the stock price is considered to be 1, and the variance is the
		      daily percent difference variance.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.blackScholesPrice optType strikePct daysExp dailyVar stockYield longBondYield)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>optType</th>
		        <td>The option type (either "call" or "put").</td>
		      </tr>
		      <tr>
		        <th>strikePct</th>
		        <td>The strike price as a percent of the current price.</td>
		      </tr>
		      <tr>
		        <th>daysExp</th>
		        <td>The number of days until expiration..</td>
		      </tr>
		      <tr>
		        <th>dailyVar</th>
		        <td>The daily percentage variance of the stock for past 365 days.</td>
		      </tr>
		      <tr>
		        <th>stockYield</th>
		        <td>The annual dividend yield for stock as a percent.</td>
		      </tr>
		      <tr>
		        <th>longBondYield</th>
		        <td>The annual long bond interest rate.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The Black-Scholes theoretical price for an option, as a percent of the current price.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.coefficientsToFormula</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.coefficientsToFormula">
			   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>coefficientsToFormula</b> 
		      returns a javaScript formula from the specified M+1 coefficient 
		      vector and the field name vector of length M.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.coefficientsToFormula coefficients fieldNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>coefficients</th>
		        <td>The M+1 coefficient vector (0 = constant term, and e = M+1 term).</td>
		      </tr>
		      <tr>
		        <th>fieldNames</th>
		        <td>The field name vector, of length M, with which the javaScript formula will be constructed.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The javaScript formula of the format (append coefficients[0] "+(" coefficients[1] "*" fieldNames[0] ")+(" ...).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.convertToArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.convertToArray">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>convertToArray</b> 
		       converts the input arguments to a vector array. A rank one
		       vector or matrix is converted into a rank two column
		       vector array. A rank two matrix is converted into a rank
		       two vector array. If the optional dependent variable vector
		       Y is present, a rank two XY vector array is always returned.</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.convertToArray X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The rank one or rank two vector or matrix to be converted.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional) A vector of dependent variable values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The XY vector array resulting from the conversion.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><b>Note1:</b> A math Lambda vector array must be an object vector of
		       length N, each element of which is a number vector of
		       length N.</P>
		    <p><b>Note2:</b> If the argument is already a rank two vector and
		    no Y argument is present, then no conversion is performed.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.convertToColumnVector</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.convertToColumnVector">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>convertToColumnVector</b> 
		       returns the vector extracted from the mth column of the
		       input array: #(w[0][m] w[1][m] .... w[N][m])</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.convertToColumnVector X m)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M vector array to be converted.</td>
		      </tr>
		      <tr>
		        <th>m</th>
		        <td>The mth column from which to extract the vector.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The mth column vector of length N.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.convertToMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.convertToMatrix">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>convertToMatrix</b> 
		       converts the input arguments to a matrix. A rank one
		       vector or matrix is converted into a rank two number matrix.
		       If the optional dependent variable vector
		       Y is present, a rank two XY number matrix is always returned.</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.convertToMatrix X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The rank one or rank two vector or matrix to be converted.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional) A vector of dependent variable values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The XY number matrix resulting from the conversion.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><b>Note1:</b> A math Lambda vector array must be an object vector of
		       length N, each element of which is a number vector of length N.</P>
		    <p><b>Note2:</b> If the argument is already a rank two matrix and
		    no Y argument is present, then no conversion is performed.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.convertToMatrixC</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.convertToMatrixC">
		  <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>convertToMatrixC</b> 
		       converts the input arguments to a matrix. A rank one
		       vector or matrix is converted into a rank two number matrix.
		       If the optional dependent variable vector
		       Y is present, a rank two XY number matrix is always returned.
		       In all cases an additional column is inserted into location zero
		       of the converted matrix. This constant column is filled with all 
		       ones, making it ready for the various regression algorithms.</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.convertToMatrixC X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The rank one or rank two vector or matrix to be converted.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional) A vector of dependent variable values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The XY number matrix resulting from the conversion.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><b>Note1:</b> A math Lambda vector array must be an object vector of
		       length N, each element of which is a number vector of length N.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.copyToMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.copyToMatrix">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>copyToMatrix</b> 
		       copies a rank one or two vector or a rank one matrix
		       into a rank two matrix.</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.copyToMatrix X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The rank one or rank two vector or matrix to be copied.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The XY number matrix resulting from the copy.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><b>Note1:</b> A math Lambda vector array must be an object vector of
		       length N, each element of which is a number vector of length N.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.correlation</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.correlation">
			  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>correlation</b> 
			       returns the correlation coefficient statistics 
			       for the two vectors.</P>         
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.correlation X Y)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>X</th>
			        <td>A vector of length N.</td>
			      </tr>
			      <tr>
			        <th>Y</th>
			        <td>A vector of length N.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The correlation coefficient of x and y</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>          
	<Section>
	    <Heading>math.covariance</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.covariance">
			 <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>covariance</b> 
			       returns the covariance coefficient statistics 
			       for the two vectors.</P>         
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.covariance X Y)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>X</th>
			        <td>A vector of length N.</td>
			      </tr>
			      <tr>
			        <th>Y</th>
			        <td>A vector of length N.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The covariance coefficient of x and y</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.cummNormalDensity</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.cummNormalDensity">
			  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>cummNormalDensity</b> 
			       returns the cummulative normal density 
			       for the specified input.</P>         
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.cummNormalDensity x)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>x</th>
			        <td>The value whose cummulative normal density is to be returned.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The cummulative normal density of x.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.cursorRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.cursorRegress">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>cursorRegress</b> 
		       returns the sparse M coefficient vector for the fields 
		       with the best least squares fit of the variables.
		       The field names vector is used to construct an N by M+1 array
		       where the M+1 column represents the dependent variable
		       (the last field name in the vector).</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.cursorRegress cursor fieldNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The dataMineLib memory cursor from which the N by M+1 array will be extracted.</td>
		      </tr>
		      <tr>
		        <th>fieldNames</th>
		        <td>The vector of field names which are to become the colums of the N by M+1 array.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td> The M+1 coefficient vector (0 = constant term, and e = M+1 term).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p>The cursor is NOT restored before the regression array is
		       extracted. This enables conditional regression on partial row sets.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.cursorToArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.cursorToArray">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>cursorToArray</b> 
		       returns a regression array from the cursor and table
		       fields specified. 
		       The field names vector is used to construct an N by M+1 array
		       where the M+1 column represents the dependent variable
		       (the last field named in the field names vector).</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.cursorToArray cursor fieldNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The dataMineLib memory cursor from which the N by M+1 array will be extracted.</td>
		      </tr>
		      <tr>
		        <th>fieldNames</th>
		        <td>The vector of field names which are to become the colums of the N by M+1 array.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td> The N by M+1 regression array with the dependent variable in the last column.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p>The cursor is NOT restored before the regression array is
		       extracted. This enables conditional regression on partial row sets.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.cursorToMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.cursorToMatrix">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>cursorToMatrix</b> 
		       returns a regression matrix from the cursor and table
		       fields specified. 
		       The field names vector is used to construct an N by M+1 matrix
		       where the M+1 column represents the dependent variable
		       (the last field named in the field names vector).</P>         
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.cursorToMatrix cursor fieldNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The dataMineLib memory cursor from which the N by M+1 matrix will be extracted.</td>
		      </tr>
		      <tr>
		        <th>fieldNames</th>
		        <td>The vector of field names which are to become the colums of the N by M+1 matrix.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td> The N by M+1 regression matrix with the dependent variable in the last column.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p>The cursor is NOT restored before the regression matrix is
		       extracted. This enables conditional regression on partial row sets.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.cursorToVector</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.cursorToVector">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>cursorToVector</b> 
		       Returns a vector containing the values from the specified
		       column from the cursor specified. If the optional string
		       switch is present, the values are returned as a column
		       of strings ready for console display.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.cursorToVector cursor fieldName stringSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The dataMineLib memory cursor from which the N by M+1 matrix will be extracted.</td>
		      </tr>
		      <tr>
		        <th>fieldName</th>
		        <td>The field name which specifies the colum to be extracted.</td>
		      </tr>
		      <tr>
		        <th>stringSW</th>
		        <td>(Optional) True IFF row numbers are to be prefixed to each value as a display string;
		            otherwise, a number vector of column values is to be returned.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td> The vector of column values.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.egm</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.egm">
			   <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>egm</b> 
			       creates a new evolutionary grid machine Lambda instance.
			       Form 1: create a new egm instance with initial training information
			       (setq estimator (math.egm cursor analystName baseExpressions fieldExpressions trainExpressions maxDepth numGridBuckets numTopGridSel))
			       Form 2: create a new egm instance with previously saved egm state information
			       (setq estimator (math.egm s)) 
			       s is structure containing saved pvars from former instance of egm.
			       <br>
			       Call Form 1 to ready machine for training on a summary table cursor.
			       See egm.setMyPvars for logic behind Form 2.
			       The cursor is reduced to a dense XY sigmod vector array using the 
			       supplied baseExpressions, fieldExpressions and trainExpressions.
			       <br>
			       Evolutionary grid machines (egm) are quasi regression engines which
			       learn and make regression estimates on XY vector arrays such as:
			       <br>
			       XY:  An NumRows by NumX + NumY array representing the original observations
			       in the matrix form of:    X Y
			       <br>
			       NumRows is the number of rows in the observation set.
			       NumX is the number of independent columns (x values).
			       NumY is the number of dependent columns (y values) for which regressions are to be peformed.
			       <br>
			       The XY vector array is constructued by applying the baseExpressions against
			       the cursor to reduce the cursor to NumRows. Then the fieldExpressions 
			       are applied to the cursor to produce NumX independent columns (x values). Then
			       the trainExpressions are applied to the cursor to produce NumY dependent
			       columns (y values). Then the XY vector is crunched to a dense sigmod vector
			       for the independent columns.
			       <br>
			       The resulting XY dense sigmod vector is stored in the egm pvars and is
			       persistent across multiple calls to egm.trainMachine
			       <br>
			       The egm is designed to process very large numbers of cross correlations
			       of the variables in the independant colums. This is accomplished by
			       keeping a top result list, for each dependent column, of only the best 
			       performing correlations and associated rows. The results from every 
			       cross-correlation are not kept and this vastly reduces the persistant 
			       storage required to store the results of machine training.
			       <br>
			       The egm.trainMachine Lambda is passed an argument that specifies some amount
			       of time within which training will be completed. Each time trainMachine is
			       called, new training, not previously performed, will be done.</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.egm cursor analystName baseExpressions fieldExpressions trainExpressions maxDepth numGridBuckets numTopGridSel)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>cursor</th>
			        <td>The dataMineLib memory cursor from which to seed the new egm machine.</td>
			      </tr>
			      <tr>
			        <th>baseExpressions</th>
			        <td>List of fitler expressons to apply to table.</td>
			      </tr>
			      <tr>
			        <th>fieldExpressions</th>
			        <td>List of field expressions to apply to table to generate independent columns (x values).</td>
			      </tr>
			      <tr>
			        <th>trainExpressions</th>
			        <td>List of training expressions to apply to table to generate dependent columns (y values)</td>
			      </tr>
			      <tr>
			        <th>maxDepth</th>
			        <td>Maximum depth of column cross correlation to perform. Can not exceed 10</td>
			      </tr>
			      <tr>
			        <th>numGridBuckets</th>
			        <td>Optional - Number of grid buckets (default is 100 for a percentile grid)</td>
			      </tr>
			      <tr>
			        <th>numTopGridSel</th>
			        <td>Optional - Number of top grid selectors to keep for each trainExpression (default is 100)</td>
			      </tr>
			      <tr>
			        <th>PreviousPeriods</th>
			        <td>Optional - Vector of TVAL dates for PreviousPeriods to process in trainMachine (default is empty vector)</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>A new evolutionary grid machine Lambda instance.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.egm.runMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.egm.runMachine">
			 <p class=overview>Overview</p>
		    <p></p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		   </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.egm.selfTest</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.egm.selfTest">
				 <p class=overview>Overview</p>
			    <p></p>
			    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.egm.trainMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.egm.trainMachine">
			 <p class=overview>Overview</p>
		    <p></p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.defaultRegressNet</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.defaultRegressNet">
			<p class=overview>Overview</p>
		    <p></p>
		    <p><font color='red'>[...under construction...]</font></P> 
		  </div>
	    ]]></Description>
	</Section>
		<Section>
	    <Heading>math.gaussianEliminate</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.gaussianEliminate">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>gaussianEliminate</b> function 
		       triangulates the M by M+1 coefficient array representing 
		       a system of M simultaneous linear equations in M variables.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.gaussianEliminate XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The M by M+1 coefficient array to be triangulated.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M+1 coefficient array after triangulation.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.gaussianSubstitute</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.gaussianSubstitute">
			  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>gaussianSubstitute</b> function 
			       returns the M coefficient vector from a triangulated array
			       representing a system of M simultaneous linear equations in 
			       M variables.</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.gaussianSubstitute T)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>T</th>
			        <td>The M by M triangulated array representing a system of M simultaneous linear equations in M variables.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The M coefficient vector representing a solution for the M variables.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.linearRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.linearRegress">
			<p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>linearRegress</b> function 
			       returns a vector containing the coefficients resulting
			       from a linear regression on two variables.
			       <br>If the matrix XY is an N by 2 matrix with the independent variable, X,
			       in the first column and the dependent variable, Y, in the last column,
			       <br>then (linearRegress XY) returns #(a  b  error),
			       <br>where a + bX = Y represents the least squares best fit.
			       The term, error, is the least squares error = sqr(y - (a + bx)).</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.linearRegress XY)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>XY</th>
			        <td>The N by 2 array representing the original observations in the matrix form of:  X Y.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The coefficient vector #(a b error)</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.makeCorrelationMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeCorrelationMatrix">
			  <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>makeCorrelationMatrix</b> function 
		       returns The N by (M*M) cross correlation matrix containing
		       all possible cross correlations of the original input
		       features, known as the correlation matrix.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.makeCorrelationMatrix X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M matrix representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N by (M*M) matrix containing all possible cross
		        correlations of the original observations in the
		        form of Xc[n,((i*M)+j)] = X[n,i]*X[n,j] for all i in M and all j in M.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>               
	<Section>
	    <Heading>math.makeGaussianArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeGaussianArray">
			 <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>makeGaussianArray</b> function 
		       returns the M by M+1 system of linear equations representing
		       the coefficient derivative equations for the least squares
		       error fit.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.makeGaussianArray XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing a system of N simultaneous linear equations in M variables.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M+1 array containing the dot products of the column 
		        vectors of the original observation array XY,
		        where: X[i,j] = vectorInnerProduct(Xcol[i],Xcol[j])</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><b>Note1:</b>See Sedgewick[2] chap 38.
		    <p><b>Note2:</b>The Gaussian array represents the coefficients of the derrivatives
		    of the least squares conversion of the original observation array in preparation for least squares regression.</P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.makeGaussianMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeGaussianMatrix">
			  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>makeGaussianMatrix</b> function 
			       returns the M by M+1 system of linear equations representing
			       the coefficient derivative equations for the least squares
			       error fit.</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.makeGaussianMatrix XY)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>XY</th>
			        <td>The N by M+1 array representing a system of N simultaneous linear equations in M variables.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The M by M+1 matrix containing the dot products of the column 
			        vectors of the original observation array XY,
			        where: X[i,j] = vectorInnerProduct(Xcol[i],Xcol[j])</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><b>Note1:</b>See Sedgewick[2] chap 38.
			    <p><b>Note2:</b>The Gaussian matrix represents the coefficients of the derrivatives
			    of the least squares conversion of the original observation array in preparation for least squares regression.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.makeGramArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeGramArray">
			   <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>makeGramArray</b> function 
			       returns the N by N array containing the dot products 
			       of the input vectors, known as the Gram array.</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.makeGramArray XY)</pre>
			    <pre>(math.makeGramArray X Y)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>XY</th>
			        <td>The N by M+1 array representing a system of N simultaneous linear equations in M variables.</td>
			      </tr>
			      <tr>
			        <th>Y</th>
			        <td>(Optional) The N column vector representing the dependent variables.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The N by N array containing the dot products of the row 
			        vectors of the original observation array XY,
			        where: G[i,j] = vectorDotProduct(XYrow[i],XYrow[j])</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><b>Note1:</b>See Cristianini, "Support Vector Machines", page 169.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.makeGramMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeGramMatrix">
				  <p class=overview>Overview</p>
			    <p></p>
			    <p class=description>The <b>makeGramMatrix</b> function 
			       returns the N by N matrix containing the dot products 
			       of the input vectors, known as the Gram matrix.</P>        
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.makeGramMatrix XY)</pre>
			    <pre>(math.makeGramMatrix X Y)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>XY</th>
			        <td>The N by M+1 array representing a system of N simultaneous linear equations in M variables.</td>
			      </tr>
			      <tr>
			        <th>Y</th>
			        <td>(Optional) The N column vector representing the dependent variables.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>The N by N matrix containing the dot products of the row 
			        vectors of the original observation array XY,
			        where: G[i,j] = vectorDotProduct(XYrow[i],XYrow[j])</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><b>Note1:</b>See Cristianini, "Support Vector Machines", page 169.</P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.makeIdentityMatrix</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.makeIdentityMatrix">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>makeIdentityMatrix</b> function 
		       returns the N by N identity matrix with 1's only 
		       along the diagonal and zero's everywhere else.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.makeIdentityMatrix N)</pre>
		    <pre>(math.makeIdentityMatrix N C)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>N</th>
		        <td>The number of rows and columns in the identity matrix.</td>
		      </tr>
		      <tr>
		        <th>C</th>
		        <td>(Optional) The alternative diagonal constant (defaults to 1.0).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N by N identity matrix, in the form of:
		            <br>1 0 ... 0 0
		            <br>0 1 ... 0 0
		            <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;... 
		            <br>0 0 ... 1 0
		            <br>0 0 ... 0 1</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixColToVector</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixColToVector">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixColToVector</b> function 
		       returns the N by N identity matrix with 1's only 
		       along the diagonal and zero's everywhere else.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixColToVector X c N)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The matrix from which the column vector is to be extracted.</td>
		      </tr>
		      <tr>
		        <th>N</th>
		        <td>The number of rows to include in the final column vector (must be less than or egual to the number of rows in X.</td>
		      </tr>
		      <tr>
		        <th>C</th>
		        <td>The column of X to be extracted.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N vector containing the values from the C column of the matrix X.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>             
	<Section>
	    <Heading>math.matrixDualGramRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixDualGramRegress">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixDualGramRegress</b> function 
		       returns the dense N coefficient vector giving the coefficients
		       with the best least squares fit of the variables, in dual Gram
		       matrix form.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixDualGramRegress X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M array or matrix representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The separate N column vector containing the dependent variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N+1th coefficient vector (with N+1th = stdError, avgError, minError, maxError, avgY).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'><b>Note:</b>See Cristianini, "Support Vector Machines" chap 2.</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixDualGramRegressC</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixDualGramRegressC">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixDualGramRegressC</b> function 
		       returns the dense N coefficient vector giving the coefficients
		       with the best least squares fit of the variables, in dual Gram
		       matrix form, with constant term inserted before the first column.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixDualGramRegressC X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M array or matrix representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The separate N column vector containing the dependent variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N+1th coefficient vector (with N+1th = stdError, avgError, minError, maxError, avgY).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'><b>Note:</b>See Cristianini, "Support Vector Machines" chap 2.</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixFillColumn</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixFillColumn">
			    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixFillColumn</b> function 
		       destructively fills the Cth column vector with the fill value.
		       The fill value may be a scalar or a vector.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixFillColumn X C newValue)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The matrix whose Cth column is to be filled.</td>
		      </tr>
		      <tr>
		        <th>C</th>
		        <td>The index of the matrix column to be filled.</td>
		      </tr>
		      <tr>
		        <th>fillValue</th>
		        <td>The value which is to fill the Cth column of the matrix.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The original input matrix with the specified column filled.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixFillRow</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixFillRow">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixFillRow</b> function 
		       destructively fills the Rth row vector with the fill value.
		       The fill value may be a scalar or a vector.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixFillRow X R newValue)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The matrix whose Rth row is to be filled.</td>
		      </tr>
		      <tr>
		        <th>R</th>
		        <td>The index of the matrix row to be filled.</td>
		      </tr>
		      <tr>
		        <th>fillValue</th>
		        <td>The value which is to fill the Rth row of the matrix.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The original input matrix with the specified row filled.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixGaussianEliminate</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixGaussianEliminate">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixGaussianEliminate</b> function 
		       triangulates the M by M+1 coefficient matrix representing 
		       a system of M simultaneous linear equations in M variables.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixGaussianEliminate XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The M by M+1 coefficient matrix to be triangulated.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M+1 coefficient matrix after triangulation.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixGaussianSolve</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixGaussianSolve">
		  <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixGaussianSolve</b> function 
		       solves the M by M+1 system of M simultaneous linear 
		       equations in M variables, and returns the M vector 
		       containing the coefficients for each of the M variables.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixGaussianSolve X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The M by M matrix representing a system of M simultaneous linear equations in M variables.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The M vector representing the dependent variables.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M coefficient vector representing a solution for the M variables.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixGaussianSubstitute</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixGaussianSubstitute">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixGaussianSubstitute</b> function 
		       returns the M coefficient vector from a triangulated matrix
		       representing a system of M simultaneous linear equations in 
		       M variables.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.gaussianSubstitute XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The M by M+1 triangulated matrix representing a system of M simultaneous linear equations in M variables.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M coefficient vector representing a solution for the M variables.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixInvert</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixInvert">
			   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixInvert</b> function 
		       returns the inversion of the N by N input matrix using 
		       gaussian LU decomposition, without pivoting, to reduce round 
		       off errors.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixInvert X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The M by M matrix to be inverted.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M matrix after inversion.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixInvertUpperTriangular</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixInvertUpperTriangular">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixInvertUpperTriangular</b> function 
		       returns the inversion of the M by M upper triangular input 
		       matrix, using gaussian substitution.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixInvertUpperTriangular U)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>U</th>
		        <td>The M by M matrix (upper triangular).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M matrix after inversion (also upper triangular).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixLower</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixLower">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixLower</b> function 
		       returns the lower triangular component matrix of the N by N 
		       input matrix using gaussian LU decomposition, without pivoting, 
		       to reduce round off errors.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixLower X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by N matrix to be lower triangulated.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N by N matrix after lower triangulation.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixMultipleRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixMultipleRegress">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixMultipleRegress</b> function 
		       returns the dense M+1 coefficient vector giving the coefficients
		       with the best least squares fit of the variables.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixMultipleRegress XY)</pre>
		    <pre>(math.matrixMultipleRegress X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 matrix representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional)A separate vector contains the dependent values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (with M+1th = stdError, avgError, minError, maxError, avgY).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixMultipleRegressC</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixMultipleRegressC">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixMultipleRegressC</b> function 
		       returns the dense M+1 coefficient vector giving the coefficients
		       with the best least squares fit of the variables. A constant
		       column is added to the input matrix.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixMultipleRegressC XY)</pre>
		    <pre>(math.matrixMultipleRegressC X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 matrix representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional)A separate vector contains the dependent values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (with M+1th = stdError, avgError, minError, maxError, avgY).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixMultiply</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixMultiply">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixMultiply</b> function 
		       Returns The M by N matrix product from multiplying A times B, 
		       where A is maximally an M by K matrix, and B is maximally a
		       K by N matrix.
		       <br>
		       Minimally the A component may be a scalar, a vector, a row vector, 
		       a column vector, a vector array, or a matrix. In each case,
		       the appropriately shaped product result will be returned.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixMultiply A B)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>A</th>
		        <td>The M by K matrix representing the left matrix.</td>
		      </tr>
		      <tr>
		        <th>B</th>
		        <td>The K by N matrix representing the right matrix.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by N matrix containing the dot products of the row 
		            vectors of the left matrix A, with the column vectors
		            of the right matrix B,
		            where: AB[m,n] = vectorInnerProduct(rowA[m],colB[n]).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>             
	<Section>
	    <Heading>math.matrixNormalize</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixNormalize">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixNormalize</b> function 
		       Normalizes the column values in a matrix. Each matrix
		       cell value is normalized by finding the high and low
		       range for the value's column, then value is converted 
		       into a fraction (0 ... 1) of it's column's high-low range.
		       <br>
		       Minimally the A component may be a scalar, a vector, a row vector, 
		       a column vector, a vector array, or a matrix. In each case,
		       the appropriately shaped product result will be returned.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixNormalize A)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>A</th>
		        <td>The M by N matrix to be normalized.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by N matrix with normalized columns.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixRowToVector</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixRowToVector">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixRowToVector</b> function 
		       returns the M number vector which is the specified 
		       row of the N by M matrix input matrix.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixRowToVector X r M)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M matrix whose specified row is to be extracted.</td>
		      </tr>
		      <tr>
		        <th>r</th>
		        <td>The row which is to be extracted.</td>
		      </tr>
		      <tr>
		        <th>M</th>
		        <td>The maximum number of elements to extract into the row vector.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The and M number vector which is the specified row of the N by M matrix input matrix.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>   		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixTranspose</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixTranspose">
		   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixTranspose</b> function 
		       returns The N by M matrix transposition of the M by N input matrix.
		       The input matrix may be a scalar, a vector, a row vector, 
		       a column vector, a vector array, or a matrix. In each case,
		       the appropriately shaped product result will be returned.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixTranspose X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The M by N matrix to be transposed.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The N by M matrix transposition.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixTriangulate</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixTriangulate">
		    <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixTriangulate</b> function 
		       triangulates the M by M matrix using gaussian elimination 
		       to reduce round off error..</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixTriangulate X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The M by M matrix to be triangulated.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M matrix after triangulation.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixUpper</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixUpper">
			   <p class=overview>Overview</p>
		    <p></p>
		    <p class=description>The <b>matrixUpper</b> function 
		       returns the upper triangular component matrix of the M by M 
		       input matrix using gaussian LU decomposition, without pivoting, 
		       to reduce round off errors.</P>        
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixUpper X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The M by M matrix to be upper triangulated.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M by M matrix after upper triangulation.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.matrixWidrowHoffRegression</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.matrixWidrowHoffRegression">
			   <p class=description>The <b>matrixWidrowHoffRegression</b> 
		      returns the dense M coefficient vector giving the coefficients
		      with the best least squares fit of the variables with a constant
		      term inserted in the model. The method used is the Widrow-Hoff
		      iterative approximation.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.matrixWidrowHoffRegression X Y Gmax err)</pre>
		    <pre>(math.matrixWidrowHoffRegression X Y Gmax err RfSW)</pre>
		    <pre>(math.matrixWidrowHoffRegression X Y Gmax err RfSW printSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M matrix representing the original observations of the independent variables..</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The N vector containing the dependent values.</td>
		      </tr>
		      <tr>
		        <th>Gmax</th>
		        <td>The maximum number of optimization trials (generations) to attempt before 
		            returning the best set of coefficients available at that time.</td>
		      </tr>
		      <tr>
		        <th>err</th>
		        <td>A minimum error value which would terminate further optimization 
		            trials and return the best set of coefficients at that time. This
		            minimum error is expressed as the absolute value of the average error.</td>
		      </tr>
		      <tr>
		        <th>RfSW</th>
		        <td>(Optional)If present and true, return a linear regression Lambda, Rf,
		            with coefficient vector, Rf.C, and Rf.Error set to the proper values.</td>
		      </tr>
		      <tr>
		        <th>printSW</th>
		        <td>(Optional)If present and true, display each regression interation on the console.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+2 coefficient vector (with M+1th = error), AND the 0th term being an inserted constant.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.multipleRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.multipleRegress">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>multipleRegress</b> 
		      returns the sparse M coefficient vector for the factors 
		      with the best least squares fits of the variables.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.multipleRegress XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+2 coefficient vector (with M+1th = error), 
		            AND the 0th term being an inserted constant.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.multivariableRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.multivariableRegress">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>multivariableRegress</b> 
		      returns the sparse M coefficient vector for the factors 
		      with the best least squares fits of the variables.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.multivariableRegress XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (with M+1th = error).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.multivariableRegressC</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.multivariableRegressC">
		 <p class=overview>Overview</p>
		    <p class=description>The <b>multivariableRegressC</b> 
		      returns the dense M coefficient vector giving the coefficients
		      with the best least squares fit of the variables with a constant
		      term inserted in the model.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.multivariableRegressC XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+2 coefficient vector (with M+1th = error), 
		            AND the 0th term being an inserted constant.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.multivariableRegressIC</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.multivariableRegressIC">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>multivariableRegressIC</b> 
		      Returns the dense M coefficient vector giving the coefficients
		      with the best least squares fit of the variables with a constant
		      term inserted in the model. The method used is evolutionary
		      approximation.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.multivariableRegressIC XY)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing the original observations.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (with M+1th = error).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.normalizeArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.normalizeArray">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>normalizeArray</b> 
		      normalizes the column values in a array. Each array
		      cell value is normalized by finding the high and low
		      range for the value's column, then value is converted 
		      into a fraction (0 ... 1) of it's column's high-low range.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.normalizeArray XY)</pre>
		    <pre>(math.normalizeArray XY lastSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M array values to be normalized.</td>
		      </tr>
		      <tr>
		        <th>lastSW</th>
		        <td>(Optional) true if last column is to be unchanged.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The normalized array (all values are fractions).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress</b> 
		      returns the input estimator Lambda with numeric coefficients 
		      optimized against the specified objective function. The 
		      regression may be linear or nonlinear and will minimize any 
		      objective function. Neither the estimator Lambda nor the 
		      objective function are required to be continuous.
		      <br>
		      The problem sizes addressed by this Lambda are classified as:
		      <br><br>
		      &nbsp;&nbsp;o Small Problems (nominally 4 columns by 500 rows of data).
		      <br>
		      &nbsp;&nbsp;o Midsize Problems (nominally 20 columns by 5000 rows of data).
		      <br>
		      &nbsp;&nbsp;o Large scale Problems (nominally 100 columns by 25000 rows of data).
		      <br><br>
		      This Lambda uses many user selectable search strategies for 
		      estimator Lambda optimization. Each technology has its own 
		      strengths and weaknesses. Some are linear only. Some cannot be
		      used on large scale problems. As new technologies become available,
		      in the scientific community, they are made available here. The
		      currently supported numeric regression strategies are as 
		      follows.
		      <br><br>
		      <b><u>Multivariate Linear Regression:</u></b> This is the technology developed
		      by Gauss several centuries ago. It is deterministic and absolutely 
		      accurate, but limited to linear regression only. This strategy is
		      extremely fast and applicable for all small, midsize, and large
		      scale regression problems.
		      <br><br>
		      <b><u>Support Vector Machine Regression:</u></b> This is technology developed
		      by Vapnik and Platt in this century. It is non-deterministic,
		      incremental, but fairly accurate and capable of handling both
		      linear and non-linear regression tasks. This strategy is
		      reasonably fast and applicable for all small, midsize, and large
		      scale regression problems.
		      <br><br>
		      <b><u>Neural Net Regression:</u></b> This is technology developed by Hecht-
		      Nielson in the previous century. It is non-deterministic,
		      incremental, somewhat accurate, and capable of handling both
		      linear and non-linear regression tasks. This strategy is
		      somewhat fast but applicable for only small scale regression 
		      problems. Although it can handle more than 500 rows of data,
		      it has trouble handling more than 4 or so continuous column inputs.
		      <br><br>
		      <b><u>Genetic Evolutionary Regression:</u></b> This technology was developed
		      by Holland and Koza in the past century. It is non-deterministic,
		      incremental, fairly inaccurate but capable of handling both
		      linear and non-linear regression tasks. This strategy is
		      fairly slow and applicable for only small scale regression 
		      problems. It has trouble handling more than 500 or so rows.
		      There are three flavors of this technology. Evolve, uses a
		      real number genome. EvolveBinary uses a binary genome, and
		      evolveBinaryMemo uses a binary genome with memoizing.
		      <br><br>	 
		      <b><u>Induced Regression:</u></b> This is ad hoc technology defined by the
		      user. The regression technology to be used must be entirely
		      contained in the user supplied estimator Lambda. As examples
		      of such ad hoc, user defined technology, we supply estimator
		      regression Lambdas to implement nearest neighbor cluster 
		      regression, and euclidean induction regression. The speed 
		      and problem size applicability of these strategies is entirely
		      on the estimator Lambda supplied by the user.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress X Y Rf Gmax err)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td><b>(Option 1)</b>: The N by M+1 array of the original observations 
		            where each of the row vectors must be Number vectors.
		            <br>
		            <b>(Option 2)</b>: The N by M+1 number matrix of the observations   
		            <br>
		            <b>(Option 3)</b>: The N by M array of the independent variables
		            where each of the row vectors must be Number vectors.</td>
		      </tr>
		        <th>Y</th>
		        <td><b>(Option A)</b> #void (in which case the XY argument must be
		            either Option 1 or Option 2, and never Option 3. 
		            <br>
		           <b>(Option B)</b> The N number vector representing the dependent variables
		           <br><br>
		           Note: If Y is NOT #void then the first argument, X, must
		           be Option 3, and never Options 1 or 2.
		           <br>
		           Note:  Each of the available regression strategies will 
		           accept X and Y variables in any of the legal options
		           combinations. In all cases, data conversion will be
		           done for the user. To avoid expensive automatic
		           data conversions, use the following X Y input
		           options for each strategy as follows:
		           <br> 
		           <table>
		           <tr><th>Multivariate Linear Regression</th><td>X(Option 2) Y(Option A)</td></tr>
		           <tr><th>Support Vector Machine Regression</th><td>X(Option 3) Y(Option B)</td></tr>
		           <tr><th>Neural Net Regression</th><td>X(Option 1) Y(Option A)</td></tr>
		           <tr><th>Genetic Evolutionary Regression</th><td>X(Option 1) Y(Option A)</td></tr>
		           <tr><th>Induced Regression</th><td>...user defined...</td></tr>
		           </table></td>
		      </tr>
		      <tr>
		        <th>Rf</th>
		        <td>The estimator Lambda which maps a number vector, of length M,
		            into a single real number, Rf: Vm --> R, whose coefficients
		            are to be optimized. The estimator Lambda is in the form of
		            a function, (Rf mVector) ==> aNumber, and the coefficients
		            to be optimized are stored as a number vector Rf.C 
		            in the persistant variables of the Rf Lambda.
		            <br><br>
		            Note: The estimator Lambda, Rf, must be an Lambda containing
		            the following persistant (pvars) variables:
		            <br>
		            <table>
		            <tr><th>C</th><td>A number vector containing the coefficients to optimized</td></tr>
		            <tr><th>Error</th><td>The final score from the objective function</td></tr> 
		            <tr><th>G</th><td>The final generation count when optimization halted</td></tr>
		            <tr><th>Objective</th><td>The objective function which maps an N by M+1 observation 
		                array, X, using it's parent estimator Lambda, Rf, into 
		                a single positive real error value. The objective function 
		                is in the form of a child Lambda, (Rf.Objective X) ==> anErrorNumber.
		                The numericRegress Lambda attempts to optimize the estimator
		                Lambda coefficients, Rf.C, such that the objective 
		                function's resulting error value is minimized.</td></tr> 
		            <tr><th>P</th><td>The final population count when optimization halted</td></tr>
		            <tr><th>Strategy</th><td>The optimization strategy to use:</td></tr>
		            <tr><th></th><td>
		            <table>
		            <tr><th>#void</th><td>Genetic Evolutionary Algorithms (real number genome)</td></tr>  
		            <tr><th>evolve</th><td>Genetic Evolutionary Algorithms (real number genome)</td></tr>  
		            <tr><th>evolveBinary</th><td>Genetic Evolutionary Algorithms (binary genome)</td></tr>  
		            <tr><th>evolveBinaryMemo</th><td>Genetic Evolutionary Algorithms (binary genome) with memos</td></tr>  
		            <tr><th>induce</th><td>Induced Regression (user supplied technology)</td></tr>  
		            <tr><th>linear</th><td>Multivariate Linear Regression</td></tr>  
		            <tr><th>neural</th><td>Neural Net Regression</td></tr>  
		            <tr><th>svm</th><td>Support Vector Machine Regression</td></tr>
		            </table>
		            </td></tr>
		            </table>
		            <br>  
		            Note:  We supply a number of child Lambdas with expertise in constructing
		            estimator Lambdas for use with the various regression strategies. 
		            Reviewing the following child Lambdas and their documentation will
		            provide assistance in using each of the available regression 
		            techniques:
		            <br>
		            <table>
		            <tr><th>Multivariate Linear Regression</th><td>makeLinear</td></tr>
		            <tr><th>Support Vector Machine Regression</th><td>makeSVM</td></tr>
		            <tr><th>Neural Net Regression</th><td>makeNeural, makeSplitNeural</td></tr>
		            <tr><th>Genetic Evolutionary Regression</th><td>makeLinearEvolve, makeLogit,makeBExponential, makeExponential, makeSinusoidal, makeTailExponential</td></tr>
		            <tr><th>Induced Regression</th><td>makeCluster, makeEuclidean, makePolynomial, makeNeighbor, makeLinearNetwork</td></tr> 
		            </table>
		            </td>
		      </tr>
		      <tr>
		        <th>Gmax</th>
		        <td>The maximum number of optimization trials (generations) to attempt before
		            returning the best set of coefficients available at that time.</td>
		      </tr>
		      <tr>
		        <th>err</th>
		        <td>A minimum error value which would terminate further optimization 
		            trials and return the best set of coefficients at that time.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda, Rf, with all coefficients in Rf.C optimized.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p>The <b>math.numericRegress.selfTest</b> child Lambda
		       contains a number of examples demonstrating the use of these regression
		       techniques to solve test regression problems. Also included are 
		       examples of using the child Lambdas to construct estimator Lambdas 
		       for use with each regression strategy.</P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeBExponential</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeBExponential">  
		    <p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.makeBExponential</b> 
		      Genetic Evolutionary Regression: (binary genome)
		      <br>
		      Return an exponential regression estimator Lambda for
		      use with numericRegress. The estimator Lambda implements 
		      an exponential polynomial regression model, which has
		      been modified to prevent overflow.
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.
		      <br><br>	    
		      <b>Model</b>:
		      <br>
		      y = C[0] + C[1]*expt(X[0],C[2]) + ... +  C[2M]*expt(X[M-1],C[2M+1])</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeBExponential variableCount)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeCluster</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeCluster">      
		    <p class=overview>Overview</p><p></p>
			   <p class=description>The <b>numericRegress.makeCluster</b> 
			      Induced Regression:
			      <br><br>
			      Return a nearest neighbor cluster induction estimator Lambda
			      for use with numericRegress.  This estimator Lambda memorizes each unique 
			      independent vector, X, observed during the training period along with the 
			      average dependent variable, y, associated with the memorized observation, X. 
			      Additionally, all the observations are segmented into nearest neighbor 
			      euclidean clusters along each independent axis. For each cluster along 
			      each independent axis, the optimal multivariable regression coefficients 
			      are memorized.
			      <br><br>
			      During estimation, if the input X has been observed during training, then
			      the best estimate for y is the average y value seen for X during training.
			      If the input X has NOT been observed during training, then the best estimate
			      for y is the average y value, returned from the memorized optimal multivariable
			      regression coefficients, for each of the euclidean nearest neighbor clusters 
			      of X as on each independent axis as segmented during training. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeCluster variableCount filter)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>filter</th>
			        <td> The type of final output filter. Must be one of (binary, bipolar, continuous, or sigmoid).</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeEuclidean</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeEuclidean">   
		    <p class=overview>Overview</p><p></p>
			  <p class=description>The <b>numericRegress.makeEuclidean</b> 
			      Induced Regression:
			      <br><br>
			      Return a Euclidean induction regression estimator Lambda for use with
			      numericRegress. This estimator Lambda memorizes each unique independent 
			      vector, X, observed during the training period along with the average 
			      dependent variable, y, associated with the memorized observation, X.
			      <br><br>
			      During estimation, if the input X has been observed during training, then
			      the best estimate for y is the average y value seen for X during training.
			      If the input X has NOT been observed during training, then the best estimate
			      for y is the average y value for the euclidean nearest neighbors of X as 
			      memorized during training. The optimal neighborhood size is determined 
			      empirically during training. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeEuclidean variableCount filter)</pre>
			    <pre>(math.numericRegress.makeEuclidean variableCount filter crunch)</pre>
			    <pre>(math.numericRegress.makeEuclidean variableCount filter crunch errorOn)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>filter</th>
			        <td> The type of final output filter. Must be one of (binary, bipolar, continuous, or sigmoid).</td>
			      </tr>
			      <tr>
			        <th>crunch</th>
			        <td>(Optional)Input vector crunch function. Defaults to copy function
			            if missing or #void. Can be used to crunch input elements 
			            into deciles, percentiles, etc. After learning, during estimation 
			            phase, new observations are compared with the memorized crunched 
			            training samples stored during learning.
			            <br>&nbsp;&nbsp;o Does not effect the dependent variable. 
			            <br>&nbsp;&nbsp;o Only used during training. 
			            <br>&nbsp;&nbsp;o Must produce a copy of the original input vector.
			            <br>&nbsp;&nbsp;o Must NEVER mutate the original input vector.
			            <br><br>
			            May use the following symbols for specially prepared sigmoid
			            input crunching functions.
			            <br>&nbsp;&nbsp;o percentile:
			            <br>&nbsp;&nbsp;o decile:
			            <br>&nbsp;&nbsp;o quintile:
			            <br>&nbsp;&nbsp;o quartile:
			            <br>&nbsp;&nbsp;o trinary:
			            <br>&nbsp;&nbsp;o binary:
			            <br><br>
			            May use a number argument for specially prepared sigmoid
			            input crunching functions of the specified arity.</td>
			      </tr>
			      <tr>
			        <th>errorOn</th>
			        <td> True iff least squared errors are to be returned from the Objective function</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeExponential</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeExponential">    
		    <p class=overview>Overview</p><p></p>
		   <p class=description>The <b>numericRegress.makeExponential</b> 
		      Genetic Evolutionary Regression: (real number genome):
		      <br><br>
		      Return an exponential regression estimator Lambda for
		      use with numericRegress. The estimator Lambda implements 
		      an exponential polynomial regression model, which has
		      been modified to prevent overflow. 
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.
		      <br><br>
		      <b>Model</b>:
		      <br>
		      y = C[0] + C[1]*expt(X[0],C[2]) + ... +  C[2M]*expt(X[M-1],C[2M+1]).</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeExponential variableCount)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeLinear</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeLinear">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.makeLinear</b> 
		      Multivariable Linear Regression (Gaussian):
		      <br><br>
		      Return a linear regression estimator Lambda for 
		      use with numericRegress. The estimator Lambda implements 
		      a linear polynomial regression model, which has
		      been modified to prevent overflow. 
		      <br><br>
		      This model does NOT support a threshold constant at C[0].
		      The model assumes each coefficient C[m] is multiplied
		      by its paired variable X[m]. 
		      A threshold constant at C[0] can be achieved by setting
		      X[0] equal to one for all rows in the training data. The
		      resulting C[0] value will equal the threshold constant. 
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.
		      <br><br>
		      <b>Model</b>:
		      <br>
		      y = C[0]*X[0] + ... +  C[M-1]*X[M-1].</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeLinear variableCount)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeLinearEvolve</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeLinearEvolve">
				<p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makeLinearEvolve</b> 
			      Genetic Evolutionary Regression (real number genome):
			      <br><br>
			      Return a linear regression estimator Lambda for
			      use with numericRegress. The estimator Lambda implements 
			      a linear polynomial regression model, which has
			      been modified to prevent overflow. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.
			      <br><br>
			      <b>Model</b>:
			      <br>
			      y = C[0] + C[1]*X[0] + ... +  C[M]*X[M-1].</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeLinearEvolve variableCount)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeLinearNetwork</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeLinearNetwork">
			<p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makeLinearNetwork</b> 
			      Induced Regression:
			      <br><br>
			      Return a linear network regression estimator Lambda for use with 
			      numericRegress. This estimator Lambda memorizes each unique independent 
			      vector, X, observed during the training period along with the average 
			      dependent variable, y, associated with the memorized observation, X. 
			      Additionally, all the observations are segmented into nearest neighbor 
			      euclidean clusters along each independent axis. For each cluster along 
			      each independent axis, the optimal multivariable regression coefficients 
			      are memorized. 
			      <br><br>
			      During estimation, if the input X has been observed during training, then
			      the best estimate for y is the average y value seen for X during training.
			      If the input X has NOT been observed during training, then the best estimate
			      for y is the average y value, returned from the memorized optimal multivariable
			      regression coefficients, for each of the euclidean nearest neighbor clusters 
			      of X as on each independent axis as segmented during training. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeLinearNetwork variableCount filter)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>filter</th>
			        <td>The type of final output filter. Must be one of (binary, nbinary, bipolar, continuous, or sigmoid).</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeLogit</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeLogit">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.makeLogit</b> 
		      Genetic Evolutionary Regression (real number genome):
		      <br><br>
		      Return a logit regression estimator Lambda for use
		      with numericRegress. The estimator Lambda implements 
		      a logit polynomial regression model, which has been
		      modified to prevent overflow. 
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.
		      <br><br>
		      <b>Model</b>:
		      <br>
		      d = C[0] + abs(C[1])*X[0] + ... +  abs(C[M])*X[M]
		      <br>
		      y = exp(d) / (1 + exp(d))
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeLogit variableCount)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>                
	<Section>
	    <Heading>math.numericRegress.makeNeighbor</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeNeighbor">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.makeNeighbor</b> 
		      Induced Regression:
		      <br><br>
		      Return a nearest neighbor induction regression estimator Lambda
		      for use with numericRegress. This estimator Lambda memorizes each unique 
		      independent vector, X, observed during the training period along with the 
		      average dependent variable, y, associated with the memorized observation, X. 
		      Additionally, all the observations are segmented into nearest neighbor euclidean 
		      clusters along each independent axis. For each cluster along each independent 
		      axis, the optimal multivariable regression coefficients are memorized. 
		      <br><br>
		      During estimation, if the input X has been observed during training, then
		      the best estimate for y is the average y value seen for X during training.
		      If the input X has NOT been observed during training, then the best estimate
		      for y is the average y value, returned from the memorized optimal multivariable
		      regression coefficients, for each of the euclidean nearest neighbor clusters 
		      of X as on each independent axis as segmented during training. 
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeNeighbor variableCount filter)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>filter</th>
		        <td>The type of final output filter. Must be one of (binary, nbinary, bipolar, continuous, or sigmoid).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeNeural</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeNeural">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.makeNeural</b> 
		      Neural Net Regression:
		      <br><br>
		      Return a neural net regression estimator Lambda for 
		      use with numericRegress. The neural net will be a Hecht-Nielson style
		      neural net with one hidden layer. The number of neurons in the hidden
		      layer can be automatically calculated (from the Hecht-Nielson Theorem)
		      or the count of neurons in the hidden layer can be supplied by the user. 
		      <br><br>
		      <b>Notes</b>:
		      <br>
		      A standard least squares objective function is used.
		      <br>
		      Estimator training data must be a single N x M+1 vector array.
		      <br>
		      Estimator input must be a single number vector.</p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.makeNeural variableCount filter)</pre>
		    <pre>(math.numericRegress.makeNeural variableCount filter hidden)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>variableCount</th>
		        <td>The number of independent variables in the regression.</td>
		      </tr>
		      <tr>
		        <th>filter</th>
		        <td>The type of final output filter. Must be one of (binary, nbinary, bipolar, continuous, or sigmoid).</td>
		      </tr>
		      <tr>
		        <th>hidden</th>
		        <td>(Optional) The number of hidden layer neurons.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makePolynomial</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makePolynomial">
			   <p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makePolynomial</b> 
			      Induced Regression (uses ad hoc Gaussian methods):
			      <br><br>
			      Return a non-linear polynomial regression estimator Lambda
			      for use with numericRegress. The estimator Lambda implements 
			      a general non-linear polynomial regression model, which has
			      been modified to prevent overflow. 
			      <br><br>
			      This ad hoc regression technique attempts to reduce a
			      non-linear problem to a linear polynomial regression
			      where Gaussian methods can be applied. 
			      <br><br>
			      First, a general polynomial is computed, then it is raised
			      to a power, and a filter is applied to the output. To find
			      the polynomial regression coefficients, the filter and power
			      are reversed in the dependent variable, Y. Now we have a linear
			      relationship between X and Y and we can use Gaussian techniques. 
			      <br><br>
			      <u>Warning</u>: In order to be reversable, the power must be a positive,
			      odd, integer. Since we need all the positive integers
			      to create the family of Nth order polynomials, from which
			      all other functions can be simulated, this method tends
			      to over fit all problems where an even integer would 
			      suffice to fit the data. The sigmoid output filter has
			      been selected so that it can be easily reversed. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      The objective function computes the average
			      absolute tolerance (expressed as a percent of each dependent variable).
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.
			      <br><br>
			      <b>Model</b>:
			      <br>
			      p = expt( C[0]*X[0] + ... +  C[M-1]*X[M-1] , power )
			      <br>
			      (filter == continuous): y = p
			      <br>
			      (filter == sigmoid): y = exp(p) / (1 + exp(p))
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makePolynomial variableCount power filter ErrTolerance)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>power</th>
			        <td>The power to which the polynomial is to be raised (a positive, odd integer).</td>
			      </tr>
			      <tr>
			        <th>filter</th>
			        <td>The output filter for the polynomial (continuous, or sigmoid).</td>
			      </tr>
			      <tr>
			        <th>ErrTolerance</th>
			        <td>The tolerance limit to use in the regression.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeSinusoidal</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeSinusoidal">
			    <p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makeSinusoidal</b> 
			      Genetic Evolutionary Regression (real number genome):
			      <br><br>
			      Return a sinusoidal regression estimator Lambda for 
			      use with numericRegress. The estimator Lambda implements 
			      a sinusoidal polynomial regression model, which has
			      been modified to prevent overflow. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.
			      <br><br>
			      <b>Model</b>:
			      <br>
			      y = C[0]*X[1] + (C[1]*X[1])*sin(C[2]*X[0])
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeSinusoidal variableCount)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeSplitNeural</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeSplitNeural">      
					    <p class=overview>Overview</p><p></p>
				    <p class=description>The <b>numericRegress.makeSplitNeural</b> 
			      Neural Net Regression:
			      <br><br>
			      Return a neural net regression estimator Lambda for 
			      use with numericRegress. A split training methodology
			      splits the training set, during regression, into sample A(80%),
			      and sample B(20%). All neural backpropagation training is
			      done on sample A; while, all error statistics are run against
			      sample B. 
			      <br><br>
			      This is an implementation of "out of sample training", and
			      helps prevent over fitting (which can plague neural nets). 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.</p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeSplitNeural variableCount filter)</pre>
			    <pre>(math.numericRegress.makeSplitNeural variableCount filter hidden)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>filter</th>
			        <td>The type of final output filter. Must be one of (binary, nbinary, bipolar, continuous, or sigmoid).</td>
			      </tr>
			      <tr>
			        <th>hidden</th>
			        <td>(Optional) The number of hidden layer neurons.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeSVM</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeSVM">
			    <p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makeSVM</b> 
			      Support Vector Machine Regression:
			      <br><br>
			      Return a support vector machine regression estimator Lambda 
			      for use with numericRegress. The estimator Lambda implements 
			      a support vector machine polynomial regression model, which has
			      been modified to prevent overflow. The Support Vector Machine
			      creates a weighted polynomial dual model based on the Gram
			      matrix of the observations. 
			      <br><br>
			      Support Vector Machine regression can be highly accurate
			      when solving non-linear regression problems. However, the
			      accuracy varies from excellent to poor depending upon
			      the ratio of: the chosen Gaussian Sample Size (maxSVSize);
			      the number of regression variables (M); and the THEORETICAL
			      number of variables created by the kernel function to
			      make the non-linear problem linearly solvable. A simplified
			      example would be as follows. 
			      <br><br>
			      Solving a quadratic regression problem with variableCount == 3,
			      y = sum{m from 0 until variableCount}(Cm*Xm*Xm), and 
			      a kernel function of vectorSquareInnerProduct, is very
			      accurate with a Gaussian Sample Size (maxSVSize) of 10.
			      However, if the variableCount is increased to 10, then the
			      accuracy completely breaks down and is not restored until
			      the Gaussian Sample Size is increased to around 100. An
			      explanation is as follows. 
			      <br><br>
			      In order to make the quadratic regression linearly tractable,
			      the vectorSquareInnerProduct performs an on-the-fly squaring
			      of each training point vector. Thus, with a training point
			      vector of size three, the vectorSquareInnerProduct creates
			      the following on-the-fly THEORETICAL new training point:
			      kernel(X1,X2,X3) => (X1,X2,X3,X1*X1,X2*X2,X3*X3,X1*X2,X1*X3,X2*X3).
			      Clearly the problem is now linearly solvable because the squared
			      variables are now terms in the THEORETICAL on-the-fly linear regression
			      created by the kernel. NOTICE however, that the THEORETICAL linear
			      regression, created on-the-fly by the kernel function, has nine variables
			      not three variables as in the original quadratic problem. Unless the
			      number of training points is greater than nine, and the Gaussian 
			      sample size is greater than nine, the on-the-fly linear regression
			      will not have enough data to get accurate results. (The Lambda
			      math.numericRegress.selfTest contains a sample test case which
			      demonstrates the fall in accuracy as Gaussian Sample Size is decreased). 
			      <br><br>
			      This model does NOT support a threshold constant at C[0].
			      The model assumes each coefficient C[m] is multiplied
			      by its paired dual model variable: kernel(X[0],Xs). 
			      A threshold constant at C[0] can be achieved by setting
			      X[0] equal to one for all rows in the training data. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      The objective function computes the average
			      absolute tolerance (expressed as a percent of each dependent variable).
			      <br>
			      Estimator training data must be an N x M vector array, X, and an N number vector, Y.
			      <br>
			      Estimator input must be a single number vector.
			      <br><br>
			      <b>Model</b>:
			      <br>
			      y = C[0]*kernel(X[0],Xs) + ... +  C[M-1]*kernel(X[M-1],Xs)
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeSVM variableCount kernel ErrTolerance maxSVSize)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>kernel</th>
			        <td>The kernel function to use in the regression.</td>
			      </tr>
			      <tr>
			        <th>ErrTolerance</th>
			        <td>The error tolerance limit to use in the regression.</td>
			      </tr>
			      <tr>
			        <th>maxSVSize</th>
			        <td>The Gaussian sample size (maximum number of support vectors to use during Gaussian initialization -- defaults to 100).</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.makeTailExponential</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.makeTailExponential">
			    <p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.makeTailExponential</b> 
			      Support Vector Machine Regression:
			      <br><br>
			      Return an exponential tail estimator Lambda for 
			      use with numericRegress.  The estimator Lambda implements 
			      an exponential polynomial regression model, which has
			      been modified to prevent overflow. 
			      <br><br>
			      This objective function trys to maximize its best top N% and 
			      to minimize its bottom N%. The product, not the sum, of the
			      actual scores is used to force more wins/losses into each tail
			      during the training process. 
			      <br><br>
			      <b>Notes</b>:
			      <br>
			      A standard least squares objective function is used.
			      <br>
			      Estimator training data must be a single N x M+1 vector array.
			      <br>
			      Estimator input must be a single number vector.
			      <br><br>
			      <b>Model</b>:
			      <br>
			      y = C[0] + C[1]*expt(X[0],C[2]) + ... +  C[2M]*expt(X[M-1],C[2M+1])
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.makeTailExponential variableCount tailPct)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>variableCount</th>
			        <td>The number of independent variables in the regression.</td>
			      </tr>
			      <tr>
			        <th>tailPct</th>
			        <td>The percent of independent variables, top and bottom tail, to be optimized.</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns an estimator Lambda,Rf, suitable for use with the <b>numericRegress</b> Lambda.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.setRandom</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.setRandom">
			   <p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.setRandom</b> 
			      Return an exponential tail estimator Lambda for 
			      use with numericRegress.  The estimator Lambda implements 
			      an exponential polynomial regression model, which has
			      been modified to prevent overflow. 
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.setRandom randomSW seed)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>randomSW</th>
			        <td>The random number switch (true for random function, false for srandom function).</td>
			      </tr>
			      <tr>
			        <th>seed</th>
			        <td>The numeric seed for the srandom function (iff randomSW = false).</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns the new randomSW setting.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.numericRegress.selfTest</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.numericRegress.selfTest">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.selfTest</b> 
		      Perform a self test of the numericRegress general regression Lambda. 
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.numericRegress.selfTest)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns true if the self test is successful.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.percentileGridMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine">
	<p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.percentileGridMachine</b> 
			      Returns a new percentile grid machine Lambda ready for training.
			      <br><br>
			      Percentile grid machines are quasi regression engines which
			      learn and make regression estimates on XY vector arrays, where
			      XY is an N by M+1 array representing the original observations.
			      <br><br> 
			      The percentile grid machine constructs a percentile grid, of the
			      XY training data. The grid contains Bayesian equal probabalistic
			      percentile views of all possible N-way cross correlations of the 
			      independent columns in XY. Each row in the percentile grid contains
			      exactly 100 entries representing the average Y values for each
			      percentile of the specified N-way cross correlation of independent
			      variables.
			      <br><br> 
			      The percentile grid machine is designed to provide either 1-way,
			      2-way, 3-way, or 4-way column cross correlations. The PGM automatically
			      selects the largest number of columns to cross correlate which it can
			      fit into available resources. The percentile grid size is determined
			      by the number of independent columns, MX, and the number of columns
			      chosen for cross correlation, C. The number of rows in the percentile
			      grid is always equal to expt(MX,C).
			      <br><br> 
			      Percentile grid machines operate on entire vector arrays 
			      at once. For this reason percentile grid machines are not
			      strictly regression engines, and therefore are not included
			      in the math.numericRegress Lambda's tool set.
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(math.numericRegress.percentileGridMachine MGrid)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>MGrid</th>
			        <td>The number of cols in each row of the percentile training grid (default is 100 for percentile subdivisions).</td>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns, pgm, a new percentile grid machine Lambda ready for training.
			        On this pgm copy the user can invoke the functions pgm.reset, pgm.inputArray, pgm.inputCursor,
			        pgm.trainMachine, and pgm.runMachine.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.percentileGridMachine.inputArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine.inputArray">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.percentileGridMachine.inputArray</b> function
		      crunches the input vector array into a dense sigmoid XY training vector array.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(pgm.inputArray XY)</pre>
		    <pre>(pgm.inputArray XY Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array of independent variable observations 
		        (if no optional Y argument is present, then the M+1th column contains the dependent variable values).</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>(Optional) The N vector of dependent variable values.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, XY, the final crunched input array ready for training.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.percentileGridMachine.inputCursor</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine.inputCursor">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.percentileGridMachine.inputCursor</b> function
		      crunches the dataMineLib table memory cursor input into a dense sigmoid XY training vector array.
		      The dataMineLib table, which the cursor is managing, must have a field named: <i>SpecialSituationNotes</i>,
		      because the <i>SpecialSituationNotes</i> field is used as a scratch pad by this function.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(pgm.inputCursor cursor baseExpressions expressionVector)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>A dataMineLib memory cursor to be crunched into a dense sigmoid XY training vector array 
		        (The dataMineLib table, which the cursor is managing, must have a field named: <i>SpecialSituationNotes</i>,
		        because the <i>SpecialSituationNotes</i> field is used as a scratch pad by this function).</td>
		      </tr>
		      <tr>
		        <th>baseExpressions</th>
		        <td>The vector of javaScript filter expressions used to reduce the table BEFORE data extraction.
		        Selecting all cursor rows would require a baseExpression argument of: #("restore;").</td>
		      </tr>
		      <tr>
		        <th>expressionVector</th>
		        <td>The M+1 vector of javaScript filter expressions used to extract each column of
		        data from the cursor. The dependent variable is the M+1 expression. </td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, XY, the final crunched input array ready for training.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.percentileGridMachine.resetMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine.resetMachine">
			<p class=overview>Overview</p><p></p>
			    <p class=description>The <b>numericRegress.percentileGridMachine.resetMachine</b> 
			      Reset this percentile grid machine (clears all existing training memory).
			      </p>
			    <p></p>
			    <p class=type>Type: <font color='black'>Function</font></p>
			    <p></p>
			    <p class=syntax>Syntax</p>
			    <p></p>
			    <pre>(pgm.resetMachine)</pre>
			    <p></p>
			    <p class=arguments>Arguments</p>
			    <hr>
			    <table border="3" cellpadding="2" class=arguments>
				<colgroup><col class=arguments><col class=explanation></colgroup>
			      <tr>
			        <th>Arguments</th>
			        <th>Explanation</th>
			      </tr>
			      <tr>
			        <th>RETURN</th>
			        <td>Always returns true.</td>
			      </tr>
			    </table>
			    <hr>
			    <p></p>
			    <p class=whentouse>When To Use</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=example>Example</p>
			    <p><font color='red'>[...under construction...]</font></P>
			    <p></p>
			    <p class=notes>Notes &amp; Hints</p>
			    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>             
	<Section>
	    <Heading>math.percentileGridMachine.runMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine.runMachine">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.percentileGridMachine.runMachine</b> 
		      Run this percentile grid machine on the X sample vector array.
		      <br><br>
		      Percentile grid machines are quasi regression engines which
		      learn and make regression estimates on X vector arrays, where
		      X is an N by M array representing the independent observations.
		      <br><br> 
		      The percentile grid machine trains on a complete N by M+1 vector
		      array, XY. When the percentile grid machine runs, it only requires 
		      a complete N by M vector array, X, on which to make its predictions
		      concerning the estimated values of the dependent variable, Y.
		      <br><br> 
		      May be run on a vector array or a table cursor, as follows.
		      <br>
		      (Option 1)  (runMachine X {gridVector})
		      <br>
		      (Option 2)  (runMachine cursor baseExpressions expressionVector {gridVector})
		      <br><br> 
		      If a dataMineLib table memory cursor is passed as an argument, the <i>SpecialSituationNotes</i> field 
		      of each row in the table cursor will contain the new dependent variable, Yest, estimates.
		      <br><br> 
		      An optional gridVector argument provides an object vector of percentile grids
		      each of which will have an equal vote on the estimator values.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(pgm.runMachine X)</pre>
		    <pre>(pgm.runMachine X gridVector)</pre>
		    <pre>(pgm.runMachine cursor baseExpressions expressionVector)</pre>
		    <pre>(pgm.runMachine cursor baseExpressions expressionVector gridVector)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <p><b>(Option 1)</b></p>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M vector array, X, on which this machine is to make its predictions
		        concerning the estimated values for the dependent variable, Y.</td>
		      </tr>
		      <tr>
		        <th>gridVector</th>
		        <td>(Optional) An object vector of percentile grids each of which will have an equal vote on the estimator values
		        (the training grid inside this machine is ignored).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, Yest, an N vector of estimates for the dependent variable, Y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p><b>(Option 2)</b></p>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>A dataMineLib memory cursor to be crunched into a dense sigmoid XY training vector array 
		        (The dataMineLib table, which the cursor is managing, must have a field named: <i>SpecialSituationNotes</i>,
		        because the <i>SpecialSituationNotes</i> field is used as a scratch pad by this function).</td>
		      </tr>
		      <tr>
		        <th>baseExpressions</th>
		        <td>The vector of javaScript filter expressions used to reduce the table BEFORE data extraction.
		        Selecting all cursor rows would require a baseExpression argument of: #("restore;").</td>
		      </tr>
		      <tr>
		        <th>expressionVector</th>
		        <td>The M vector of javaScript filter expressions used to extract each column of data from the cursor.</td>
		      </tr>
		      <tr>
		        <th>gridVector</th>
		        <td>(Optional) An object vector of percentile grids each of which will have an equal vote on the estimator values
		        (the training grid inside this machine is ignored).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, Yest, an N vector of estimates for the dependent variable, Y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.percentileGridMachine.trainMachine</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.percentileGridMachine.trainMachine">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>numericRegress.percentileGridMachine.trainMachine</b> 
		      Train this percentile grid machine on an XY training vector array.
		      <br><br>
		      May be cummulatively trained on multiple training data arrays 
		      as long as the percentile grid machine is not reset between trainings.
		      <br><br>
		      Percentile grid machines are quasi regression engines which
		      learn and make regression estimates on XY vector arrays, where
		      X is an N by M+1 array representing the independent observations,
		      with the M+1th column being the sependent variable, Y.
		      <br><br> 
		      The percentile grid machine trains on a complete N by M+1 vector
		      array, XY. When the percentile grid machine runs, it only requires 
		      a complete N by M vector array, X, on which to make its predictions
		      concerning the estimated values of the dependent variable, Y.
		      <br><br> 
		      May be trained on a vector array or a table cursor, as follows.
		      <br>
		      (Option 1)  (pgm.trainMachine XY)
		      <br>
		      (Option 2)  (pgm.trainMachine X Y)
		      <br>
		      (Option 3)  (pgm.trainMachine cursor baseExpressions expressionVector)
		      <br><br> 
		      If a dataMineLib table memory cursor is passed as an argument, the <i>SpecialSituationNotes</i> field 
		      of each row in the table cursor will contain the new dependent variable, Yest, estimates.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(pgm.trainMachine X)</pre>
		    <pre>(pgm.trainMachine X Y)</pre>
		    <pre>(pgm.trainMachine cursor baseExpressions expressionVector)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <p><b>(Option 1)</b></p>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 vector array, XY, on which this machine is to be trained.
		        The M+1th column contains the values for the dependent variable, Y.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, Grid, the training grid estimates for the dependent variable, Y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p><b>(Option 2)</b></p>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M vector array, X, on which this machine is to be trained.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The N vector containing the values for the dependent variable, Y.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, Grid, the training grid estimates for the dependent variable, Y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p><b>(Option 3)</b></p>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>A dataMineLib memory cursor to be crunched into a dense sigmoid XY training vector array 
		        (The dataMineLib table, which the cursor is managing, must have a field named: <i>SpecialSituationNotes</i>,
		        because the <i>SpecialSituationNotes</i> field is used as a scratch pad by this function).</td>
		      </tr>
		      <tr>
		        <th>baseExpressions</th>
		        <td>The vector of javaScript filter expressions used to reduce the table BEFORE data extraction.
		        Selecting all cursor rows would require a baseExpression argument of: #("restore;").</td>
		      </tr>
		      <tr>
		        <th>expressionVector</th>
		        <td>The M+1 vector of javaScript filter expressions used to extract each column of data from the cursor.
		        The M+1th expression is used to extract the values for the dependent variable, Y.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns, Grid, the training grid estimates for the dependent variable, Y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.projectRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.projectRegress">
		   <p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.projectRegress</b> function 
		      correlates the strategies in a dataMineLib miner project.
		      Returns the sparse M coefficient vector for the strategies 
		      with the best least squares fit of the variables.
		      The strategy names are used to construct an N by M+1 array
		      where the M+1 column represents the dependent variable
		      (the last strategy named in the strategy list).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.projectRegress cursor strategyNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The memory cursor from which the N by M+1 array will be extracted.</td>
		      </tr>
		      <tr>
		        <th>strategyNames</th>
		        <td>The strategy names with which the N by M+1 array will be extracted.
		            (Note: the strategy names must contain strategies tiles from the Name column
		            of the data mine miner project).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (0 = constant term, and e = M+1 term).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.projectToArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.projectToArray">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.projectToArray</b> function 
		      returns a regression array from the cursor and project strategies specified.
		      The strategy names are used to construct an N by M+1 array
		      where the M+1 column represents the dependent variable
		      (the last strategy named in the list).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.projectToArray cursor strategyNames)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>cursor</th>
		        <td>The memory cursor from which the N by M+1 array will be extracted.</td>
		      </tr>
		      <tr>
		        <th>strategyNames</th>
		        <td>The strategy names with which the N by M+1 array will be extracted.
		            (Note: the strategy names must contain strategies tiles from the Name column
		            of the data mine miner project).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The M+1 coefficient vector (0 = constant term, and e = M+1 term).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regress">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regress</b> function 
		      returns a vector containing the coefficients resulting
		      from a linear regression on two vectors of equal length. 
		      If x and y are vectors of equal length,
		      then (regression x y) is: #(a  b  e).
		      where a + bx = y represents the least squares best fit
		      extracted from a comparison of the two vectors. The term
		      e is the error  sqr(y - (a + bx)).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regress X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The coefficient vector #(a b error) containing the optimized regression terms.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNet</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNet">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNet</b> function 
		      returns an Lambda using the coefficients from several 
		      segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNet X)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNetBinaryRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNetBinaryRegress">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNetBinaryRegress</b> function 
		      returns an Lambda using the coefficients from several 
		      segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNetBinaryRegress X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable to segment at the top level.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNetCart2</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNetCart2">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNetCart2</b> function 
		      returns an Lambda using the coefficients from several 
		      segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNetCart2 X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable to segment at the top level.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNetCart3</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNetCart3">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNetCart3</b> function 
		      returns an Lambda using Classification Tree with 3 classes (no pruning).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNetCart3 X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable of the first split.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNetMultiSegment</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNetMultiSegment">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNetMultiSegment</b> function 
		      returns an Lambda using the coefficients from several segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNetMultiSegment X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable of the first split.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.regressNetTwoSegment</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressNetTwoSegment">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressNetTwoSegment</b> function 
		      returns an Lambda using the coefficients from several segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressNetTwoSegment X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable of the first split.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>                 
	<Section>
	    <Heading>math.regressTree</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.regressTree">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.regressTree</b> function 
		      returns an Lambda using the coefficients from several segmented multiple regressions.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.regressTree X T S Z)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the last column
		        representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>T</th>
		        <td>The column index of the target variable of the first split.</td>
		      </tr>
		      <tr>
		        <th>S</th>
		        <td>The maximum number of splits to segment the target variable.</td>
		      </tr>
		      <tr>
		        <th>Z</th>
		        <td>The minimum number of elements in each segment of the target variable.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The estimator Lambda (Lambda(x) ==> y) expecting an x input vector (length M), returning a scalar y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.sigmoidizeArray</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.sigmoidizeArray">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.sigmoidizeArray</b> function 
		      converts the column values in an array to sigmoid values. 
		      Each array cell value is normalized by finding the positive
		      logit value x/(1+x). Positive values of x are scaled into [.5 - 1.0]. 
		      Negative values of x are scaled into [0 - .5].
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.sigmoidizeArray X depSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M+1 array representing the original observations with the 
		        last column representing the dependent variable Y.</td>
		      </tr>
		      <tr>
		        <th>depSW</th>
		        <td>(Optional) true if last column is to be unchanged.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The sigmoidized array (all values are positive fractions).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.smoRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.smoRegress">
		    <p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.smoRegress</b> function 
		      trains a support vector machine dual regression Lambda,
		      and returns the trained Lambda.
		      <br><br>
		      Support Vector Machine regression can be highly accurate
		      when solving non-linear regression problems. However, the
		      accuracy varies from excellent to poor depending upon
		      the ratio of: the chosen Gaussian Sample Size (maxSVSize);
		      the number of regression variables (M); and the THEORETICAL
		      number of variables created by the kernel function to
		      make the non-linear problem linearly solvable. A simplified
		      example would be as follows.      
		      <br><br>
		      Solving a quadratic regression problem with variableCount == 3,
		      y = sum{m from 0 until variableCount}(Cm*Xm*Xm), and 
		      a kernel function of vectorSquareInnerProduct, is very
		      accurate with a Gaussian Sample Size (maxSVSize) of 10.
		      However, if the variableCount is increased to 10, then the
		      accuracy completely breaks down and is not restored until
		      the Gaussian Sample Size is increased to around 100. An
		      explanation is as follows.      
		      <br><br>
		      In order to make the quadratic regression linearly tractable,
		      the vectorSquareInnerProduct performs an on-the-fly squaring
		      of each training point vector. Thus, with a training point
		      vector of size three, the vectorSquareInnerProduct creates
		      the following on-the-fly THEORETICAL new training point:
		      kernel(X1,X2,X3) => (X1,X2,X3,X1*X1,X2*X2,X3*X3,X1*X2,X1*X3,X2*X3).
		      Clearly the problem is now linearly solvable because the squared
		      variables are now terms in the THEORETICAL on-the-fly linear regression
		      created by the kernel. NOTICE however, that the THEORETICAL linear
		      regression, created on-the-fly by the kernel function, has nine variables
		      not three variables as in the original quadratic problem. Unless the
		      number of training points is greater than nine, and the Gaussian 
		      sample size is greater than nine, the on-the-fly linear regression
		      will not have enough data to get accurate results. (The Lambda
		      math.numericRegress.selfTest contains a sample test case which
		      demonstrates the fall in accuracy as Gaussian Sample Size is decreased).      
		      <br><br>
		      See Cristianini, "Support Vector Machines", page 169.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.smoRegress X Y kernelID tolerance maxErr maxGen maxSVSize verboseSW)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>The N by M array representing the independent variables
		            <br>(must be an ObjVector of length N with each Object element being a NumVector of length M).</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>The N vector of dependent variables.</td>
		      </tr>
		      <tr>
		        <th>kernelID</th>
		        <td>The kernel identifier to be used for support vector machine training.
		            <table>
		            <tr><th>void</th><td>Use a linear inner product kernel.</td></tr>
		            <tr><th>"linear"</th><td>Use a linear inner product kernel.</td></tr>  
		            <tr><th>"square"</th><td>Use a squared linear dot product kernel.</td></tr>  
		            <tr><th>"cube"</th><td>Use a cubed linear dot product kernel.</td></tr>  
		            <tr><th>Lambda</th><td>Use any user supplied modified dot product kernel.</td></tr>  
		            <tr><th>function</th><td>Use any user supplied modified dot product kernel.</td></tr>  
		            </table>
		       </td>
		      </tr>
		      <tr>
		        <th>tolerance</th>
		        <td>(Optional) The regression error tolerance as a percent of Y (defaults to 0.1).</td>
		      </tr>
		      <tr>
		        <th>maxErr</th>
		        <td>(Optional) The maximum error before halting training as a percent of Y (defaults to .05).</td>
		      </tr>
		      <tr>
		        <th>maxGen</th>
		        <td>(Optional) The maximum generation count before halting training (defaults to 1).</td>
		      </tr>
		      <tr>
		        <th>maxSVSize</th>
		        <td>(Optional) The Gaussian sample size (maximum number of support vectors to use during Gaussian initialization -- defaults to 100).</td>
		      </tr>
		      <tr>
		        <th>verboseSW</th>
		        <td>(Optional) True iff we are to set verbose mode on (defaults to false).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The result structure containing the trained dual regression model results, where
		            <table>
		            <tr><th>result.Error</th><td>Contains the final tolerance (expressed as a percent of each target value).</td></tr>
		            <tr><th>result.Generations</th><td>Contains the number of generations used during training.</td></tr>  
		            <tr><th>result.Weights</th><td>Contains the weight number vector after training.</td></tr>  
		            <tr><th>result.Ey</th><td>Contains the estimate errors for each training example.</td></tr>  
		            <tr><th>result.Py</th><td>Contains the estimate errors for each training example (expressed as a percent of each target value).</td></tr>  
		            </table>
		        </td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.symbolicMath</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.symbolicMath">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.symbolicMath</b> function 
		      manages symbolic math problems. This Lambda contains
		      a number of expert system rules about algebra which
		      are used to evaluate and simplify symbolic algebra
		      problems.
		      <br><br>
		      Invoking this parent function initializes the symbolic
		      math system, and is a required step before using this Lambda
		      to perform symbolic math operations.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.symbolicMath)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns true.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.symbolicMath.evaluate</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.symbolicMath.evaluate">
		    <p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.symbolicMath.evaluate</b> function 
		      manages symbolic math problems. This Lambda contains
		      a number of expert system rules about algebra which
		      are used to evaluate and simplify symbolic algebra
		      problems.
		      <br><br>
		      Invoking this parent function initializes the symbolic
		      math system, and is a required step before using this Lambda
		      to perform symbolic math operations.
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.symbolicMath.evaluate formula)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>formula</th>
		        <td>The symbolic math formula to be evaluated (in either string or list format).</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns the symbolic or numeric value of the evaluated formula.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.symbolicRegress</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.symbolicRegress">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.symbolicRegress</b> function 
		      returns a regression estimator function with numeric coefficients 
		      optimized against the specified objective function. The 
		      regression is nonlinear and will minimize any objective function.
		      Neither the estimator function nor the objective function 
		      are required to be continuous.
		      <br><br>
		      This Lambda uses three search technologies for estimator function
		      optimization: multivariate regression, neural net regression,
		      and genetic algorithm regression. Genetic algorithms learn
		      faster when the input data has been crunched into the sigmoid
		      or the closed bipolar domain. The neural net regression requires 
		      that the input data be crunched into the sigmoid domain. 
		      <br><br>
		      Multivariate regression is deterministic and absolutely accurate,
		      but limited in scope. Both genetic algorithms and neural nets are
		      nondeterministic and only appoximately accurate, but are general 
		      in scope. Please see the _selfTest child Lambda for an introduction
		      to the use and accuracy of these various regression techniques in
		      a wide range of sample problem domains.
		      <br><br>
		      The regression estimator function maps a number vector, of length M,
		      into a single real number, Rf: Xm --> R, whose coefficients
		      are optimized. The estimator function is in the form of
		      an Lambda, (Rf mVector) ==> aNumber, and the coefficients
		      to be optimized are stored as a number vector Rf.C 
		      in the persistant variables of the Rf Lambda.
		      <br><br>
		      <b>Note</b>: The returned estimator function, Rf, will be an Lambda containing
		      the following persistant (pvars) variables:</P>
		      <table>
		      <tr><th>C</th><td>A number vector containing the coefficients to optimize</td></tr>
		      <tr><th>Error</th><td>The final score from the objective function</td></tr> 
		      <tr><th>G</th><td>The final generation count when optimization halted</td></tr>
		      <tr><th>Objective</th><td>The objective function which maps an N by M+1 observation 
		                                matrix, w, using it's parent estimator function, Rf, into 
		                                a single positive real error value. The objective function 
		                                is in the form of a child Lambda, (Rf.Objective w) ==> anErrorNumber.
		                                The symbolicRegress Lambda attempts to optimize the estimator
		                                function coefficients, Rf.C, such that the objective 
		                                function's resulting error value is minimized.</td></tr> 
		      <tr><th>P</th><td>The final population count when optimization halted</td></tr> 
		      <tr><th>Strategy</th><td>The optimization strategy to use:</td></tr>
		      <tr><th>        </th><td><table>               
		                           <tr><th>void</th><td>Use genetic algorithm</td></tr>  
		                           <tr><th>evolve</th><td>Use genetic algorithm (real number genome)</td></tr>  
		                           <tr><th>evolveBinary</th><td>Use genetic algorithm (binary genome)</td></tr>  
		                           <tr><th>evolveBinaryMemo</th><td>Use genetic algorithm (binary genome) with memos</td></tr>  
		                           <tr><th>evolveInteger</th><td>Use genetic algorithm (integer genome)</td></tr>  
		                           <tr><th>linear</th><td>Use multivariate linear regression</td></tr>  
		                           <tr><th>neural</th><td>Use neural net regression</td></tr> 
		                           </table></td></tr>
		      </table>
		      <p></p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.symbolicRegress XY Gmax err)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>XY</th>
		        <td>The N by M+1 array representing the original observations with the M+1th column being the dependent variable.</td>
		      </tr>
		      <tr>
		        <th>Gmax</th>
		        <td>The maximum number of optimization trials (generations) to attempt before
		        returning the best set of coefficients available at that time.</td>
		      </tr>
		      <tr>
		        <th>err</th>
		        <td>A minimum error value which would terminate further optimization 
		        trials and return the best set of coefficients at that time.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns a regression estimator function, Rf.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorAdd</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorAdd">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorAdd</b> function 
		      returns the sum of two vectors or of a vector and a constant. 
		      If x and y are vectors of equal length,
		      then x+y is: #(x[0]+y[0]  x[1]+y[1] .... x[N]+y[N]).
		      If x is a vector and y is a constant,
		      then x+y is: #(x[0]+y  x[1]+y .... x[N]+y).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorAdd X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N or a constant.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>Always returns the vector sum of x+y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorDeltas</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorDeltas">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorDeltas</b> function 
		      converts an N vector into an N-1 vector of deltas.
		      <br> 
		      If x is: x[0] x[1] .... x[N], then result is: (x[1]-x[0]) (x[2]-x[1]) .... (x[N]-x[N-1]).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorDeltas Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>An N-1 vector of deltas.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorDeltaPercents</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorDeltaPercents">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorDeltaPercents</b> function 
		      converts an N vector into an N-1 vector of deltas (expressed as percent differences).
		      <br> 
		      If x is: x[0] x[1] .... x[N], then result is: (x[1]/x[0])-1 (x[2]/x[1])-1 .... (x[N]/x[N-1])-1.
		      <br><br>
		      <b>Note</b>: Where ever x[n] == 0, then x[n+1]/x[n] == x[n+1].
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorDeltaPercents Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>An N-1 vector of deltas (expressed as percent differences).</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorDivide</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorDivide">
			<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorDivide</b> function 
		      returns the quotient of two vectors or of a vector and a constant.
		      <br> 
		      If x and y are vectors of equal length, then xy is: #(x[0]/y[0]  x[1]/y[1] .... x[N]/y[N]).
		      <br><br>
		      If x is a vector and y is a constant, then xy is: #(x[0]/y  x[1]/y .... x[N]/y).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorDivide X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N or a constant.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The vector quotient of x and y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>	 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorDotProduct</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorDotProduct">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorDotProduct</b> function 
		      returns the inner (dot) product of two vectors.
		      <br> 
		      If x and y are vectors of equal length, then x*y is: x[0]y[0] + x[1]y[1] + .... x[N]y[N].
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorDotProduct X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The vector inner (dot) product of x and y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>math.vectorProduct</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorProduct">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorProduct</b> function 
		      returns the product of two vectors or of a vector and a constant.
		      <br> 
		      If x and y are vectors of equal length, then x*y is: #(x[0]y[0]  x[1]y[1] .... x[N]y[N]).
		      <br> 
		      If x is a vector and y is a constant, then x*y is: #(x[0]y  x[1]y .... x[N]y).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorProduct X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N or a constant.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The vector product of x and y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>                   
	<Section>
	    <Heading>math.vectorSub</Heading>
		<Description><![CDATA[		
		    <div class="h2section" id="math.vectorSub">
		<p class=overview>Overview</p><p></p>
		    <p class=description>The <b>math.vectorSub</b> function 
		      returns the difference of two vectors or of a vector and a constant.
		      <br> 
		      If x and y are vectors of equal length, then x-y is: #(x[0]-y[0]  x[1]-y[1] .... x[N]-y[N]).
		      <br> 
		      If x is a vector and y is a constant, then x-y is: #(x[0]-y  x[1]-y .... x[N]-y).
		      </p>
		    <p></p>
		    <p class=type>Type: <font color='black'>Function</font></p>
		    <p></p>
		    <p class=syntax>Syntax</p>
		    <p></p>
		    <pre>(math.vectorSub X Y)</pre>
		    <p></p>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>X</th>
		        <td>A vector of length N.</td>
		      </tr>
		      <tr>
		        <th>Y</th>
		        <td>A vector of length N or a constant.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The vector difference of x and y.</td>
		      </tr>
		    </table>
		    <hr>
		    <p></p>
		    <p class=whentouse>When To Use</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=example>Example</p>
		    <p><font color='red'>[...under construction...]</font></P>
		    <p></p>
		    <p class=notes>Notes &amp; Hints</p>
		    <p><font color='red'>[...under construction...]</font></P>		 
		  </div>
	    ]]></Description>
	</Section>
</Essay>
