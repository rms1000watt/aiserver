<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE Essay SYSTEM "../DTD/Essay.dtd">
<Essay>
	<KnowledgeBase>
	    <Title>SQL Stored Programs</Title>
		<Topic>AIS</Topic>
		<SubTopic>Overview</SubTopic>
		<HumanKeywords>SQL Language programming</HumanKeywords>
	</KnowledgeBase>
	<Section>
	    <Heading>Overview</Heading>
		<Description><![CDATA[
		<p>This chapter discusses stored programs and views, which are database objects defined in terms of of SQL code that is stored on the server for later invocation.</p>
		<p>Stored programs include these objects:</p>
		<p>Stored routines, that is, stored functions and procedures. A stored function is used much like a built-in function.
			you invoke it in an expression and it returns a value during expression evaluation. A stored procedure is invoked using the CALL statement.
			A procedure does not have a return value but can modify its parameters for later inspection by the caller. It can also generate result sets to be returned to the client program.</p>
		<p>Triggers. A trigger is a named database object that is associated with a table and that is activated when a particular event occurs for the table, such as an insert or update.</p>
		<p>Events. An event is a task that runs according to schedule.</p>
		<p>Views are stored queries that when invoked produce a result set. A view acts as a virtual table.</p>
		<p>This chapter describes how to use each type of stored program and views. Additional information about SQL syntax for statements related to these objects is available in the following locations:</p>
		<p>For each object type, there are CREATE, ALTER, and DROP statements that control which objects exist and how they are defined.</p>
		<p>The CALL statement is used to invoke stored procedures.</p>
		<p>Stored program definitions contain a body that may use compound statements, loops, conditionals, and declared variables.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Defining Stored Programs</Heading>
		<Description><![CDATA[
		<p>Each stored program contains a body that consists of an SQL statement.
			This statement may be a compound statement made up of several statements separated by semicolon (;) characters.
				For example, the following stored procedure has a body made up of a BEGIN ... END block that contains a SET statement and a REPEAT loop that itself contains another SET statement:</p>
		<pre>(sql sqlHandle {
CREATE PROCEDURE dorepeat(p1 INT)
BEGIN
  SET @x = 0;
  REPEAT SET @x = @x + 1; UNTIL @x > p1 END REPEAT;
END})</pre>
		<pre>(sql sqlHandle {CALL dorepeat(1000)})</pre>
		<pre>(sql sqlHandle {SELECT @x}) <b>Returns</b>
+------+
| @x   |
+------+
| 1001 |
+------+</pre>
		<p>The following is an example of a function that takes a parameter, performs an operation using an SQL function, and returns the result.
			In this case, it is unnecessary to use delimiter because the function definition contains no internal ; statement delimiters:</p>
		<pre>(sql sqlHandle {CREATE FUNCTION hello (s CHAR(20)) RETURNS CHAR(50) DETERMINISTIC RETURN CONCAT('Hello, ',s,'!')})</pre>
		<pre>(sql sqlHandle {SELECT hello('world')}) <b>Returns</b>
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+</pre>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Using Stored Routines (Procedures and Functions)</Heading>
		<Description><![CDATA[
		<p>Stored routines (procedures and functions) are supported in MySQL 5.1. A stored routine is a set of SQL statements that can be stored in the server.
			Once this has been done, clients don't need to keep reissuing the individual statements but can refer to the stored routine instead.</p>
		<p>Stored routines require the proc table in the mysql database. This table is created during the MySQL 5.1 installation procedure.
			If you are upgrading to MySQL 5.1 from an earlier version, be sure to update your grant tables to make sure that the proc table exists.</p>
		<p>Stored routines can be particularly useful in certain situations:</p>
		<ul>
			<li>
				<p>When multiple client applications are written in different languages or work on different platforms, but need to perform the same database operations.</p>
			</li>
			<li>
				<p>When security is paramount. Banks, for example, use stored procedures and functions for all common operations.
					This provides a consistent and secure environment, and routines can ensure that each operation is properly logged.
					In such a setup, applications and users would have no access to the database tables directly, but can only execute specific stored routines.</p>
			</li>
		</ul>
		<p>Stored routines can provide improved performance because less information needs to be sent between the server and the client.
			The tradeoff is that this does increase the load on the database server because more of the work is done on the server side and less is done on the client (application) side.
			Consider this if many client machines (such as Web servers) are serviced by only one or a few database servers.</p>
		<p>Stored routines also allow you to have libraries of functions in the database server.
			This is a feature shared by modern application languages that allow such design internally (for example, by using classes).
			Using these client application language features is beneficial for the programmer even outside the scope of database use.</p>
		<p>MySQL follows the SQL:2003 syntax for stored routines, which is also used by IBM's DB2.</p>
		<p>The MySQL implementation of stored routines is still in progress. All syntax described here is supported and any limitations and extensions are documented where appropriate.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Stored Routine Syntax</Heading>
		<Description><![CDATA[
		<p>A stored routine is either a procedure or a function. Stored routines are created with the CREATE PROCEDURE and CREATE FUNCTION statements.
			A procedure is invoked using a CALL statement, and can only pass back values using output variables.
			A function can be called from inside a statement just like any other function (that is, by invoking the function's name), and can return a scalar value.
			The body of a stored routine can use compound statements.</p>
		<p>Stored routines can be dropped with the DROP PROCEDURE and DROP FUNCTION statements, and altered with the ALTER PROCEDURE and ALTER FUNCTION statements.</p>
		<p>A stored procedure or function is associated with a particular database. This has several implications:</p>
		<ul>
			<li>
				<p>When the routine is invoked, an implicit USE db_name is performed (and undone when the routine terminates). USE statements within stored routines are disallowed.</p>
			</li>
			<li>
				<p>You can qualify routine names with the database name. This can be used to refer to a routine that is not in the current database.
					For example, to invoke a stored procedure p or function f that is associated with the test database, you can say CALL test.p() or test.f().</p>
			</li>
			<li>
				<p>When a database is dropped, all stored routines associated with it are dropped as well.</p>
			</li>
		</ul>
		<p>Stored functions cannot be recursive.</p>
		<p>Recursion in stored procedures is allowed but disabled by default. To enable recursion, set the max_sp_recursion_depth server system variable to a value greater than zero.
			Stored procedure recursion increases the demand on thread stack space. If you increase the value of max_sp_recursion_depth,
			it may be necessary to increase thread stack size by increasing the value of thread_stack at server startup.</p>
		<p>MySQL supports the very useful extension that allows the use of regular SELECT statements (that is, without using cursors or local variables) inside a stored procedure.
			The result set of such a query is simply sent directly to the client. Multiple SELECT statements generate multiple result sets,
			so the client must use a MySQL client library that supports multiple result sets. This means the client must use a client library from a version of MySQL at least as recent as 4.1.
			The client should also specify the CLIENT_MULTI_RESULTS option when it connects.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Stored Routines and MySQL Privileges</Heading>
		<Description><![CDATA[
		<p>The MySQL grant system takes stored routines into account as follows:</p>
		<ul>
			<li>
				<p>The CREATE ROUTINE privilege is needed to create stored routines.</p>
			</li>
			<li>
				<p>The ALTER ROUTINE privilege is needed to alter or drop stored routines.
					This privilege is granted automatically to the creator of a routine if necessary, and dropped when the routine creator drops the routine.</p>
			</li>
			<li>
				<p>The EXECUTE privilege is required to execute stored routines.
					However, this privilege is granted automatically to the creator of a routine if necessary (and dropped when the creator drops the routine).
					Also, the default SQL SECURITY characteristic for a routine is DEFINER, which enables users who have access to the database with which the routine is associated to execute the routine.</p>
			</li>
			<li>
				<p>If the automatic_sp_privileges system variable is 0, the EXECUTE and ALTER ROUTINE privileges are not automatically granted and dropped.</p>
			</li>
		</ul>
		<p>The server manipulates the mysql.proc table in response to statements that create, alter, or drop stored routines. It is not supported that the server will notice manual manipulation of this table.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Stored Routine Metadata</Heading>
		<Description><![CDATA[
		<p>Metadata about stored routines can be obtained as follows:</p>
		<ul>
			<li>
				<p>Query the ROUTINES table of the INFORMATION_SCHEMA database.</p>
			</li>
			<li>
				<p>Use the SHOW CREATE PROCEDURE and SHOW CREATE FUNCTION statements to see routine definitions.</p>
			</li>
			<li>
				<p>Use the SHOW PROCEDURE STATUS and SHOW FUNCTION STATUS statements to see routine characteristics.</p>
			</li>
		</ul>
		<p>INFORMATION_SCHEMA does not have a PARAMETERS table until MySQL 6.0, so applications that need to acquire routine parameter information
			at runtime must use workarounds such as parsing the output of SHOW CREATE statements or the param_list column of the mysql.proc table.
			param_list contents can be processed from within a stored routine, unlike the output from SHOW.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Stored Procedures, Functions, Triggers, and LAST_INSERT_ID()</Heading>
		<Description><![CDATA[
		<p>Within the body of a stored routine (procedure or function) or a trigger, the value of LAST_INSERT_ID() changes the same way as for statements executed outside the body of these kinds of objects.
			The effect of a stored routine or trigger upon the value of LAST_INSERT_ID() that is seen by following statements depends on the kind of routine:</p>
		<ul>
			<li>
				<p>If a stored procedure executes statements that change the value of LAST_INSERT_ID(), the changed value is seen by statements that follow the procedure call.</p>
			</li>
			<li>
				<p>For stored functions and triggers that change the value, the value is restored when the function or trigger ends, so following statements do not see a changed value.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Using Triggers</Heading>
		<Description><![CDATA[
		<p>A trigger is a named database object that is associated with a table, and that activates when a particular event occurs for the table.
			Some uses for triggers are to perform checks of values to be inserted into a table or to perform calculations on values involved in an update.</p>
		<p>A trigger is defined to activate when an INSERT, DELETE, or UPDATE statement executes for the associated table.
			A trigger can be set to activate either before or after the triggering statement.
			For example, you can have a trigger activate before each row that is inserted into a table or after each row that is updated.</p>
		<p>Important: MySQL triggers are activated by SQL statements only. They are not activated by changes in tables made by APIs that do not transmit SQL statements to the MySQL Server;
			in particular, they are not activated by updates made using the NDB API.</p>
		<p>To use triggers if you have upgraded to MySQL 5.1 from an older release that did not support triggers, you should upgrade your grant tables so that they contain the trigger-related privileges.</p>
		<p>The following discussion describes the syntax for creating and dropping triggers, and shows some examples of how to use them.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Trigger Syntax</Heading>
		<Description><![CDATA[
		<p>To create a trigger or drop a trigger, use the CREATE TRIGGER or DROP TRIGGER statement.</p>
		<p>Here is a simple example that associates a trigger with a table for INSERT statements.
			The trigger acts as an accumulator, summing the values inserted into one of the columns of the table.</p>
		<pre>(sql sqlHandle {CREATE TABLE account (acct_num INT, amount DECIMAL(10,2))})</pre>
		<pre>(sql sqlHandle {CREATE TRIGGER ins_sum BEFORE INSERT ON account FOR EACH ROW SET @sum = @sum + NEW.amount})</pre>
		<p>The CREATE TRIGGER statement creates a trigger named ins_sum that is associated with the account table.
			It also includes clauses that specify the trigger activation time, the triggering event, and what to do with the trigger activates:</p>
		<ul>
			<li>
				<p>The keyword BEFORE indicates the trigger action time. In this case, the trigger should activate before each row inserted into the table. The other allowable keyword here is AFTER.</p>
			</li>
			<li>
				<p>The keyword INSERT indicates the event that activates the trigger. In the example, INSERT statements cause trigger activation. You can also create triggers for DELETE and UPDATE statements.</p>
			</li>
			<li>
				<p>The statement following FOR EACH ROW defines the statement to execute each time the trigger activates, which occurs once for each row affected by the triggering statement In the example,
					the triggered statement is a simple SET that accumulates the values inserted into the amount column.
					The statement refers to the column as NEW.amount which means "the value of the amount column to be inserted into the new row."</p>
			</li>
		</ul>
		<p>To use the trigger, set the accumulator variable to zero, execute an INSERT statement, and then see what value the variable has afterward:</p>
		<pre>(sql sqlHandle {SET @sum = 0})</pre>
		<pre>(sql sqlHandle {INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00)})</pre>
		<pre>(sql sqlHandle {SELECT @sum AS 'Total amount inserted'}) <b>Returns</b>
+-----------------------+
| Total amount inserted |
+-----------------------+
| 1852.48               |
+-----------------------+</pre>
		<p>In this case, the value of @sum after the INSERT statement has executed is 14.98 + 1937.50 - 100, or 1852.48.</p>
		<p>To destroy the trigger, use a DROP TRIGGER statement. You must specify the schema name if the trigger is not in the default schema:</p>
		<pre>(sql sqlHandle {DROP TRIGGER test.ins_sum})</pre>
		<p>Triggers for a table are also dropped if you drop the table.</p>
		<p>Trigger names exist in the schema namespace, meaning that all triggers must have unique names within a schema. Triggers in different schemas can have the same name.</p>
		<p>In addition to the requirement that trigger names be unique for a schema, there are other limitations on the types of triggers you can create.
			In particular, you cannot have two triggers for a table that have the same activation time and activation event.
			For example, you cannot define two BEFORE INSERT triggers or two AFTER UPDATE triggers for a table.
			This should rarely be a significant limitation, because it is possible to define a trigger that executes multiple statements by using the BEGIN ... END compound statement construct after FOR EACH ROW.
			(An example appears later in this section.)</p>
		<p>The OLD and NEW keywords enable you to access columns in the rows affected by a trigger. (OLD and NEW are not case sensitive.)
			In an INSERT trigger, only NEW.col_name can be used; there is no old row. In a DELETE trigger, only OLD.col_name can be used; there is no new row.
			In an UPDATE trigger, you can use OLD.col_name to refer to the columns of a row before it is updated and NEW.col_name to refer to the columns of the row after it is updated.</p>
		<p>A column named with OLD is read only. You can refer to it (if you have the SELECT privilege), but not modify it.
			A column named with NEW can be referred to if you have the SELECT privilege for it.
			In a BEFORE trigger, you can also change its value with SET NEW.col_name = value if you have the UPDATE privilege for it.
			This means you can use a trigger to modify the values to be inserted into a new row or that are used to update a row.</p>
		<p>In a BEFORE trigger, the NEW value for an AUTO_INCREMENT column is 0, not the automatically generated sequence number that will be generated when the new record actually is inserted.</p>
		<p>OLD and NEW are MySQL extensions to triggers.</p>
		<p>By using the BEGIN ... END construct, you can define a trigger that executes multiple statements. Within the BEGIN block,
			you also can use other syntax that is allowed within stored routines such as conditionals and loops.
			The following example illustrates these points. It defines an UPDATE trigger that checks the new value to be used for updating each row, and modifies the value to be within the range from 0 to 100.
			This must be a BEFORE trigger because the value needs to be checked before it is used to update the row:</p>
		<pre>(sql sqlHandle {
CREATE TRIGGER upd_check BEFORE UPDATE ON account
    FOR EACH ROW
    BEGIN
        IF NEW.amount < 0 THEN
            SET NEW.amount = 0;
        ELSEIF NEW.amount > 100 THEN
            SET NEW.amount = 100;
        END IF;
    END;})</pre>
		<p>It can be easier to define a stored procedure separately and then invoke it from the trigger using a simple CALL statement.
			This is also advantageous if you want to invoke the same routine from within several triggers.</p>
		<p>There are some limitations on what can appear in statements that a trigger executes when activated:</p>
		<ul>
			<li>
				<p>The trigger cannot use the CALL statement to invoke stored procedures that return data to the client or that use dynamic SQL.
					(Stored procedures are allowed to return data to the trigger through OUT or INOUT parameters.)</p>
			</li>
			<li>
				<p>The trigger cannot use statements that explicitly or implicitly begin or end a transaction such as START TRANSACTION, COMMIT, or ROLLBACK.</p>
			</li>
		</ul>
		<p>MySQL handles errors during trigger execution as follows:</p>
		<ul>
			<li>
				<p>If a BEFORE trigger fails, the operation on the corresponding row is not performed.</p>
			</li>
			<li>
				<p>A BEFORE trigger is activated by the attempt to insert or modify the row, regardless of whether the attempt subsequently succeeds.</p>
			</li>
			<li>
				<p>An AFTER trigger is executed only if the BEFORE trigger (if any) and the row operation both execute successfully.</p>
			</li>
			<li>
				<p>An error during either a BEFORE or AFTER trigger results in failure of the entire statement that caused trigger invocation.</p>
			</li>
			<li>
				<p>For transactional tables, failure of a statement should cause rollback of all changes performed by the statement.
					Failure of a trigger causes the statement to fail, so trigger failure also causes rollback.
					For non-transactional tables, such rollback cannot be done, so although the statement fails, any changes performed prior to the point of the error remain in effect.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Trigger Metadata</Heading>
		<Description><![CDATA[
		<p>Metadata about triggers can be obtained as follows:</p>
		<ul>
			<li>
				<p>Query the TRIGGERS table of the INFORMATION_SCHEMA database.</p>
			</li>
			<li>
				<p>Use the SHOW TRIGGERS statement.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Using the Event Scheduler</Heading>
		<Description><![CDATA[
		<p>The MySQL Event Scheduler manages the scheduling and execution of events: Tasks that run according to schedule. Event support was added in MySQL 5.1.6.</p>
		<p>Stored routines require the event table in the mysql database. This table is created during the MySQL 5.1 installation procedure.
			If you are upgrading to MySQL 5.1 from an earlier version, be sure to update your grant tables to make sure that the event table exists.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Event Scheduler Overview</Heading>
		<Description><![CDATA[
		<p>MySQL Events are tasks that run according to a schedule. Therefore, we sometimes refer to them as scheduled events.
			When you create an event, you are creating a named database object containing one or more SQL statements to be executed at one or more regular intervals,
			beginning and ending at a specific date and time. Conceptually, this is similar to the idea of the Unix crontab (also known as a "cron job") or the Windows Task Scheduler.</p>
		<p>Scheduled tasks of this type are also sometimes known as "temporal triggers", implying that these are objects that are triggered by the passage of time.
			Events should more specifically not be confused with "temporary triggers". Whereas a trigger is a database object whose statements are executed in response
			to a specific type of event that occurs on a given table, a (scheduled) event is an object whose statements are executed in response to the passage of a specified time interval.</p>
		<p>While there is no provision in the SQL Standard for event scheduling, there are precedents in other database systems,
			and you may notice some similarities between these implementations and that found in the MySQL Server.</p>
		<p>MySQL Events have the following major features and properties:</p>
		<ul>
			<li>
				<p>In MySQL 5.1.12 and later, an event is uniquely identified by its name and the schema to which it is assigned. (Previously, an event was also unique to its definer.)</p>
			</li>
			<li>
				<p>An event performs a specific action according to a schedule. This action consists of an SQL statement, which can be a compound statement in a BEGIN ... END block if desired.
					An event's timing can be either one-time or recurrent. A one-time event executes one time only.
					A recurrent event repeats its action at a regular interval, and the schedule for a recurring event can be assigned a specific start day and time, end day and time, both, or neither.
					(By default, a recurring event's schedule begins as soon as it is created, and continues indefinitely, until it is disabled or dropped.)</p>
			</li>
			<li>
				<p>Users can create, modify, and drop scheduled events using SQL statements intended for these purposes.
					Syntactically invalid event creation and modification statements fail with an appropriate error message.
					A user may include statements in an event's action which require privileges that the user does not actually have.
					The event creation or modification statement succeeds but the event's action fails.</p>
			</li>
			<li>
				<p>Many of the properties of an event can be set or modified using SQL statements.
					These properties include the event's name, timing, persistence (that is, whether it is preserved following the expiration of its schedule),
					status (enabled or disabled), action to be performed, and the schema to which it is assigned.</p>
			</li>
			<li>
				<p>The default definer of an event is the user who created the event, unless the event has been altered,
					in which case the definer is the user who issued the last ALTER EVENT statement affecting that event.
					An event can be modified by any user having the EVENT privilege on the database for which the event is defined.
					(Prior to MySQL 5.1.12, only an event's definer, or a user having privileges on the mysql.event table, could modify a given event.)</p>
			</li>
			<li>
				<p>An event's action statement may include most SQL statements permitted within stored routines.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Event Scheduler Configuration</Heading>
		<Description><![CDATA[
		<p>Events are executed by a special event scheduler thread; when we refer to the Event Scheduler, we actually refer to this thread.
			When running, the event scheduler thread and its current state can be seen by users having the PROCESS privilege in the output of SHOW PROCESSLIST, as shown in the discussion that follows.</p>
		<p>The global event_scheduler system variable determines whether the Event Scheduler is enabled and running on the server.
			Beginning with MySQL 5.1.12, it has one of these 3 values, which affect event scheduling as described here:</p>
		<ul>
			<li>
				<p>OFF: The Event Scheduler is stopped. The event scheduler thread does not run, is not shown in the output of SHOW PROCESSLIST, and no scheduled events are executed.
					OFF is the default value for event_scheduler.</p>
				<p>When the Event Scheduler is stopped (event_scheduler is OFF), it can be started by setting the value of event_scheduler to ON. (See next item.)</p>
			</li>
			<li>
				<p>ON: The Event Scheduler is started; the event scheduler thread runs and executes all scheduled events.</p>
				<p>When the Event Scheduler is ON, the event scheduler thread is listed in the output of SHOW PROCESSLIST as a daemon process, and its state is represented as shown here:</p>
				<pre>mysql> SHOW PROCESSLIST\G
*************************** 1. row ***************************
     Id: 1
   User: root
   Host: localhost
     db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 2. row ***************************
     Id: 2
   User: event_scheduler
   Host: localhost
     db: NULL
Command: Daemon
   Time: 3
  State: Waiting for next activation
   Info: NULL</pre>
				<p>Event scheduling can be stopped by setting the value of event_scheduler to OFF.</p>
			</li>
			<li>
				<p>DISABLED: This value renders the Event Scheduler non-operational. When the Event Scheduler is DISABLED, the event scheduler thread does not run (and so does not appear in the output of SHOW PROCESSLIST).
					In addition, the Event Scheduler state cannot be changed at runtime.</p>
			</li>
		</ul>
		<p>If the Event Scheduler status has not been set to DISABLED, event_scheduler can be toggled between ON and OFF (using SET).
			It is also possible to use 0 for OFF, and 1 for ON when setting this variable. Thus, any of the following 4 statements can be used in the mysql client to turn on the Event Scheduler:</p>
		<pre>SET GLOBAL event_scheduler = ON;
SET @@global.event_scheduler = ON;
SET GLOBAL event_scheduler = 1;
SET @@global.event_scheduler = 1;</pre>
		<p>Similarly, any of these 4 statements can be used to turn off the Event Scheduler:</p>
		<pre>SET GLOBAL event_scheduler = OFF;
SET @@global.event_scheduler = OFF;
SET GLOBAL event_scheduler = 0;
SET @@global.event_scheduler = 0;</pre>
		<p>Although ON and OFF have numeric equivalents, the value displayed for event_scheduler by SELECT or SHOW VARIABLES is always one of OFF, ON, or DISABLED.
			DISABLED has no numeric equivalent. For this reason, ON and OFF are usually preferred over 1 and 0 when setting this variable.</p>
		<p>Note that attempting to set event_scheduler without specifying it as a global variable causes an error:</p>
		<pre>mysql> SET @@event_scheduler = OFF;
ERROR 1229 (HY000): Variable 'event_scheduler' is a GLOBAL variable and should be set with SET GLOBAL</pre>
		<p>Important: It is possible to set the Event Scheduler to DISABLED only at server startup. If event_scheduler is ON or OFF, you cannot set it to DISABLED at runtime.
			Also, if the Event Scheduler is set to DISABLED at startup, you cannot change the value of event_scheduler at runtime.</p>
		<p>To disable the event scheduler, use one of the following two methods:</p>
		<ul>
			<li>
				<p>As a command-line option when starting the server:</p>
				<p>--event-scheduler=DISABLED</p>
			</li>
			<li>
				<p>In the server configuration file (my.cnf, or my.ini on Windows systems), include the line where it will be read by the server (for example, in a [mysqld] section):</p>
				<p>event_scheduler=DISABLED</p>
			</li>
		</ul>
		<p>To enable the Event Scheduler, restart the server without the --event-scheduler=DISABLED command-line option,
			or after removing or commenting out the line containing event_scheduler=DISABLED in the server configuration file, as appropriate.
			Alternatively, you can use ON (or 1) or OFF (or 0) in place of the DISABLED value when starting the server.</p>
		<p>Note: You can issue event-manipulation statements when event_scheduler is set to DISABLED.
			No warnings or errors are generated in such cases (provided that the statements are themselves valid).
			However, scheduled events cannot execute until this variable is set to ON (or 1).
			Once this has been done, the event scheduler thread executes all events whose scheduling conditions are satisfied.</p>
		<p>In MySQL 5.1.11, event_scheduler behaved as follows: this variable could take one of the values 0 (or OFF), 1 (or ON), or 2.
			Setting it to 0 turned event scheduling off, so that the event scheduler thread did not run;
			the event_scheduler variable could not be set to this value while the server was running.
			Setting it to 1 so that the event scheduler thread ran and executed scheduled events.
			In this state, the event scheduler thread appeared to be sleeping when viewed with SHOW PROCESSLIST.
			When event_scheduler was set to 2 (which was the default value), the Event Scheduler was considered to be "suspended";
			the event scheduler thread ran and could be seen in the output of SHOW PROCESSLIST (where Suspended was displayed in the State column), but did not execute any scheduled events.
			The value of event_scheduler could be changed only between 1 (or ON) and 2 while the server was running.
			Setting it to 0 (or OFF) required a server restart, as did changing its value from 0 (or OFF) to 1 (or ON) or 2.</p>
		<p>Prior to MySQL 5.1.11, event_scheduler could take one of only the 2 values 0|OFF or 1|ON, and the default value was 0|OFF.
			It was also possible to start and stop the event scheduler thread while the MySQL server was running.</p>
		<p>For more information concerning the reasons for these changes in behaviour, see Bug#17619.</p>
		<p>Beginning with MySQL 5.1.17, starting the MySQL server with the --skip-grant-tables option causes event_scheduler to be set to DISABLED,
			overriding any other value set either on the command line or in the my.cnf or my.ini file (Bug#26807).</p>
		<p>MySQL 5.1.6 and later provides an EVENTS table in the INFORMATION_SCHEMA database.
			This table can be queried to obtain information about scheduled events which have been defined on the server.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Event Syntax</Heading>
		<Description><![CDATA[
		<p>MySQL 5.1.6 and later provides several SQL statements for working with scheduled events:</p>
		<ul>
			<li>
				<p>New events are defined using the CREATE EVENT statement.</p>
			</li>
			<li>
				<p>The definition of an existing event can be changed by means of the ALTER EVENT statement.</p>
			</li>
			<li>
				<p>When a scheduled event is no longer wanted or needed, it can be deleted from the server by its definer using the DROP EVENT statement. 
					Whether an event persists past the end of its schedule also depends on its ON COMPLETION clause, if it has one.</p>
				<p>An event can be dropped by any user having the EVENT privilege for the database on which the event is defined.
					Prior to MySQL 5.1.12, a user other than the definer required privileges on the mysql.event table.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Event Metadata</Heading>
		<Description><![CDATA[
		<p>Metadata about events can be obtained as follows:</p>
		<ul>
			<li>
				<p>Query the EVENTS table of the INFORMATION_SCHEMA database.</p>
			</li>
			<li>
				<p>Use the SHOW CREATE EVENT statement.</p>
			</li>
			<li>
				<p>Use the SHOW EVENTS statement.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Event Scheduler Status</Heading>
		<Description><![CDATA[
		<p>A record of events executed on the server can be read from the MySQL Server's error log.</p>
		<p>Information about the state of the Event Scheduler for debugging and troubleshooting purposes can be obtained as follows:</p>
		<ul>
			<li>
				<p>In debugging builds of MySQL 5.1.11, you can use the SHOW SCHEDULER STATUS statement;
					This statement was removed in MySQL 5.1.12. We intend to implement an SQL statement providing similar functionality in a future MySQL release.</p>
			</li>
			<li>
				<p>Beginning with MySQL 5.1.12, event scheduler status information can be obtained by running mysqladmin debug;
					after running this command, the server's error log contains output relating to the Event Scheduler, similar to what is shown here:</p>
				<pre>Events status:
LLA = Last Locked At  LUA = Last Unlocked At
WOC = Waiting On Condition  DL = Data Locked

Event scheduler status:
State      : INITIALIZED
Thread id  : 0
LLA        : init_scheduler:313
LUA        : init_scheduler:318
WOC        : NO
Workers    : 0
Executed   : 0
Data locked: NO

Event queue status:
Element count   : 1
Data locked     : NO
Attempting lock : NO
LLA             : init_queue:148
LUA             : init_queue:168
WOC             : NO
Next activation : 0000-00-00 00:00:00</pre>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>The Event Scheduler and MySQL Privileges</Heading>
		<Description><![CDATA[
		<p>To enable or disable the execution of scheduled events, it is necessary to set the value of the global event_scheduler system variable. This requires the SUPER privilege.</p>
		<p>MySQL 5.1.6 introduces a privilege governing the creation, modification, and deletion of events, the EVENT privilege.
			This privilege can be bestowed using GRANT. For example, this GRANT statement confers the EVENT privilege for the schema named myschema on the user jon@ghidora:</p>
		<pre>GRANT EVENT ON myschema.* TO jon@ghidora;</pre>
		<p>(We assume that this user account already exists, and that we wish for it to remain unchanged otherwise.)</p>
		<p>To grant this same user the EVENT privilege on all schemas, use the following statement:</p>
		<pre>GRANT EVENT ON *.* TO jon@ghidora;</pre>
		<p>The EVENT privilege has global or schema-level scope. Therefore, trying to grant it on a single table results in an error as shown:</p>
		<pre>GRANT EVENT ON myschema.mytable TO jon@ghidora; ERROR 1144 (42000): Illegal GRANT/REVOKE command; please consult the manual to see which privileges can be used</pre>
		<p>It is important to understand that an event is executed with the privileges of its definer, and that it cannot perform any actions for which its definer does not have the requisite privileges.
			For example, suppose that jon@ghidora has the EVENT privilege for myschema. Suppose also that this user has the SELECT privilege for myschema, but no other privileges for this schema.
			It is possible for jon@ghidora to create a new event such as this one:</p>
		<pre>CREATE EVENT e_store_ts
    ON SCHEDULE 
      EVERY 10 SECOND
    DO 
      INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());</pre>
		<p>The user waits for a minute or so, and then performs a SELECT * FROM mytable; query, expecting to see several new rows in the table.
			Instead, he finds that the table is empty. Since he does not have the INSERT privilege for the table in question, the event has no effect.</p>
		<p>If you inspect the MySQL error log (hostname.err), you can see that the event is executing, but the action it is attempting to perform fails, as indicated by RetCode=0:</p>
		<pre>060209 22:39:44 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:39:44 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0
060209 22:39:54 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:39:54 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0
060209 22:40:04 [Note]     EVEX EXECUTING event newdb.e [EXPR:10]
060209 22:40:04 [Note]     EVEX EXECUTED event newdb.e  [EXPR:10]. RetCode=0</pre>
		<p>Since this user very likely does not have access to the error log, he can verify whether the event's action statement is valid by running it himself:</p>
		<pre>INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP()); ERROR 1142 (42000): INSERT command denied to user 'jon'@'ghidora' for table 'mytable'</pre>
		<p>Inspection of the INFORMATION_SCHEMA.EVENTS table shows that e_store_ts exists and is enabled, but its LAST_EXECUTED column is NULL:</p>
		<pre>mysql> SELECT * FROM INFORMATION_SCHEMA.EVENTS WHERE EVENT_NAME='e_store_ts' AND EVENT_SCHEMA='myschema'\G
*************************** 1. row ***************************
   EVENT_CATALOG: NULL
    EVENT_SCHEMA: myschema
      EVENT_NAME: e_store_ts
         DEFINER: jon@ghidora
      EVENT_BODY: SQL
EVENT_DEFINITION: INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP())
      EVENT_TYPE: RECURRING
      EXECUTE_AT: NULL
  INTERVAL_VALUE: 5
  INTERVAL_FIELD: SECOND
        SQL_MODE: NULL
          STARTS: 0000-00-00 00:00:00
            ENDS: 0000-00-00 00:00:00
          STATUS: ENABLED
   ON_COMPLETION: NOT PRESERVE
         CREATED: 2006-02-09 22:36:06
    LAST_ALTERED: 2006-02-09 22:36:06
   LAST_EXECUTED: NULL
   EVENT_COMMENT:</pre>
		<p>Note: Prior to MySQL 5.1.12, there was no EVENT_DEFINITION column, and EVENT_BODY contained the SQL statement or statements to be executed.</p>
		<p>To rescind the EVENT privilege, use the REVOKE statement. In this example, the EVENT privilege on the schema myschema is removed from the jon@ghidora user account:</p>
		<pre>REVOKE EVENT ON myschema.* FROM jon@ghidora;</pre>
		<p>Important: Revoking the EVENT privilege from a user does not delete or disable any events that may have been created by that user.
			An event is not migrated or dropped as a result of renaming or dropping the user who created it.</p>
		<p>For example, suppose that the user jon@ghidora has been granted the EVENT and INSERT privileges on the myschema schema. This user then creates the following event:</p>
		<pre>CREATE EVENT e_insert
    ON SCHEDULE 
      EVERY 7 SECOND
    DO 
      INSERT INTO myschema.mytable;</pre>
		<p>After this event has been created, root revokes the EVENT privilege for jon@ghidora. However, e_insert continues to execute, inserting a new row into mytable each seven seconds.
			The same would be true if root had issued either of these statements:</p>
		<ul>
			<li>
				<pre>DROP USER jon@ghidora;</pre>
			</li>
			<li>
				<pre>RENAME USER jon@ghidora TO someotherguy@ghidora;</pre>
			</li>
		</ul>
		<p>You can verify that this is true by examining the mysql.event table (discussed later in this section) or the INFORMATION_SCHEMA.EVENTS table before and after issuing a DROP USER or RENAME USER statement.</p>
		<p>Event definitions are stored in the mysql.event table, which was added in MySQL 5.1.6.
			To drop an event created by another user account, the MySQL root user (or another user with the necessary privileges) can delete rows from this table.
			For example, to remove the event e_insert shown previously, root can use the following statement:</p>
		<pre>DELETE FROM mysql.event
    WHERE db = 'myschema' 
      AND definer = 'jon@ghidora' 
      AND name = 'e_insert';</pre>
		<p>It is very important to match the event name, database schema name, and user account when deleting rows from the mysql.event table.
			This is because the same user can create different events of the same name in different schemas.</p>
		<p>Note: The namespace for scheduled events changed in MySQL 5.1.12. Prior to that MySQL version, different users could create different events having the same name in the same database;
			in MySQL 5.1.12 and later, that is no longer the case. When upgrading to MySQL 5.1.12 or later from MySQL 5.1.11 or earlier,
			it is extremely important to make sure that no events in the same database share the same name, prior to performing the upgrade.</p>
		<p>Users' EVENT privileges are stored in the Event_priv columns of the mysql.user and mysql.db tables.
			In both cases, this column holds one of the values 'Y' or 'N'. 'N' is the default.
			mysql.user.Event_priv is set to 'Y' for a given user only if that user has the global EVENT privilege (that is, if the privilege was bestowed using GRANT EVENT ON *.*).
			For a schema-level EVENT privilege, GRANT creates a row in mysql.db and sets that row's Db column to the name of the schema, the User column to the name of the user, and the Event_priv column to 'Y'.
			There should never be any need to manipulate these tables directly, since the GRANT EVENT and REVOKE EVENT statement perform the required operations on them.</p>
		<p>MySQL 5.1.6 introduces five status variables providing counts of event-related operations (but not of statements executed by events;). These are:</p>
		<ul>
			<li>
				<p>Com_create_event: The number of CREATE EVENT statements executed since the last server restart.</p>
			</li>
			<li>
				<p>Com_alter_event: The number of ALTER EVENT statements executed since the last server restart.</p>
			</li>
			<li>
				<p>Com_drop_event: The number of DROP EVENT statements executed since the last server restart.</p>
			</li>
			<li>
				<p>Com_show_create_event: The number of SHOW CREATE EVENT statements executed since the last server restart.</p>
			</li>
			<li>
				<p>Com_show_events: The number of SHOW EVENTS statements executed since the last server restart.</p>
			</li>
		</ul>
		<p>You can view current values for all of these at one time by running the statement SHOW STATUS LIKE '%event%';.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Using Views</Heading>
		<Description><![CDATA[
		<p>Views (including updatable views) are available in MySQL Server 5.1. Views are stored queries that when invoked produce a result set. A view acts as a virtual table.</p>
		<p>To use views if you have upgraded to MySQL 5.1 from an older release that did not support views, you should upgrade your grant tables so that they contain the view-related privileges.</p>
		<p>The following discussion describes the syntax for creating and dropping views, and shows some examples of how to use them.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>View Syntax</Heading>
		<Description><![CDATA[
		<p>The CREATE VIEW statement creates a new view. To alter the definition of a view or drop a view, use ALTER VIEW, or DROP VIEW.</p>
		<p>A view can be created from many kinds of SELECT statements. It can refer to base tables or other views.
			It can use joins, UNION, and subqueries. The SELECT need not even refer to any tables.
			The following example defines a view that selects two columns from another table, as well as an expression calculated from those columns:</p>
		<pre>(sql sqlHandle {CREATE TABLE t (qty INT, price INT)})</pre>
		<pre>(sql sqlHandel {INSERT INTO t VALUES(3, 50), (5, 60)})</pre>
		<pre>(sql sqlHandel {CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t})</pre>
		<pre>(sql sqlHandel {SELECT * FROM v}) <b>Returns</b>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 | 
|    5 |    60 |   300 | 
+------+-------+-------+</pre>
		<pre>(sql sqlHandel {SELECT * FROM v WHERE qty = 5}) <b>Returns</b>
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    5 |    60 |   300 | 
+------+-------+-------+</pre>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>View Processing Algorithms</Heading>
		<Description><![CDATA[
		<p>The optional ALGORITHM clause for CREATE VIEW or ALTER VIEW is a MySQL extension to standard SQL.
			It affects how MySQL processes the view. ALGORITHM takes three values: MERGE, TEMPTABLE, or UNDEFINED. The default algorithm is UNDEFINED if no ALGORITHM clause is present.</p>
		<p>For MERGE, the text of a statement that refers to the view and the view definition are merged such that parts of the view definition replace corresponding parts of the statement.</p>
		<p>For TEMPTABLE, the results from the view are retrieved into a temporary table, which then is used to execute the statement.</p>
		<p>For UNDEFINED, MySQL chooses which algorithm to use. It prefers MERGE over TEMPTABLE if possible, because MERGE is usually more efficient and because a view cannot be updatable if a temporary table is used.</p>
		<p>A reason to choose TEMPTABLE explicitly is that locks can be released on underlying tables after the temporary table has been created and before it is used to finish processing the statement.
			This might result in quicker lock release than the MERGE algorithm so that other clients that use the view are not blocked as long.</p>
		<p>A view algorithm can be UNDEFINED for three reasons:</p>
		<ul>
			<li>
				<p>No ALGORITHM clause is present in the CREATE VIEW statement.</p>
			</li>
			<li>
				<p>The CREATE VIEW statement has an explicit ALGORITHM = UNDEFINED clause.</p>
			</li>
			<li>
				<p>ALGORITHM = MERGE is specified for a view that can be processed only with a temporary table.
					In this case, MySQL generates a warning and sets the algorithm to UNDEFINED.</p>
			</li>
		</ul>
		<p>As mentioned earlier, MERGE is handled by merging corresponding parts of a view definition into the statement that refers to the view.
			The following examples briefly illustrate how the MERGE algorithm works. The examples assume that there is a view v_merge that has this definition:</p>
		<pre>CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS
SELECT c1, c2 FROM t WHERE c3 > 100;</pre>
		<p>Example 1: Suppose that we issue this statement:</p>
		<pre>SELECT * FROM v_merge;</pre>
		<p>MySQL handles the statement as follows:</p>
		<ul>
			<li>
				<p>v_merge becomes t</p>
			</li>
			<li>
				<p>* becomes vc1, vc2, which corresponds to c1, c2</p>
			</li>
			<li>
				<p>The view WHERE clause is added</p>
			</li>
		</ul>
		<p>The resulting statement to be executed becomes:</p>
		<pre>SELECT c1, c2 FROM t WHERE c3 > 100;</pre>
		<p>Example 2: Suppose that we issue this statement:</p>
		<pre>SELECT * FROM v_merge WHERE vc1 < 100;</pre>
		<p>This statement is handled similarly to the previous one, except that vc1 < 100 becomes c1 < 100 and
			the view WHERE clause is added to the statement WHERE clause using an AND connective (and parentheses are added to make sure the parts of the clause are executed with correct precedence).
			The resulting statement to be executed becomes:</p>
		<pre>SELECT c1, c2 FROM t WHERE (c3 > 100) AND (c1 < 100);</pre>
		<p>Effectively, the statement to be executed has a WHERE clause of this form:</p>
		<pre>WHERE (select WHERE) AND (view WHERE)</pre>
		<p>The MERGE algorithm requires a one-to-one relationship between the rows in the view and the rows in the underlying table.
			If this relationship does not hold, a temporary table must be used instead. Lack of a one-to-one relationship occurs if the view contains any of a number of constructs:</p>
		<ul>
			<li>
				<p>Aggregate functions (SUM(), MIN(), MAX(), COUNT(), and so forth)</p>
			</li>
			<li>
				<p>DISTINCT</p>
			</li>
			<li>
				<p>GROUP BY</p>
			</li>
			<li>
				<p>HAVING</p>
			</li>
			<li>
				<p>LIMIT</p>
			</li>
			<li>
				<p>UNION or UNION ALL</p>
			</li>
			<li>
				<p>Subquery in the select list</p>
			</li>
			<li>
				<p>Refers only to literal values (in this case, there is no underlying table)</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Updatable and Insertable Views</Heading>
		<Description><![CDATA[
		<p>Some views are updatable. That is, you can use them in statements such as UPDATE, DELETE, or INSERT to update the contents of the underlying table.
			For a view to be updatable, there must be a one-to-one relationship between the rows in the view and the rows in the underlying table.
			There are also certain other constructs that make a view non-updatable. To be more specific, a view is not updatable if it contains any of the following:</p>
		<ul>
			<li>
				<p>Aggregate functions (SUM(), MIN(), MAX(), COUNT(), and so forth)</p>
			</li>
			<li>
				<p>DISTINCT</p>
			</li>
			<li>
				<p>GROUP BY</p>
			</li>
			<li>
				<p>HAVING</p>
			</li>
			<li>
				<p>UNION or UNION ALL</p>
			</li>
			<li>
				<p>Subquery in the select list</p>
			</li>
			<li>
				<p>Certain joins (see additional join discussion later in this section)</p>
			</li>
			<li>
				<p>Non-updatable view in the FROM clause</p>
			</li>
			<li>
				<p>A subquery in the WHERE clause that refers to a table in the FROM clause</p>
			</li>
			<li>
				<p>Refers only to literal values (in this case, there is no underlying table to update)</p>
			</li>
			<li>
				<p>Uses ALGORITHM = TEMPTABLE (use of a temporary table always makes a view non-updatable)</p>
			</li>
			<li>
				<p>Multiple references to any column of a base table.</p>
			</li>
		</ul>
		<p>With respect to insertability (being updatable with INSERT statements), an updatable view is insertable if it also satisfies these additional requirements for the view columns:</p>
		<ul>
			<li>
				<p>There must be no duplicate view column names.</p>
			</li>
			<li>
				<p>The view must contain all columns in the base table that do not have a default value.</p>
			</li>
			<li>
				<p>The view columns must be simple column references and not derived columns.
					A derived column is one that is not a simple column reference but is derived from an expression. These are examples of derived columns:</p>
				<pre>3.14159
col1 + 3
UPPER(col2)
col3 / col4
(subquery)</pre>
			</li>
		</ul>
		<p>A view that has a mix of simple column references and derived columns is not insertable,
			but it can be updatable if you update only those columns that are not derived. Consider this view:</p>
		<pre>CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;</pre>
		<p>This view is not insertable because col2 is derived from an expression. But it is updatable if the update does not try to update col2. This update is allowable:</p>
		<pre>UPDATE v SET col1 = 0;</pre>
		<p>This update is not allowable because it attempts to update a derived column:</p>
		<pre>UPDATE v SET col2 = 0;</pre>
		<p>It is sometimes possible for a multiple-table view to be updatable, assuming that it can be processed with the MERGE algorithm.
			For this to work, the view must use an inner join (not an outer join or a UNION). Also, only a single table in the view definition can be updated,
			so the SET clause must name only columns from one of the tables in the view. Views that use UNION ALL are disallowed even though they might be theoretically updatable,
			because the implementation uses temporary tables to process them.</p>
		<p>For a multiple-table updatable view, INSERT can work if it inserts into a single table. DELETE is not supported.</p>
		<p>INSERT DELAYED is not supported for views.</p>
		<p>If a table contains an AUTO_INCREMENT column, inserting into an insertable view on the table that does not include the AUTO_INCREMENT column does not change the value of LAST_INSERT_ID(),
			because the side effects of inserting default values into columns not part of the view should not be visible.</p>
		<p>The WITH CHECK OPTION clause can be given for an updatable view to prevent inserts or updates to rows except those for which the WHERE clause in the select_statement is true.</p>
		<p>In a WITH CHECK OPTION clause for an updatable view, the LOCAL and CASCADED keywords determine the scope of check testing when the view is defined in terms of another view.
			The LOCAL keyword restricts the CHECK OPTION only to the view being defined. CASCADED causes the checks for underlying views to be evaluated as well.
			When neither keyword is given, the default is CASCADED. Consider the definitions for the following table and set of views:</p>
		<pre>(sql sqlHandel {CREATE TABLE t1 (a INT)})</pre>
		<pre>(sql sqlHandel {CREATE VIEW v1 AS SELECT * FROM t1 WHERE a < 2 WITH CHECK OPTION})</pre>
		<pre>(sql sqlHandel {CREATE VIEW v2 AS SELECT * FROM v1 WHERE a > 0 WITH LOCAL CHECK OPTION})</pre>
		<pre>(sql sqlHandel {CREATE VIEW v3 AS SELECT * FROM v1 WHERE a > 0 WITH CASCADED CHECK OPTION})</pre>
		<p>Here the v2 and v3 views are defined in terms of another view, v1. v2 has a LOCAL check option, so inserts are tested only against the v2 check.
			v3 has a CASCADED check option, so inserts are tested not only against its own check, but against those of underlying views. The following statements illustrate these differences:</p>
		<pre>(sql sqlHandel {INSERT INTO v2 VALUES (2)})</pre>
		<pre>(sql sqlHandel {INSERT INTO v3 VALUES (2)}) <b>Returns</b> ERROR 1369 (HY000): CHECK OPTION failed 'test.v3'</pre>
		<p>MySQL sets a flag, called the view updatability flag, at CREATE VIEW time. The flag is set to YES (true) if UPDATE and DELETE (and similar operations) are legal for the view.
			Otherwise, the flag is set to NO (false). The IS_UPDATABLE column in the INFORMATION_SCHEMA.VIEWS table displays the status of this flag.
			It means that the server always knows whether a view is updatable. If the view is not updatable, statements such UPDATE, DELETE, and INSERT are illegal and will be rejected.
			(Note that even if a view is updatable, it might not be possible to insert into it, as described elsewhere in this section.)</p>
		<p>The updatability of views may be affected by the value of the updatable_views_with_limit system variable.</p>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>View Metadata</Heading>
		<Description><![CDATA[
		<p>Metadata about views can be obtained as follows:</p>
		<ul>
			<li>
				<p>Query the VIEWS table of the INFORMATION_SCHEMA database.</p>
			</li>
			<li>
				<p>Use the SHOW CREATE VIEW statement.</p>
			</li>
		</ul>
	    ]]></Description>
	</Section>
</Essay>

