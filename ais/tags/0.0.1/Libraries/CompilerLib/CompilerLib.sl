;;/**********************************************************************************
;;    Copyright (C) 2008 Investment Science Corp.
;;
;;    This program is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation, either version 3 of the License, or
;;    any later version.
;;
;;    This program is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;
;;***********************************************************************************/
;;
;;*************************************
;;*************************************
;; Exported Lambda File Cabinet Document
;;*************************************
;;*************************************

;;**EXPORTKEY**:Test:CFile
;#text#
#if 0
CompilerLibSelfTest.c

SUMMARY: 			This Lambda implements the CompilerLibSelfTest Lambda as a registered
	          		C user defined function. Each compiled instruction is
	          		marked with a boxed comment lines for ease of human understanding.
	         
NOTE: 	   			This code was machine generated by CompilerLib.

AUTHORS:            CompilerLib

#endif

#define _Lambda_COMPILER_ 1
#include "fsmtbase.h"

extern TVAL FCompilerLibSelfTest_Init(LpXCONTEXT gCP,LpTHREAD gTP);
extern TVAL FCompilerLibSelfTest_MakeNative(LpXCONTEXT gCP,LpTHREAD gTP,NUM argc,TVAL argv[]);

/* Lambda native C evaluator function declarations. */
extern TVAL FCompilerLibSelfTest_Eval1000(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* Lambda,NUM argc,TVAL argv[]);
extern TVAL FCompilerLibSelfTest_Eval1001(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* Lambda,NUM argc,TVAL argv[]);
extern TVAL FCompilerLibSelfTest_Eval1002(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* Lambda,NUM argc,TVAL argv[]);


/********************************************************************/ 
/* BEGIN MACRO DEFINITIONS
/********************************************************************/

#define RealValue(x, pTval, lbl) \
	switch ((pTval)->Tag) { \
	case TYBOLE: \
	case TYCHAR: \
	case TYNUM:    x = (REAL)((pTval)->u.Int);   break; \
	case TYREAL: \
	case TYDATE: \
	case TYMONEY:  x = (pTval)->u.Real;  break; \
	case TYSHORT:  x = (REAL)((pTval)->u.Short); break; \
	case TYTEXT:   x = gCP->atof((pTval)->u.Text); break; \
	case TYSTRING: x = gCP->atof((char *)(gCP->FSmartbase_ObjectPtr((POINTER)gCP, gTP, (pTval)))); break; \
	case TYVOID: \
	default: goto lbl; }

#define IntValue(i, pTval, lbl) \
	switch ((pTval)->Tag) { \
	case TYBOLE: \
	case TYCHAR: \
	case TYNUM:    i = (pTval)->u.Int;   break; \
	case TYREAL: \
	case TYDATE: \
	case TYMONEY:  i = (NUM)((pTval)->u.Real);  break; \
	case TYSHORT:  i = (NUM)((pTval)->u.Short); break; \
	case TYTEXT:   i = gCP->atol((pTval)->u.Text); break; \
	case TYSTRING: i = gCP->atol((char *)(gCP->FSmartbase_ObjectPtr((POINTER)gCP, gTP, (pTval)))); break; \
	case TYVOID: \
	default: goto lbl; }

#define IsNative(Pred, pTval) \
	switch ((pTval)->Tag) { \
	case TYVOID:  \
	case TYBOLE:  \
	case TYCHAR:  \
	case TYNUM:   \
	case TYREAL:  \
	case TYDATE:  \
	case TYMONEY: \
	case TYSHORT: \
	case TYTEXT:  Pred = 1; break; \
	default: Pred = 0; }

#define IsScalar(Pred, pTval) \
	switch ((pTval)->Tag) { \
	case TYVOID:  \
	case TYBOLE:  \
	case TYCHAR:  \
	case TYNUM:   \
	case TYREAL:  \
	case TYDATE:  \
	case TYMONEY: \
	case TYSHORT: \
	case TYTEXT:  \
	case TYSTRING: Pred = 1; break; \
	default: Pred = 0; }

/*	----------------------------------------------------------------------------
CALC - Macro to perform numeric operation on two TVALs that contain a numeric
Helper MACRO for child Lambdas

t1			[in] TVAL containing a numeric value (NUM,REAL,DATE,MONEY,...)
t2			[in] TVAL containing a numeric value
op			[in] numeric operation (+, -, *, /)
lbl			[in] label for jump must be distinct for each macro call in an Lambda
Returns:	TVAL containing result in result
			result is of type TYREAL unless both Args are of type TYNUM
	------------------------------------------------------------------------- */
#define CALC(t1, t2, op, lbl, R) \
	if (t1.Tag == TYNUM && t2.Tag == TYNUM) \
	{	Result.Tag = TYNUM; \
		Result.u.Int = t1.u.Int op t2.u.Int; \
		__asm{ jno lbl } \
		Result.Tag = TYREAL; \
		Result.u.Real = (REAL)(t1.u.Int) op t2.u.Int; \
lbl:	; \
	} \
	else \
	{	RealValue(R, &t1, BadTypeError) \
		RealValue(Result.u.Real, &t2, BadTypeError) \
		Result.Tag = TYREAL; \
		Result.u.Real op= R; \
	}
  

/*	----------------- Miscellaneous Macros ------------------------  */
  
#define inRange(v,s,e)        (v >= s && v < e)  
#define CharArray(tval)       ((LpCHAR)*((TString*)((tval).u.Object))->itsCString)
#define String(tval)          ((TString*)((tval).u.Object))
#define SymbolArray(tval)     ((LpCHAR)*((TSymbol*)((tval).u.Object))->itsCString)
#define Symbol(tval)          ((TSymbol*)((tval).u.Object)) 
#define Vector(tval)          ((TVector*)((tval).u.Object))
#define NumVector(tval)       ((TNumVector*)((tval).u.Object))
#define IntVector(tval)       (tval.u.IntVector)
#define FltVector(tval)       ((TFltVector*)((tval).u.Object))
#define ByteVector(tval)      ((TByteVector*)((tval).u.Object))
#define BitVector(tval)       ((TBitVector*)((tval).u.Object))
#define ObjVector(tval)       ((TObjVector*)((tval).u.Object))
#define PcodeVector(tval)     ((TPcodeVector*)((tval).u.Object))
#define Structure(tval)		  ((TStructure*)((tval).u.Object))
#define Directory(tval)       ((TDirectory*)((tval).u.Object))
#define Dictionary(tval)      ((TDictionary*)((tval).u.Object))
#define Matrix(tval)          ((TMatrix*)((tval).u.Object))
#define NumMatrix(tval)       ((TNumMatrix*)((tval).u.Object))
#define IntArray(tval)        ((LpNUM)*((TIntVector*)((tval).u.Object))->itsIntArray)
#define TvalArray(tval)       ((LpTVAL)*((TVector*)((tval).u.Object))->itsTvalArray)
#define BitArray(tval)        ((LpCHAR)*((TBitVector*)((tval).u.Object))->itsBitArray)
#define ByteArray(tval)       ((LpCHAR)*((TByteVector*)((tval).u.Object))->itsByteArray)
#define RealArray(tval)       ((LpREAL)*((TNumVector*)((tval).u.Object))->itsRealArray)
#define FloatArray(tval)      ((LpFLOAT)*((TFltVector*)((tval).u.Object))->itsFloatArray)
#define ObjArray(tval)        ((struct TObject**)*((TObjVector*)((tval).u.Object))->itsObjectArray)
#define PcodeArray(tval)      ((LpNUM)*((TPcodeVector*)((tval).u.Object))->itsInstructionArray)
#define TvalMatrix(tval)      ((LpTVAL)*((TMatrix*)((tval).u.Object))->itsTvalMatrix)
#define RealMatrix(tval)      ((LpREAL)*((TNumMatrix*)((tval).u.Object))->itsRealMatrix)
#define BondArray(tval)       ((LpBIND)*((TDictionary*)((tval).u.Object))->itsDictionaryArray)
#define BindArray(tval)       ((LpBIND)*((TStructure*)((tval).u.Object))->itsDictionaryArray)
#define PBindArray(tval)      ((LpPBIND)*((TDirectory*)((tval).u.Object))->itsDirectoryArray) 
#define _TObject_TypeFlag(tt) atHMChar(gCP->TObject_TypeFlag,(tt))

#if 0 
Setup macros for arithmetic overflow conditions  
#endif

#define JumpNoOverflow(label)		_asm { jno label }
#define JumpOnOverflow(label)		_asm { jo label }

/********************************************************************/ 
/* END MACRO DEFINITIONS
/********************************************************************/
 

#if 0
FCompilerLibSelfTest_Init

This function initializes the native C Code support for the CompilerLibSelfTest Lambda, and
registers all necessary support functions to the Smartbase environment. There are
several steps to this process:

	o	The FCompilerLibSelfTest.c & FCompilerLibSelfTest.h source files must be compiled and linked with
		the glue layer code. 
	
	o	The FCompilerLibSelfTest_Init function must be called during engine initialization.

	o	After the CompilerLibSelfTest Lambda has been loaded into memory, the FCompilerLibSelfTest_MakeNative 
		function must be called, which links the CompilerLibSelfTest Lambda to the FCompilerLibSelfTest_Eval
		function, so the CompilerLibSelfTest Lambda can be evaluated at native C speed instead of 
		at emulated speed.
	
	Hint: 	After the CompilerLibSelfTest Lambda has been loaded into memory, the FCompilerLibSelfTest_MakeNative 
			function may be called, from the console, as follows: (CompilerLibSelfTest_MakeNative CompilerLibSelfTest)

#endif

TVAL FCompilerLibSelfTest_Init(LpXCONTEXT gCP,LpTHREAD gTP)
{
	StartFrame
	DeclareTVAL(lEc);
	EndFrame
 
	/* Register the Smartbase functions contained in this package */
	Stack(lEc) = gCP->FSmartbase_RegisterCProcedure((POINTER)gCP,gTP,(LpCHAR)"CompilerLibSelfTest_MakeNative",(LpFUNC)&FCompilerLibSelfTest_MakeNative);
	ExitOnError(Stack(lEc));
	
	FrameExit(gCP->Tval_TRUE);
}

#if 0
FCompilerLibSelfTest_MakeNative


Usage:		(CompilerLibSelfTest_MakeNative CompilerLibSelfTest)


The CompilerLibSelfTest_MakeNative Function receives an instance of the CompilerLibSelfTest Lambda 
as an argument. The CompilerLibSelfTest_MakeNative Function links the CompilerLibSelfTest Lambda to 
the FCompilerLibSelfTest_Eval function, so the CompilerLibSelfTest Lambda can be evaluated at native 
C speed instead of at emulated speed.

Note:
 1.	After the conversion to native, the CompilerLibSelfTest Lambda should perform exactly as prior
	to conversion with the exception that it should evaluate faster.

#endif

TVAL FCompilerLibSelfTest_MakeNative(LpXCONTEXT gCP,LpTHREAD gTP,NUM argc, TVAL argv[])
{
	// Initialize the global symbols and protect them from garbage collection.
	StartFrame
	DeclareTVAL(myLambda);
	DeclareTVAL(childLambda);
	DeclareTVAL(lEc);
	EndFrame

	/* Make sure we pass only one argument and that must be our Lambda. */
	
	if ((argc != 1) || (argv[0].Tag != TYLAMBDA))
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);		
		}
		
	/* Link the Lambda (argument) to the FCompilerLibSelfTest_Eval function. 		   */
	/* Note: This allows the CompilerLibSelfTest Lambda to be evaluated faster. 	   */
	/* Warning: Passing the wrong Lambda or an out of date CompilerLibSelfTest Lambda */
	/*			to this function will result in unpredictable behavior.    */
		
    Stack(myLambda) = gCP->FSmartbase_Evals((POINTER)gCP,gTP,"CompilerLibSelfTest",FALSE);
    Lambda(Stack(myLambda))->VirtualMachine = TSYMBOL("nativeEvaluator");
    Lambda(Stack(myLambda))->NativeCodeVector = TFUNCTION(FCompilerLibSelfTest_Eval1000);

    Stack(myLambda) = gCP->FSmartbase_Evals((POINTER)gCP,gTP,"CompilerLibSelfTest.Cv[14]",FALSE);
    Lambda(Stack(myLambda))->VirtualMachine = TSYMBOL("nativeEvaluator");
    Lambda(Stack(myLambda))->NativeCodeVector = TFUNCTION(FCompilerLibSelfTest_Eval1001);

    Stack(myLambda) = gCP->FSmartbase_Evals((POINTER)gCP,gTP,"CompilerLibSelfTest.Cv[20]",FALSE);
    Lambda(Stack(myLambda))->VirtualMachine = TSYMBOL("nativeEvaluator");
    Lambda(Stack(myLambda))->NativeCodeVector = TFUNCTION(FCompilerLibSelfTest_Eval1002);



	FrameExit(gCP->TObject_TRUE);
}




#if 0
NAME:	FCompilerLibSelfTest_Eval1000
#endif

TVAL FCompilerLibSelfTest_Eval1000(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* myLambda,NUM argc, TVAL argv[])
{   
    /* RUNTIME REGISTER POINTERS */
	register LpTVAL		argsPtr;	/* Pointer to Lambda args 	*/
	register LpBIND		varsPtr;	/* Pointer to Lambda vars 	*/
	register LpBIND		pvarsPtr;	/* Pointer to Lambda pvars 	*/
	register LpBIND		cvarsPtr;	/* Pointer to Lambda cvars 	*/
	register TSymbol**	pcodePtr;	/* Pointer to pcode vector 	*/

	StartFrame
	DeclareTVAL(__Ec);		// Error code
	DeclareTVAL(__Ret);		// Return Value 
	
	/* -VARS_TVAL_DECLARATIONS- */
	DeclareTVAL(_v1);
    DeclareTVAL(_v2);
    DeclareTVAL(_vr);
    DeclareTVAL(_result);
    DeclareTVAL(_vintvec);
    DeclareTVAL(_monthlyBills);
    DeclareTVAL(_aLongString);
    DeclareTVAL(_aHostObj);
    DeclareTVAL(___T8);
    DeclareTVAL(___T9);
    DeclareTVAL(ErrorLambdaTval);
    DeclareTVALArray(prmv, 5);
    InitTVALArray(prmv);
    
	
	EndFrame

	/* -AUTO_ARG_CHECKING- */ 
	if (argc < 3)
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);
		}
	
	/* INITIALIZATION. */
	
	argsPtr = argv;
	varsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->TemporaryVariables);
	pvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PersistantVariables);
	cvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->ClassVariables); 
	pcodePtr = (TSymbol**)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PcodeVector); 
	
	/* -INITIALIZE_VARS_DECLARATIONS- */
	Stack(_v1) = varsPtr[0].Value;
    Stack(_v2) = varsPtr[1].Value;
    Stack(_vr) = varsPtr[2].Value;
    Stack(_result) = varsPtr[3].Value;
    Stack(_vintvec) = varsPtr[4].Value;
    Stack(_monthlyBills) = varsPtr[5].Value;
    Stack(_aLongString) = varsPtr[6].Value;
    Stack(_aHostObj) = varsPtr[7].Value;
    Stack(___T8) = varsPtr[8].Value;
    Stack(___T9) = varsPtr[9].Value;
    
	
	/* START OF GENERATED CODE. */	
	L0:   
          Stack(prmv[0]) = cvarsPtr[4].Value;
    L2:   /*********** Calling function: eval ***********/
          Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[270]->itsGlobalValue, 1, &Stack(prmv[0]));
          ExitWhenError(Stack(___T8));
    L6:   
          Stack(prmv[0]) = argsPtr[0];
          Stack(prmv[1]) = argsPtr[1];
          Stack(prmv[2]) = argsPtr[2];
    L10:   /*********** Calling function: __T8 ***********/
           Stack(_result) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, Stack(___T8), 3, &Stack(prmv[0]));
           ExitWhenError(Stack(_result));
    L14:   cvarsPtr[2].Value =   TINT(argc);
    L16:   pvarsPtr[2].Value = cvarsPtr[2].Value; 
    L19:   Stack(_vr) = pvarsPtr[2].Value; 
    L22:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(_vr), Stack(_result)).u.Bool == TRUE)  goto L34;
    L26:   
           Stack(prmv[0]) = cvarsPtr[5].Value;
    L28:   /*********** Calling function: error ***********/
           Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
           ExitWhenError(Stack(___T8));
    L32:   goto L37;
    L34:   Stack(___T8) = cvarsPtr[6].Value; 
    L37:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, pvarsPtr[2].Value, Stack(_result)).u.Bool == TRUE)  goto L49;
    L41:   
           Stack(prmv[0]) = cvarsPtr[7].Value;
    L43:   /*********** Calling function: error ***********/
           Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
           ExitWhenError(Stack(___T8));
    L47:   goto L52;
    L49:   Stack(___T8) = cvarsPtr[6].Value; 
    L52:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, cvarsPtr[2].Value, Stack(_result)).u.Bool == TRUE)  goto L64;
    L56:   
           Stack(prmv[0]) = cvarsPtr[8].Value;
    L58:   /*********** Calling function: error ***********/
           Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
           ExitWhenError(Stack(___T8));
    L62:   goto L67;
    L64:   Stack(___T8) = cvarsPtr[6].Value; 
    L67:   
           Stack(prmv[0]) = cvarsPtr[9].Value;
    L69:   /*********** Calling function: eval ***********/
           Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[270]->itsGlobalValue, 1, &Stack(prmv[0]));
           ExitWhenError(Stack(___T8));
    L73:   
           Stack(prmv[0]) = argsPtr[0];
           Stack(prmv[1]) = argsPtr[1];
           Stack(prmv[2]) = argsPtr[2];
    L77:   /*********** Calling function: __T8 ***********/
           Stack(_result) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, Stack(___T8), 3, &Stack(prmv[0]));
           ExitWhenError(Stack(_result));
    L81:   cvarsPtr[2].Value =   argv[asInt(&cvarsPtr[10].Value)];
    L84:   pvarsPtr[2].Value = cvarsPtr[2].Value; 
    L87:   Stack(_vr) = pvarsPtr[2].Value; 
    L90:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(_vr), Stack(_result)).u.Bool == TRUE)  goto L102;
    L94:   
           Stack(prmv[0]) = cvarsPtr[11].Value;
    L96:   /*********** Calling function: error ***********/
           Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
           ExitWhenError(Stack(___T8));
    L100:   goto L105;
    L102:   Stack(___T8) = cvarsPtr[6].Value; 
    L105:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, pvarsPtr[2].Value, Stack(_result)).u.Bool == TRUE)  goto L117;
    L109:   
            Stack(prmv[0]) = cvarsPtr[12].Value;
    L111:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L115:   goto L120;
    L117:   Stack(___T8) = cvarsPtr[6].Value; 
    L120:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, cvarsPtr[2].Value, Stack(_result)).u.Bool == TRUE)  goto L132;
    L124:   
            Stack(prmv[0]) = cvarsPtr[13].Value;
    L126:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L130:   goto L135;
    L132:   Stack(___T8) = cvarsPtr[6].Value; 
    L135:   Stack(___T9) = cvarsPtr[14].Value; 
    L138:   
            Stack(prmv[0]) = cvarsPtr[15].Value;
            Stack(prmv[1]) = cvarsPtr[16].Value;
            Stack(prmv[2]) = Stack(___T9);
    L142:   /*********** Calling function: addMethod ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[179]->itsGlobalValue, 3, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L146:   Stack(_monthlyBills) = cvarsPtr[17].Value; 
    L149:   
            Stack(prmv[0]) = Stack(_monthlyBills);
    L151:   Stack(prmv[1]) = cvarsPtr[16].Value;
            /*********** Calling function: __send ***********/
            Stack(_result) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, gCP->TSymbol___send->itsGlobalValue, 2, &Stack(prmv[0]));
            ExitWhenError(Stack(_result));
    L155:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(_result), cvarsPtr[18].Value).u.Bool == TRUE)  goto L167;
    L159:   
            Stack(prmv[0]) = cvarsPtr[19].Value;
    L161:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L165:   goto L170;
    L167:   Stack(___T8) = cvarsPtr[6].Value; 
    L170:   Stack(___T9) = cvarsPtr[20].Value; 
    L173:   
            Stack(prmv[0]) = cvarsPtr[21].Value;
            Stack(prmv[1]) = cvarsPtr[22].Value;
            Stack(prmv[2]) = Stack(___T9);
    L177:   /*********** Calling function: addMethod ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[179]->itsGlobalValue, 3, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L181:   
            Stack(prmv[0]) = cvarsPtr[21].Value;
            Stack(prmv[1]) = cvarsPtr[23].Value;
    L184:   /*********** Calling function: new ***********/
            Stack(_aLongString) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[186]->itsGlobalValue, 2, &Stack(prmv[0]));
            ExitWhenError(Stack(_aLongString));
    L188:   
            Stack(prmv[0]) = Stack(_aLongString);
            Stack(prmv[1]) = cvarsPtr[24].Value;
            Stack(prmv[2]) = cvarsPtr[25].Value;
    L192:   
            Stack(prmv[3]) = cvarsPtr[26].Value;
    L194:   Stack(prmv[4]) = cvarsPtr[22].Value;
            /*********** Calling function: __send ***********/
            Stack(_result) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, gCP->TSymbol___send->itsGlobalValue, 5, &Stack(prmv[0]));
            ExitWhenError(Stack(_result));
    L198:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(_result), cvarsPtr[27].Value).u.Bool == TRUE)  goto L210;
    L202:   
            Stack(prmv[0]) = cvarsPtr[28].Value;
    L204:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L208:   goto L213;
    L210:   Stack(___T8) = cvarsPtr[6].Value; 
    L213:   pvarsPtr[0].Value = cvarsPtr[29].Value; 
    L216:   Stack(_result) =   TOBJ(myLambda);
    L218:   Stack(prmv[0]) = Stack(_result);
            Stack(prmv[1]) = cvarsPtr[30].Value;
            /*********** Calling function: FSmartbase_Ref ***********/
            Stack(___T8) =  gCP->FSmartbase_Refv((POINTER)gCP, gTP, 2 , &Stack(prmv[0]));
    
            ExitWhenError(Stack(___T8));
    L222:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), pvarsPtr[0].Value).u.Bool == TRUE)  goto L234;
    L226:   
            Stack(prmv[0]) = cvarsPtr[31].Value;
    L228:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L232:   goto L237;
    L234:   Stack(___T8) = cvarsPtr[6].Value; 
    L237:   Stack(_v1) = cvarsPtr[6].Value; 
    L240:   cvarsPtr[0].Value = Stack(_v1); 
    L243:   pvarsPtr[0].Value = cvarsPtr[0].Value; 
    L246:   Stack(_v2) = cvarsPtr[32].Value; 
    L249:   cvarsPtr[1].Value = Stack(_v2); 
    L252:   pvarsPtr[1].Value = cvarsPtr[1].Value; 
    L255:   
            Stack(prmv[0]) = cvarsPtr[33].Value;
            Stack(prmv[1]) = Stack(_v1);
            Stack(prmv[2]) = cvarsPtr[34].Value;
    L259:   
            Stack(prmv[3]) = Stack(_v2);
            Stack(prmv[4]) = cvarsPtr[35].Value;
    L262:   /*********** Calling function: append ***********/
            Stack(___T9) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[264]->itsGlobalValue, 5, &Stack(prmv[0]));
            ExitWhenError(Stack(___T9));
    L266:   
            Stack(prmv[0]) = Stack(___T9);
    L268:   /*********** Calling function: eval ***********/
            Stack(_result) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[270]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(_result));
    L272:   Stack(_vr).u.Bool =  Stack(_v1).u.Bool + Stack(_v2).u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L276:   Stack(___T8) = Stack(_vr); 
    L279:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L291;
    L283:   
            Stack(prmv[0]) = cvarsPtr[36].Value;
    L285:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L289:   goto L294;
    L291:   Stack(___T8) = cvarsPtr[6].Value; 
    L294:   Stack(_vr).u.Bool =  Stack(_v1).u.Bool + pvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L298:   Stack(___T8) = Stack(_vr); 
    L301:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L313;
    L305:   
            Stack(prmv[0]) = cvarsPtr[37].Value;
    L307:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L311:   goto L316;
    L313:   Stack(___T8) = cvarsPtr[6].Value; 
    L316:   Stack(_vr).u.Bool =  Stack(_v1).u.Bool + cvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L320:   Stack(___T8) = Stack(_vr); 
    L323:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L335;
    L327:   
            Stack(prmv[0]) = cvarsPtr[38].Value;
    L329:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L333:   goto L338;
    L335:   Stack(___T8) = cvarsPtr[6].Value; 
    L338:   Stack(_vr).u.Bool =  pvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L342:   Stack(___T8) = Stack(_vr); 
    L345:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L357;
    L349:   
            Stack(prmv[0]) = cvarsPtr[39].Value;
    L351:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L355:   goto L360;
    L357:   Stack(___T8) = cvarsPtr[6].Value; 
    L360:   Stack(_vr).u.Bool =  pvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L364:   Stack(___T8) = Stack(_vr); 
    L367:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L379;
    L371:   
            Stack(prmv[0]) = cvarsPtr[40].Value;
    L373:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L377:   goto L382;
    L379:   Stack(___T8) = cvarsPtr[6].Value; 
    L382:   Stack(_vr).u.Bool =  pvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L386:   Stack(___T8) = Stack(_vr); 
    L389:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L401;
    L393:   
            Stack(prmv[0]) = cvarsPtr[41].Value;
    L395:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L399:   goto L404;
    L401:   Stack(___T8) = cvarsPtr[6].Value; 
    L404:   Stack(_vr).u.Bool =  cvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L408:   Stack(___T8) = Stack(_vr); 
    L411:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L423;
    L415:   
            Stack(prmv[0]) = cvarsPtr[42].Value;
    L417:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L421:   goto L426;
    L423:   Stack(___T8) = cvarsPtr[6].Value; 
    L426:   Stack(_vr).u.Bool =  cvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L430:   Stack(___T8) = Stack(_vr); 
    L433:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L445;
    L437:   
            Stack(prmv[0]) = cvarsPtr[43].Value;
    L439:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L443:   goto L448;
    L445:   Stack(___T8) = cvarsPtr[6].Value; 
    L448:   Stack(_vr).u.Bool =  cvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            Stack(_vr).Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L452:   Stack(___T8) = Stack(_vr); 
    L455:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L467;
    L459:   
            Stack(prmv[0]) = cvarsPtr[44].Value;
    L461:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L465:   goto L470;
    L467:   Stack(___T8) = cvarsPtr[6].Value; 
    L470:   pvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + Stack(_v2).u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L474:   Stack(___T8) = pvarsPtr[2].Value; 
    L477:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L489;
    L481:   
            Stack(prmv[0]) = cvarsPtr[45].Value;
    L483:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L487:   goto L492;
    L489:   Stack(___T8) = cvarsPtr[6].Value; 
    L492:   pvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + pvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L496:   Stack(___T8) = pvarsPtr[2].Value; 
    L499:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L511;
    L503:   
            Stack(prmv[0]) = cvarsPtr[46].Value;
    L505:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L509:   goto L514;
    L511:   Stack(___T8) = cvarsPtr[6].Value; 
    L514:   pvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + cvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L518:   Stack(___T8) = pvarsPtr[2].Value; 
    L521:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L533;
    L525:   
            Stack(prmv[0]) = cvarsPtr[47].Value;
    L527:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L531:   goto L536;
    L533:   Stack(___T8) = cvarsPtr[6].Value; 
    L536:   pvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L540:   Stack(___T8) = pvarsPtr[2].Value; 
    L543:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L555;
    L547:   
            Stack(prmv[0]) = cvarsPtr[48].Value;
    L549:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L553:   goto L558;
    L555:   Stack(___T8) = cvarsPtr[6].Value; 
    L558:   pvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L562:   Stack(___T8) = pvarsPtr[2].Value; 
    L565:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L577;
    L569:   
            Stack(prmv[0]) = cvarsPtr[49].Value;
    L571:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L575:   goto L580;
    L577:   Stack(___T8) = cvarsPtr[6].Value; 
    L580:   pvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L584:   Stack(___T8) = pvarsPtr[2].Value; 
    L587:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L599;
    L591:   
            Stack(prmv[0]) = cvarsPtr[50].Value;
    L593:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L597:   goto L602;
    L599:   Stack(___T8) = cvarsPtr[6].Value; 
    L602:   pvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L606:   Stack(___T8) = pvarsPtr[2].Value; 
    L609:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L621;
    L613:   
            Stack(prmv[0]) = cvarsPtr[51].Value;
    L615:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L619:   goto L624;
    L621:   Stack(___T8) = cvarsPtr[6].Value; 
    L624:   pvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L628:   Stack(___T8) = pvarsPtr[2].Value; 
    L631:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L643;
    L635:   
            Stack(prmv[0]) = cvarsPtr[52].Value;
    L637:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L641:   goto L646;
    L643:   Stack(___T8) = cvarsPtr[6].Value; 
    L646:   pvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            pvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L650:   Stack(___T8) = pvarsPtr[2].Value; 
    L653:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L665;
    L657:   
            Stack(prmv[0]) = cvarsPtr[53].Value;
    L659:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L663:   goto L668;
    L665:   Stack(___T8) = cvarsPtr[6].Value; 
    L668:   cvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + Stack(_v2).u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L672:   Stack(___T8) = cvarsPtr[2].Value; 
    L675:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L687;
    L679:   
            Stack(prmv[0]) = cvarsPtr[54].Value;
    L681:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L685:   goto L690;
    L687:   Stack(___T8) = cvarsPtr[6].Value; 
    L690:   cvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + pvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L694:   Stack(___T8) = cvarsPtr[2].Value; 
    L697:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L709;
    L701:   
            Stack(prmv[0]) = cvarsPtr[55].Value;
    L703:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L707:   goto L712;
    L709:   Stack(___T8) = cvarsPtr[6].Value; 
    L712:   cvarsPtr[2].Value.u.Bool =  Stack(_v1).u.Bool + cvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L716:   Stack(___T8) = cvarsPtr[2].Value; 
    L719:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L731;
    L723:   
            Stack(prmv[0]) = cvarsPtr[56].Value;
    L725:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L729:   goto L734;
    L731:   Stack(___T8) = cvarsPtr[6].Value; 
    L734:   cvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L738:   Stack(___T8) = cvarsPtr[2].Value; 
    L741:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L753;
    L745:   
            Stack(prmv[0]) = cvarsPtr[57].Value;
    L747:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L751:   goto L756;
    L753:   Stack(___T8) = cvarsPtr[6].Value; 
    L756:   cvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L760:   Stack(___T8) = cvarsPtr[2].Value; 
    L763:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L775;
    L767:   
            Stack(prmv[0]) = cvarsPtr[58].Value;
    L769:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L773:   goto L778;
    L775:   Stack(___T8) = cvarsPtr[6].Value; 
    L778:   cvarsPtr[2].Value.u.Bool =  pvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L782:   Stack(___T8) = cvarsPtr[2].Value; 
    L785:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L797;
    L789:   
            Stack(prmv[0]) = cvarsPtr[59].Value;
    L791:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L795:   goto L800;
    L797:   Stack(___T8) = cvarsPtr[6].Value; 
    L800:   cvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + Stack(_v2).u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L804:   Stack(___T8) = cvarsPtr[2].Value; 
    L807:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L819;
    L811:   
            Stack(prmv[0]) = cvarsPtr[60].Value;
    L813:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L817:   goto L822;
    L819:   Stack(___T8) = cvarsPtr[6].Value; 
    L822:   cvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + pvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L826:   Stack(___T8) = cvarsPtr[2].Value; 
    L829:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L841;
    L833:   
            Stack(prmv[0]) = cvarsPtr[61].Value;
    L835:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L839:   goto L844;
    L841:   Stack(___T8) = cvarsPtr[6].Value; 
    L844:   cvarsPtr[2].Value.u.Bool =  cvarsPtr[0].Value.u.Bool + cvarsPtr[1].Value.u.Bool;
            cvarsPtr[2].Value.Tag = TYBOLE; 
            JumpOnOverflow(OverFlowError)
    
    L848:   Stack(___T8) = cvarsPtr[2].Value; 
    L851:   if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, gCP->TSymbol_compareEQ->itsGlobalValue, 2, Stack(___T8), Stack(_result)).u.Bool == TRUE)  goto L863;
    L855:   
            Stack(prmv[0]) = cvarsPtr[62].Value;
    L857:   /*********** Calling function: error ***********/
            Stack(___T8) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[859]->itsGlobalValue, 1, &Stack(prmv[0]));
            ExitWhenError(Stack(___T8));
    L861:   goto L866;
    L863:   Stack(___T8) = cvarsPtr[6].Value; 
    L866:   Stack(___T8) = cvarsPtr[63].Value; 
    L869:   FrameExit(Stack(___T8));
       

 
 IllegalValue:
     Stack(__Ret) = gCP->FVmScript_ERROR_ILLEGAL_VALUE;
     goto Quit;

 IllegalDivide:

    Stack(__Ret) = gCP->FVmScript_ERROR_DIVIDE_BY_ZERO;
    goto Quit;

 OverFlowError: 
 
    Stack(__Ret) = gCP->FVmScript_ERROR_OVERFLOW;
    goto Quit;

Quit:
	FrameExit(Stack(__Ret));
}





#if 0
NAME:	FCompilerLibSelfTest_Eval1001
#endif

TVAL FCompilerLibSelfTest_Eval1001(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* myLambda,NUM argc, TVAL argv[])
{   
    /* RUNTIME REGISTER POINTERS */
	register LpTVAL		argsPtr;	/* Pointer to Lambda args 	*/
	register LpBIND		varsPtr;	/* Pointer to Lambda vars 	*/
	register LpBIND		pvarsPtr;	/* Pointer to Lambda pvars 	*/
	register LpBIND		cvarsPtr;	/* Pointer to Lambda cvars 	*/
	register TSymbol**	pcodePtr;	/* Pointer to pcode vector 	*/

	StartFrame
	DeclareTVAL(__Ec);		// Error code
	DeclareTVAL(__Ret);		// Return Value 
	
	/* -VARS_TVAL_DECLARATIONS- */
	DeclareTVAL(___T0);
    DeclareTVAL(ErrorLambdaTval);
    DeclareTVALArray(prmv, 2);
    InitTVALArray(prmv);
    
	
	EndFrame

	/* -AUTO_ARG_CHECKING- */ 
	if (argc < 1)
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);
		}
	
	/* INITIALIZATION. */
	
	argsPtr = argv;
	varsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->TemporaryVariables);
	pvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PersistantVariables);
	cvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->ClassVariables); 
	pcodePtr = (TSymbol**)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PcodeVector); 
	
	/* -INITIALIZE_VARS_DECLARATIONS- */
	Stack(___T0) = varsPtr[0].Value;
    
	
	/* START OF GENERATED CODE. */	
	L0:   
          Stack(prmv[0]) = pcodePtr[1]->itsGlobalValue;
          Stack(prmv[1]) = argsPtr[0];
    L3:   /*********** Calling function: apply ***********/
          Stack(___T0) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[5]->itsGlobalValue, 2, &Stack(prmv[0]));
          ExitWhenError(Stack(___T0));
    L7:   FrameExit(Stack(___T0));
       

 
 IllegalValue:
     Stack(__Ret) = gCP->FVmScript_ERROR_ILLEGAL_VALUE;
     goto Quit;

 IllegalDivide:

    Stack(__Ret) = gCP->FVmScript_ERROR_DIVIDE_BY_ZERO;
    goto Quit;

 OverFlowError: 
 
    Stack(__Ret) = gCP->FVmScript_ERROR_OVERFLOW;
    goto Quit;

Quit:
	FrameExit(Stack(__Ret));
}





#if 0
NAME:	FCompilerLibSelfTest_Eval1002
#endif

TVAL FCompilerLibSelfTest_Eval1002(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* myLambda,NUM argc, TVAL argv[])
{   
    /* RUNTIME REGISTER POINTERS */
	register LpTVAL		argsPtr;	/* Pointer to Lambda args 	*/
	register LpBIND		varsPtr;	/* Pointer to Lambda vars 	*/
	register LpBIND		pvarsPtr;	/* Pointer to Lambda pvars 	*/
	register LpBIND		cvarsPtr;	/* Pointer to Lambda cvars 	*/
	register TSymbol**	pcodePtr;	/* Pointer to pcode vector 	*/

	StartFrame
	DeclareTVAL(__Ec);		// Error code
	DeclareTVAL(__Ret);		// Return Value 
	
	/* -VARS_TVAL_DECLARATIONS- */
	DeclareTVAL(___T0);
    DeclareTVAL(ErrorLambdaTval);
    DeclareTVALArray(prmv, 4);
    InitTVALArray(prmv);
    
	
	EndFrame

	/* -AUTO_ARG_CHECKING- */ 
	if (argc < 4)
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);
		}
	
	/* INITIALIZATION. */
	
	argsPtr = argv;
	varsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->TemporaryVariables);
	pvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PersistantVariables);
	cvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->ClassVariables); 
	pcodePtr = (TSymbol**)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PcodeVector); 
	
	/* -INITIALIZE_VARS_DECLARATIONS- */
	Stack(___T0) = varsPtr[0].Value;
    
	
	/* START OF GENERATED CODE. */	
	L0:   
          Stack(prmv[0]) = argsPtr[0];
          Stack(prmv[1]) = argsPtr[1];
          Stack(prmv[2]) = argsPtr[2];
    L4:   
          Stack(prmv[3]) = argsPtr[3];
    L6:   /*********** Calling function: append ***********/
          Stack(___T0) =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, pcodePtr[8]->itsGlobalValue, 4, &Stack(prmv[0]));
          ExitWhenError(Stack(___T0));
    L10:   FrameExit(Stack(___T0));
       

 
 IllegalValue:
     Stack(__Ret) = gCP->FVmScript_ERROR_ILLEGAL_VALUE;
     goto Quit;

 IllegalDivide:

    Stack(__Ret) = gCP->FVmScript_ERROR_DIVIDE_BY_ZERO;
    goto Quit;

 OverFlowError: 
 
    Stack(__Ret) = gCP->FVmScript_ERROR_OVERFLOW;
    goto Quit;

Quit:
	FrameExit(Stack(__Ret));
}





;;**EXPORTKEY**:CompilerLib
(defun CompilerLib(_input)
;; ********************************************************************
;; summary:  The CompilerLib compiler generated from CompilerLib:DEFINITION.
;; Summary:  This Lambda implements the CompilerLib compiler as defined
;;           in the CompilerLib:DEFINITION compiler definition file.
;;           Much code has been marked with a boxed comment lines for
;;           ease of human understanding.
;; Note:     This code was machine generated by ParseLib.
;; Parms:    _input   The CompilerLib language source string
;; return:   _result  The Lambda resulting from compiling the _input source.
;; Modification history:
;; TM Jan 15 99 Added Console Error suppression (see _consoleError, _makeError and _lastError)
;; TM Jan 20 99 Added _verboseLexIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSynIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSemIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Changes _verbosexxxIn so that you supply a stop count
;;              example: (setq CompilerLib._verboseSynIn.MYRULE 2})  ; error after 2nd pass
;;                       (setq CompilerLib._verboseSynIn.MYRULE 0})  ; verbose on every pass
;;                       (setq CompilerLib._verboseSynIn.MYRULE: -1}) ; not verbose
;; ********************************************************************
   pvars:(_changeCount             ;; Number of rule based substitutions
          _explainOnOff            ;; Switch for saving semantic explanation steps in the _explanation variable 
          _explanation             ;; Variable for saving semantic explanation steps (see _explainOnOff) 
          _indent                  ;; Indent for displaying each explanation step on the console
          _io                      ;; Current parse tree index object
          _ip                      ;; Current parse tree index pointer
          (_maxPasses 200)         ;; Maximum number of passes before issuing error (singlePass = false)
          (morphFail |*failure*|:) ;; Morph rule failure RHS value
          _name                    ;; Name of the current compiler definition
          _parseLen                ;; Current parse tree length
          _parseTree               ;; Current head of the parse tree during recognition
          _passCount               ;; Current number of passes already executed by apply
          _result                  ;; Final result of parsing the submitted compiler definition rules 
          _semanticRule            ;; Current semantic rule to be applied by _applyRule 
          _semanticVerbose         ;; Switch for displaying each semantic explanation step on the console 
          _showTokens              ;; Show only the token list resulting from the lexical analyzer
          _syntaxFeatures          ;; Syntax features supplied in the compiler definition
          _tkIN                    ;; Place holder for the input source string (see $IN) 
          _tkLIST                  ;; The output token list from the lexer rules.
          _tkOUT                   ;; Output a feature based token to the token list.
          tokenDirectory           ;; Lexicon of token and their attributes
          _userFunctions           ;; User functions source code supplied in the compiler definition
          _verbose                 ;; Switch for displaying each explanation step on the console
          _verboseLexIn            ;; Structure of lex parse routines in which we should force _verbose true
          _verboseSynIn            ;; Structure of syntax parse routines in which we should force _verbose true
          _verboseSemIn            ;; Structure of semantic parse routines in which we should force _verbose true
          _verboseLexCount         ;; Structure of Counts used by _verboseLexCount (not set by user!)
          _verboseSynCount         ;; Structure of Counts used by _verboseSynCount (not set by user!)
          _verboseSemCount         ;; Structure of Counts used by _verboseSemCount (not set by user!)
          _lastError               ;; Error encountered during parse
          (_consoleErrors true)    ;; Error messaging flag is false no messages will be printed to console
          ;; Methods list 
          _findLineNum             ;; find the line the error ocurred in
          _makeError               ;; _error function wrapper that creates pretty errors and sets _lastError values
          _error                   ;; error function wrapper allowing silent or console messaging
          _apply                   ;; Apply the specified semantic rule to the result
          _applyRule               ;; Apply the current semantic rule to a sub list
          appendList               ;; Append multiple arguments into a list
          defaultLexer             ;; Default lexical analyzer for recognizing input symbols
          defaultTokenRule         ;; Modified default rule for adding attributes to a parsed token
          _eofToken                ;; Return true if we are at the end of the parse tree
          _errorHandler            ;; Handle any errors which may occur during compilation
          _getToken                ;; Get the next attributed token in the parse tree
          _Initialize              ;; Initialization routine for setting token dicrectory, etc.
          _initializeSW            ;; Initialization switch (set true after first initialization).
          initRule                 ;; User defined initialization routine for setting token dicrectory, etc.
          _lastIp                  ;; Move the current parse tree index to the previous position
          _lenIp                   ;; Return the length of the current parse tree
          _nextIp                  ;; Move the current parse tree index to the next position
          outputRule               ;; Default rule for returning the final output from the compiler
          _popIp                   ;; Pop the current parse tree index up one level to the next position
          preLexRule               ;; Default rule for any pre-lexical compiler operations.
          _pushIp                  ;; Push the current parse tree index down one level to the next position
          _setLexicalFeature       ;; Assign a set of letters to the specified lexical feature
          _setSyntaxFeature        ;; Set a whole class of syntax tokens with the specified attribute
          _showInput               ;; Show a fragment of the input source string in lexical verbose mode
          _showSource              ;; Show a fragment of the input source string in syntax verbose mode
          startRule                ;; Default rule for starting the compiler
          _writeRule               ;; Display the results of a rule firing in verbose mode
          $IN                      ;; Place holder for the input source string (see _tkIN)
          $LIST                    ;; The output token list from the lexer rules.
          $OUT                     ;; Output a feature based token to the token list.
          $ASIS                    ;; Output a feature based token to the token list (as is).



          ;; Variables to hold lexical feature bit maps
          _LF_Alpha
          _LF_AlphaNum
          _LF_BackSlash
          _LF_Bar
          _LF_NotBar
          _LF_Digit
          _LF_DQuote
          _LF_NotDQuote
          _LF_Eol
          _LF_NotEol
          _LF_LeftParen
          _LF_Letter
          _LF_NameChar
          _LF_NameStart
          _LF_Operator
          _LF_Period
          _LF_PoundSign
          _LF_Quote
          _LF_NotQuote
          _LF_SpecialChar
          _LF_Whitespace
          ;; Functions to implement Lexical Rules
          _LEXRULE_MAIN
          ;; Functions to implement Syntax Rules
          _SYNRULE_AEXPRESSION
          _SYNRULE_ASMSTATEMENT
          _SYNRULE_INTFACELIST
          _SYNRULE_MAIN
          _SYNRULE_OBJVECTOR
          _SYNRULE_OPERANDS
          _SYNRULE_STMTLIST
          ;; Functions to implement Semantic Rules
         ) ;; end of persistent variables
   vars:(i verboseHold outString outExplain)
   ;; ***************************************************
   ;; Define the child Lambdas which belong to this parent
   ;; ***************************************************

   ;;*********************************************************************
   ;; Finds the line number given a character position
   ;;*********************************************************************
   (defun _findLineNum(pos)
      vars: (i j l)
      (setq j 0)
      (setq l (length $IN))
      (if (< pos l) (setq l pos))
      (loop for i from 0 until l step 1 do
         (if (= $IN[i] 10) (setq j (iadd j 1)))
         ); end loop
      j; return number of linefeeds found
      ); end findLineNum

   ;;*********************************************************************
   ;; Construct Error
   ;;*********************************************************************
   (defun _makeError(errorKey pos desc)
      vars: (i j line1 line2 line3 line4 eof nontabs tabs temp result)

      (setq eof (length $IN))
      (setq nontabs 0)
      (setq tabs 0)


      ;find start of error line - line2
      (setq i pos)
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line2 (iadd i 1)) (setq line2 0))

      ;Count number of tabs and non-tabs up to error in error line
      (setq j line2)
      (while (< j pos) (if (= $IN[j] 9) (setq tabs (iadd tabs 1)) (setq nontabs (iadd nontabs 1))) (setq j (iadd j 1)))

      ;find start of line1
      (while (and (>= i 0) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (isub i 1))) 
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line1 (iadd i 1)) (setq line1 0))

      ;find start of line 3
      (setq i pos) ; reset to error position
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
       (setq line3 i)

      ;find start of line 4
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
      (setq line4 i)

      ;Create error window
      (setq temp (append 
           (if (> (- line2 line1) 0) (substring $IN line1 (isub line2 1)) "") ;line 1
           (if (> (- line3 line2) 0) (substring $IN line2 (isub line3 1)) "") ;line 2 
           (if (= line3 eof) _eol ""); add an _eol if line2 is the only line!
           (rept " " nontabs) (rept (string (char 9)) tabs) "^error" _eol 
           (if (> line4 line3) (substring $IN line3 (isub line4 1)) "")
           ))

      ; Normalize tabs to 4 chars each
      (setq j (length temp))
      (setq result "")
      (loop for i from 0 until j step 1 do
         (setq result (append result (if (= temp[i] 9) "    " (string temp[i]))))
         ); end loop

      ;insert values into the _lastError structure
      (setq _lastError.errorKey errorKey)
      (setq _lastError.line (_findLineNum pos))
      (setq _lastError.desc desc)
      (setq _lastError.charpos pos)
      (setq _lastError.message result)

      ;(_error errorKey (append " " desc " Line:" _lastError.line " Charpos:" pos _eol _lastError.message))
      (_error (append " " desc " Line:" _lastError.line " Char:" pos _eol _lastError.message))

      ); end _makeError

   ;; _error wraps the builtin error function so that it 
   ;; is possible to disable console errors for silent
   ;; operation. The _consoleErrors variable determines
   ;; the function of _error.
   (defun _error ( ... )
      vars:(argc i e)

      (setq argc (argCount))
      (setq e (new Vector: argc))
      (loop for i from 0 until argc do
         (setq e[i] (argFetch i))
         ); end loop

       (if _consoleErrors (apply error e) (error e[0]))

      false ; we will never actually get here but put in a return anyway
      ); of defun _error

   ;; Append multiple arguments into a list.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun appendList(one two ...)
       vars:(result argc i)
       (cond 
           ((and (isPair one) (isPair two)) (setq result (append one two)))
           ((= one #void) (setq result two))
           ((and (isPair one) (= two #void)) (setq result one))
           ((isPair one) (setq result (append one (list two))))
           ((= two #void) (setq result (list one)))
           (else (setq result (list one two)))
           ) ; end cond
       (setq argc (argCount))
       (loop for i from 2 until argc do
           (setq result (appendList result (argFetch i)))
           ) ;; end loop
       result) ;; end appendList
   ;; Apply the specified semantic rule to the result.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun _apply(theRule multiplePass)
       vars:(outList outString outExplain)
       ;(if _semanticVerbose (setq outString (append "Replacing: " (string _result true) " ==> ")))
       ;(if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string _result true) " ==> "))))
       (setq outList _result)
       (setq _passCount 0)
       (setq _semanticRule theRule)
       Retry::
       (if (> _passCount _maxPasses) (_error "ParseLib_Pass" "Exceeded maximum number of apply rules."))
       (setq _changeCount 0)
       (setq outList (morph (list outList) _applyRule morphFail))
       (if (isPair outList) (setq outList (car outList)))
       (if (and (> _changeCount 0) (= multiplePass true) (isPair outList)) (goto Retry:))
       ;(if (= _semanticVerbose true) (writeln outString  (string outList true)))
       ;(if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
       (setq _result outList)
       _result) ;; end of _apply
   ;; Apply the current semantic rule to a sub list
   ;; Note: This Lambda is called by morph for every sub list
   ;;       in the larger result list. 
   (defun _applyRule(sexp)
      vars:(ret outString outExplain)
      (setq _ip -1)
      (setq _io sexp)
      (if _semanticVerbose (setq outString (append "Replacing: " (string sexp true) " ==> ")))
      (if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string sexp true) " ==> "))))
      (setq _semanticStack (new Structure: _io _ip))
      (if (<> (setq ret (_semanticRule)) morphFail)
          (begin
             (++ _changeCount)
             (if (= _semanticVerbose true) (writeln outString  (string ret true)))
             (if _explainOnOff (setq _explanation (append _explanation outExplain (string ret true) _eol)))
             (return ret)
          )) ;; end if
      morphFail) ;; end of _applyRule
   ;; Modified default rule for adding attributes to a parsed token.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun defaultTokenRule(token)
       vars:(result tokenLen tokenEnd)
       ;; Is this token a delimited constant?
       (if (isVector token) 
           (begin
              (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
              (return result)
              )) ;; end if delimited constant
       ;; Is this token an integer constant?
       (if (isInteger token) 
           (begin
              (setq result (new Structure: Value: token  Integer: true  Number: true  Constant: true))
              (return result)
              )) ;; end if integer constant
       ;; Is this token an numeric constant?
       (if (isNumber token) 
           (begin
              (setq result (new Structure: Value: token  Number: true  Constant: true))
              (return result)
              )) ;; end if numeric constant
       ;; Is this token a name token?
       (if (isCharName token) 
           (begin
              (setq result (new Structure: Value: token  Name: true  Default: true))
              ;; Add the token to the directory so we don't have to do this again.
              (setq tokenDirectory[token] result) 
              (return result)
              )) ;; end if numeric constant
       ;; Create a default attributed structure for this token
       (setq result (new Structure: Value: token Default: true))
       ;; Add the token to the directory so we don't have to do this again.
       (setq tokenDirectory[token] result) 
       result) ;; end defaultTokenRule
   ;; Return true if the we are at the end of the parse tree.
   (defun _eofToken()
       (if (>= (_nextIp) (_lenIp)) true (_lastIp))) ;; end _eofToken
   ;; Manages any errors which may occur during compilation.
   (defun _errorHandler(errMsg)
      vars:(stemp n)
      (setq stemp (string errMsg true))
      (setq n (length stemp))
      (setq stemp (right (left stemp (- n 2)) (- n 4)))
      (error stemp)) ;; end of _errorHandler
   ;; Get the next token in the current parse tree.
   (defun _getToken()
       vars:(result i io n)
       ;; Load the next token in the parse tree.
       ;(if (>= (_nextIp) (_lenIp)) (begin (setq result morphFail) (_lastIp) (return result)))
       (if (>= (_nextIp) (_lenIp)) (return morphFail))
       (if (isNumber _ip) (return _io[_ip]))
       (setq n (subi (length _ip) 1))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (setq result io[_ip[n]]) 
       result) ;; end of _getToken
   ;; Initialization routine for setting token dicrectory, etc.
   ;; Note: This Lambda is run once during the lifetime of the
   ;;       parent Lambda.
   (defun _Initialize()
       (setq _initializeSW true)
       ;; Reset the verbose mode indent.
       (setq _indent "")
       ;; Create the token directory for the compiler definition language.
       (setq tokenDirectory (new Directory:))
       ;; Adjust the lexical analyzer for the compiler definition language.
       (defaultLexer._Initialize)



       ;; Initialization of Delimited Strings
       (defaultLexer.addStringDelimiters   String: {"} {"})
       (defaultLexer.addStringDelimiters   Symbol: {'} {'})
       (defaultLexer.addStringDelimiters   Whitespace: {/*} {*/})
       (defaultLexer.addStringDelimiters   Whitespace2: {//} _eol)
         ;; Initialization of Lexical Features
       (setq _LF_Alpha (_setLexicalFeature _LF_Alpha #( 1 97 122 1 65 90)))
       (setq _LF_AlphaNum (_setLexicalFeature _LF_AlphaNum #( 1 97 122 1 65 90 1 48 57)))
       (setq _LF_BackSlash (_setLexicalFeature _LF_BackSlash #( 1 92 92)))
       (setq _LF_Bar (_setLexicalFeature _LF_Bar #( 1 124 124)))
       (setq _LF_NotBar (_setLexicalFeature _LF_NotBar #( 1 0 255 0 124 124)))
       (setq _LF_Digit (_setLexicalFeature _LF_Digit #( 1 48 57)))
       (setq _LF_DQuote (_setLexicalFeature _LF_DQuote #( 1 34 34)))
       (setq _LF_NotDQuote (_setLexicalFeature _LF_NotDQuote #( 1 0 255 0 34 34)))
       (setq _LF_Eol (_setLexicalFeature _LF_Eol #( 1 10 10 1 13 13)))
       (setq _LF_NotEol (_setLexicalFeature _LF_NotEol #( 1 0 255 0 10 10 0 13 13)))
       (setq _LF_LeftParen (_setLexicalFeature _LF_LeftParen #( 1 40 40)))
       (setq _LF_Letter (_setLexicalFeature _LF_Letter #( 1 97 122 1 65 90)))
       (setq _LF_NameChar (_setLexicalFeature _LF_NameChar #( 1 97 122 1 65 90 1 48 57 1 95 95)))
       (setq _LF_NameStart (_setLexicalFeature _LF_NameStart #( 1 97 122 1 65 90 1 95 95 1 36 36)))
       (setq _LF_Operator (_setLexicalFeature _LF_Operator #( 1 61 61)))
       (setq _LF_Period (_setLexicalFeature _LF_Period #( 1 46 46)))
       (setq _LF_PoundSign (_setLexicalFeature _LF_PoundSign #( 1 35 35)))
       (setq _LF_Quote (_setLexicalFeature _LF_Quote #( 1 39 39)))
       (setq _LF_NotQuote (_setLexicalFeature _LF_NotQuote #( 1 0 255 0 39 39)))
       (setq _LF_SpecialChar (_setLexicalFeature _LF_SpecialChar #( 1 95 95 0 33 33 0 35 35 0 36 36 0 37 37 0 94 94 0 38 38 0 42 42 0 45 45 0 61 61 0 92 92 0 92 92 0 43 43 0 47 47 0 63 63 0 60 60 0 62 62)))
       (setq _LF_Whitespace (_setLexicalFeature _LF_Whitespace #( 1 0 32)))
         ;; Initialization of Syntax Features
       (_setSyntaxFeature AsmOperator: #( |argcount| |argfetch| |call| |move| |push| |add| |addi| |and| |div| |divi| |divr| |divri| |mul| |muli| |or| |sub| |subi| |xor| |jmple| |jmplt| |jmpge| |jmpgt| |jmpeq| |jmpne| |jump| |iadd| |idiv| |idivr| |imul| |isub| |ijmple| |ijmplt| |ijmpge| |ijmpgt| |ijmpeq| |ijmpne| |nadd| |nand| |nandb| |ndiv| |ndivr| |nmul| |nor| |norb| |nsub| |nxor| |nxorb| |njmple| |njmplt| |njmpge| |njmpgt| |njmpeq| |njmpne| |newline| |onerror| |ref| |return| |self| |send| |set| |shl| |shr| |badd| |bdiv| |bdivr| |bmul| |bsub| |bjmple| |bjmplt| |bjmpge| |bjmpgt| |bjmpeq| |bjmpne| |cadd| |cdiv| |cdivr| |cmul| |csub| |cjmple| |cjmplt| |cjmpge| |cjmpgt| |cjmpeq| |cjmpne| |reftext| |refstring| |refstrvalue| |refstrkey| |refsymbol| |refvector| |refbitvector| |refbytvector| |refobjvector| |refintvector| |refnumvector| |reffltvector| |refpcdvector| |refdicvalue| |refdickey| |refdirvalue| |refdirkey| |refmatrix| |refnummatrix| |setstring| |setstrvalue| |setstrkey| |setvector| |setbitvector| |setbytvector| |setobjvector| |setintvector| |setnumvector| |setfltvector| |setpcdvector| |setdicvalue| |setdickey| |setdirvalue| |setdirkey| |setmatrix| |setnummatrix|) #void)
       (_setSyntaxFeature Codegen: #( |argcount| |argfetch| |call| |move| |push| |return| |add| |addi| |div| |divi| |divr| |divri| |mul| |muli| |sub| |subi| |and| |or| |xor| |nand| |nor| |nxor| |nandb| |norb| |nxorb| |shl| |shr| |jmple| |jmplt| |jmpge| |jmpgt| |jmpeq| |jmpne| |jump| |bjmple| |bjmplt| |bjmpge| |bjmpgt| |bjmpeq| |bjmpne| |cjmple| |cjmplt| |cjmpge| |cjmpgt| |cjmpeq| |cjmpne| |ijmple| |ijmplt| |ijmpge| |ijmpgt| |ijmpeq| |ijmpne| |njmple| |njmplt| |njmpge| |njmpgt| |njmpeq| |njmpne| |badd| |bdiv| |bdivr| |bmul| |bsub| |cadd| |cdiv| |cdivr| |cmul| |csub| |iadd| |idiv| |idivr| |imul| |isub| |nadd| |ndiv| |ndivr| |nmul| |nsub| |newline| |onerror| |ref| |self| |send| |set| |reftext| |refstring| |refstrvalue| |refstrkey| |refsymbol| |refvector| |refbitvector| |refbytvector| |refobjvector| |refintvector| |refnumvector| |reffltvector| |refpcdvector| |refdicvalue| |refdickey| |refdirvalue| |refdirkey| |refmatrix| |refnummatrix| |setstring| |setstrvalue| |setstrkey| |setvector| |setbitvector| |setbytvector| |setobjvector| |setintvector| |setnumvector| |setfltvector| |setpcdvector| |setdicvalue| |setdickey| |setdirvalue| |setdirkey| |setmatrix| |setnummatrix|) #(c_argcount c_argfetch c_call c_move c_push c_return c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jump c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xadd c_xdiv c_xdiv c_xmul c_xsub c_xadd c_xdiv c_xdiv c_xmul c_xsub c_xadd c_xdiv c_xdiv c_xmul c_xsub c_xadd c_xdiv c_xdiv c_xmul c_xsub c_newline c_onerror c_ref c_self c_send c_set c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xref c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset c_xset ))
       (_setSyntaxFeature ChkType: #( |reftext| |refstring| |refstrvalue| |refstrkey| |refsymbol| |refvector| |refbitvector| |refbytvector| |refobjvector| |refintvector| |refnumvector| |reffltvector| |refpcdvector| |refdicvalue| |refdickey| |refdirvalue| |refdirkey| |refmatrix| |refnummatrix| |setstring| |setstrvalue| |setstrkey| |setvector| |setbitvector| |setbytvector| |setobjvector| |setintvector| |setnumvector| |setfltvector| |setpcdvector| |setdicvalue| |setdickey| |setdirvalue| |setdirkey| |setmatrix| |setnummatrix|) #(TYTEXT TYSTRING TYSTRUCTURE TYSTRUCTURE TYSYMBOL TYVECTOR TYBITVECTOR TYBYTEVECTOR TYOBJVECTOR TYINTVECTOR TYNUMVECTOR TYFLTVECTOR TYPCODEVECTOR TYDICTIONARY TYDICTIONARY TYDIRECTORY TYDIRECTORY TYMATRIX TYNUMMATRIX TYSTRING TYSTRUCTURE TYSTRUCTURE TYVECTOR TYBITVECTOR TYBYTEVECTOR TYOBJVECTOR TYINTVECTOR TYNUMVECTOR TYFLTVECTOR TYPCODEVECTOR TYDICTIONARY TYDICTIONARY TYDIRECTORY TYDIRECTORY TYMATRIX TYNUMMATRIX ))
       (_setSyntaxFeature RangeType: #( |reftext| |refstring| |refstrvalue| |refstrkey| |refsymbol| |refvector| |refbitvector| |refbytvector| |refobjvector| |refintvector| |refnumvector| |reffltvector| |refpcdvector| |refdicvalue| |refdickey| |refdirvalue| |refdirkey| |refmatrix| |refnummatrix| |setstring| |setstrvalue| |setstrkey| |setvector| |setbitvector| |setbytvector| |setobjvector| |setintvector| |setnumvector| |setfltvector| |setpcdvector| |setdicvalue| |setdickey| |setdirvalue| |setdirkey| |setmatrix| |setnummatrix|) #(SpecialCase String Structure Structure Symbol Vector SpecialCase ByteVector ObjVector IntVector NumVector FltVector PcodeVector Dictionary Dictionary Directory Directory Matrix NumMatrix String Structure Structure Vector SpecialCase ByteVector ObjVector IntVector NumVector FltVector PcodeVector Dictionary Dictionary Directory Directory Matrix NumMatrix ))
       (_setSyntaxFeature Name: #( |argcount| |argfetch| |call| |move| |push| |add| |addi| |and| |div| |divi| |divr| |divri| |mul| |muli| |or| |sub| |subi| |xor| |jmple| |jmplt| |jmpge| |jmpgt| |jmpeq| |jmpne| |jump| |iadd| |idiv| |idivr| |imul| |isub| |ijmple| |ijmplt| |ijmpge| |ijmpgt| |ijmpeq| |ijmpne| |nadd| |nand| |nandb| |ndiv| |ndivr| |nmuli| |nor| |norb| |nsub| |nxor| |nxorb| |njmple| |njmplt| |njmpge| |njmpgt| |njmpeq| |njmpne| |newline| |onerror| |xpush| |ref| |return| |self| |send| |set| |shl| |shr| |badd| |bdiv| |bdivr| |bmul| |bsub| |bjmple| |bjmplt| |bjmpge| |bjmpgt| |bjmpeq| |bjmpne| |cadd| |cdiv| |cdivr| |cmul| |csub| |cjmple| |cjmplt| |cjmpge| |cjmpgt| |cjmpeq| |cjmpne| |reftext| |refstring| |refstrvalue| |refstrkey| |refsymbol| |refvector| |refbitvector| |refbytvector| |refobjvector| |refintvector| |refnumvector| |reffltvector| |refpcdvector| |refdicvalue| |refdickey| |refdirvalue| |refdirkey| |refmatrix| |refnummatrix| |setstring| |setstrvalue| |setstrkey| |setvector| |setbitvector| |setbytvector| |setobjvector| |setintvector| |setnumvector| |setfltvector| |setpcdvector| |setdicvalue| |setdickey| |setdirvalue| |setdirkey| |setmatrix| |setnummatrix|) #void)
       (_setSyntaxFeature SymbolName: #( ||| 1 |-| 255 ||| |~| 44 |~| 13 |~| 9 |~| 10) #void)
       (_setSyntaxFeature OperatorName: #( ||+|| ||-|| ||/|| ||| |%| ||| ||*|| ||==|| ||=|| ||<|| ||<=|| ||>|| ||>=||) #void)
       (_setSyntaxFeature InitializeOperator: #( |=|) #void)
       (_setSyntaxFeature Binding: #( |Binding|) #void)
       (_setSyntaxFeature Args: #( |args| |vars| |pvars| |cvars| |faces|) #void)
       (_setSyntaxFeature Storage: #( |args| |vars| |pvars| |cvars| |faces|) #void)
       (_setSyntaxFeature PoundSign: #( "#") #void)
       (_setSyntaxFeature Semicolon: #( ";") #void)
       (_setSyntaxFeature Colon: #( ":") #void)
       (_setSyntaxFeature LeftParen: #( "(") #void)
       (_setSyntaxFeature RightParen: #( ")") #void)
       (_setSyntaxFeature LeftBrace: #( "{") #void)
       (_setSyntaxFeature RightBrace: #( "}") #void)
       (_setSyntaxFeature LeftBracket: #( "[") #void)
       (_setSyntaxFeature RightBracket: #( "]") #void)
       (_setSyntaxFeature Comma: #( ",") #void)
       (_setSyntaxFeature Boolean: #( |true| |false|) #void)
       ;; Call the user defined initialization routine
       (initRule)
       true) ;; end _Initialize
   ;; Default rule for user defined compiler initialization tasks.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun initRule()
       true) ;; end initRule
   ;; Move the current parse tree index to the previous position.
   (defun _lastIp()
       (if (isNumber _ip) (return (setq _ip (subi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (subi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _lastIp
   ;; Return the length of the current parse.
   (defun _lenIp()
       vars:(i io n)
       (if (isNumber _ip) (return (length _io)))
       (setq n (sub1 (length _ip)))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (length io)) ;; end _lenIp
   ;; Default main Lexical Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _LEXRULE_MAIN()
       (defaultLexer $IN)) ;; end _LEXRULE_MAIN
   ;; Move the current parse tree index to the next position.
   (defun _nextIp()
       (if (isNumber _ip) (return (setq _ip (addi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (addi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _nextIp
   ;; Default rule for returning the final output from the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun outputRule(result)
       result) ;; end outputRule
   ;; Pop the current parse tree index up one level to the next position.
   (defun _popIp()
       (if (isNumber _ip) (return true))
       (if (<= (length _ip) 1) (begin (setq _ip _ip[0]) (return true)))
       (resize _ip (subi (length _ip) 1))
       true) ;; end _popIp
   ;; Default rule for any pre-lexical compiler operations.
   (defun preLexRule(input) input)
   ;; Push the current parse tree index down one level to the next position.
   (defun _pushIp()
       (if (isNumber _ip) (setq _ip (new Vector: 1 _ip)))
       (setq _ip[(length _ip)] -1)
       true) ;; end _pushIp
   ;; Assign a set of letters to the specified lexical feature
   (defun _setLexicalFeature(letterBitMap values)
       vars:(i j valueLen start end bit)
       (setq valueLen (length values))
       (if (= letterBitMap #void) (setq letterBitMap (new Vector: bit: 255)))
       (loop for i from 0 until valueLen by 3 do
          (setq bit values[i])
          (setq start (integer (min values[(+ i 1)] values[(+ i 2)])))
          (setq end (integer (max values[(+ i 1)] values[(+ i 2)])))
          (loop for j from start to end do
              (setq letterBitMap[j] bit)
              ) ; end j loop
           ) ; end i loop
       letterBitMap) ; end _setLexicalFeature
   ;; Set a whole class of syntax tokens with the specified attribute and values
   (defun _setSyntaxFeature(name words values)
       vars:(i wordLen token)
       (setq wordLen (length words))
       (loop for i from 0 until wordLen do
           (setq token tokenDirectory[words[i]])
           (if (= token #void) (setq token (new Structure:)))
           (if (= values[i] #void)
               (setq token[name] true)
               (setq token[name] values[i])
               ) ; end if
           (setq token.Value words[i])
           (setq tokenDirectory[words[i]] token)
           ) ; end loop
       true) ; end _setSyntaxFeature
   ;; Show a fragment of the input source string in lexical verbose mode
   (defun _showInput(size)
       vars:(sourceIndex sourceLen result)
       (setq sourceLen (length $IN))
       (setq sourceIndex (addi _ip 1))
       (if (< sourceIndex sourceLen)
           (setq result (mid $IN sourceIndex size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showInput
   ;; Show a fragment of the input source string in syntax verbose mode
   (defun _showSource(size)
       vars:(treeIndex treeLen result)
       (setq treeLen (length _parseTree))
       (setq treeIndex (addi _ip 1))
       (if (< treeIndex treeLen)
           (setq result (mid $IN _parseTree[treeIndex].Charpos size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showSource
   ;; Default rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun startRule()
       true) ;; end startRule
   ;; Default main Syntax Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _SYNRULE_MAIN()
       _parseTree) ;; end _SYNRULE_MAIN
   ;; Display the results of a rule firing in verbose mode.
   (defun writeRule(ruleID _ret t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10)
       (writeln _indent "Firing " ruleID)
       (if (<> t1 #void)  (writeln "  " _indent "t1 = " t1))
       (if (<> t2 #void)  (writeln "  " _indent "t2 = " t2))
       (if (<> t3 #void)  (writeln "  " _indent "t3 = " t3))
       (if (<> t4 #void)  (writeln "  " _indent "t4 = " t4))
       (if (<> t5 #void)  (writeln "  " _indent "t5 = " t5))
       (if (<> t6 #void)  (writeln "  " _indent "t6 = " t6))
       (if (<> t7 #void)  (writeln "  " _indent "t7 = " t7))
       (if (<> t8 #void)  (writeln "  " _indent "t8 = " t8))
       (if (<> t9 #void)  (writeln "  " _indent "t9 = " t9))
       (if (<> t10 #void) (writeln "  " _indent "t10 = " t10))
       (writeln "  " _indent " ==> " _ret)
       (setq _indent (left _indent (sub1 (length _indent))))
       true) ;; end writeRule
    ;; Output a feature based token to the token list (output as is).
    (defun _tkASIS(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (error "$ASIS must have at least two arguments"))
       (if (isOdd (argCount)) (error "$ASIS must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Use these value as is. Do not use the syntax feature directory.
       ;; Note: Create an attributed token using the user supplied features.
       (setq tokenAttr (new Structure:))
       (setq tokenAttr.Value value)
       (setq tokenAttr.Charpos charpos)
       (loop for argIndex from 2 until (argCount) by 2 do
          (setq featureName (argFetch argIndex))
          (setq featureValue (argFetch (iadd argIndex 1)))
          (setq tokenAttr[(symbol featureName)] featureValue)
          ) ; end feature loop
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkASIS
    ;; Output a feature based token to the token list.
    (defun _tkOUT(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (_error "$OUT must have at least two arguments"))
       (if (isOdd (argCount)) (_error "$OUT must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Load any syntax features for this value.
       (setq tokenAttr tokenDirectory[value])
       (if (= tokenAttr #void)
           then
           ;; This value is not found in the syntax feature directory.
           ;; Note: Create an attributed token using the user supplied features.
           (begin
              (setq tokenAttr (new Structure:))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              (loop for argIndex from 2 until (argCount) by 2 do
                 (setq featureName (argFetch argIndex))
                 (setq featureValue (argFetch (iadd argIndex 1)))
                 (setq tokenAttr[(symbol featureName)] featureValue)
                 ) ; end feature loop
              ) ; end then
           else
           ;; This value is found in the syntax feature directory.
           ;; Note: Copy the features from the dictionary and set the value.
           (begin
              (setq tokenAttr (copy tokenAttr))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              ) ; end else
           ) ; end if
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkOUT
   ;; ************************************************
   ;; Define the main entry code for this parent Lambda
   ;; ************************************************
   ;; Perform any pre-lexical work required before compilation
   (setq _lastError (new Structure:)) ;; Clear _lastError 
   (onError _errorHandler)
   (setq _verboseLexCount (new Structure:)) ;Clear routine pass counts
   (setq _verboseSynCount (new Structure:))
   (setq _verboseSemCount (new Structure:))

   (setq _input (preLexRule _input))
   ;; Initialize the parent Lambda once and only once.
   (setq _tkIN _input)
   (setq $IN _input)
   (setq $OUT _tkOUT)
   (setq $ASIS _tkASIS)
   (if (= _initializeSW #void) (_Initialize))
   (setq defaultLexer.defaultTokenRule defaultTokenRule)
   (setq defaultLexer.tokenDirectory tokenDirectory)
   ;; In verbose mode, display the source string contents
   (if _verbose (writeln _eol "************Input Source************" _eol $IN))
   ;; Run the user defined start rule.
   (startRule)
   ;; Run the Lexical Rules
   ;; Note: Create the attributed token stream parse tree.
   (if _verbose (writeln "*********Lexical Rule Firings*********"))
   (setq _tkLIST #void)
   (setq $LIST _tkLIST)
   (setq _ip -1)
   (setq _parseTree (_LEXRULE_MAIN))
   ;; In verbose mode, display the parse tree contents
   (if (or _verbose _showTokens)
      (begin
         (writeln "*********Lexed Tokens with Features*********")
         (loop for i from 0 until (length _parseTree) do
             (writeln "[" i "] " _parseTree[i])
             ) ; end loop
         )) ; end if
   ;; Run the Syntax Rules
   (if _verbose (writeln "*********Syntax Rule Firings*********"))
   (setq _ip -1)
   (setq _io _parseTree)
   (setq _parseLen (length _parseTree))
   (setq _result (_SYNRULE_MAIN))
   ;; Run the Semantic Rules
   (if _verbose (writeln "*********Semantic Rule Firings*********"))
   (setq verboseHold _verbose)
   (setq _verbose false)
   (setq _semanticVerbose verboseHold)
   (setq _explanation #void)
   (if _semanticVerbose (setq outString (append "Reducing:= " (string _result true) " ==> " )))
   (if _explainOnOff (setq outExplain (append "Reducing:= " (string _result true) " ==> " )))



   ;; Perform semantic passes (if any)
   ;; Return the final output by invoking the user defined output rule.
   (if _semanticVerbose (writeln outString (string _result true)))
   (if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
   (setq _verbose verboseHold)
   (setq _result (outputRule _result))
   (if _verbose (writeln "*********Final Output*********" _eol _result))
   _result) ;; end of compiler





;;**EXPORTKEY**:CompilerLib:%DEFINITION
;#text#
;; ********************************************************************
;; summary:  This CompilerLib compiler definition includes all the features
;;           of a full CompilerLib compiler for the LambdaBase engine.
;;           See the following references:                                  
;;
;;           [1]  "SmartBase/LambdaServer CompilerLib compiler", Korns Associates
;;           [2]  "CompilerLib For The World Wide Web", Postscript Press
;;           [3]  "CompilerLib Developer's Resource", Prentice Hall
;;
;; Notes:    Requires the browseLib, the ParseLib, and this compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |CompilerLib:DEFINITION|.
;; Parms:    none
;; return:   Lambda   The ParseLib checks in a newly updated copy of the
;;                  Lambda compiler source and compiles the "CompilerLib" compiler.
;; ********************************************************************

#LexicalRules#

 MAIN: user ordering :: true ::    
 MAIN: "void" << ($ASIS $ch #void  Term: true Constant: true Void: true) >> 
 ;;MAIN: "true" << ($ASIS  $ch $1  Term: true Constant: true Boolean: true) >>
 ;;MAIN: "false" << ($ASIS $ch $1  Term: true Constant: true Boolean: true) >>  
 MAIN: PoundSign "void" << ($ASIS $ch #void  Term: true Constant: true  Void: true) >> 
 MAIN: PoundSign LeftParen "obj" Bar << ($ASIS $ch $3 VecStart: true Constant: true) >>
 ;; MAIN: PoundSign BackSlash PoundSign BackSlash Any << ($ASIS $ch $5 Character: true Term: true Constant: true) >> 
 MAIN: PoundSign BackSlash Any << ($ASIS $ch $3 Character: true Term: true Constant: true) >>  
 MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>    
 MAIN: Bar NotBar* Bar << ($ASIS $ch $2 SymbolName: true Term: true Name: true Constant: true) >>    
 MAIN: Quote NameStart NameChar* << ($ASIS $ch (makeQuotedSymbol (append $2 $3)) Symbol: true Term: true Constant: true) >>  
 MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true ) >>  
 MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true Constant: true) >>    
 MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true Constant: true) >>    
 MAIN: Period Digit+    << ($ASIS $ch (number (append $1 $2)) Number: true Term: true Constant: true) >>    
 MAIN: / * Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}*  * / << true >>    
 MAIN: / / NotEol* Eol? << true >>    
 MAIN: Bar  << ($OUT $ch $1 Bar: true) >>
 MAIN: PoundSign < NameStart NameChar* Whitespace*  Digit* > << ($OUT $ch (inspect (number $6)) Term: true Object: true Constant: true) >> 
 MAIN: Whitespace+      << true >>    
 ;; MAIN: SpecialChar* << ($ASIS $ch $1 SymbolName: true Term: true Name: true Constant: true ) >>  
 MAIN: Any              << ($OUT $ch (symbol (string $1)) Default: true) >>    
 MAIN: Eof :: $LIST ::

#End#

#LexicalFeatures#

Alpha: [|a-z| |A-Z|]
AlphaNum: [|a-z| |A-Z| |"0"-"9"|]
BackSlash: ["\\"]
Bar: [124]
NotBar: [|0-255| ~ 124]
Digit: [|"0"-"9"|]
DQuote: [34]
NotDQuote: [|0-255| ~ 34]
Eol: [10 13]
NotEol: [|0-255| ~ 10 13]
LeftParen: ["("] 
Letter: [|a-z| |A-Z|]  
NameChar: [|a-z| |A-Z| |"0"-"9"| "_"]
NameStart: [|a-z| |A-Z| "_" $]  
Operator: [ = ]  
Period: ["."]
PoundSign: ["#"]
Quote: [39]
NotQuote: [|0-255| ~ 39]
SpecialChar: [_ ~ ! # $ % ^ & * - = \\ + / ? < >]
Whitespace: [|0-32|]

#End#
 
;; 140 last error code

#SyntaxRules#

  MAIN: user ordering :: true ::
  MAIN: # "CompilerLib" # || (= $3.Charpos 14) || << true >>
  MAIN: STMTLIST Eof :: (list $1.Value) ::
  MAIN: STMTLIST Value :: (_makeError "AC 100" $2.Charpos "Invalid expression") ::
  MAIN: Value :: (_makeError "AC 101" $1.Charpos "Invalid expression") ::
  ;; MAIN: Eof :: (list #void) ::
  MAIN: Eof :: (begin (outGlobal) (list #void) ) ::
  
  
  STMTLIST: ASMSTATEMENT << (addToQuadsList $0 $1) >>
  STMTLIST: Value :: (_makeError "AC 140" $1.Charpos "Invalid Statement") ::  
  ;; STMTLIST: Eof :: $0 ::
  STMTLIST: Eof :: (begin (outGlobal) $0) ::
  
  ;; Note: This rule returns quads as lists as in (operator source1 source2 target)
  ASMSTATEMENT: user ordering :: true ::
  ;; ASMSTATEMENT: Number Colon AsmOperator OPERANDS :: (outInstruction $1.Value $3.Value $4.Value) ::
  ASMSTATEMENT: Number Colon AsmOperator OPERANDS ::  (outCInstruction  $1.Value $3 $4.Value)::
  ASMSTATEMENT: Binding InitializeOperator String :: (begin (list $1.Value $3.Value) (setq LambdaName (removeSpecChar $3.Value))) ::
  ASMSTATEMENT: Args Colon InitializeOperator INTFACELIST($1.Value) :: (list $1.Value $4.Value) ::   
  ASMSTATEMENT: "vm" Colon InitializeOperator PoundSign "<" Name Name ">"
  				<< (if  (= $7.Value "dtrtlVirtualMachine") true (_makeError "AC 140" $7.Value "Invalid Virtual Machine")) >>
  ;;ASMSTATEMENT: "Instructions" Colon << true >>    
  ASMSTATEMENT: "Instructions" Colon :: (outVars) ::    
  
  INTFACELIST: user ordering :: true ::  
  INTFACELIST: Void  :: $1 ::
  ;;INTFACELIST: Void  :: (setq (setq (setq $0.Value #void)[Charpos:] $1.Charpos)[Term:] true) ::
  INTFACELIST: VecStart OBJVECTOR(%0) :: (setq $2.Charpos $1.Charpos) ::   
 
  OBJVECTOR: user ordering :: true :: 
  OBJVECTOR: Binding  << (setq $0.Value (addToVarList %0 $1.Value)) >>
  OBJVECTOR: Name  << (setq $0.Value (addToVarList %0 $1.Value)) >>
  OBJVECTOR: Term  << (setq $0.Value (addToVarList %0 $1.Value)) >>
  OBJVECTOR: RightParen :: $0 ::
       
  OPERANDS: user ordering :: true :: 
  OPERANDS: AEXPRESSION Comma OPERANDS :: (setq $0.Value (insert $3.Value 0 $1)) ::  
  OPERANDS: AEXPRESSION :: (setq $0.Value (new Vector: 1 $1)) ::
  OPERANDS: Value :: (_makeError "AC 137" $1.Charpos "Invalid argument list")::

  AEXPRESSION: user ordering :: true ::  
  AEXPRESSION: Storage Colon LeftParen Name Colon String RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) :: 
  AEXPRESSION: Storage Colon LeftParen Name RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) :: 
  AEXPRESSION: Boolean :: (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true)::
  AEXPRESSION: Name :: (addToGvars $1) ::  
  AEXPRESSION: SymbolName :: (addToGvars $1) ::  
  AEXPRESSION: OperatorName :: (addToGvars $1) ::  
  AEXPRESSION: Term :: (if $1.Name (addToGvars $1) (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true)):: 

#End#

#DelimitedStrings#
  String: {"} {"}
  Symbol: {'} {'}
  Whitespace: {/*} {*/}
  Whitespace2: {//} _eol
#End#

#SyntaxFeatures#

 AsmOperator: [ argcount argfetch call move push
  				add addi and div divi divr divri mul muli or sub subi xor
                jmple jmplt jmpge jmpgt jmpeq jmpne jump 
  				iadd idiv idivr imul isub 
                ijmple ijmplt ijmpge ijmpgt ijmpeq ijmpne 
                nadd nand nandb ndiv ndivr nmul nor norb nsub nxor nxorb
                njmple njmplt njmpge njmpgt njmpeq njmpne                 
                newline onerror  ref return self send set shl shr 
                badd bdiv bdivr  bmul bsub 
				bjmple bjmplt bjmpge bjmpgt bjmpeq bjmpne   
				cadd cdiv cdivr cmul csub 
				cjmple cjmplt cjmpge cjmpgt cjmpeq cjmpne
				reftext refstring refstrvalue refstrkey refsymbol 
				refvector refbitvector refbytvector refobjvector refintvector refnumvector reffltvector
				refpcdvector refdicvalue refdickey refdirvalue refdirkey refmatrix refnummatrix
				setstring setstrvalue setstrkey 
				setvector setbitvector setbytvector setobjvector setintvector setnumvector setfltvector 
			    setpcdvector setdicvalue setdickey setdirvalue setdirkey setmatrix setnummatrix 
				]                               
				                              
 Codegen:     [ argcount argfetch call move push return
  				add addi div divi divr divri mul muli sub subi 
                and or xor nand nor nxor nandb norb nxorb shl shr
                jmple jmplt jmpge jmpgt jmpeq jmpne jump 
                bjmple bjmplt bjmpge bjmpgt bjmpeq bjmpne 
                cjmple cjmplt cjmpge cjmpgt cjmpeq cjmpne  
                ijmple ijmplt ijmpge ijmpgt ijmpeq ijmpne
                njmple njmplt njmpge njmpgt njmpeq njmpne
                badd bdiv bdivr bmul bsub 
				cadd cdiv cdivr cmul csub                  
  				iadd idiv idivr imul isub 
                nadd  ndiv ndivr nmul nsub 
				newline onerror ref self send set
				reftext refstring refstrvalue refstrkey refsymbol 
				refvector refbitvector refbytvector refobjvector refintvector refnumvector reffltvector
				refpcdvector refdicvalue refdickey refdirvalue refdirkey refmatrix refnummatrix
				setstring setstrvalue setstrkey 
				setvector setbitvector setbytvector setobjvector setintvector setnumvector setfltvector 
			    setpcdvector setdicvalue setdickey setdirvalue setdirkey setmatrix setnummatrix 
			  ]                               
              [ c_argcount c_argfetch c_call c_move c_push c_return
  				c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval c_eval                 
                c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop c_bitop
                c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jmpcc c_jump 
				c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc 
				c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc  
				c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc 
				c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc c_xjmpcc                
  				c_xadd c_xdiv c_xdiv c_xmul c_xsub 
                c_xadd c_xdiv c_xdiv c_xmul c_xsub 
                c_xadd c_xdiv c_xdiv c_xmul c_xsub 
				c_xadd c_xdiv c_xdiv c_xmul c_xsub 
				c_newline c_onerror c_ref c_self c_send c_set 
				c_xref c_xref c_xref c_xref c_xref 
				c_xref c_xref c_xref c_xref c_xref c_xref c_xref
				c_xref c_xref c_xref c_xref c_xref c_xref c_xref
                c_xset c_xset c_xset
                c_xset c_xset c_xset c_xset c_xset c_xset c_xset
				c_xset c_xset c_xset c_xset c_xset c_xset c_xset
				]  
				                             
   
 ChkType: 	 	[reftext refstring refstrvalue refstrkey refsymbol
				refvector refbitvector refbytvector refobjvector refintvector refnumvector reffltvector
				refpcdvector refdicvalue refdickey refdirvalue refdirkey refmatrix refnummatrix 
				setstring setstrvalue setstrkey 
				setvector setbitvector setbytvector setobjvector setintvector setnumvector setfltvector 
			    setpcdvector setdicvalue setdickey setdirvalue setdirkey setmatrix setnummatrix 
 			    ] 
				[TYTEXT TYSTRING TYSTRUCTURE TYSTRUCTURE TYSYMBOL 
				TYVECTOR TYBITVECTOR TYBYTEVECTOR TYOBJVECTOR TYINTVECTOR TYNUMVECTOR TYFLTVECTOR
				TYPCODEVECTOR TYDICTIONARY TYDICTIONARY TYDIRECTORY TYDIRECTORY TYMATRIX TYNUMMATRIX
				TYSTRING TYSTRUCTURE TYSTRUCTURE
				TYVECTOR TYBITVECTOR TYBYTEVECTOR TYOBJVECTOR TYINTVECTOR TYNUMVECTOR TYFLTVECTOR
				TYPCODEVECTOR TYDICTIONARY TYDICTIONARY TYDIRECTORY TYDIRECTORY TYMATRIX TYNUMMATRIX				
				] 
				
 RangeType: 	[reftext refstring refstrvalue refstrkey refsymbol
				refvector refbitvector refbytvector refobjvector refintvector refnumvector reffltvector
				refpcdvector refdicvalue refdickey refdirvalue refdirkey refmatrix refnummatrix 
				setstring setstrvalue setstrkey 
				setvector setbitvector setbytvector setobjvector setintvector setnumvector setfltvector 
			    setpcdvector setdicvalue setdickey setdirvalue setdirkey setmatrix setnummatrix 
				] 
				[SpecialCase String Structure Structure Symbol 
				Vector SpecialCase ByteVector ObjVector IntVector NumVector FltVector
				PcodeVector Dictionary Dictionary Directory Directory Matrix NumMatrix
				String Structure Structure
				Vector SpecialCase ByteVector ObjVector IntVector NumVector FltVector
				PcodeVector Dictionary Dictionary Directory Directory Matrix NumMatrix				
				]

				                              				                             
 Name: 			[ argcount argfetch call move push
  				add addi and div divi divr divri mul muli or sub subi xor
                jmple jmplt jmpge jmpgt jmpeq jmpne jump 
  				iadd idiv idivr imul isub 
                ijmple ijmplt ijmpge ijmpgt ijmpeq ijmpne 
                nadd nand nandb ndiv ndivr nmuli nor norb nsub nxor nxorb
                njmple njmplt njmpge njmpgt njmpeq njmpne                 
                newline onerror xpush ref return self send set shl shr 
                badd bdiv bdivr  bmul bsub 
				bjmple bjmplt bjmpge bjmpgt bjmpeq bjmpne   
				cadd cdiv cdivr cmul csub 
				cjmple cjmplt cjmpge cjmpgt cjmpeq cjmpne
				reftext refstring refstrvalue refstrkey refsymbol
				refvector refbitvector refbytvector refobjvector refintvector refnumvector reffltvector
				refpcdvector refdicvalue refdickey refdirvalue refdirkey refmatrix refnummatrix
				setstring setstrvalue setstrkey 
				setvector setbitvector setbytvector setobjvector setintvector setnumvector setfltvector 
			    setpcdvector setdicvalue setdickey setdirvalue setdirkey setmatrix setnummatrix 				
				]                               
				                               
  SymbolName: [ |1-255| ~ 44 ~ 13 ~ 9 ~ 10]
  
  OperatorName: [ |+| |-| |/| |%| |*| |==| |=| |<| |<=| |>| |>=| ]  
				                              

  InitializeOperator: [=]
  Binding: [Binding] 
  Args: [args vars pvars cvars faces]
  Storage: [args vars pvars cvars faces]
  PoundSign: ["#"]
  Semicolon: [";"]
  Colon: [":"]
  LeftParen: ["("]
  RightParen: [")"]
  LeftBrace: ["{"]
  RightBrace: ["}"]
  LeftBracket: ["["]
  RightBracket: ["]"]
  Comma: [","]  
  Boolean: [true false]

#End#



;;**EXPORTKEY**:CompilerLib:%ENVIRONMENT
;;*********************************************************************
;; Compile time child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib compilation process.
;;*********************************************************************                                           

                                                           
;;*********************************************************************
;; Function start pushes a new variable dictionary on the stack
;; Note: These persistant variables will extend the Lambda environment                    
;;*********************************************************************
(defchild CompilerLib:startRule()
    vars: ( i st )
    pvars:(addToGvars 			;; Add global symbol to the global vector
           LambdaDisassemble     ;; The Lambda that disassembles an input 
           LambdaName			;; Save the name of the Lambda 
           avarVector           ;; Vector of declared argument variables.
           CFile				;; Result C source File 
           codeString           ;; Result generated C code string.
           cvarVector           ;; Vector of declared class variables. 
           facesVector			;; Vector of declared interface variables.
           gArgStack			;; Vector containing a simulated stack of arguments                     
           glinenum				;; The linenumber of the current statement being constructed
           glocalSymbols        ;; Local Symbol Declaration String
           gMaxStackDepth		;; Maximum argument stack depth 
           gTopArgStack			;; The top of stack pointer for the argument stack
           gvarDir              ;; Directory of declared global variables.
           gvarDisp             ;; Dictionary of declared global variable pcode vector displacements.
           gvarVector           ;; Vector of declared global variables. 
           pvarVector           ;; Vector of declared persistant variables.
           varVector            ;; Vector of declared temporary variables.    
           vgenCntr				;; Persistent variable counter 
           ;; Self Test child Lambdas
           selfTest				;; Self test Lambda 
           ) ; end of persistant variables
    ;; Initialize the variable vectors.
    (setq gvarVector (new Vector: 0))
    (setq pvarVector (new Vector: 0))
    (setq cvarVector (new Vector: 0))
    (setq varVector (new Vector: 0))
    (setq avarVector (new Vector: 0))
    (setq facesVector (new Vector: 0))
    (setq gArgStack (new Vector: 0))     
    (setq gvarDir (new Directory: ))
    (setq gMaxStackDepth 0)
    
    ;; Initialize library global functions   
    (setq vgenCntr 100)
    ;; save the Global Symbol name in the global variable directory     
    
    ;; save the textual name and the symbolic name for "add"    
    (setq gvarDir[add:] "+")

    ;; save the textual name and the symbolic name for "sub"    
    (setq gvarDir[sub:] "-")

    ;; save the textual name and the symbolic name for "mul"    
    (setq gvarDir[mul:] "*")

    ;; save the textual name and the symbolic name for "div"    
    (setq gvarDir[div:] "/")
    
    ;; save the textual name only for "send"    
    (setq gvarDir[__send:] "__send")


    ;; save the textual name only for "divr"    
    (setq gvarDir[divr:] "divr")
  
    ;; save the textual name only for "divri"    
    (setq gvarDir[divri:] "divri")
     
    ;; save the textual name only for "addi"    
    (setq gvarDir[addi:] "addi")

    ;; save the textual name only for "subi"    
    (setq gvarDir[subi:] "subi")

    ;; save the textual name only for "divi"    
    (setq gvarDir[divi:] "divi")
  
    ;; save the textual name only for "muli"    
    (setq gvarDir[muli:] "muli")
     
    ;; save the textual name only for "ref"    
    (setq gvarDir[ref:] "ref")

    ;; save the textual name only for "set"    
    (setq gvarDir[set:] "set")
    
    ;; save the textual name only for "send"    
    (setq gvarDir[send:] "send")
    
     ;; save the textual name only for "compare"    
    (setq gvarDir[compare:] "compare")
    
    ;; save the textual name only for "compareLT"    
    (setq gvarDir[compareLT:] "compareLT")
    
    ;; save the textual name only for "compareLE"    
    (setq gvarDir[compareLE:] "compareLE")
    
    ;; save the textual name only for "compareEQ"    
    (setq gvarDir[compareEQ:] "compareEQ")  
    
    ;; save the textual name only for "compareNE"    
    (setq gvarDir[compareNE:] "compareNE")  
    
    ;; save the textual name only for "compareGT"    
    (setq gvarDir[compareGT:] "compareGT")
    
    ;; save the textual name only for "compareGE"    
    (setq gvarDir[compareGE:] "compareGE")
    
    
   (setq codeString "")  
    true) ; end startRule

;;*********************************************************************
;; Function preLexRule converts the input to an Lambda
;;*********************************************************************
(defchild CompilerLib:preLexRule(input)
    ;; check if the input is an Lambda
    (if (isLambda input) 
        (begin 
           (setq gvarDisp (globalReferences input))
           (setq input (LambdaDisassemble input))
        )) ; end if
    input) ; end preLexRule

;;*********************************************************************
;; The translate function converts the Lambda object to C evaluator 
;; function source file.
;;*********************************************************************
(defchild CompilerLib:translate(inputLambda varStruct rootName LambdaExpression)
    vars:(n N 
          tempString
          newLambdaExpression newVarStruct
          ) ; end temporary variables
    pvars:(HFile				;; Result C source header File 
           CFile				;; Result C source native evaluator function File
           NEval				;; The incremental evaluator index 
           ) ; end of persistant variables
       
    ;; Load the parent Lambda to be converted into C.
    (setq CFile #void) 
    (if (<> inputLambda.Vm #<VmEvaluator dtrtlVirtualMachine>) (return false)) 

    ;; Convert input Lambda to C file source and append it to C header source. 
    ;; Note: Add extern declaration, for the Lambda eval function, to the C file.
    (writeln "Starting compile of [" LambdaExpression "]") 
    (CompilerLib inputLambda)
    (setq HFile (append HFile _eol CFile))
    (setq HFile (substitute HFile "%FILENAME%" rootName)) 
    (setq HFile (substitute HFile "%NN%" (string NEval))) 
    (setq HFile (substitute HFile "$$$EXTERNS$$$" (append "extern TVAL F" rootName "_Eval" NEval "(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* Lambda,NUM argc,TVAL argv[]);" _eol "$$$EXTERNS$$$")))

    ;; Add the C code to bind the Lambda eval function to the C file.
    (setq tempString (append "    " "Stack(myLambda) = gCP->FSmartbase_Evals((POINTER)gCP,gTP,\"" LambdaExpression "\",FALSE);" _eol))
    (setq tempString (append tempString "    " "Lambda(Stack(myLambda))->VirtualMachine = TSYMBOL(\"nativeEvaluator\");" _eol))
    (setq tempString (append tempString "    " "Lambda(Stack(myLambda))->NativeCodeVector = TFUNCTION(F" rootName "_Eval" NEval ");" _eol))
    (setq HFile (substitute HFile "$$$EVALUATORS$$$" (append tempString _eol "$$$EVALUATORS$$$")))
    (setq NEval (integer (+ NEval 1)))
    
    ;; Scan through any child Lambdas registered to the pvars of this Lambda.
    (if (<> inputLambda.Pv varStruct)
        (begin
           (setq newVarStruct inputLambda.Pv)
           (setq N (length newVarStruct))
           (loop for n from 0 until N do
              (if (isLambda newVarStruct[n])
                  (begin
                     (setq newLambdaExpression (append LambdaExpression ".Pv." newVarStruct[n 0]))
                     (translate newVarStruct[n] newVarStruct rootName newLambdaExpression)
                  )) ; end if
              ) ; end pvars loop
        )) ; end pvars if
          
    ;; Scan through any child Lambdas registered to the cvars of this Lambda.
    (if (<> inputLambda.Cv varStruct)
        (begin
           (setq newVarStruct inputLambda.Cv)
           (setq N (length newVarStruct))
           (loop for n from 0 until N do
              (if (isLambda newVarStruct[n])
                  (begin
                     (setq newLambdaExpression (append LambdaExpression ".Cv[" n "]"))
                     (translate newVarStruct[n] newVarStruct rootName newLambdaExpression)
                  )) ; end if
              ) ; end cvars loop
        )) ; end cvars if
          
    ;; Scan through any child Lambdas registered to the vars of this Lambda.
    (if (<> inputLambda.Tv varStruct)
        (begin
           (setq newVarStruct inputLambda.Tv)
           (setq N (length newVarStruct))
           (loop for n from 0 until N do
              (if (isLambda newVarStruct[n])
                  (begin
                     (setq newLambdaExpression (append LambdaExpression ".Tv." newVarStruct[n 0]))
                     (translate newVarStruct[n] newVarStruct rootName newLambdaExpression)
                  )) ; end if
              ) ; end vars loop
        )) ; end vars if
          
    true) ; end translate

;;*********************************************************************
;; The checkin function converts the Lambda object to C source
;; and saves the result in the file cabinet. 
;;*********************************************************************
(defchild CompilerLib:checkin(cabinetName LambdaName checkinRootName)
    vars:(inputLambda)
    pvars:(HFile				;; Result C source header File 
           CFile				;; Result C source native evaluator function File 
           NEval				;; The incremental evaluator index 
           ) ; end of persistant variables
       
    ;; Load the parent Lambda to be converted into C.
    (writeln _eol "Starting CompilerLib checkin of " LambdaName) 
    (setq NEval 1000) 
    (setq inputLambda (getGlobalValue (symbol LambdaName)))
    (if (<> inputLambda.In.Binding LambdaName) (error "CompilerLib: invalid parent Lambda bindings")) 
    (if (<> inputLambda.Vm #<VmEvaluator dtrtlVirtualMachine>) (error "CompilerLib: invalid parent Lambda virtual machine")) 

    ;; Substitute the filename with the derived filename saved in temp
    (setq HFile (browseLib.checkout "CompilerLib:@%C_HEADER"))
    (setq HFile (substitute HFile "%FILENAME%" LambdaName)) 

    ;; Convert input Lambda to C file source and append it to C header source.. 
    ;; Note: Add extern declaration, for the Lambda eval function, to the C file. 
    (translate inputLambda #void LambdaName LambdaName)
      
    ;; Check converted C file source into the file cabinet.
    (setq HFile (substitute HFile "$$$EXTERNS$$$" ""))
    (setq HFile (substitute HFile "$$$EVALUATORS$$$" ""))
    (browseLib.checkin cabinetName (append checkinRootName ":CFile") HFile)    
    (writeln "CompilerLib checkin of " LambdaName " completed.") 

    true) ; end checkin

;;*********************************************************************
;; The writeSourceFile converts the Lambda object to C source 
;; and writes the result file to disk.
;;*********************************************************************
(defchild CompilerLib:writeSourceFile(parentPathName inputLambda)
    pvars:(CFile				;; Result C source File 
           ) ; end of persistant variables
    ;; Convert input Lambda to C file source.
    (CompilerLib inputLambda)
    ;; Check converted C file source into the file cabinet.
    (browseLib.writeSourceFile (append "F" parentPathName ".c") (mid CFile 9 10000000))    
    
    true) ; end writeSourceFile

;;*********************************************************************
;; The removeSpecChar removes special characters from the binding name 
;; so that the name conforms to C standards
;;*********************************************************************
(defchild CompilerLib:removeSpecChar(bindName)
    vars:(cName 				;; Result C source name
          bindNamelen			;; length of the original name string
          i						;; Index into string
          ) ;; end vars
   ;; Check if the binding name contains any special characters
   (if (isCharAlphanumeric bindName) (return bindName))  ;; no conversion necessary 
   ;; Convert binding name to conventional C name 
   (setq cName (new String: ""))
   (setq bindNamelen (length bindName))      
   (loop for i from 0 until bindNamelen 
            (if (isCharAlphanumeric bindName[i]) (setq cName[i] bindName[i]) (setq cName[i] #\_))
   ) ;; end loop

    cName) ; end removeSpecChar

;;*********************************************************************
;; Convert the VM storage type of the Operand to the C version.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild CompilerLib:cnvType(operand)
    vars:(result op)  
    (setq result "") 
    ;; Handle the case where the operand might be a Symbol Name
    (cond  
       ;; If the VM operand is a constant, convert the constant to the proper tval
       ((= operand.Storage cons:)
       	   (cond 
       	   		;; Handle integer constant
       	   		((= operand.Integer true)  (setq result (append result "TINT(" operand.Value ")" )))
       	   		;; Handle string constant 
       	   		((= operand.String true)   (setq result (append result "TSTRING(" (char 34) operand.Value (char 34) ")" )))
       	   		;; Handle real constant 
       	   		((= operand.Number true)   (setq result (append result "TREAL(" operand.Value ")" ))) 
       	   		;; Handle Symbol constant
       	   		((= operand.Symbol true)   (setq result (append result "TSYMBOL(" (char 34) operand.Value (char 34) ")" )))
        	   	;; Handle Character constant
       	   		((= operand.Character true)(setq result (append result "TCHAR(" (char 39) operand.Value  (char 39) ")" )))
       	   	    ;; Handle Object constant
       	   		((= operand.Object true)  (error "cannot proceed with an embedded object reference in the pcode vector"))
       	   		;; Handle void constant
       	   		((= operand.Void true)     (setq result (append result "gCP->Tval_VOID" )))       	   		
       	   ))       	    
       ;; If the VM operand is a pvars:, set the C storage type to pvarsPtr.
       ((= operand.Storage pvars:) 
       	   (setq result (append result "pvarsPtr[" (member operand.Value pvarVector) "].Value")))
       ((= operand.Storage args:) 
       	   (setq result (append result "argsPtr[" (member operand.Value avarVector) "]")))
       ((= operand.Storage cvars:) 
       	   (setq result (append result "cvarsPtr[" (member operand.Value cvarVector) "].Value")))
       ((= operand.Storage vars:) 
       	   (setq result (append result "Stack(_" operand.Value ")")))
       ;; Check if the current operand is a global. 
       ((= operand.Storage glbs:)
            (begin
            ;; Check if the current global is in the global directory (gvarDir).  
 ;;             (if (<> gvarDir[operand.Value] #void)
 ;;              (setq op gvarDir[operand.Value])
            (setq op operand.Value)
            (if (= gvarDisp[op] #void)
       	        (setq result (append result "gCP->TSymbol_" op "->itsGlobalValue"))
       	        (setq result (append result "pcodePtr[" gvarDisp[op] "]->itsGlobalValue"))
       	        ) ; end if
       	    ); end begin       	   
       	  ) ; end cond     
       ) ; end cond
    result) ; end cnvType
;;*********************************************************************
;; addToQuadsList
;; Note: Avoid using append for repeatedly linking long lists together.
;;       Use the setCdr function, it is much faster. Append was never
;;       meant to be used for long lists repeatedly.
;;*********************************************************************
(defchild CompilerLib:addToQuadsList(struct x)
    ;; Return if there is nothing to append.
    (if (= x #void) (return struct))
    (cond
        ;; Set up begin list header the first time.
        ((= struct.Value #void)
         (begin 
            (setq struct.Value x)
            (setq struct._noBeginList true)
            ))
        ;; Set up begin list header the second time.
        ((= struct._noBeginList true)
         (begin
            ;; Singletons can be ignored because they have no side effects.
            (if (= (isPair struct.Value) false)
                then
                (setq struct.Value x)
                else
                (begin 
                   (setq struct._noBeginList false)
                   (setq struct.Value (list struct.Value))
                   (setCdr struct (last struct.Value))
                   (setCdr (cdr struct) (list x))
                   (setCdr struct (last (cdr struct)))
                   ) ; end else
                ) ; end if
            ))                                                                                                      
        ;; Append to the begin list the remaining times.
        (else 
         (begin
            (setCdr (cdr struct) (list x))
            (setCdr struct (last (cdr struct)))
            ))
        ) ; end conf
    struct) ; end addToQuadsList



;;*********************************************************************
;; Modified default rule for adding Term attributes to all name tokens.
;;*********************************************************************
(defchild CompilerLib:defaultTokenRule(token)
    vars:(result tokenLen tokenEnd)
    ;; Is this token a delimited constant?
    (if (isVector token) 
        (begin
           (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
           ;; If this is a String constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] String:) 
               (begin
                  (setq result.Value (mid result.Value 1 (subi (length result.Value) 2)))
                  (setq result.Term true)
                  )) ; end if
           ;; If this is a Symbol constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] Symbol:) 
               (begin
                  (setq result.Value (makeQuotedSymbol (mid result.Value 1 (subi (length result.Value) 2))))
                  (setq result.Term true)
                  )) ; end if
           (return result)
           )) ;; end if delimited constant
    ;; Is this token an integer constant?
    (if (isInteger token) 
        (begin
           (setq result (new Structure: Value: token  Integer: true  Number: true  Term: true))
           (return result)
           )) ;; end if integer constant
    ;; Is this token a numeric constant?
    (if (isNumber token) 
        (begin
           (setq result (new Structure: Value: token  Number: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Is this token a name token?
    (if (isCharName token) 
        (begin
           (setq result (new Structure: Value: token  Name: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Create a default attributed structure for this token
    (setq result (new Structure: Value: token Default: true))
    result) ;; end defaultTokenRule


;;*********************************************************************
;; Appends a variable to one of the global variable vectors 
;;*********************************************************************
(defchild CompilerLib:addToVarList(storagetype value)
    vars:(vecLast)   
    (cond
      ;; If the storage type is pvar then add the new value to the pvar vector.
       ((= storagetype "pvars")
       	(begin
       	 (setq vecLast (length pvarVector))
            (if (not (isMember value pvarVector ))    ;; make sure the value is not in vector already
                (setq pvarVector[vecLast] value)      ;; install unique value in vector of declared persistant variables.	             	
           ) ; end if
        ); end begin
        (return pvarVector)	             	
        )
       ;; If the storage type is var then add the new value to the var vector.
       ((= storagetype "vars")
       	(begin 
       	(setq vecLast (length varVector))
           (if (not (isMember value varVector ))    ;; make sure the value is not in vector already
               (setq varVector[vecLast] value)      ;; install unique value in vector of declared temporary variables.	             	
           ) ; end if                            	
        ); end begin
	    (return varVector)	         	
        )
       ;; If the storage type is arg then add the new value to the arg vector.
       ((= storagetype "args")
        (begin
       	 (setq vecLast (length avarVector))
            (if (not (isMember value avarVector ))    ;; make sure the value is not in vector already
                (setq avarVector[vecLast] value)      ;; install unique value in vector of declared argument variables.	             	
           ) ; end if
        ); end begin
        (return avarVector)	         	    	
        )
       ;; If the storage type is cvar then add the new value to the cvar vector.
       ((= storagetype "cvars")
        (begin
       	  (setq vecLast (length cvarVector))
          (if (not (isMember value cvarVector ))    ;; make sure the value is not in vector already
              (setq cvarVector[vecLast] value)      ;; install unique value in vector of declared class variables.
            ) ;end if	             	
          ) ; end begin
        (return cvarVector)	             	
        )  
        ;; If the storage type is faces then add the new value to the interfaces vector.
        ((= storagetype "faces")
        (begin
       	  (setq vecLast (length facesVector))
          (if (not (isMember value facesVector ))  ;; make sure the value is not in vector already
              (setq facesVector[vecLast] value)    ;; install unique value in vector of declared interface variables.	             	
 			) ; end if 
          ) ;end begin  
        (return facesVector)	             	
        )

     ) ; end cond
    true) ; end addToVarList

;; *******************************************************************
;; summary:  Disassemble the specified Lambda Object into a source string
;;           or convert the specified object to a delimited string. Each
;;           element of the result string is separated by the endDel
;;           delimiter, and two item elements have each item separated
;;           by the midDel delimiter.
;; args:     anObj       The object to be converted into a string.
;; return:   dString     The converted delimited string   
;; *******************************************************************
(defchild CompilerLib:LambdaDisassemble(anObj) 
   vars:(title i n midDel endDel dString quoteDel)
   (setq dString "")
   (setq quoteDel (string (char 34)))
   (setq midDel " = ")
   (setq endDel _eol)
   ;; Use the object type to determine the string format.
   (if (isType Lambda: anObj) (setq n 0) (setq n (length anObj)))
   (cond  
       ;; Disassemble an Lambda into a string.
       ((isType Lambda: anObj)
        (begin
           (setq title anObj.In.Binding)
           (if (= title #void) 
               (setq title (globalBinding anObj)))
           (if (= title #void) 
               (setq title (string anObj)))
           (setq dString (append "Binding" midDel (string (char 34)) title (string (char 34)) endDel))
           (setq dString (append dString "args:" midDel (string (refAttributes anObj.Av) true) endDel))
           (setq dString (append dString "vars:" midDel (string (refAttributes anObj.Tv) true) endDel))
           (setq dString (append dString "pvars:" midDel (string (refAttributes anObj.Pv) true) endDel))
           (setq dString (append dString "cvars:" midDel (string (refAttributes anObj.Cv) true) endDel))
           (setq dString (append dString "faces:" midDel (string (refAttributes anObj.In) true) endDel))
           (setq dString (append dString "vm:" midDel (string anObj.Vm) endDel))
           (setq dString (append dString "Instructions:" endDel))
           (setq dString (append dString (disassemble anObj short:)))
           ))
       ;; Anything else is an error.
       (else
        (error "LambdaDisassemble: expecting an Lambda as input"))) ;; end cond
   dString) ;; LambdaDisassemble
 
 ;;*********************************************************************
;; The outInstruction extracts variables from the operand vector and places them in a list
;;*********************************************************************
(defchild CompilerLib:outInstruction(linenum operator opvec )
    vars:(vecLen i result)  
    (setq result (list (makeQuotedSymbol (append "L" linenum)) operator))
    (setq glinenum linenum) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; Move each operand from the vector to the result list
    (setq opLen (length opvec))
    (loop for i from 0 until opLen do
       (setq result (append result (list (makeQuotedSymbol opvec[i].Storage) opvec[i].Value)))
       ) ; end loop
    result) ; end outInstruction

;;*********************************************************************
;; The outCInstruction formats the virtual machine instruct into a C instruction
;;*********************************************************************
(defchild CompilerLib:outCInstruction(linenum operator opvec )
    vars:(vecLen i result) 
    (setq result "") 

    ;; Construct the line number label for this instruction
    (setq result (append "L" (string linenum) ":   "))
    ;; output the line number 
    (setq codeString (append codeString result))
    ;; save the line number string for this instruction in the global variable
    (setq glinenum result)    
    
    ;; assign all operators global storage class
    (setq operator[Storage:] glbs:)
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
    ;; Check what type of operator we have 
    ;; if we don't support this operator, exit now 
    (if (= CompilerLib.Pv[operator.Codegen] #void) (return result))  
    ;; otherwise execute the function to handle the operator.
    (CompilerLib.Pv[operator.Codegen] operator opvec)
    (return true)
    ) ; end outCInstruction

;;*********************************************************************
 ;; Add the new value to the gvar directory. 
;;*********************************************************************
(defchild CompilerLib:addToGvars(struct)
   vars:(vecLast)
 ;; A key in the gvar directory can be a SymbolName such as "+"  
 ;; or a Name such as "sqrt"
 ;; If the key is a Symbol Name, the value for the key is the corresponding Name function #{ dic | "+"  "_S100"}
 ;; If the key is a Name, the value for that name is also the name #{ dic | sqrt: sqrt}  
   (setq vecLast (length gvarDir))            	    ;; Check if the globals directory is empty
   (if (not (isMember struct.Value gvarDir )) 		;; make sure the value is not in the global structure already 
       (if (= struct.SymbolName true)               ;; is it a symbolic name ? 
           (setq gvarDir[struct.Value]  (append "_S" (string (setq vgenCntr (addi vgenCntr 1))))) ;; generate and install a symbol name
           (setq gvarDir[struct.Value] (string struct.Value))          ;; install just the name as is
       ) ; end if 
   ) ; end if  
   
   (setq struct.Storage glbs:)		 		 	 	;; set the storage attribute to global
   (setq struct.Term true)                       	;; set the Term attribute to true   
   struct) ;addToGvars       
    
;;*********************************************************************
;; Output the declarations for the C header file and the C source file
;;*********************************************************************
(defchild CompilerLib:outVars() 
	 pvars:(outDeclare) vars:(temp i j  _pos nameLength newChar)
    ;; Get the template for the C source file 
    (setq temp (new String: "")) 
   	(setq nameLength (length LambdaName)) 
   	;; We are going derive the filename from the Lambda name.  Any prefixes will be removed. 
   	;; Look for underscore characters in the name  (the underscore separates the prefix from the filename
    (setq _pos (find  "_" LambdaName 0))
    (if (isNumber _pos)
       (begin
       ;; Move the all of the characters after the underscore characters into the temp buffer
       (setq j 0)
       (loop for i from _pos until nameLength 
            (if (isCharAlphanumeric LambdaName[i]) (begin (setq newChar LambdaName[i]) (setq temp[j] newChar) (setq j (addi j 1))))))
    else
        (setq temp LambdaName))

   ;; Substitute the filename with the derived filename saved in temp
   (setq CFile (mid (browseLib.checkout "CompilerLib:@%C_EVAL_FUNCTION") 7 1000000))
   (outDeclare)
 true) ; end outVars    
 

;;*********************************************************************
;; The outDeclare function formats the declarations for the var,pvar,avar,cvar vectors
;;*********************************************************************
(defchild CompilerLib:outDeclare()
    vars:(vecLen i result endDel) 

    (setq endDel _eol)
    ;; Check for the correct number of argument variables 
    (setq vecLen (length avarVector))
    (setq CFile (substitute CFile "%AUTO_ARG_CHECKING%" (string vecLen)))
   
    ;; Output the C code to Protect the local variables from garbage collection
    (if (<> (setq vecLen (length varVector)) 0) 
        (begin
        ;; Format the declarations for this Lambda's local variables
        (setq result "")
    	(loop for i from 0 until vecLen 
    	    (setq result (append result "DeclareTVAL(_"  (string varVector[i]) ");" endDel "    "))
    	)  ;; end loop 
    	  
    	;; Setup the special tval container for the error handler Lambda
    	(setq result (append result "DeclareTVAL(ErrorLambdaTval);" endDel "    ")) 
    	
    	
    	;; Setup the parameter stack but leave out the maximum depth for now
    	(setq result (append result "DeclareTVALArray(prmv, $$$);" endDel "    ")) 
    	(setq result (append result "InitTVALArray(prmv);" endDel "    ")) 
    	   	  	  	
        ;; insert the local variable declarations into the C file   
    	;;(setq CFile (substitute CFile "%VARS_TVAL_DECLARATIONS%" result)) 
    	
    	;; save this string and we will output it at the end of the code generation 
    	(setq glocalSymbols result)
    	
    	;; Initialize the local variable declarations 
    	(setq result "")
     	(loop for i from 0 until vecLen 
    	    (setq result (append result "Stack(_"  (string varVector[i]) ") = varsPtr[" i "].Value;"  endDel "    "))
    	)  ;; end loop   	
   
   		(setq CFile (substitute CFile "%INITIALIZE_VARS_DECLARATIONS%" result))
      ) ;end begin  
   ); end if      
    true) ; end outDeclare   
    
;;*********************************************************************
;; The outGlobal function extracts variables from the global variable directory
;;*********************************************************************
(defchild CompilerLib:outGlobal()
    vars:(vecLen i op opname result endDel) 
    
    (setq endDel _eol)
    
    ;; Finish constructing the argument stack declataion string in the local symbols string
    (setq result (substitute glocalSymbols "$$$" (string gMaxStackDepth))) 
   
    ;; insert the local variable declarations into the C file   
    (setq CFile (substitute CFile "%VARS_TVAL_DECLARATIONS%" result)) 
    	
    ;; insert the code string into the C file   
    (setq CFile (substitute CFile "%CODE%" codeString) )
    
    
    true) ; end outGlobal

;;*********************************************************************
;; Build a C instruction source string for the return opcode
;;*********************************************************************
(defchild CompilerLib:c_return(operator opvec)
    vars:(vecLen i result operand1)
    (setq result "")  
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; The return instruction has one operand. 
	(if (<> (length opvec) 1)  (return result))
	;; Get the operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	(setq result (append result "FrameExit(" operand1 ");"  ))
    (setq codeString (append codeString result _eol "    "))
    true) ; end c_return
 
;;*********************************************************************
;; Build a C source string for the argCount instruction
;;*********************************************************************
 
(defchild CompilerLib:c_argcount(operator opvec) 
   	vars:(result)
	(setq result "") 
	;; Check if the operand vector contains one target operand
	(if  (<> (length opvec) 1) (return result)) 
	(setq result (cnvType opvec[0]))
	(setq result (append result " =   TINT(argc);" ) )
	(setq codeString (append codeString result _eol  "    "))
 
    true) ; end c_argcount

;;*********************************************************************
;; Build a C source string for the self instruction
;;*********************************************************************
 
(defchild CompilerLib:c_self(operator opvec) 
   	vars:(result)
	(setq result "") 
	;; Check if the operand vector contains one target operand
	(if  (<> (length opvec) 1) (return result)) 
	(setq result (cnvType opvec[0]))
	(setq result (append result " =   TOBJ(myLambda);" ) )
	(setq codeString (append codeString result _eol  "    "))
 
    true) ; end c_self

;;*********************************************************************
;; Build a C source string for the newline instruction
;;*********************************************************************
 
(defchild CompilerLib:c_newlinelf(operator opvec) 
   	vars:(result)
	(setq result "") 
	;; The newline instruction results in a noop 
    true) ; end c_self

;;*********************************************************************
;; Build a C source string for the argFetch opcode
;;*********************************************************************
 
(defchild CompilerLib:c_argfetch(operator opvec) 
   	vars:(result operand1 index tmp)
	(setq result "")
	;; Check if the operand vector contains one target operand and the index operand
	(if  (<> (length opvec) 2) (return result))
	(setq index (cnvType opvec[0]))
	(setq operand2 (cnvType opvec[1]))
	(setq result (append operand2 " =   argv[asInt(&" index ")];" ) )
	(setq codeString (append codeString result _eol  "    "))
 
true) ; end c_argfetch

;;*********************************************************************
;; Build a C instruction source string for the move opcode
;;*********************************************************************
(defchild CompilerLib:c_move(operator opvec)
    vars:(vecLen i result operand1 operand2)
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; The move instruction has 2 operands. 
	(if (<> (length opvec) 2)  (return result))
	;; Get the target operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source operand's storage class string
	(setq operand2 (cnvType opvec[1]))
	(setq result (append result operand2  " = " operand1  "; "  )) 
    (setq codeString (append codeString result _eol  "    "))
    true) ; end c_move 
      
 ;;*********************************************************************
;; Function c_ref builds a C instruction to call the ref function  
;; Note: This function is called whenever it is not possible to 
;; generate inline instructions
;;*********************************************************************

(defchild CompilerLib:c_ref(operator opvec)
    vars:(numArgs i result operand1 operand2 operand3 bottom topOfStack indent)
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
     
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (append (rept " " linenumlength))) 

    ;; get the number of arguments to the ref instruction  
    (setq numArgs (length opvec))  
    
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result)) 
    
    ;; Return if the operands vector is empty
    (if (= numArgs 0) (return result)) 
    
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 

	;; Check if this ref instruction has a only two operands
	(if (= numArgs 2)
	    (begin 
		;; This is a special case ref; treat it as a move instruction
		(setq result (append result operand2  " = " operand1  "; "  ))
	    (setq codeString (append codeString result _eol  "    ")) 	
        )
    else
    	(begin
	    ;; Get the third (target) operand	  
		(setq operand3 (cnvType opvec[2]))		
        ;; build the call to the Smartbase_Ref function: first prepare the argument stack 
        
        ;; Compute the top of the argument stack  
        (setq bottom (setq gTopArgStack (length gArgStack)))
        ;; Move the source argument to the stack
        (setq result (append result "Stack(prmv[" gTopArgStack "]) = " operand2  ";" _eol  "    "))
        ;; adjust the stack pointer
        (setq gTopArgStack (addi gTopArgStack 1)) 
        
        ;; determine if we have reached a new maximum stack depth
        (if (> gTopArgStack gMaxStackDepth) (setq gMaxStackDepth gTopArgStack))
 
        ;; Move the index argument to the stack     
        (setq result (append result  indent "Stack(prmv[" gTopArgStack "]) = " operand1 ";" _eol  "    "))
                 
        ;; For code readability, output a comment containing name of the function to be called.
        
        (setq result (append result indent  "/*********** Calling function: FSmartbase_Ref ***********/" _eol  "    " ))    
        (setq result (append result indent operand3 " =  gCP->FSmartbase_Refv((POINTER)gCP, gTP, 2 , &Stack(prmv[" bottom "]));" _eol  "    " )) 
   
        ;;  Always check for an error after a call to 'FSmartbase_Ref'  
    	(setq codeString (append codeString result  _eol  "    ")) 
    	(setq codeString (append codeString indent "ExitWhenError(" operand3  ");" _eol  "    "  ))
       
  		;; Adjust the stack size to compensate for the arguments popped.    			
             
	    ) ;; end begin
	    );; end if
	    
	    true) ; end c_ref 
                                                     
 ;;*********************************************************************
;; Function c_set builds a C instruction to call the ref function  
;; Note: This function is called whenever it is not possible to 
;; generate inline instructions
;;*********************************************************************

(defchild CompilerLib:c_set(operator opvec)
    vars:(numArgs i result operand1 operand2 operand3 bottom topOfStack indent)
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
     
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (append (rept " " linenumlength))) 

    ;; get the number of arguments to the ref instruction  
    (setq numArgs (length opvec))  
    
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result)) 
    
    ;; Return if the operands vector is empty
    (if (= numArgs 0) (return result)) 
    
	;; Get the index operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string	  
    (setq operand3 (cnvType opvec[2]))
    		
    ;; build the call to the Smartbase_Set function: first prepare the argument stack 
    
    ;; Compute the top of the argument stack  
    (setq bottom (setq gTopArgStack (length gArgStack))) 
    ;; Move the target argument to the stack
    (setq result (append result "Stack(prmv[" gTopArgStack "]) = " operand3  ";" _eol  "    "))
    (setq gTopArgStack (addi gTopArgStack 1))
    ;; determine if we have reached a new maximum stack depth
    (if (> gTopArgStack gMaxStackDepth) (setq gMaxStackDepth gTopArgStack))   
    ;; Move the source argument to the stack
    (setq result (append result indent "Stack(prmv[" gTopArgStack "]) = " operand1  ";" _eol  "    "))
    ;; adjust the stack pointer
    (setq gTopArgStack (addi gTopArgStack 1))
    ;; Move the index argument to the stack     
    (setq result (append result  indent "Stack(prmv[" gTopArgStack "]) = " operand2 ";" _eol  "    "))

    ;; For code readability, output a comment containing name of the function to be called.
    (setq result (append result indent  "/*********** Calling function: FSmartbase_Set ***********/" _eol  "    " ))   
    (setq result (append result indent operand3 " =  gCP->FSmartbase_Setv((POINTER)gCP, gTP, 3 , &Stack(prmv[" bottom "]));" _eol  "    " )) 
  
    ;;  Always check for an error after a call to 'FSmartbase_Set'  
    (setq codeString (append codeString result  _eol  "    ")) 
    (setq codeString (append codeString indent "ExitWhenError(" operand3  ");" _eol  "    "  ))
	true) ; end c_set
                                                     
;;*********************************************************************
;; Function c_eval builds a C instruction to call the eval function  
;; Note: This function is called whenever it is not possible to 
;; generate inline instructions
;;********************************************************************* 
(defchild CompilerLib:c_eval(operator opvec)
    vars:(vecLen i result operand1 operand2 operand3 functionName globalName indent)
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
     
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (append (rept " " linenumlength))) 

    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (error "c_eval:invalid operands")) 
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (error "c_eval:incorrect number of operands")) 
     ;; Return if the operands vector is empty
    (if (<> (length opvec) 3) (error "c_eval:incorrect number of operands"))
   
    ;; get the name of the function associated with this operator  
    (setq functionName (cnvType operator)) 
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 

     ;; For code readability, output a comment containing name of the function to be called.
    (setq result (append result  "/*********** Calling function: " operator.Value " ***********/" _eol  "    " )) 
   
   ;; build the call to the specified function
	(setq result (append operand3 " = gCP->FSmartbase_Eval((POINTER)gCP, gTP, "  ))	
	(setq result (append result  functionName  " ,2, " operand2, ", " operand1 ");"  ))
	(setq codeString (append codeString result _eol  "    ")) 	
    (setq codeString (append codeString indent "ExitWhenError(" operand3 ");"  _eol  "    "  ))
    true) ; end c_eval   
 ;;*********************************************************************
;; Function c_push pushes an argument on the stack (simulated by a vector)
;; Note: We use the persistant variable gArgStack 
;;*********************************************************************
(defchild CompilerLib:c_push(operator operand) 
     vars:( numOperands i topOfStack)
    
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
    
     ;; For readability, force the line number label on a separate line  
    (setq codeString (append codeString  _eol "    " ))
    (setq glinenum "")
 
    ;; check how many operands we have to push. 
    (setq numOperands (length operand))
    
    ;; Compute the top of the argument stack  
    (setq gTopArgStack (length gArgStack))
    
    (loop for i from 0 until numOperands step 1 do
      (begin
      ;; Insert the argument(s) in the internal stack.  
      (setq gArgStack[gTopArgStack] operand[i])
      ;; Format the C instruction to insert the argument in the parameter array for the call "FSmartbase_Evalv"
      (setq topOfStack (string gTopArgStack))  
      (setq result (append result  indent "Stack(prmv[" topOfStack "]) = " (cnvType gArgStack[gTopArgStack]) ";" _eol  "    "))
      (setq gTopArgStack (addi gTopArgStack 1)) 
      ) ; end begin
    ); end loop  
    
    ;;  Copy the result string to the output string 
    (setq codeString (append codeString result)) 
    
    ;; determine if we have reached a new maximum stack depth
    (if (> gTopArgStack gMaxStackDepth) (setq gMaxStackDepth gTopArgStack))
 
    true ) ; end c_push

    
;;*********************************************************************
;; Function c_call constructs the C code to call a function
;; Note: We setup the arguments from the stack (simulated by a vector) 
;;*********************************************************************
(defchild CompilerLib:c_call(operator operand) 
   vars:(result vecLast target func numArgs topOfStack bottom i j indent linenumlength)  

    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
    
    ;; Check if this call instruction has 3 arguments    
    (if (= (length operand) 0) (return result))
   
    ;; convert the arguments to a c string
    (setq target  (cnvType operand[2]))
    (setq func    (cnvType operand[1])) 
    (setq numArgs operand[0].Value)
     
    ;; Compute the top of stack pointer (the stack may contain more argument than is needed for this call)
    (setq topOfStack (sub1 gTopArgStack)) 
    
    ;: Compute the pointer to the start of the arguments just for this function
    (setq bottom (- gTopArgStack numArgs))
   
    ;; For code readability, output a comment containing name of the function to be called.
    (setq result (append result  "/*********** Calling function: " operand[1].Value " ***********/" _eol  "    " )) 
   
   
   ;; Create the call to Evalv   
    (setq result (append result indent target " =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, " func ", " numArgs,  ", &Stack(prmv[" bottom "]));" _eol  "    " )) 
   
   ;;  Always check for an error after a call to 'evalv'  
    (setq codeString (append codeString result)) 
    (setq codeString (append codeString indent "ExitWhenError(" target  ");" _eol  "    "  ))
       
  ;; Adjust the stack size to compensate for the arguments popped.    			
   (resize gArgStack (- (length gArgStack) numArgs))

   true ) ; end c_call


 ;;*********************************************************************
;; Function c_send constructs the C code to send a message 
;; Note: We setup the arguments from the stack (simulated by a vector) 
;;*********************************************************************
(defchild CompilerLib:c_send(operator operand) 
   vars:(result vecLast target func msg numArgs top bottom i j indent linenumlength)  

    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 

    ;; Check if this call instruction has 3 arguments    
    (if (= (length operand) 0) (return result))
    ;; convert the arguments to a c string
    (setq target  (cnvType operand[2]))
    (setq msg     (cnvType operand[1]))   ;; needs to be placed on the stack 
    (setq numArgs operand[0].Value)
  
    ;; build the call to the send function: first prepare the argument stack 
    ;; top is the next position (top of stack) 
    ;; bottom is where the other arguments start (bottom of stack)

    (setq top (setq gTopArgStack (length gArgStack)))   ;; Compute the top of the argument stack 
    
    ;; Push the message argument on the parameter stack and increment the numArgs variable
    (setq result (append result  "Stack(prmv[" top "]) = " msg ";" _eol  "    "))
    ;; Also, push the argument to the internal stack.  
    (setq gArgStack[gTopArgStack] operand[1]) 
   

    ;; We just pushed a new argument on the stack, so update the internal stack pointer and our local stack pointer
    (setq numArgs (add1 numArgs))
    (setq gTopArgStack (addi gTopArgStack 1))   ;; compute the new top of stack 

     ;; determine if we have reached a new maximum stack depth
    (if (> gTopArgStack gMaxStackDepth) (setq gMaxStackDepth gTopArgStack))
 
    ;; get the name of the function associated with this operator i.e. "send" 
    (setq operator.Value "__send")
    (setq func(cnvType operator)) 
                                                          
    ;; Compute the pointer to the start of ALL of the arguments; They might have been placed on the stack by a 
    ;; previous push instruction. 
    (setq bottom (- gTopArgStack numArgs))
  

    ;; For code readability, output a comment containing name of the function to be called.
    (setq result (append result indent "/*********** Calling function: " operator.Value " ***********/" _eol  "    " )) 
   
   
    ;; Create the call to Evalv   
    (setq result (append result indent target " =  gCP->FSmartbase_Evalv((POINTER)gCP, gTP, " func ", " numArgs,  ", &Stack(prmv[" bottom "]));" _eol  "    " )) 
   
    ;; Always check for an error after a call to 'evalv'  
    (setq codeString (append codeString result)) 
    (setq codeString (append codeString indent "ExitWhenError(" target  ");" _eol  "    "  ))
       
    ;; Adjust the stack size to compensate for the arguments popped.    			
    (resize gArgStack (- (length gArgStack) numArgs))
    ;; Adjust the global top of stack pointer. 
    (setq gTopArgStack bottom)

     true ) ; end c_send


;;*********************************************************************
;; Function c_jump constructs a C goto statement
;;*********************************************************************
(defchild CompilerLib:c_jump(operator operand) 
   vars:(result  target )  
     
    ;; a jump instruction always has 1 arguments  
   (if (<> (length operand) 1) (return result))
   ;; get the statement number of the target of the jump
   (setq target (string operand[0].Value)) 
   
   (setq result (append "goto L" target ";" _eol  "    " ))
       
   (setq codeString (append codeString result))
    true ) ; end c_jump

;;*********************************************************************
;; Function c_jmpcc constructs a C conditional jump
;;*********************************************************************
(defchild CompilerLib:c_jmpcc(operator operand) 
   vars:(result src1 src2 target condition func)  
     
    ;; a conditional jump instruction always has 3 arguments  
   (if (<> (length operand) 3) (return result))
   
   ;; get the type of comparison
   (setq condition (upcase (right operator.Value 2)))
   ;; get the operands to be compared
   (setq src1  (cnvType operand[0]))
   (setq src2  (cnvType operand[1])) 
   ;; get the statement number of the target of the jump  
   (setq target (string operand[2].Value)) 
   
   (setq func  (append "compare" condition))
   (setq operator.Value func)
   (setq func (cnvType operator))   
   
   (setq result (append  "if  (gCP->FSmartbase_Eval((POINTER)gCP, gTP, " func ", 2, "   src1 ", " src2 ").u.Bool == TRUE)  goto L"  target ";" _eol  "    "))     
   (setq codeString (append codeString result))  
   
    true ) ; end c_jmpcc

;;*********************************************************************
;; Function c_xjmpcc constructs a strongly typed C conditional jump 
;; Note:  all operands are assumed to be int
;;*********************************************************************
(defchild CompilerLib:c_xjmpcc(operator operand) 
   vars:(result src1 src2 target condition typeString typeCode)  
     
    ;; a conditional jump instruction always has 3 arguments  
   (if (<> (length operand) 3) (return result))
   
   ;; get the type of comparison
   (setq condition (upcase (right operator.Value 2))) 
   
   ;; get the operands to be compared
   (setq src1  (cnvType operand[0]))
   (setq src2  (cnvType operand[1]))  
   
   ;; get the type of operands to be compared
   (setq typeCode (left operator.Value 1))
   ;; Determine the type string  for each of the strongly typed jump instructions
   (if (= typeCode "n")  (setq typeString "Real") (setq typeString "Int"))
   		
   ;; get the statement number of the target of the jump  
   (setq target (string operand[2].Value)) 
 
   ;; Construct the jump code  
   (cond  
   		((=  condition "NE") (setq result (append  "if  (" src1 ".u." typeString " != "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))
   		((=  condition "EQ") (setq result (append  "if  (" src1 ".u." typeString " == "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))
   		((=  condition "GT") (setq result (append  "if  (" src1 ".u." typeString " >  "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))
   		((=  condition "GE") (setq result (append  "if  (" src1 ".u." typeString " >= "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))  
    	((=  condition "LT") (setq result (append  "if  (" src1 ".u." typeString " <  "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))
    	((=  condition "LE") (setq result (append  "if  (" src1 ".u." typeString " <= "  src2 ".u." typeString ")  goto L"  target ";" _eol  "    ")))
   ) ;; end cond 

     
   (setq codeString (append codeString result))  
   true ) ; end c_xjmpcc

;;*********************************************************************
;; Function c_xadd constructs a C strongly typed add
;;*********************************************************************
(defchild CompilerLib:c_xadd(operator opvec) 
   vars:(result typeCode operand1 operand2 operand3 func linenumlength indent)  
     
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
 
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
    
    ;; Get the strong type of this operation
    (setq typeCode (left operator.Value 1))
    
    ;; get the name of the function associated with this operator  
    (setq func (cnvType operator)) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; Binary operations have a target and 2 source operands 
	(if (<> (length opvec) 3)  (return result))
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 

    ;; Generate code for each of the strongly typed instructions
    (cond  
       ;; Handle boolean adds.
       ((= typeCode "b")
          	(begin
		    (setq result (append operand3 ".u.Bool =  " operand2 ".u.Bool + " operand1 ".u.Bool;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYBOLE; " _eol  "    "))    
            ))   ;; end begin
  
        ;; Handle character adds. 
       ((= typeCode "c")
          	(begin
		    (setq result (append operand3 ".u.Char =  " operand2 ".u.Char + " operand1 ".u.Char;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYCHAR; " _eol  "    "))    
            ))   ;; end begin
    
        ;; Handle real adds. 
       ((= typeCode "n")
          	(begin
		    (setq result (append operand3 ".u.Real =  " operand2 ".u.Real + " operand1 ".u.Real;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYREAL; " _eol  "    "))    
            ))   ;; end begin  
             
        ;; Handle integer adds.         
        ((= typeCode "i")
          	(begin
		    (setq result (append operand3 ".u.Int =  " operand2 ".u.Int + " operand1 ".u.Int;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYNUM; " _eol  "    "))    
            ))   ;; end begin   
           
    ) ;; end cond 
    
    (if (<> typeCode "n")
    	(setq result (append result indent  "JumpOnOverflow(OverFlowError)"  _eol  "    " )))
    (setq codeString (append codeString result _eol  "    "))

       
    true ) ; end c_xadd
 
;;*********************************************************************
;; Function c_xsub constructs a C strongly typed subtraction instruction
;;*********************************************************************
(defchild CompilerLib:c_xsub(operator opvec) 
   vars:(result typeCode operand1 operand2 operand3 func linenumlength indent)  
     
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "")
     
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
    
    
    ;; Get the strong type of this operation
    (setq typeCode (left operator.Value 1))
    
    ;; get the name of the function associated with this operator  
    (setq func (cnvType operator)) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; Binary operations have a target and 2 source operands 
	(if (<> (length opvec) 3)  (return result))
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 

    ;; Generate code for each of the strongly typed instructions
    (cond  
       ;; Handle boolean subtraction.
       ((= typeCode "b")
          	(begin
		    (setq result (append operand3 ".u.Bool =  " operand2 ".u.Bool - " operand1 ".u.Bool;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYBOLE; " _eol  "    "))    
            ))   ;; end begin
  
        ;; Handle character subtraction. 
       ((= typeCode "c")
          	(begin
		    (setq result (append operand3 ".u.Char =  " operand2 ".u.Char - " operand1 ".u.Char;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYCHAR; " _eol  "    "))    
            ))   ;; end begin
    
       ;; Handle real subtraction. 
       ((= typeCode "n")
          	(begin
		    (setq result (append operand3 ".u.Real =  " operand2 ".u.Real - " operand1 ".u.Real;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYREAL; " _eol  "    "))    
            ))   ;; end begin  
      
       ;; Handle integer subtraction.              
       ((= typeCode "i")
          	(begin
		    (setq result (append operand3 ".u.Int =  " operand2 ".u.Int - " operand1 ".u.Int;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYNUM; " _eol  "    "))    
            ))   ;; end begin   
           
    ) ;; end cond 
    
    (if (<> typeCode "n")
    	(setq result (append result indent "JumpOnOverflow(OverFlowError)"  _eol  "    " )))
    (setq codeString (append codeString result _eol  "    "))     
    true ) ; end c_xsub
 
;;*********************************************************************
;; Function c_xmul constructs a C strongly typed multiplication instruction
;;*********************************************************************
(defchild CompilerLib:c_xmul(operator opvec) 
   vars:(result typeCode operand1 operand2 operand3 func linenumlength indent)  
     
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
    
     ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 

    ;; Get the strong type of this operation
    (setq typeCode (left operator.Value 1))
    
    ;; get the name of the function associated with this operator  
    (setq func (cnvType operator)) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; Binary operations have a target and 2 source operands 
	(if (<> (length opvec) 3)  (return result))
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 

    ;; Generate code for each of the strongly typed instructions
    (cond  
       ;; Handle boolean multiplication.
       ((= typeCode "b")
          	(begin
		    (setq result (append operand3 ".u.Bool =  " operand2 ".u.Bool * " operand1 ".u.Bool;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYBOLE; " _eol  "    "))    
            ))   ;; end begin
  
        ;; Handle character multiplication. 
       ((= typeCode "c")
          	(begin
		    (setq result (append operand3 ".u.Char =  " operand2 ".u.Char * " operand1 ".u.Char;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYCHAR; " _eol  "    "))    
            ))   ;; end begin
    
       ;; Handle real multiplication. 
       ((= typeCode "n")
          	(begin
		    (setq result (append operand3 ".u.Real =  " operand2 ".u.Real * " operand1 ".u.Real;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYREAL; " _eol  "    "))    
            ))   ;; end begin  
      
       ;; Handle integer multiplication.              
       ((= typeCode "i")
          	(begin
		    (setq result (append operand3 ".u.Int =  " operand2 ".u.Int * " operand1 ".u.Int;" _eol  "    "))
		    (setq result (append result indent operand3 ".Tag = TYNUM; " _eol  "    "))    
            ))   ;; end begin   
           
    ) ;; end cond 
    
    (if (<> typeCode "n")
    	(setq result (append result indent "JumpOnOverflow(OverFlowError)"  _eol  "    " )))
    (setq codeString (append codeString result _eol  "    "))     
    true ) ; end c_xmul
 
;;*********************************************************************
;; Function c_xdiv constructs a C strongly typed division instruction
;;*********************************************************************
(defchild CompilerLib:c_xdiv(operator opvec) 
   vars:(result typeCode rem operand1 operand2 operand3 func divoper linenumlength indent)  
     
    (setq result "") 
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
 
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
   
    ;; Get the strong type of this operation
    (setq typeCode (left operator.Value 1))
    
    ;; Determine if this divide instruction is a remainder divide
    (setq rem (right operator.Value 1))
    (if (= rem "r") (setq divoper "%") (setq divoper "/")) 
    ;; get the name of the function associated with this operator  
    (setq func (cnvType operator)) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; Binary operations have a target and 2 source operands 
	(if (<> (length opvec) 3)  (return result))
	;; Get the source1 operand's storage class string
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 

    ;; Generate code for each of the strongly typed instructions
    (cond  
       ;; Handle boolean division.
       ((= typeCode "b") 
       	   (begin
           (setq result (append "if (" operand2 ".u.Bool == FALSE ) goto IllegalDivide;" _eol  "    " ))
		   (setq result (append result indent operand3 ".u.Bool =  (" operand2 ".u.Bool " divoper " " operand1 ".u.Bool) == TRUE ? TRUE : FALSE; "
		    									  			_eol  "    "))
		   (setq result (append result indent operand3 ".Tag = TYBOLE; " _eol  "    "))     
           )) ;; end Boolean division 
             
       ;; Handle character division. 
       ((= typeCode "c")
          (begin
          (setq result (append "if (" operand2 ".u.Char == 0 ) goto IllegalDivide;" _eol  "    " ))
		  (setq result (append result indent operand3 ".u.Char =  " operand2 ".u.Char " divoper " "operand1 ".u.Char;" _eol  "    "))
		  (setq result (append result indent operand3 ".Tag = TYCHAR; " _eol  "    "))
          )) ;; end character division 
           	 	    
       ;; Handle real division. 
       ((= typeCode "n")
         (begin
          (setq result (append "if (" operand2 ".u.Real == 0 ) goto IllegalDivide;" _eol  "    "))
          ;; Handle remainder division for reals as a special case
          (if (= rem "r") 
          		(begin
		        (setq result (append result indent "gTP->FVmscript_Fraction = modf(" operand2 ".u.Real / " operand1 ".u.Real, &gTP->FVmscript_Integer);" _eol  "    "))
                (setq result (append result indent operand3 ".u.Real = " operand1  ".u.Real * gTP->FVmscript_Fraction;"   _eol  "    "))
                )  ;; end begin
          else
		        (setq result (append result indent operand3 ".u.Real =  " operand2 ".u.Real " divoper " " operand1 ".u.Real;" _eol  "    "))
          ) ;; endif
          (setq result (append result indent operand3 ".Tag = TYREAL; " _eol  "    "))
          )) ;; end real division  
      
       ;; Handle integer division.              
       ((= typeCode "i")
          (begin
          (setq result (append "if (" operand2 ".u.Int == 0 ) goto IllegalDivide;" _eol  "    " ))
		  (setq result (append result indent operand3 ".u.Int =  " operand2 ".u.Int " divoper  " " operand1 ".u.Int;" _eol  "    "))
		  (setq result (append result indent operand3 ".Tag = TYNUM; " _eol  "    "))
        )) ;; end Integers division 
           
    ) ;; end cond 
    
    (setq codeString (append codeString result _eol  "    "))     
    true ) ; end c_xdiv

;;*********************************************************************
;; Function c_bitop constructs the C statements for bitwise operations: and, or, xor, shl, shr
;;*********************************************************************
(defchild CompilerLib:c_bitop(operator opvec) 
   vars:(result negCode operand1 operand2 operand3 func linenumlength indent op binaryCode)  
     
    (setq operand1 "")
    (setq operand2 "") 
    (setq operand3 "") 
    
    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
     
    ;; (debug traceon:) 
    ;; Check if the operands are passed as a vector
    (if  (= (isVector opvec) false) (return result))
    ;; Return if the operands vector is empty
    (if (= (length opvec) 0) (return result))
	;; logical operations have a target and 2 source operands 
	(if (<> (length opvec) 3)  (return result))
     
    ;; Copy the original operator string
    (setq op operator.Value)

    ;; Check if this operation is to be negated
    (setq negCode (left operator.Value 1)) 
    
    ;; Check if this operation is to be binary not'd
    (setq binaryCode (right operator.Value 1))   
    
    ;; remove the negate code from the original operator string
    (if  (= negCode "n" ) (setq op (right op (sub1 (length op )))))
 	;; Get the source1 operand's storage class string   
    (if (= binaryCode "b" ) (setq op (left op (sub1 (length op )))))
   
	(setq operand1 (cnvType opvec[0]))
	;; Get the source2 operand's storage class string
	(setq operand2 (cnvType opvec[1])) 
	;; Get the target operand's storage class string
	(setq operand3 (cnvType opvec[2])) 
      
    ;; Insert the target operand string into the output string (result)  
    (setq result (append operand3 ".u.Int =  ")) 

    ;; Extra parenthesis are required for negate and binary operations
    (if (= binaryCode "b" ) (setq result (append result  "!(" )) 
    else 
        (if (= negCode "n" ) (setq result (append result  "(" ))))
         
    ;; Generate code for each of the bitwise logical instructions
    (cond  
       ((= op "and")
		    (setq result (append result operand2 ".u.Int & " operand1 ".u.Int" )))
  
       ((= op "or")
		    (setq result (append result operand2 ".u.Int | " operand1 ".u.Int" )))
           
       ((= op "xor")
		    (setq result (append result operand2 ".u.Int ^ " operand1 ".u.Int" ))) 
		    
	   ((= op "shr")
		    (setq result (append result operand2 ".u.Int >> " operand1 ".u.Int" )))
		    
	   ((= op "shl")
		    (setq result (append result operand2 ".u.Int << " operand1 ".u.Int" )))
    ) ;; end cond 
    
    ;; Check if this is a binary not opcode.  If so, complete the not operation if required
    (if (= binaryCode "b") (setq result (append result ")" )) 
    else
    	;; Check the negate code and negate if required
    	(if (= negCode "n") (setq result (append result ") ^ -1 "))))
    
    (setq result (append result ";" _eol "    " ))
    
    ;; force the target type to be an integer 
    (setq result (append result indent operand3 ".Tag = TYNUM; " _eol  "    "))    
    (setq codeString (append codeString result _eol  "    "))
    true ) ; end c_bitop
 
;;*********************************************************************
;; Function c_xref constructs the C instructions to reference an 
;; item in an object of a specific type
;;*********************************************************************
(defchild CompilerLib:c_xref(operator operand) 
   vars:(result index source target op attributes access indent linenumlength)  

   (setq linenumlength (length glinenum))
   (setq indent (append (rept " " linenumlength))) 

   ;; a strongly typed ref instruction always has 3 arguments  
   (if (<> (length operand) 3) (return result))
   
   (setq index  (cnvType operand[0]))
   (setq source (cnvType operand[1])) 
   (setq target (cnvType operand[2])) 

   ;; Copy the original operator string
   (setq op operator.Value)

   ;; Isolate the target type from the original operator string
   (setq op (right op (subi (length op ) 3)))
   
   ;; Perform a simple type check
   (setq attributes operator) 
   (setq access ".")
   (setq result (append "if (" source access "Tag != " (string (ref attributes ChkType:)) ") goto IllegalValue;"  _eol  "    "))   
   
   ;; Perform a range check
   (cond 
      ((= op "text") 
       		(setq result (append result indent "if (!inRange(" index access "u.Int,0,MAXTVALTEXTLEN)) goto IllegalValue;"  _eol  "    "))) 
      ((= op "symbol") 
       		(setq result (append result indent "if (!inRange(" index access "u.Int, 0,"  (string (ref attributes RangeType:)) "(" source ")->itsMaxDataIndex)) goto IllegalValue;"  _eol  "    ")))
   	  ((= op "string") 
       		(setq result (append result indent "if (!inRange(" index access "u.Int, 0,"  (string (ref attributes RangeType:)) "(" source ")->itsMaxDataIndex)) goto IllegalValue;"  _eol  "    ")))
      ((= op "bitvector")
       		(setq result (append result indent "if (!inRange((" index access "u.Int / 8), 0, BitVector(" source ")->itsMaxItemIndex)) goto IllegalValue;"  _eol  "    ")))      
      (else (setq result (append result indent "if (!inRange(" index access "u.Int, 0,"  (string (ref attributes RangeType:)) "(" source ")->itsMaxItemIndex)) goto IllegalValue;"  _eol  "    ")))
    )  ;; end cond
   
   ;; Generate code for each of the aggregate types
   (cond  
       ((= op "text") 
      		(begin
		    (setq result (append result indent target access "u.Char = " source access "u.Text[" index access "u.Int];" _eol  "    "))
		    (setq result (append result indent target access  "Tag = TYCHAR;"  _eol  "    "))
            ))
           
       ((= op "symbol")
      		(begin
		    (setq result (append result indent target access "u.Char = SymbolArray(" source ")[" index access "u.Int];" _eol  "    "))
		    (setq result (append result indent target access "Tag = TYCHAR;"  _eol  "    "))
            ))
		    
       ((= op "string")
      		(begin
		    (setq result (append result indent target access "u.Char = CharArray(" source ")[" index access "u.Int];" _eol  "    "))
		    (setq result (append result indent target access "Tag = TYCHAR;"  _eol  "    "))
            )) 
            
       ((= op "vector")
      		(begin
		    (setq result (append result indent target " = TvalArray(" source ")[" index access "u.Int];" _eol  "    "))
            ))
 		
       ((= op "bitvector")
      		(begin
		    (setq result (append result indent target access "u.Int = ((BitArray(" source ")[" index access "u.Int / 8] & gCP->TBitVector_OrMasks [" index access "u.Int % 8]) != 0);" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYNUM;"  _eol  "    "))
            ))

        ((= op "bytvector")
      		(begin
		    (setq result (append result indent target access "u.Char = ByteArray(" source ")[" index access "u.Int];" _eol  "    "))
		    (setq result (append result indent target access "Tag = TYCHAR;"  _eol  "    "))
            ))
		   
       ((= op "intvector")
      		(begin
		    (setq result (append result indent target access "u.Int = IntArray(" source ")[" index access "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYNUM;"  _eol  "    "))
            )) 

       ((= op "numvector")
      		(begin
		    (setq result (append result indent target access "u.Real = RealArray(" source ")[" index access "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYREAL;"  _eol  "    "))
            ))  
            
      ((= op "fltvector")
      		(begin
		    (setq result (append result indent target access "u.Real = FloatArray(" source ")[" index access "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYREAL;"  _eol  "    "))
            )) 
            
      ((= op "objvector")
      		(begin
		    (setq result (append result indent target access "u.Object = ObjArray(" source ")[" index access "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = (" target ".u.Object != NIL) ? " target access "u.Object->itsObjectType : TYVOID;"  _eol  "    "))
            )) 
            
      ((= op "pcdvector")
      		(begin
		    (setq result (append result indent target access "u.Int = PcodeArray(" source ")[" index access "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYNUM;"  _eol  "    "))
            ))
            
      ((= op "matrix")
		    (setq result (append result indent target " = TvalMatrix(" source ")[" index access "u.Int];" _eol  "    ")))

      ((= op "nummatrix")
      		(begin
		    (setq result (append result indent target access "u.Real = RealMatrix(" source ")[" index access  "u.Int];" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = TYREAL;"  _eol  "    ")) 
		    ))
		
      ((= op "dickey")
      		(begin
		    (setq result (append result indent target access "u.Object"  " = BondArray(" source ")[" index access "u.Int].Key;" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = ( "target ".u.Object != NIL) ? " target access "u.Object->itsObjectType : TYVOID;"  _eol  "    ")) 
		    ))
		
       ((= op "strkey")
      		(begin
		    (setq result (append result indent target access "u.Object = BindArray(" source ")[" index access  "u.Int].Key;" _eol  "    "))		    
		    (setq result (append result indent target access "Tag = ( "target ".u.Object != NIL) ? " target access "u.Object->itsObjectType : TYVOID;"  _eol  "    ")) 
		    ))
		
        ((= op "dirkey")
      		(begin
		    (setq result (append result indent target  " = PBindArray(" source ")[" index access "u.Int].Key;" _eol  "    "))		    
		    ))

         ((= op "dicvalue")
		    (setq result (append result indent target " = BondArray(" source ")[" index access "u.Int].Value;"  _eol  "    ")))
       
         ((= op "strvalue")
		    (setq result (append result indent target " = BindArray(" source ")[" index access "u.Int].Value;"  _eol  "    ")))
       
        ((= op "dirvalue")
		    (setq result (append result indent  target " = PBindArray(" source ")[" index access "u.Int].Value;"  _eol  "    ")))
  	
 ) ;; end cond 

   (setq codeString (append codeString result))  
   
    true ) ; end c_xref
                           
;;*********************************************************************
;; Function c_xset constructs the C instructions to set an 
;; item in an object of a specific type
;;*********************************************************************
(defchild CompilerLib:c_xset(operator operand) 
   vars:(result index source target op attributes linenumlength indent)
   
     
   (setq linenumlength (length glinenum))
   (setq indent (append (rept " " linenumlength))) 
    
   ;; a strongly typed set instruction always has 3 arguments  
   (if (<> (length operand) 3) (return result))
   
   (setq index  (cnvType operand[0]))
   (setq source (cnvType operand[1])) 
   (setq target (cnvType operand[2])) 

   ;; Copy the original operator string
   (setq op operator.Value)

   ;; Isolate the target type from the original operator string
   (setq op (right op (subi (length op ) 3)))
   
   ;; Perform a simple type check
   (setq attributes operator)
   (setq result (append "if (" target ".Tag != " (string (ref attributes ChkType:))  ") goto IllegalValue;"  _eol  "    "))   
   
   ;; Perform a range check
   
   (if (= op "bitvector")
       (setq result (append result indent "if (!inRange((" index ".u.Int / 8), 0, BitVector(" target ")->itsMaxItemIndex)) goto IllegalValue;"  _eol  "    ")) 
   else
       (if (= op "string")
   	   		(setq result (append result indent "if (!inRange(" index ".u.Int,0,"  (string (ref attributes RangeType:)) "(" target ")->itsMaxDataIndex)) goto IllegalValue;"  _eol  "    "))
        else  
   	   		(setq result (append result indent "if (!inRange(" index ".u.Int,0,"  (string (ref attributes RangeType:)) "(" target ")->itsMaxItemIndex)) goto IllegalValue;"  _eol  "    "))))


   
   ;; Generate code for each of the aggregate types
   (cond  
       ((= op "string")
		    (setq result (append result indent "CharArray(" target ")[" index ".u.Int] = " source ".u.Char;" _eol  "    "))) 
                        
       ((= op "vector")
		    (setq result (append result indent "TvalArray(" target ")[" index ".u.Int] = " source ";" _eol  "    ")))

       ((= op "bitvector")
      		(begin 
      		(setq result (append result indent "if (" source ".u.Int == 1 )" _eol  "    "))
		    (setq result (append result indent "    BitArray(" target ")[" index ".u.Int / 8] |= gCP->TBitVector_OrMasks[("source ".u.Int % 8)];" _eol  "    "))		    
       		(setq result (append result indent "else" _eol "    "))
		    (setq result (append result indent "    BitArray(" target ")[" index ".u.Int / 8] &= gCP->TBitVector_AndMasks[("source ".u.Int % 8)];" _eol  "    "))		      
            ))

       ((= op "bytvector")
		    (setq result (append result indent "ByteArray(" target ")[" index ".u.Int] = " source ".u.Char;" _eol  "    ")))
		    		   
       ((= op "intvector")
		    (setq result (append result indent "IntArray(" target  ")[" index ".u.Int] = " source ".u.Int;" _eol  "    ")))		    
            
       ((= op "numvector")
		    (setq result (append result indent "RealArray(" target ")[" index ".u.Int] = " source ".u.Real;" _eol  "    ")))		    
         
       ((= op "fltvector")
		    (setq result (append result indent "FloatArray(" target ")[" index ".u.Int] = " source ".u.Real;" _eol  "    ")))		    
           
      ((= op "objvector")
      		(begin
        	(setq result (append result indent "if (isObject(&" target "))" _eol  "    "))    		
		    (setq result (append result indent "    ObjArray(" target ")[" index ".u.Int] = " source ".u.Object;" _eol  "    "))	
		    (setq result (append result indent "else" _eol "    "))	    
		    (setq result (append result indent "    ObjArray(" target ")[" index ".u.Int] = NIL;" _eol  "    "))		    
            )) 
  
       ((= op "pcdvector")
		    (setq result (append result indent "PcodeArray(" target ")[" index ".u.Int] = " source ".u.Int;" _eol  "    ")))		    
            
      ((= op "matrix")
		    (setq result (append result indent "TvalMatrix(" target ")[" index ".u.Int] = " source ";" _eol  "    ")))		    

      ((= op "nummatrix")
		    (setq result (append result indent "RealMatrix(" target ")[" index ".u.Int] = " source ".u.Real;" _eol  "    ")))		    
  		
      ((= op "dickey")
      		(begin
        	(setq result (append result indent "if (isObject(&" source "))" _eol  "    "))    		
		    (setq result (append result indent "    BondArray(" target ")[" index ".u.Int].Key = " source ".u.Object;" _eol  "    "))	
		    (setq result (append result indent "else" _eol "    "))	                                
		    (setq result (append result indent "    BondArray(" target ")[" index ".u.Int].Key = NIL;" _eol  "    "))		    
            )) 
		
       ((= op "strkey")
      		(begin
        	(setq result (append result indent "if (isObject(&" source "))" _eol  "    "))    		
		    (setq result (append result indent "    BindArray(" target ")[" index ".u.Int].Key = " source ".u.Object;" _eol  "    "))	
		    (setq result (append result indent "else" _eol "    "))	    
		    (setq result (append result indent "    BindArray(" target ")[" index ".u.Int].Key = NIL;" _eol  "    "))		    
            )) 
            		
        ((= op "dirkey")
		    (setq result (append result indent "PBindArray(" target ")[" index ".u.Int].Key = " source ";" _eol  "    ")))		    
   
        ((= op "dicvalue")
		    (setq result (append result indent "BondArray(" target ")[" index ".u.Int].Value = " source ";"  _eol  "    ")))

         ((= op "strvalue")
		    (setq result (append result indent "BindArray(" target ")[" index ".u.Int].Value = " source ";"  _eol  "    ")))
       
        ((= op "dirvalue")
		    (setq result (append result indent "PBindArray(" target ")[" index ".u.Int].Value = " source ";"  _eol  "    ")))
 ) ;; end cond 

   (setq codeString (append codeString result))  
   
    true ) ; end c_xset
                           
;;*********************************************************************
;; Function c_onError constructs the C code to call an error function
;;*********************************************************************
(defchild CompilerLib:c_onerror(operator operand) 
   vars:(result func numArgs indent linenumlength)  

    ;; For code readability, compute the number of spaces to indent 
    (setq linenumlength (length glinenum))
    (setq indent (rept " " linenumlength))
    (setq result "") 
       
    ;; convert the arguments to a c string
    (setq target  (cnvType operand[1]))
    (setq func    (cnvType operand[0])) 
  
   
    ;; For code readability, output a comment containing name of the error function that will saved.
    (setq result (append result  "/*********** Saving Error Handler: " func "***********/" _eol  "    " )) 
   
   ;; Save the error handler in the special container: ErrorLambdaTval 
    (setq result (append result indent  "Stack(ErrorLambdaTval) = " func ";" _eol  "    " )) 
    (setq result (append result indent  target " = " func  ";" _eol  "    " )) 
    (setq codeString (append codeString result))  
 
   true ) ; end c_onerror



;;**EXPORTKEY**:CompilerLib:%RUNALL
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:runall(groupid) 
   vars:(v1 v2 vr result vintvec )  
   pvars:(p1 p2 pr pintvec )  
   cvars:(c1 c2 cr cintvec)  
     
 ;; test each of the vm instruction types. 
(setq oldSelfTest (copy CompilerLib.selfTest))
(CompilerLib__SELFTEST_MakeNative CompilerLib.selfTest)
(CompilerLib.selfTest "vmargCount" 1 2 )
(CompilerLib.selfTest "vmargFetch" 1 2 3)
(CompilerLib.selfTest "vmSend1" 1 )
(CompilerLib.selfTest "vmSend2" 1 )   
 
 (CompilerLib.selfTest "vmadd" 3 2)
 (CompilerLib.selfTest "vmsub" 3 2) 
 (CompilerLib.selfTest "vmmul" 3 2)
 (CompilerLib.selfTest "vmdiv" 6 2)
 
(setq oldSelfTest (copy CompilerLib.selfTest2))
(CompilerLib__SELFTEST2_MakeNative CompilerLib.selfTest2)
(CompilerLib.selfTest2 "vmrefNumVector" 0)
(CompilerLib.selfTest2 "vmrefIntVector" 0)
(CompilerLib.selfTest2 "vmrefVector" 0)
(CompilerLib.selfTest2 "vmrefBytVector" 0)
(CompilerLib.selfTest2 "vmrefFltVector" 0)
(CompilerLib.selfTest2 "vmrefBitVector" 0)
                                             
(setq oldSelfTest (copy CompilerLib.selfTest3))
(CompilerLib__SELFTEST3_MakeNative CompilerLib.selfTest3)
(CompilerLib.selfTest3 "vmrefObjVector" 0)
(CompilerLib.selfTest3 "vmrefSymbol" 0)
(CompilerLib.selfTest3 "vmrefString" 0)
(CompilerLib.selfTest3 "vmrefPcdVector" 0)
(CompilerLib.selfTest3 "vmrefText" 0)
   
 (setq oldSelfTest (copy CompilerLib.selfTest4))
(CompilerLib__SELFTEST4_MakeNative CompilerLib.selfTest4)
(CompilerLib.selfTest4 "vmrefDicKey" 0)
(CompilerLib.selfTest4 "vmrefDicValue" 0)
(CompilerLib.selfTest4 "vmrefDirKey" 3)
(CompilerLib.selfTest4 "vmrefDirValue" 3)    

(setq oldSelfTest (copy CompilerLib.selfTest5))
(CompilerLib__SELFTEST5_MakeNative CompilerLib.selfTest5)
(CompilerLib.selfTest5 "vmsetIntVector" 0 9)
(CompilerLib.selfTest5 "vmsetVector" 0 9)
(CompilerLib.selfTest5 "vmsetNumVector" 0 9.0)
(CompilerLib.selfTest5 "vmsetFltVector" 0 9.1)
(CompilerLib.selfTest5 "vmsetBytVector" 0 #\N)
(CompilerLib.selfTest5 "vmsetBitVector" 0 0)

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest6)
(setq oldSelfTest (copy CompilerLib.selfTest6))
(CompilerLib__SELFTEST6_MakeNative CompilerLib.selfTest6)
(CompilerLib.selfTest6 "vmsetString" 0 #\J)
(CompilerLib.selfTest6 "vmsetBitVector" 0 0)
(CompilerLib.selfTest6 "vmref" 0)
(CompilerLib.selfTest6 "vmref2" 0 1)
(CompilerLib.selfTest6 "vmset" 0 9)
(CompilerLib.selfTest6 "vmset2" 0 9)
(CompilerLib.selfTest6 "vmshr" 8 1)
(CompilerLib.selfTest6 "vmshl" 8 1)

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest7)
(setq oldSelfTest (copy CompilerLib.selfTest7))
(CompilerLib__SELFTEST7_MakeNative CompilerLib.selfTest7)
(CompilerLib.selfTest7 "vmsetStrValue" 3 22)
(CompilerLib.selfTest7 "vmsetStrKey" 3 z:)
(CompilerLib.selfTest7 "vmsetDicValue" 3 22)
(CompilerLib.selfTest7 "vmsetDicKey" 3 z:)
(CompilerLib.selfTest7 "vmsetDirValue" 3 22)
(CompilerLib.selfTest7 "vmsetDirKey" 3 z:) 

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest8)
(setq oldSelfTest (copy CompilerLib.selfTest8))
(CompilerLib__SELFTEST8_MakeNative CompilerLib.selfTest8)
(CompilerLib.selfTest8 "vmor" 7 1)
(CompilerLib.selfTest8 "vmxor" 7 1)
(CompilerLib.selfTest8 "vmand" 6 6)
(CompilerLib.selfTest8 "vmnand" 6 6)
(CompilerLib.selfTest8 "vmnandb" 6 6)
(CompilerLib.selfTest8 "vmnor" 7 1)
(CompilerLib.selfTest8 "vmnorb" 7 1)
(CompilerLib.selfTest8 "vmnxor" 7 1)
(CompilerLib.selfTest8 "vmnxorb" 7 1)

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest9)
(setq oldSelfTest (copy CompilerLib.selfTest9))
(CompilerLib__SELFTEST9_MakeNative CompilerLib.selfTest9)
(CompilerLib.selfTest9 "vmiadd" 3 2)
(CompilerLib.selfTest9 "vmisub" 3 2) 
(CompilerLib.selfTest9 "vmimul" 3 2)
(CompilerLib.selfTest9 "vmidiv" 6 2)
(CompilerLib.selfTest9 "vmimod" 7 2)
(CompilerLib.selfTest9 "vmnadd" 3.0 2.0)
(CompilerLib.selfTest9 "vmnsub" 3.0 2.0) 
(CompilerLib.selfTest9 "vmnmul" 3.0 2.0)
(CompilerLib.selfTest9 "vmndiv" 6.0 2.0)
(CompilerLib.selfTest9 "vmnmod" 7.0 2.0)
 
(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest10)
(setq oldSelfTest (copy CompilerLib.selfTest10))
(CompilerLib__SELFTEST10_MakeNative CompilerLib.selfTest10)
(CompilerLib.selfTest10 "vmbadd" 0 0)
(CompilerLib.selfTest10 "vmbsub" 0 0) 
(CompilerLib.selfTest10 "vmbmul" 0 0)
(CompilerLib.selfTest10 "vmbdiv" 0 0)
(CompilerLib.selfTest10 "vmbmod" 1 1)
(CompilerLib.selfTest10 "vmcadd" 70 1)
(CompilerLib.selfTest10 "vmcsub" 71 1) 
(CompilerLib.selfTest10 "vmcmul" 35 2)
(CompilerLib.selfTest10 "vmcdiv" 150 2 )
(CompilerLib.selfTest10 "vmcmod" 170 110)
 
(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest11)
(setq oldSelfTest (copy CompilerLib.selfTest11))
(CompilerLib__SELFTEST11_MakeNative CompilerLib.selfTest11)
(CompilerLib.selfTest11 "vmadd" 3 2)
(CompilerLib.selfTest11 "vmsub" 3 2) 
(CompilerLib.selfTest11 "vmmul" 3 2)
(CompilerLib.selfTest11 "vmdiv" 6 2)
(CompilerLib.selfTest11 "vmaddi" 3 2)
(CompilerLib.selfTest11 "vmsubi" 3 2) 
(CompilerLib.selfTest11 "vmmuli" 3 2)
(CompilerLib.selfTest11 "vmdivi" 6 2)
(CompilerLib.selfTest11 "vmmod" 7 2)
(CompilerLib.selfTest11 "vmmodi" 7 2) 

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest12)
(setq oldSelfTest (copy CompilerLib.selfTest12))
(CompilerLib__SELFTEST12_MakeNative CompilerLib.selfTest12)
(CompilerLib.selfTest12 "vmjmplt" 3 2)
(CompilerLib.selfTest12 "vmjmpgt" 3 2) 
(CompilerLib.selfTest12 "vmjmpeq" 3 2)
(CompilerLib.selfTest12 "vmjmpne" 3 2)
(CompilerLib.selfTest12 "vmjmple" 3 2)
(CompilerLib.selfTest12 "vmjmpge" 3 2)  

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest13)
(setq oldSelfTest (copy CompilerLib.selfTest13))
(CompilerLib__SELFTEST13_MakeNative CompilerLib.selfTest13)
(CompilerLib.selfTest13 "vmijmplt" 3 2)
(CompilerLib.selfTest13 "vmijmpgt" 3 2) 
(CompilerLib.selfTest13 "vmijmpeq" 3 2)
(CompilerLib.selfTest13 "vmijmpne" 3 2)
(CompilerLib.selfTest13 "vmijmple" 3 2)
(CompilerLib.selfTest13 "vmijmpge" 3 2) 

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest14)
(setq oldSelfTest (copy CompilerLib.selfTest14))
(CompilerLib__SELFTEST14_MakeNative CompilerLib.selfTest14)
(CompilerLib.selfTest14 "vmnjmplt" 3.3 2.2)
(CompilerLib.selfTest14 "vmnjmpgt" 3.3 2.2) 
(CompilerLib.selfTest14 "vmnjmpeq" 3.3 2.2)
(CompilerLib.selfTest14 "vmnjmpne" 3.3 2.2)
(CompilerLib.selfTest14 "vmnjmple" 3.3 2.2)
(CompilerLib.selfTest14 "vmnjmpge" 3.3 2.2) 

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest15)
(setq oldSelfTest (copy CompilerLib.selfTest15))
(CompilerLib__SELFTEST15_MakeNative CompilerLib.selfTest15)
(CompilerLib.selfTest15 "vmbjmplt" 3 2)
(CompilerLib.selfTest15 "vmbjmpgt" 3 2) 
(CompilerLib.selfTest15 "vmbjmpeq" 3 2)
(CompilerLib.selfTest15 "vmbjmpne" 3 2)
(CompilerLib.selfTest15 "vmbjmple" 3 2)
(CompilerLib.selfTest15 "vmbjmpge" 3 2) 

(CompilerLib.checkin "CompilerLib" "Test" CompilerLib.selfTest16)
(setq oldSelfTest (copy CompilerLib.selfTest16))
(CompilerLib__SELFTEST16_MakeNative CompilerLib.selfTest16)
(CompilerLib.selfTest16 "vmcjmplt" 3 2)
(CompilerLib.selfTest16 "vmcjmpgt" 3 2) 
(CompilerLib.selfTest16 "vmcjmpeq" 3 2)
(CompilerLib.selfTest16 "vmcjmpne" 3 2)
(CompilerLib.selfTest16 "vmcjmple" 3 2)
(CompilerLib.selfTest16 "vmcjmpge" 3 2) 
    true ) ; end runall




;;**EXPORTKEY**:CompilerLib:%SELFTEST10
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest10(testId ...) 
   vars:(v1 v2 vr result vintvec )  
   pvars:(p1 p2 pr pintvec )  
   cvars:(c1 c2 cr cintvec)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmbsub instruction  
       ((= testId "vmbsub")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bsub " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bsub v1 v2)) result) (error "vmbsub:v1:v2:vr"))  		   
		   (if (<> (setq vr (bsub v1 p2)) result) (error "vmbsub:v1:p2:vr"))  
		   (if (<> (setq vr (bsub v1 c2)) result) (error "vmbsub:v1:c2:vr"))  

		   (if (<> (setq vr (bsub p1 v2)) result) (error "vmbsub:p1:v2:vr"))  		   
		   (if (<> (setq vr (bsub p1 p2)) result) (error "vmbsub:p1:p2:vr"))  
		   (if (<> (setq vr (bsub p1 c2)) result) (error "vmbsub:p1:c2:vr"))  
             
		   (if (<> (setq vr (bsub c1 v2)) result) (error "vmbsub:c1:v2:vr"))  		   
		   (if (<> (setq vr (bsub c1 p2)) result) (error "vmbsub:c1:p2:vr"))  		   
		   (if (<> (setq vr (bsub c1 c2)) result) (error "vmbsub:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bsub v1 v2)) result) (error "vmbsub:v1:v2:pr"))  
		   (if (<> (setq pr (bsub v1 p2)) result) (error "vmbsub:v1:p2:pr"))  
		   (if (<> (setq pr (bsub v1 c2)) result) (error "vmbsub:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bsub p1 v2)) result) (error "vmbsub:p1:v2:pr"))  		   
		   (if (<> (setq pr (bsub p1 p2)) result) (error "vmbsub:p1:p2:pr"))  		   
		   (if (<> (setq pr (bsub p1 c2)) result) (error "vmbsub:p1:c2:pr"))  
             
		   (if (<> (setq pr (bsub c1 v2)) result) (error "vmbsub:c1:v2:pr"))  		   
		   (if (<> (setq pr (bsub c1 p2)) result) (error "vmbsub:c1:p2:pr"))  		   
		   (if (<> (setq pr (bsub c1 c2)) result) (error "vmbsub:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bsub v1 v2)) result) (error "vmbsub:v1:v2:cr"))  
		   (if (<> (setq cr (bsub v1 p2)) result) (error "vmbsub:v1:p2:cr"))  
		   (if (<> (setq cr (bsub v1 c2)) result) (error "vmbsub:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bsub p1 v2)) result) (error "vmbsub:p1:v2:cr"))  		   
		   (if (<> (setq cr (bsub p1 p2)) result) (error "vmbsub:p1:p2:cr"))  		   
		   (if (<> (setq cr (bsub p1 c2)) result) (error "vmbsub:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bsub c1 v2)) result) (error "vmbsub:c1:v2:cr"))  
		   (if (<> (setq cr (bsub c1 p2)) result) (error "vmbsub:c1:p2:cr"))  		   
		   (if (<> (setq cr (bsub c1 c2)) result) (error "vmbsub:c1:c2:cr"))  
        )) ; end vmbsub case           
       ;; Test the vmbmul instruction  
         ((= testId "vmbmul")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bmul " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bmul v1 v2)) result) (error "vmbmul:v1:v2:vr"))  		   
		   (if (<> (setq vr (bmul v1 p2)) result) (error "vmbmul:v1:p2:vr"))  
		   (if (<> (setq vr (bmul v1 c2)) result) (error "vmbmul:v1:c2:vr"))  

		   (if (<> (setq vr (bmul p1 v2)) result) (error "vmbmul:p1:v2:vr"))  		   
		   (if (<> (setq vr (bmul p1 p2)) result) (error "vmbmul:p1:p2:vr"))  
		   (if (<> (setq vr (bmul p1 c2)) result) (error "vmbmul:p1:c2:vr"))  
             
		   (if (<> (setq vr (bmul c1 v2)) result) (error "vmbmul:c1:v2:vr"))  		   
		   (if (<> (setq vr (bmul c1 p2)) result) (error "vmbmul:c1:p2:vr"))  		   
		   (if (<> (setq vr (bmul c1 c2)) result) (error "vmbmul:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bmul v1 v2)) result) (error "vmbmul:v1:v2:pr"))  
		   (if (<> (setq pr (bmul v1 p2)) result) (error "vmbmul:v1:p2:pr"))  
		   (if (<> (setq pr (bmul v1 c2)) result) (error "vmbmul:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bmul p1 v2)) result) (error "vmbmul:p1:v2:pr"))  		   
		   (if (<> (setq pr (bmul p1 p2)) result) (error "vmbmul:p1:p2:pr"))  		   
		   (if (<> (setq pr (bmul p1 c2)) result) (error "vmbmul:p1:c2:pr"))  
             
		   (if (<> (setq pr (bmul c1 v2)) result) (error "vmbmul:c1:v2:pr"))  		   
		   (if (<> (setq pr (bmul c1 p2)) result) (error "vmbmul:c1:p2:pr"))  		   
		   (if (<> (setq pr (bmul c1 c2)) result) (error "vmbmul:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bmul v1 v2)) result) (error "vmbmul:v1:v2:cr"))  
		   (if (<> (setq cr (bmul v1 p2)) result) (error "vmbmul:v1:p2:cr"))  
		   (if (<> (setq cr (bmul v1 c2)) result) (error "vmbmul:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bmul p1 v2)) result) (error "vmbmul:p1:v2:cr"))  		   
		   (if (<> (setq cr (bmul p1 p2)) result) (error "vmbmul:p1:p2:cr"))  		   
		   (if (<> (setq cr (bmul p1 c2)) result) (error "vmbmul:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bmul c1 v2)) result) (error "vmbmul:c1:v2:cr"))  
		   (if (<> (setq cr (bmul c1 p2)) result) (error "vmbmul:c1:p2:cr"))  		   
		   (if (<> (setq cr (bmul c1 c2)) result) (error "vmbmul:c1:c2:cr"))  
        )) ; end vmbmul case           

         ((= testId "vmbdiv")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bdiv " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bdiv v1 v2)) result) (error "vmbdiv:v1:v2:vr"))  		   
		   (if (<> (setq vr (bdiv v1 p2)) result) (error "vmbdiv:v1:p2:vr"))  
		   (if (<> (setq vr (bdiv v1 c2)) result) (error "vmbdiv:v1:c2:vr"))  

		   (if (<> (setq vr (bdiv p1 v2)) result) (error "vmbdiv:p1:v2:vr"))  		   
		   (if (<> (setq vr (bdiv p1 p2)) result) (error "vmbdiv:p1:p2:vr"))  
		   (if (<> (setq vr (bdiv p1 c2)) result) (error "vmbdiv:p1:c2:vr"))  
             
		   (if (<> (setq vr (bdiv c1 v2)) result) (error "vmbdiv:c1:v2:vr"))  		   
		   (if (<> (setq vr (bdiv c1 p2)) result) (error "vmbdiv:c1:p2:vr"))  		   
		   (if (<> (setq vr (bdiv c1 c2)) result) (error "vmbdiv:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bdiv v1 v2)) result) (error "vmbdiv:v1:v2:pr"))  
		   (if (<> (setq pr (bdiv v1 p2)) result) (error "vmbdiv:v1:p2:pr"))  
		   (if (<> (setq pr (bdiv v1 c2)) result) (error "vmbdiv:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bdiv p1 v2)) result) (error "vmbdiv:p1:v2:pr"))  		   
		   (if (<> (setq pr (bdiv p1 p2)) result) (error "vmbdiv:p1:p2:pr"))  		   
		   (if (<> (setq pr (bdiv p1 c2)) result) (error "vmbdiv:p1:c2:pr"))  
             
		   (if (<> (setq pr (bdiv c1 v2)) result) (error "vmbdiv:c1:v2:pr"))  		   
		   (if (<> (setq pr (bdiv c1 p2)) result) (error "vmbdiv:c1:p2:pr"))  		   
		   (if (<> (setq pr (bdiv c1 c2)) result) (error "vmbdiv:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bdiv v1 v2)) result) (error "vmbdiv:v1:v2:cr"))  
		   (if (<> (setq cr (bdiv v1 p2)) result) (error "vmbdiv:v1:p2:cr"))  
		   (if (<> (setq cr (bdiv v1 c2)) result) (error "vmbdiv:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bdiv p1 v2)) result) (error "vmbdiv:p1:v2:cr"))  		   
		   (if (<> (setq cr (bdiv p1 p2)) result) (error "vmbdiv:p1:p2:cr"))  		   
		   (if (<> (setq cr (bdiv p1 c2)) result) (error "vmbdiv:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bdiv c1 v2)) result) (error "vmbdiv:c1:v2:cr"))  
		   (if (<> (setq cr (bdiv c1 p2)) result) (error "vmbdiv:c1:p2:cr"))  		   
		   (if (<> (setq cr (bdiv c1 c2)) result) (error "vmbdiv:c1:c2:cr"))  
        )) ; end vmbdiv case           
                   
        ((= testId "vmbmod")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bmod " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bmod v1 v2)) result) (error "vmbmod:v1:v2:vr"))  		   
		   (if (<> (setq vr (bmod v1 p2)) result) (error "vmbmod:v1:p2:vr"))  
		   (if (<> (setq vr (bmod v1 c2)) result) (error "vmbmod:v1:c2:vr"))  

		   (if (<> (setq vr (bmod p1 v2)) result) (error "vmbmod:p1:v2:vr"))  		   
		   (if (<> (setq vr (bmod p1 p2)) result) (error "vmbmod:p1:p2:vr"))  
		   (if (<> (setq vr (bmod p1 c2)) result) (error "vmbmod:p1:c2:vr"))  
             
		   (if (<> (setq vr (bmod c1 v2)) result) (error "vmbmod:c1:v2:vr"))  		   
		   (if (<> (setq vr (bmod c1 p2)) result) (error "vmbmod:c1:p2:vr"))  		   
		   (if (<> (setq vr (bmod c1 c2)) result) (error "vmbmod:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bmod v1 v2)) result) (error "vmbmod:v1:v2:pr"))  
		   (if (<> (setq pr (bmod v1 p2)) result) (error "vmbmod:v1:p2:pr"))  
		   (if (<> (setq pr (bmod v1 c2)) result) (error "vmbmod:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bmod p1 v2)) result) (error "vmbmod:p1:v2:pr"))  		   
		   (if (<> (setq pr (bmod p1 p2)) result) (error "vmbmod:p1:p2:pr"))  		   
		   (if (<> (setq pr (bmod p1 c2)) result) (error "vmbmod:p1:c2:pr"))  
             
		   (if (<> (setq pr (bmod c1 v2)) result) (error "vmbmod:c1:v2:pr"))  		   
		   (if (<> (setq pr (bmod c1 p2)) result) (error "vmbmod:c1:p2:pr"))  		   
		   (if (<> (setq pr (bmod c1 c2)) result) (error "vmbmod:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bmod v1 v2)) result) (error "vmbmod:v1:v2:cr"))  
		   (if (<> (setq cr (bmod v1 p2)) result) (error "vmbmod:v1:p2:cr"))  
		   (if (<> (setq cr (bmod v1 c2)) result) (error "vmbmod:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bmod p1 v2)) result) (error "vmbmod:p1:v2:cr"))  		   
		   (if (<> (setq cr (bmod p1 p2)) result) (error "vmbmod:p1:p2:cr"))  		   
		   (if (<> (setq cr (bmod p1 c2)) result) (error "vmbmod:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bmod c1 v2)) result) (error "vmbmod:c1:v2:cr"))  
		   (if (<> (setq cr (bmod c1 p2)) result) (error "vmbmod:c1:p2:cr"))  		   
		   (if (<> (setq cr (bmod c1 c2)) result) (error "vmbmod:c1:c2:cr"))  
        )) ; end vmbmod case
       ;; Test the vmcadd instruction  
       ((= testId "vmcadd")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(cadd " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (cadd v1 v2)) result) (error "vmcadd:v1:v2:vr"))  		   
		   (if (<> (setq vr (cadd v1 p2)) result) (error "vmcadd:v1:p2:vr"))  
		   (if (<> (setq vr (cadd v1 c2)) result) (error "vmcadd:v1:c2:vr"))  

		   (if (<> (setq vr (cadd p1 v2)) result) (error "vmcadd:p1:v2:vr"))  		   
		   (if (<> (setq vr (cadd p1 p2)) result) (error "vmcadd:p1:p2:vr"))  
		   (if (<> (setq vr (cadd p1 c2)) result) (error "vmcadd:p1:c2:vr"))  
             
		   (if (<> (setq vr (cadd c1 v2)) result) (error "vmcadd:c1:v2:vr"))  		   
		   (if (<> (setq vr (cadd c1 p2)) result) (error "vmcadd:c1:p2:vr"))  		   
		   (if (<> (setq vr (cadd c1 c2)) result) (error "vmcadd:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (cadd v1 v2)) result) (error "vmcadd:v1:v2:pr"))  
		   (if (<> (setq pr (cadd v1 p2)) result) (error "vmcadd:v1:p2:pr"))  
		   (if (<> (setq pr (cadd v1 c2)) result) (error "vmcadd:v1:c2:pr"))  
		   
		   (if (<> (setq pr (cadd p1 v2)) result) (error "vmcadd:p1:v2:pr"))  		   
		   (if (<> (setq pr (cadd p1 p2)) result) (error "vmcadd:p1:p2:pr"))  		   
		   (if (<> (setq pr (cadd p1 c2)) result) (error "vmcadd:p1:c2:pr"))  
             
		   (if (<> (setq pr (cadd c1 v2)) result) (error "vmcadd:c1:v2:pr"))  		   
		   (if (<> (setq pr (cadd c1 p2)) result) (error "vmcadd:c1:p2:pr"))  		   
		   (if (<> (setq pr (cadd c1 c2)) result) (error "vmcadd:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (cadd v1 v2)) result) (error "vmcadd:v1:v2:cr"))  
		   (if (<> (setq cr (cadd v1 p2)) result) (error "vmcadd:v1:p2:cr"))  
		   (if (<> (setq cr (cadd v1 c2)) result) (error "vmcadd:v1:c2:cr"))  
		   
		   (if (<> (setq cr (cadd p1 v2)) result) (error "vmcadd:p1:v2:cr"))  		   
		   (if (<> (setq cr (cadd p1 p2)) result) (error "vmcadd:p1:p2:cr"))  		   
		   (if (<> (setq cr (cadd p1 c2)) result) (error "vmcadd:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (cadd c1 v2)) result) (error "vmcadd:c1:v2:cr"))  
		   (if (<> (setq cr (cadd c1 p2)) result) (error "vmcadd:c1:p2:cr"))  		   
		   (if (<> (setq cr (cadd c1 c2)) result) (error "vmcadd:c1:c2:cr"))  
        )) ; end vmcadd case       
        
        ;; Test the vmbsub instruction  
       ((= testId "vmcsub")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(csub " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (csub v1 v2)) result) (error "vmcsub:v1:v2:vr"))  		   
		   (if (<> (setq vr (csub v1 p2)) result) (error "vmcsub:v1:p2:vr"))  
		   (if (<> (setq vr (csub v1 c2)) result) (error "vmcsub:v1:c2:vr"))  

		   (if (<> (setq vr (csub p1 v2)) result) (error "vmcsub:p1:v2:vr"))  		   
		   (if (<> (setq vr (csub p1 p2)) result) (error "vmcsub:p1:p2:vr"))  
		   (if (<> (setq vr (csub p1 c2)) result) (error "vmcsub:p1:c2:vr"))  
             
		   (if (<> (setq vr (csub c1 v2)) result) (error "vmcsub:c1:v2:vr"))  		   
		   (if (<> (setq vr (csub c1 p2)) result) (error "vmcsub:c1:p2:vr"))  		   
		   (if (<> (setq vr (csub c1 c2)) result) (error "vmcsub:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (csub v1 v2)) result) (error "vmcsub:v1:v2:pr"))  
		   (if (<> (setq pr (csub v1 p2)) result) (error "vmcsub:v1:p2:pr"))  
		   (if (<> (setq pr (csub v1 c2)) result) (error "vmcsub:v1:c2:pr"))  
		   
		   (if (<> (setq pr (csub p1 v2)) result) (error "vmcsub:p1:v2:pr"))  		   
		   (if (<> (setq pr (csub p1 p2)) result) (error "vmcsub:p1:p2:pr"))  		   
		   (if (<> (setq pr (csub p1 c2)) result) (error "vmcsub:p1:c2:pr"))  
             
		   (if (<> (setq pr (csub c1 v2)) result) (error "vmcsub:c1:v2:pr"))  		   
		   (if (<> (setq pr (csub c1 p2)) result) (error "vmcsub:c1:p2:pr"))  		   
		   (if (<> (setq pr (csub c1 c2)) result) (error "vmcsub:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (csub v1 v2)) result) (error "vmcsub:v1:v2:cr"))  
		   (if (<> (setq cr (csub v1 p2)) result) (error "vmcsub:v1:p2:cr"))  
		   (if (<> (setq cr (csub v1 c2)) result) (error "vmcsub:v1:c2:cr"))  
		   
		   (if (<> (setq cr (csub p1 v2)) result) (error "vmcsub:p1:v2:cr"))  		   
		   (if (<> (setq cr (csub p1 p2)) result) (error "vmcsub:p1:p2:cr"))  		   
		   (if (<> (setq cr (csub p1 c2)) result) (error "vmcsub:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (csub c1 v2)) result) (error "vmcsub:c1:v2:cr"))  
		   (if (<> (setq cr (csub c1 p2)) result) (error "vmcsub:c1:p2:cr"))  		   
		   (if (<> (setq cr (csub c1 c2)) result) (error "vmcsub:c1:c2:cr"))  
        )) ; end vmcsub case           

          ;; Test the vmbmul instruction  
       ((= testId "vmcmul")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(cmul " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (cmul v1 v2)) result) (error "vmcmul:v1:v2:vr"))  		   
		   (if (<> (setq vr (cmul v1 p2)) result) (error "vmcmul:v1:p2:vr"))  
		   (if (<> (setq vr (cmul v1 c2)) result) (error "vmcmul:v1:c2:vr"))  

		   (if (<> (setq vr (cmul p1 v2)) result) (error "vmcmul:p1:v2:vr"))  		   
		   (if (<> (setq vr (cmul p1 p2)) result) (error "vmcmul:p1:p2:vr"))  
		   (if (<> (setq vr (cmul p1 c2)) result) (error "vmcmul:p1:c2:vr"))  
             
		   (if (<> (setq vr (cmul c1 v2)) result) (error "vmcmul:c1:v2:vr"))  		   
		   (if (<> (setq vr (cmul c1 p2)) result) (error "vmcmul:c1:p2:vr"))  		   
		   (if (<> (setq vr (cmul c1 c2)) result) (error "vmcmul:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (cmul v1 v2)) result) (error "vmcmul:v1:v2:pr"))  
		   (if (<> (setq pr (cmul v1 p2)) result) (error "vmcmul:v1:p2:pr"))  
		   (if (<> (setq pr (cmul v1 c2)) result) (error "vmcmul:v1:c2:pr"))  
		   
		   (if (<> (setq pr (cmul p1 v2)) result) (error "vmcmul:p1:v2:pr"))  		   
		   (if (<> (setq pr (cmul p1 p2)) result) (error "vmcmul:p1:p2:pr"))  		   
		   (if (<> (setq pr (cmul p1 c2)) result) (error "vmcmul:p1:c2:pr"))  
             
		   (if (<> (setq pr (cmul c1 v2)) result) (error "vmcmul:c1:v2:pr"))  		   
		   (if (<> (setq pr (cmul c1 p2)) result) (error "vmcmul:c1:p2:pr"))  		   
		   (if (<> (setq pr (cmul c1 c2)) result) (error "vmcmul:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (cmul v1 v2)) result) (error "vmcmul:v1:v2:cr"))  
		   (if (<> (setq cr (cmul v1 p2)) result) (error "vmcmul:v1:p2:cr"))  
		   (if (<> (setq cr (cmul v1 c2)) result) (error "vmcmul:v1:c2:cr"))  
		   
		   (if (<> (setq cr (cmul p1 v2)) result) (error "vmcmul:p1:v2:cr"))  		   
		   (if (<> (setq cr (cmul p1 p2)) result) (error "vmcmul:p1:p2:cr"))  		   
		   (if (<> (setq cr (cmul p1 c2)) result) (error "vmcmul:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (cmul c1 v2)) result) (error "vmcmul:c1:v2:cr"))  
		   (if (<> (setq cr (cmul c1 p2)) result) (error "vmcmul:c1:p2:cr"))  		   
		   (if (<> (setq cr (cmul c1 c2)) result) (error "vmcmul:c1:c2:cr"))  
        )) ; end vmcmul case           
          ;; Test the vmcdiv instruction  
         ((= testId "vmcdiv")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(cdiv " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (cdiv v1 v2)) result) (error "vmcdiv:v1:v2:vr"))  		   
		   (if (<> (setq vr (cdiv v1 p2)) result) (error "vmcdiv:v1:p2:vr"))  
		   (if (<> (setq vr (cdiv v1 c2)) result) (error "vmcdiv:v1:c2:vr"))  

		   (if (<> (setq vr (cdiv p1 v2)) result) (error "vmcdiv:p1:v2:vr"))  		   
		   (if (<> (setq vr (cdiv p1 p2)) result) (error "vmcdiv:p1:p2:vr"))  
		   (if (<> (setq vr (cdiv p1 c2)) result) (error "vmcdiv:p1:c2:vr"))  
             
		   (if (<> (setq vr (cdiv c1 v2)) result) (error "vmcdiv:c1:v2:vr"))  		   
		   (if (<> (setq vr (cdiv c1 p2)) result) (error "vmcdiv:c1:p2:vr"))  		   
		   (if (<> (setq vr (cdiv c1 c2)) result) (error "vmcdiv:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (cdiv v1 v2)) result) (error "vmcdiv:v1:v2:pr"))  
		   (if (<> (setq pr (cdiv v1 p2)) result) (error "vmcdiv:v1:p2:pr"))  
		   (if (<> (setq pr (cdiv v1 c2)) result) (error "vmcdiv:v1:c2:pr"))  
		   
		   (if (<> (setq pr (cdiv p1 v2)) result) (error "vmcdiv:p1:v2:pr"))  		   
		   (if (<> (setq pr (cdiv p1 p2)) result) (error "vmcdiv:p1:p2:pr"))  		   
		   (if (<> (setq pr (cdiv p1 c2)) result) (error "vmcdiv:p1:c2:pr"))  
             
		   (if (<> (setq pr (cdiv c1 v2)) result) (error "vmcdiv:c1:v2:pr"))  		   
		   (if (<> (setq pr (cdiv c1 p2)) result) (error "vmcdiv:c1:p2:pr"))  		   
		   (if (<> (setq pr (cdiv c1 c2)) result) (error "vmcdiv:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (cdiv v1 v2)) result) (error "vmcdiv:v1:v2:cr"))  
		   (if (<> (setq cr (cdiv v1 p2)) result) (error "vmcdiv:v1:p2:cr"))  
		   (if (<> (setq cr (cdiv v1 c2)) result) (error "vmcdiv:v1:c2:cr"))  
		   
		   (if (<> (setq cr (cdiv p1 v2)) result) (error "vmcdiv:p1:v2:cr"))  		   
		   (if (<> (setq cr (cdiv p1 p2)) result) (error "vmcdiv:p1:p2:cr"))  		   
		   (if (<> (setq cr (cdiv p1 c2)) result) (error "vmcdiv:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (cdiv c1 v2)) result) (error "vmcdiv:c1:v2:cr"))  
		   (if (<> (setq cr (cdiv c1 p2)) result) (error "vmcdiv:c1:p2:cr"))  		   
		   (if (<> (setq cr (cdiv c1 c2)) result) (error "vmcdiv:c1:c2:cr"))  
        )) ; end vmcdiv case           
          ;; Test the vmcmod instruction  
        ((= testId "vmcmod")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(cmod " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (cmod v1 v2)) result) (error "vmcmod:v1:v2:vr"))  		   
		   (if (<> (setq vr (cmod v1 p2)) result) (error "vmcmod:v1:p2:vr"))  
		   (if (<> (setq vr (cmod v1 c2)) result) (error "vmcmod:v1:c2:vr"))  

		   (if (<> (setq vr (cmod p1 v2)) result) (error "vmcmod:p1:v2:vr"))  		   
		   (if (<> (setq vr (cmod p1 p2)) result) (error "vmcmod:p1:p2:vr"))  
		   (if (<> (setq vr (cmod p1 c2)) result) (error "vmcmod:p1:c2:vr"))  
             
		   (if (<> (setq vr (cmod c1 v2)) result) (error "vmcmod:c1:v2:vr"))  		   
		   (if (<> (setq vr (cmod c1 p2)) result) (error "vmcmod:c1:p2:vr"))  		   
		   (if (<> (setq vr (cmod c1 c2)) result) (error "vmcmod:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (cmod v1 v2)) result) (error "vmcmod:v1:v2:pr"))  
		   (if (<> (setq pr (cmod v1 p2)) result) (error "vmcmod:v1:p2:pr"))  
		   (if (<> (setq pr (cmod v1 c2)) result) (error "vmcmod:v1:c2:pr"))  
		   
		   (if (<> (setq pr (cmod p1 v2)) result) (error "vmcmod:p1:v2:pr"))  		   
		   (if (<> (setq pr (cmod p1 p2)) result) (error "vmcmod:p1:p2:pr"))  		   
		   (if (<> (setq pr (cmod p1 c2)) result) (error "vmcmod:p1:c2:pr"))  
             
		   (if (<> (setq pr (cmod c1 v2)) result) (error "vmcmod:c1:v2:pr"))  		   
		   (if (<> (setq pr (cmod c1 p2)) result) (error "vmcmod:c1:p2:pr"))  		   
		   (if (<> (setq pr (cmod c1 c2)) result) (error "vmcmod:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (cmod v1 v2)) result) (error "vmcmod:v1:v2:cr"))  
		   (if (<> (setq cr (cmod v1 p2)) result) (error "vmcmod:v1:p2:cr"))  
		   (if (<> (setq cr (cmod v1 c2)) result) (error "vmcmod:v1:c2:cr"))  
		   
		   (if (<> (setq cr (cmod p1 v2)) result) (error "vmcmod:p1:v2:cr"))  		   
		   (if (<> (setq cr (cmod p1 p2)) result) (error "vmcmod:p1:p2:cr"))  		   
		   (if (<> (setq cr (cmod p1 c2)) result) (error "vmcmod:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (cmod c1 v2)) result) (error "vmcmod:c1:v2:cr"))  
		   (if (<> (setq cr (cmod c1 p2)) result) (error "vmcmod:c1:p2:cr"))  		   
		   (if (<> (setq cr (cmod c1 c2)) result) (error "vmcmod:c1:c2:cr"))  
        )) ; end vmcmod case  
    ) ; end cond
    (append "result = " result " vr = " vr)
    ) ; end selfTest10




;;**EXPORTKEY**:CompilerLib:%SELFTEST11
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest11(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmadd instruction  
       ((= testId "vmadd")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(+ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (+ v1 v2)) result) (error "vmadd:v1:v2:vr"))  		   
		   (if (<> (setq vr (+ v1 p2)) result) (error "vmadd:v1:p2:vr"))  
		   (if (<> (setq vr (+ v1 c2)) result) (error "vmadd:v1:c2:vr"))  

		   (if (<> (setq vr (+ p1 v2)) result) (error "vmadd:p1:v2:vr"))  		   
		   (if (<> (setq vr (+ p1 p2)) result) (error "vmadd:p1:p2:vr"))  
		   (if (<> (setq vr (+ p1 c2)) result) (error "vmadd:p1:c2:vr"))  
             
		   (if (<> (setq vr (+ c1 v2)) result) (error "vmadd:c1:v2:vr"))  		   
		   (if (<> (setq vr (+ c1 p2)) result) (error "vmadd:c1:p2:vr"))  		   
		   (if (<> (setq vr (+ c1 c2)) result) (error "vmadd:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (+ v1 v2)) result) (error "vmadd:v1:v2:pr"))  
		   (if (<> (setq pr (+ v1 p2)) result) (error "vmadd:v1:p2:pr"))  
		   (if (<> (setq pr (+ v1 c2)) result) (error "vmadd:v1:c2:pr"))  
		   
		   (if (<> (setq pr (+ p1 v2)) result) (error "vmadd:p1:v2:pr"))  		   
		   (if (<> (setq pr (+ p1 p2)) result) (error "vmadd:p1:p2:pr"))  		   
		   (if (<> (setq pr (+ p1 c2)) result) (error "vmadd:p1:c2:pr"))  
             
		   (if (<> (setq pr (+ c1 v2)) result) (error "vmadd:c1:v2:pr"))  		   
		   (if (<> (setq pr (+ c1 p2)) result) (error "vmadd:c1:p2:pr"))  		   
		   (if (<> (setq pr (+ c1 c2)) result) (error "vmadd:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (+ v1 v2)) result) (error "vmadd:v1:v2:cr"))  
		   (if (<> (setq cr (+ v1 p2)) result) (error "vmadd:v1:p2:cr"))  
		   (if (<> (setq cr (+ v1 c2)) result) (error "vmadd:v1:c2:cr"))  
		   
		   (if (<> (setq cr (+ p1 v2)) result) (error "vmadd:p1:v2:cr"))  		   
		   (if (<> (setq cr (+ p1 p2)) result) (error "vmadd:p1:p2:cr"))  		   
		   (if (<> (setq cr (+ p1 c2)) result) (error "vmadd:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (+ c1 v2)) result) (error "vmadd:c1:v2:cr"))  
		   (if (<> (setq cr (+ c1 p2)) result) (error "vmadd:c1:p2:cr"))  		   
		   (if (<> (setq cr (+ c1 c2)) result) (error "vmadd:c1:c2:cr"))  
        )) ; end vmadd case           
       ;; Test the vmsub instruction  
       ((= testId "vmsub")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(- " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (- v1 v2)) result) (error "vmsub:v1:v2:vr"))  		   
		   (if (<> (setq vr (- v1 p2)) result) (error "vmsub:v1:p2:vr"))  
		   (if (<> (setq vr (- v1 c2)) result) (error "vmsub:v1:c2:vr"))  

		   (if (<> (setq vr (- p1 v2)) result) (error "vmsub:p1:v2:vr"))  		   
		   (if (<> (setq vr (- p1 p2)) result) (error "vmsub:p1:p2:vr"))  
		   (if (<> (setq vr (- p1 c2)) result) (error "vmsub:p1:c2:vr"))  
             
		   (if (<> (setq vr (- c1 v2)) result) (error "vmsub:c1:v2:vr"))  		   
		   (if (<> (setq vr (- c1 p2)) result) (error "vmsub:c1:p2:vr"))  		   
		   (if (<> (setq vr (- c1 c2)) result) (error "vmsub:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (- v1 v2)) result) (error "vmsub:v1:v2:pr"))  
		   (if (<> (setq pr (- v1 p2)) result) (error "vmsub:v1:p2:pr"))  
		   (if (<> (setq pr (- v1 c2)) result) (error "vmsub:v1:c2:pr"))  
		   
		   (if (<> (setq pr (- p1 v2)) result) (error "vmsub:p1:v2:pr"))  		   
		   (if (<> (setq pr (- p1 p2)) result) (error "vmsub:p1:p2:pr"))  		   
		   (if (<> (setq pr (- p1 c2)) result) (error "vmsub:p1:c2:pr"))  
             
		   (if (<> (setq pr (- c1 v2)) result) (error "vmsub:c1:v2:pr"))  		   
		   (if (<> (setq pr (- c1 p2)) result) (error "vmsub:c1:p2:pr"))  		   
		   (if (<> (setq pr (- c1 c2)) result) (error "vmsub:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (- v1 v2)) result) (error "vmsub:v1:v2:cr"))  
		   (if (<> (setq cr (- v1 p2)) result) (error "vmsub:v1:p2:cr"))  
		   (if (<> (setq cr (- v1 c2)) result) (error "vmsub:v1:c2:cr"))  
		   
		   (if (<> (setq cr (- p1 v2)) result) (error "vmsub:p1:v2:cr"))  		   
		   (if (<> (setq cr (- p1 p2)) result) (error "vmsub:p1:p2:cr"))  		   
		   (if (<> (setq cr (- p1 c2)) result) (error "vmsub:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (- c1 v2)) result) (error "vmsub:c1:v2:cr"))  
		   (if (<> (setq cr (- c1 p2)) result) (error "vmsub:c1:p2:cr"))  		   
		   (if (<> (setq cr (- c1 c2)) result) (error "vmsub:c1:c2:cr"))  
        )) ; end vmsub case           


         ((= testId "vmmul")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(* " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (* v1 v2)) result) (error "vmmul:v1:v2:vr"))  		   
		   (if (<> (setq vr (* v1 p2)) result) (error "vmmul:v1:p2:vr"))  
		   (if (<> (setq vr (* v1 c2)) result) (error "vmmul:v1:c2:vr"))  

		   (if (<> (setq vr (* p1 v2)) result) (error "vmmul:p1:v2:vr"))  		   
		   (if (<> (setq vr (* p1 p2)) result) (error "vmmul:p1:p2:vr"))  
		   (if (<> (setq vr (* p1 c2)) result) (error "vmmul:p1:c2:vr"))  
             
		   (if (<> (setq vr (* c1 v2)) result) (error "vmmul:c1:v2:vr"))  		   
		   (if (<> (setq vr (* c1 p2)) result) (error "vmmul:c1:p2:vr"))  		   
		   (if (<> (setq vr (* c1 c2)) result) (error "vmmul:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (* v1 v2)) result) (error "vmmul:v1:v2:pr"))  
		   (if (<> (setq pr (* v1 p2)) result) (error "vmmul:v1:p2:pr"))  
		   (if (<> (setq pr (* v1 c2)) result) (error "vmmul:v1:c2:pr"))  
		   
		   (if (<> (setq pr (* p1 v2)) result) (error "vmmul:p1:v2:pr"))  		   
		   (if (<> (setq pr (* p1 p2)) result) (error "vmmul:p1:p2:pr"))  		   
		   (if (<> (setq pr (* p1 c2)) result) (error "vmmul:p1:c2:pr"))  
             
		   (if (<> (setq pr (* c1 v2)) result) (error "vmmul:c1:v2:pr"))  		   
		   (if (<> (setq pr (* c1 p2)) result) (error "vmmul:c1:p2:pr"))  		   
		   (if (<> (setq pr (* c1 c2)) result) (error "vmmul:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (* v1 v2)) result) (error "vmmul:v1:v2:cr"))  
		   (if (<> (setq cr (* v1 p2)) result) (error "vmmul:v1:p2:cr"))  
		   (if (<> (setq cr (* v1 c2)) result) (error "vmmul:v1:c2:cr"))  
		   
		   (if (<> (setq cr (* p1 v2)) result) (error "vmmul:p1:v2:cr"))  		   
		   (if (<> (setq cr (* p1 p2)) result) (error "vmmul:p1:p2:cr"))  		   
		   (if (<> (setq cr (* p1 c2)) result) (error "vmmul:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (* c1 v2)) result) (error "vmmul:c1:v2:cr"))  
		   (if (<> (setq cr (* c1 p2)) result) (error "vmmul:c1:p2:cr"))  		   
		   (if (<> (setq cr (* c1 c2)) result) (error "vmmul:c1:c2:cr"))  
        )) ; end vmmul case           

         ((= testId "vmdiv")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(/ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (/ v1 v2)) result) (error "vmdiv:v1:v2:vr"))  		   
		   (if (<> (setq vr (/ v1 p2)) result) (error "vmdiv:v1:p2:vr"))  
		   (if (<> (setq vr (/ v1 c2)) result) (error "vmdiv:v1:c2:vr"))  

		   (if (<> (setq vr (/ p1 v2)) result) (error "vmdiv:p1:v2:vr"))  		   
		   (if (<> (setq vr (/ p1 p2)) result) (error "vmdiv:p1:p2:vr"))  
		   (if (<> (setq vr (/ p1 c2)) result) (error "vmdiv:p1:c2:vr"))  
             
		   (if (<> (setq vr (/ c1 v2)) result) (error "vmdiv:c1:v2:vr"))  		   
		   (if (<> (setq vr (/ c1 p2)) result) (error "vmdiv:c1:p2:vr"))  		   
		   (if (<> (setq vr (/ c1 c2)) result) (error "vmdiv:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (/ v1 v2)) result) (error "vmdiv:v1:v2:pr"))  
		   (if (<> (setq pr (/ v1 p2)) result) (error "vmdiv:v1:p2:pr"))  
		   (if (<> (setq pr (/ v1 c2)) result) (error "vmdiv:v1:c2:pr"))  
		   
		   (if (<> (setq pr (/ p1 v2)) result) (error "vmdiv:p1:v2:pr"))  		   
		   (if (<> (setq pr (/ p1 p2)) result) (error "vmdiv:p1:p2:pr"))  		   
		   (if (<> (setq pr (/ p1 c2)) result) (error "vmdiv:p1:c2:pr"))  
             
		   (if (<> (setq pr (/ c1 v2)) result) (error "vmdiv:c1:v2:pr"))  		   
		   (if (<> (setq pr (/ c1 p2)) result) (error "vmdiv:c1:p2:pr"))  		   
		   (if (<> (setq pr (/ c1 c2)) result) (error "vmdiv:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (/ v1 v2)) result) (error "vmdiv:v1:v2:cr"))  
		   (if (<> (setq cr (/ v1 p2)) result) (error "vmdiv:v1:p2:cr"))  
		   (if (<> (setq cr (/ v1 c2)) result) (error "vmdiv:v1:c2:cr"))  
		   
		   (if (<> (setq cr (/ p1 v2)) result) (error "vmdiv:p1:v2:cr"))  		   
		   (if (<> (setq cr (/ p1 p2)) result) (error "vmdiv:p1:p2:cr"))  		   
		   (if (<> (setq cr (/ p1 c2)) result) (error "vmdiv:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (/ c1 v2)) result) (error "vmdiv:c1:v2:cr"))  
		   (if (<> (setq cr (/ c1 p2)) result) (error "vmdiv:c1:p2:cr"))  		   
		   (if (<> (setq cr (/ c1 c2)) result) (error "vmdiv:c1:c2:cr"))  
        )) ; end vmdiv case           
                   
       ;; Test the vmaddi instruction  
       ((= testId "vmaddi")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(addi " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (addi v1 v2)) result) (error "vmaddi:v1:v2:vr"))  		   
		   (if (<> (setq vr (addi v1 p2)) result) (error "vmaddi:v1:p2:vr"))  
		   (if (<> (setq vr (addi v1 c2)) result) (error "vmaddi:v1:c2:vr"))  

		   (if (<> (setq vr (addi p1 v2)) result) (error "vmaddi:p1:v2:vr"))  		   
		   (if (<> (setq vr (addi p1 p2)) result) (error "vmaddi:p1:p2:vr"))  
		   (if (<> (setq vr (addi p1 c2)) result) (error "vmaddi:p1:c2:vr"))  
             
		   (if (<> (setq vr (addi c1 v2)) result) (error "vmaddi:c1:v2:vr"))  		   
		   (if (<> (setq vr (addi c1 p2)) result) (error "vmaddi:c1:p2:vr"))  		   
		   (if (<> (setq vr (addi c1 c2)) result) (error "vmaddi:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (addi v1 v2)) result) (error "vmaddi:v1:v2:pr"))  
		   (if (<> (setq pr (addi v1 p2)) result) (error "vmaddi:v1:p2:pr"))  
		   (if (<> (setq pr (addi v1 c2)) result) (error "vmaddi:v1:c2:pr"))  
		   
		   (if (<> (setq pr (addi p1 v2)) result) (error "vmaddi:p1:v2:pr"))  		   
		   (if (<> (setq pr (addi p1 p2)) result) (error "vmaddi:p1:p2:pr"))  		   
		   (if (<> (setq pr (addi p1 c2)) result) (error "vmaddi:p1:c2:pr"))  
             
		   (if (<> (setq pr (addi c1 v2)) result) (error "vmaddi:c1:v2:pr"))  		   
		   (if (<> (setq pr (addi c1 p2)) result) (error "vmaddi:c1:p2:pr"))  		   
		   (if (<> (setq pr (addi c1 c2)) result) (error "vmaddi:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (addi v1 v2)) result) (error "vmaddi:v1:v2:cr"))  
		   (if (<> (setq cr (addi v1 p2)) result) (error "vmaddi:v1:p2:cr"))  
		   (if (<> (setq cr (addi v1 c2)) result) (error "vmaddi:v1:c2:cr"))  
		   
		   (if (<> (setq cr (addi p1 v2)) result) (error "vmaddi:p1:v2:cr"))  		   
		   (if (<> (setq cr (addi p1 p2)) result) (error "vmaddi:p1:p2:cr"))  		   
		   (if (<> (setq cr (addi p1 c2)) result) (error "vmaddi:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (addi c1 v2)) result) (error "vmaddi:c1:v2:cr"))  
		   (if (<> (setq cr (addi c1 p2)) result) (error "vmaddi:c1:p2:cr"))  		   
		   (if (<> (setq cr (addi c1 c2)) result) (error "vmaddi:c1:c2:cr"))  
        )) ; end vmaddi case           
       ;; Test the vmsubi instruction  
       ((= testId "vmsubi")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(subi " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (subi v1 v2)) result) (error "vmsubi:v1:v2:vr"))  		   
		   (if (<> (setq vr (subi v1 p2)) result) (error "vmsubi:v1:p2:vr"))  
		   (if (<> (setq vr (subi v1 c2)) result) (error "vmsubi:v1:c2:vr"))  

		   (if (<> (setq vr (subi p1 v2)) result) (error "vmsubi:p1:v2:vr"))  		   
		   (if (<> (setq vr (subi p1 p2)) result) (error "vmsubi:p1:p2:vr"))  
		   (if (<> (setq vr (subi p1 c2)) result) (error "vmsubi:p1:c2:vr"))  
             
		   (if (<> (setq vr (subi c1 v2)) result) (error "vmsubi:c1:v2:vr"))  		   
		   (if (<> (setq vr (subi c1 p2)) result) (error "vmsubi:c1:p2:vr"))  		   
		   (if (<> (setq vr (subi c1 c2)) result) (error "vmsubi:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (subi v1 v2)) result) (error "vmsubi:v1:v2:pr"))  
		   (if (<> (setq pr (subi v1 p2)) result) (error "vmsubi:v1:p2:pr"))  
		   (if (<> (setq pr (subi v1 c2)) result) (error "vmsubi:v1:c2:pr"))  
		   
		   (if (<> (setq pr (subi p1 v2)) result) (error "vmsubi:p1:v2:pr"))  		   
		   (if (<> (setq pr (subi p1 p2)) result) (error "vmsubi:p1:p2:pr"))  		   
		   (if (<> (setq pr (subi p1 c2)) result) (error "vmsubi:p1:c2:pr"))  
             
		   (if (<> (setq pr (subi c1 v2)) result) (error "vmsubi:c1:v2:pr"))  		   
		   (if (<> (setq pr (subi c1 p2)) result) (error "vmsubi:c1:p2:pr"))  		   
		   (if (<> (setq pr (subi c1 c2)) result) (error "vmsubi:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (subi v1 v2)) result) (error "vmsubi:v1:v2:cr"))  
		   (if (<> (setq cr (subi v1 p2)) result) (error "vmsubi:v1:p2:cr"))  
		   (if (<> (setq cr (subi v1 c2)) result) (error "vmsubi:v1:c2:cr"))  
		   
		   (if (<> (setq cr (subi p1 v2)) result) (error "vmsubi:p1:v2:cr"))  		   
		   (if (<> (setq cr (subi p1 p2)) result) (error "vmsubi:p1:p2:cr"))  		   
		   (if (<> (setq cr (subi p1 c2)) result) (error "vmsubi:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (subi c1 v2)) result) (error "vmsubi:c1:v2:cr"))  
		   (if (<> (setq cr (subi c1 p2)) result) (error "vmsubi:c1:p2:cr"))  		   
		   (if (<> (setq cr (subi c1 c2)) result) (error "vmsubi:c1:c2:cr"))  
        )) ; end vmsubi case           

         ((= testId "vmuli")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(muli " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (muli v1 v2)) result) (error "vmuli:v1:v2:vr"))  		   
		   (if (<> (setq vr (muli v1 p2)) result) (error "vmuli:v1:p2:vr"))  
		   (if (<> (setq vr (muli v1 c2)) result) (error "vmuli:v1:c2:vr"))  

		   (if (<> (setq vr (muli p1 v2)) result) (error "vmuli:p1:v2:vr"))  		   
		   (if (<> (setq vr (muli p1 p2)) result) (error "vmuli:p1:p2:vr"))  
		   (if (<> (setq vr (muli p1 c2)) result) (error "vmuli:p1:c2:vr"))  
             
		   (if (<> (setq vr (muli c1 v2)) result) (error "vmuli:c1:v2:vr"))  		   
		   (if (<> (setq vr (muli c1 p2)) result) (error "vmuli:c1:p2:vr"))  		   
		   (if (<> (setq vr (muli c1 c2)) result) (error "vmuli:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (muli v1 v2)) result) (error "vmuli:v1:v2:pr"))  
		   (if (<> (setq pr (muli v1 p2)) result) (error "vmuli:v1:p2:pr"))  
		   (if (<> (setq pr (muli v1 c2)) result) (error "vmuli:v1:c2:pr"))  
		   
		   (if (<> (setq pr (muli p1 v2)) result) (error "vmuli:p1:v2:pr"))  		   
		   (if (<> (setq pr (muli p1 p2)) result) (error "vmuli:p1:p2:pr"))  		   
		   (if (<> (setq pr (muli p1 c2)) result) (error "vmuli:p1:c2:pr"))  
             
		   (if (<> (setq pr (muli c1 v2)) result) (error "vmuli:c1:v2:pr"))  		   
		   (if (<> (setq pr (muli c1 p2)) result) (error "vmuli:c1:p2:pr"))  		   
		   (if (<> (setq pr (muli c1 c2)) result) (error "vmuli:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (muli v1 v2)) result) (error "vmuli:v1:v2:cr"))  
		   (if (<> (setq cr (muli v1 p2)) result) (error "vmuli:v1:p2:cr"))  
		   (if (<> (setq cr (muli v1 c2)) result) (error "vmuli:v1:c2:cr"))  
		   
		   (if (<> (setq cr (muli p1 v2)) result) (error "vmuli:p1:v2:cr"))  		   
		   (if (<> (setq cr (muli p1 p2)) result) (error "vmuli:p1:p2:cr"))  		   
		   (if (<> (setq cr (muli p1 c2)) result) (error "vmuli:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (muli c1 v2)) result) (error "vmuli:c1:v2:cr"))  
		   (if (<> (setq cr (muli c1 p2)) result) (error "vmuli:c1:p2:cr"))  		   
		   (if (<> (setq cr (muli c1 c2)) result) (error "vmuli:c1:c2:cr"))  
        )) ; end vmuli case           

         ((= testId "vmdivi")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(divi " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (divi v1 v2)) result) (error "vmdivi:v1:v2:vr"))  		   
		   (if (<> (setq vr (divi v1 p2)) result) (error "vmdivi:v1:p2:vr"))  
		   (if (<> (setq vr (divi v1 c2)) result) (error "vmdivi:v1:c2:vr"))  

		   (if (<> (setq vr (divi p1 v2)) result) (error "vmdivi:p1:v2:vr"))  		   
		   (if (<> (setq vr (divi p1 p2)) result) (error "vmdivi:p1:p2:vr"))  
		   (if (<> (setq vr (divi p1 c2)) result) (error "vmdivi:p1:c2:vr"))  
             
		   (if (<> (setq vr (divi c1 v2)) result) (error "vmdivi:c1:v2:vr"))  		   
		   (if (<> (setq vr (divi c1 p2)) result) (error "vmdivi:c1:p2:vr"))  		   
		   (if (<> (setq vr (divi c1 c2)) result) (error "vmdivi:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (divi v1 v2)) result) (error "vmdivi:v1:v2:pr"))  
		   (if (<> (setq pr (divi v1 p2)) result) (error "vmdivi:v1:p2:pr"))  
		   (if (<> (setq pr (divi v1 c2)) result) (error "vmdivi:v1:c2:pr"))  
		   
		   (if (<> (setq pr (divi p1 v2)) result) (error "vmdivi:p1:v2:pr"))  		   
		   (if (<> (setq pr (divi p1 p2)) result) (error "vmdivi:p1:p2:pr"))  		   
		   (if (<> (setq pr (divi p1 c2)) result) (error "vmdivi:p1:c2:pr"))  
             
		   (if (<> (setq pr (divi c1 v2)) result) (error "vmdivi:c1:v2:pr"))  		   
		   (if (<> (setq pr (divi c1 p2)) result) (error "vmdivi:c1:p2:pr"))  		   
		   (if (<> (setq pr (divi c1 c2)) result) (error "vmdivi:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (divi v1 v2)) result) (error "vmdivi:v1:v2:cr"))  
		   (if (<> (setq cr (divi v1 p2)) result) (error "vmdivi:v1:p2:cr"))  
		   (if (<> (setq cr (divi v1 c2)) result) (error "vmdivi:v1:c2:cr"))  
		   
		   (if (<> (setq cr (divi p1 v2)) result) (error "vmdivi:p1:v2:cr"))  		   
		   (if (<> (setq cr (divi p1 p2)) result) (error "vmdivi:p1:p2:cr"))  		   
		   (if (<> (setq cr (divi p1 c2)) result) (error "vmdivi:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (divi c1 v2)) result) (error "vmdivi:c1:v2:cr"))  
		   (if (<> (setq cr (divi c1 p2)) result) (error "vmdivi:c1:p2:cr"))  		   
		   (if (<> (setq cr (divi c1 c2)) result) (error "vmdivi:c1:c2:cr"))  
        )) ; end vmdivi case           
                   
        ((= testId "vmmodi")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(modi " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (modi v1 v2)) result) (error "vmmodi:v1:v2:vr"))  		   
		   (if (<> (setq vr (modi v1 p2)) result) (error "vmmodi:v1:p2:vr"))  
		   (if (<> (setq vr (modi v1 c2)) result) (error "vmmodi:v1:c2:vr"))  

		   (if (<> (setq vr (modi p1 v2)) result) (error "vmmodi:p1:v2:vr"))  		   
		   (if (<> (setq vr (modi p1 p2)) result) (error "vmmodi:p1:p2:vr"))  
		   (if (<> (setq vr (modi p1 c2)) result) (error "vmmodi:p1:c2:vr"))  
             
		   (if (<> (setq vr (modi c1 v2)) result) (error "vmmodi:c1:v2:vr"))  		   
		   (if (<> (setq vr (modi c1 p2)) result) (error "vmmodi:c1:p2:vr"))  		   
		   (if (<> (setq vr (modi c1 c2)) result) (error "vmmodi:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (modi v1 v2)) result) (error "vmmodi:v1:v2:pr"))  
		   (if (<> (setq pr (modi v1 p2)) result) (error "vmmodi:v1:p2:pr"))  
		   (if (<> (setq pr (modi v1 c2)) result) (error "vmmodi:v1:c2:pr"))  
		   
		   (if (<> (setq pr (modi p1 v2)) result) (error "vmmodi:p1:v2:pr"))  		   
		   (if (<> (setq pr (modi p1 p2)) result) (error "vmmodi:p1:p2:pr"))  		   
		   (if (<> (setq pr (modi p1 c2)) result) (error "vmmodi:p1:c2:pr"))  
             
		   (if (<> (setq pr (modi c1 v2)) result) (error "vmmodi:c1:v2:pr"))  		   
		   (if (<> (setq pr (modi c1 p2)) result) (error "vmmodi:c1:p2:pr"))  		   
		   (if (<> (setq pr (modi c1 c2)) result) (error "vmmodi:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (modi v1 v2)) result) (error "vmmodi:v1:v2:cr"))  
		   (if (<> (setq cr (modi v1 p2)) result) (error "vmmodi:v1:p2:cr"))  
		   (if (<> (setq cr (modi v1 c2)) result) (error "vmmodi:v1:c2:cr"))  
		   
		   (if (<> (setq cr (modi p1 v2)) result) (error "vmmodi:p1:v2:cr"))  		   
		   (if (<> (setq cr (modi p1 p2)) result) (error "vmmodi:p1:p2:cr"))  		   
		   (if (<> (setq cr (modi p1 c2)) result) (error "vmmodi:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (modi c1 v2)) result) (error "vmmodi:c1:v2:cr"))  
		   (if (<> (setq cr (modi c1 p2)) result) (error "vmmodi:c1:p2:cr"))  		   
		   (if (<> (setq cr (modi c1 c2)) result) (error "vmmodi:c1:c2:cr"))  
        )) ; end vmmodi case           

          ((= testId "vmmod")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(mod " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (mod v1 v2)) result) (error "vmmod:v1:v2:vr"))  		   
		   (if (<> (setq vr (mod v1 p2)) result) (error "vmmod:v1:p2:vr"))  
		   (if (<> (setq vr (mod v1 c2)) result) (error "vmmod:v1:c2:vr"))  

		   (if (<> (setq vr (mod p1 v2)) result) (error "vmmod:p1:v2:vr"))  		   
		   (if (<> (setq vr (mod p1 p2)) result) (error "vmmod:p1:p2:vr"))  
		   (if (<> (setq vr (mod p1 c2)) result) (error "vmmod:p1:c2:vr"))  
             
		   (if (<> (setq vr (mod c1 v2)) result) (error "vmmod:c1:v2:vr"))  		   
		   (if (<> (setq vr (mod c1 p2)) result) (error "vmmod:c1:p2:vr"))  		   
		   (if (<> (setq vr (mod c1 c2)) result) (error "vmmod:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (mod v1 v2)) result) (error "vmmod:v1:v2:pr"))  
		   (if (<> (setq pr (mod v1 p2)) result) (error "vmmod:v1:p2:pr"))  
		   (if (<> (setq pr (mod v1 c2)) result) (error "vmmod:v1:c2:pr"))  
		   
		   (if (<> (setq pr (mod p1 v2)) result) (error "vmmod:p1:v2:pr"))  		   
		   (if (<> (setq pr (mod p1 p2)) result) (error "vmmod:p1:p2:pr"))  		   
		   (if (<> (setq pr (mod p1 c2)) result) (error "vmmod:p1:c2:pr"))  
             
		   (if (<> (setq pr (mod c1 v2)) result) (error "vmmod:c1:v2:pr"))  		   
		   (if (<> (setq pr (mod c1 p2)) result) (error "vmmod:c1:p2:pr"))  		   
		   (if (<> (setq pr (mod c1 c2)) result) (error "vmmod:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (mod v1 v2)) result) (error "vmmod:v1:v2:cr"))  
		   (if (<> (setq cr (mod v1 p2)) result) (error "vmmod:v1:p2:cr"))  
		   (if (<> (setq cr (mod v1 c2)) result) (error "vmmod:v1:c2:cr"))  
		   
		   (if (<> (setq cr (mod p1 v2)) result) (error "vmmod:p1:v2:cr"))  		   
		   (if (<> (setq cr (mod p1 p2)) result) (error "vmmod:p1:p2:cr"))  		   
		   (if (<> (setq cr (mod p1 c2)) result) (error "vmmod:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (mod c1 v2)) result) (error "vmmod:c1:v2:cr"))  
		   (if (<> (setq cr (mod c1 p2)) result) (error "vmmod:c1:p2:cr"))  		   
		   (if (<> (setq cr (mod c1 c2)) result) (error "vmmod:c1:c2:cr"))  
        )) ; end vmmod case           
        
                  
       ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest




;;**EXPORTKEY**:CompilerLib:%SELFTEST12
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest12(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmjmplt instruction  
       ((= testId "vmjmplt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(< " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (< v1 v2)) result) (error "vmjmplt:v1:v2:vr"))  		   
		   (if (<> (setq vr (< v1 p2)) result) (error "vmjmplt:v1:p2:vr"))  
		   (if (<> (setq vr (< v1 c2)) result) (error "vmjmplt:v1:c2:vr"))  

		   (if (<> (setq vr (< p1 v2)) result) (error "vmjmplt:p1:v2:vr"))  		   
		   (if (<> (setq vr (< p1 p2)) result) (error "vmjmplt:p1:p2:vr"))  
		   (if (<> (setq vr (< p1 c2)) result) (error "vmjmplt:p1:c2:vr"))  
             
		   (if (<> (setq vr (< c1 v2)) result) (error "vmjmplt:c1:v2:vr"))  		   
		   (if (<> (setq vr (< c1 p2)) result) (error "vmjmplt:c1:p2:vr"))  		   
		   (if (<> (setq vr (< c1 c2)) result) (error "vmjmplt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (< v1 v2)) result) (error "vmjmplt:v1:v2:pr"))  
		   (if (<> (setq pr (< v1 p2)) result) (error "vmjmplt:v1:p2:pr"))  
		   (if (<> (setq pr (< v1 c2)) result) (error "vmjmplt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (< p1 v2)) result) (error "vmjmplt:p1:v2:pr"))  		   
		   (if (<> (setq pr (< p1 p2)) result) (error "vmjmplt:p1:p2:pr"))  		   
		   (if (<> (setq pr (< p1 c2)) result) (error "vmjmplt:p1:c2:pr"))  
             
		   (if (<> (setq pr (< c1 v2)) result) (error "vmjmplt:c1:v2:pr"))  		   
		   (if (<> (setq pr (< c1 p2)) result) (error "vmjmplt:c1:p2:pr"))  		   
		   (if (<> (setq pr (< c1 c2)) result) (error "vmjmplt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (< v1 v2)) result) (error "vmjmplt:v1:v2:cr"))  
		   (if (<> (setq cr (< v1 p2)) result) (error "vmjmplt:v1:p2:cr"))  
		   (if (<> (setq cr (< v1 c2)) result) (error "vmjmplt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (< p1 v2)) result) (error "vmjmplt:p1:v2:cr"))  		   
		   (if (<> (setq cr (< p1 p2)) result) (error "vmjmplt:p1:p2:cr"))  		   
		   (if (<> (setq cr (< p1 c2)) result) (error "vmjmplt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (< c1 v2)) result) (error "vmjmplt:c1:v2:cr"))  
		   (if (<> (setq cr (< c1 p2)) result) (error "vmjmplt:c1:p2:cr"))  		   
		   (if (<> (setq cr (< c1 c2)) result) (error "vmjmplt:c1:c2:cr"))  
        )) ; end vmjmplt case 
                  
       ;; Test the vmjmpgt instruction  
       ((= testId "vmjmpgt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(> " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (> v1 v2)) result) (error "vmjmpgt:v1:v2:vr"))  		   
		   (if (<> (setq vr (> v1 p2)) result) (error "vmjmpgt:v1:p2:vr"))  
		   (if (<> (setq vr (> v1 c2)) result) (error "vmjmpgt:v1:c2:vr"))  

		   (if (<> (setq vr (> p1 v2)) result) (error "vmjmpgt:p1:v2:vr"))  		   
		   (if (<> (setq vr (> p1 p2)) result) (error "vmjmpgt:p1:p2:vr"))  
		   (if (<> (setq vr (> p1 c2)) result) (error "vmjmpgt:p1:c2:vr"))  
             
		   (if (<> (setq vr (> c1 v2)) result) (error "vmjmpgt:c1:v2:vr"))  		   
		   (if (<> (setq vr (> c1 p2)) result) (error "vmjmpgt:c1:p2:vr"))  		   
		   (if (<> (setq vr (> c1 c2)) result) (error "vmjmpgt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (> v1 v2)) result) (error "vmjmpgt:v1:v2:pr"))  
		   (if (<> (setq pr (> v1 p2)) result) (error "vmjmpgt:v1:p2:pr"))  
		   (if (<> (setq pr (> v1 c2)) result) (error "vmjmpgt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (> p1 v2)) result) (error "vmjmpgt:p1:v2:pr"))  		   
		   (if (<> (setq pr (> p1 p2)) result) (error "vmjmpgt:p1:p2:pr"))  		   
		   (if (<> (setq pr (> p1 c2)) result) (error "vmjmpgt:p1:c2:pr"))  
             
		   (if (<> (setq pr (> c1 v2)) result) (error "vmjmpgt:c1:v2:pr"))  		   
		   (if (<> (setq pr (> c1 p2)) result) (error "vmjmpgt:c1:p2:pr"))  		   
		   (if (<> (setq pr (> c1 c2)) result) (error "vmjmpgt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (> v1 v2)) result) (error "vmjmpgt:v1:v2:cr"))  
		   (if (<> (setq cr (> v1 p2)) result) (error "vmjmpgt:v1:p2:cr"))  
		   (if (<> (setq cr (> v1 c2)) result) (error "vmjmpgt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (> p1 v2)) result) (error "vmjmpgt:p1:v2:cr"))  		   
		   (if (<> (setq cr (> p1 p2)) result) (error "vmjmpgt:p1:p2:cr"))  		   
		   (if (<> (setq cr (> p1 c2)) result) (error "vmjmpgt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (> c1 v2)) result) (error "vmjmpgt:c1:v2:cr"))  
		   (if (<> (setq cr (> c1 p2)) result) (error "vmjmpgt:c1:p2:cr"))  		   
		   (if (<> (setq cr (> c1 c2)) result) (error "vmjmpgt:c1:c2:cr"))  
        )) ; end vmjmpgt case        
        
        ;; Test the vmjmpeq instruction  
       ((= testId "vmjmpeq")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(= " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (= v1 v2)) result) (error "vmjmpeq:v1:v2:vr"))  		   
		   (if (<> (setq vr (= v1 p2)) result) (error "vmjmpeq:v1:p2:vr"))  
		   (if (<> (setq vr (= v1 c2)) result) (error "vmjmpeq:v1:c2:vr"))  

		   (if (<> (setq vr (= p1 v2)) result) (error "vmjmpeq:p1:v2:vr"))  		   
		   (if (<> (setq vr (= p1 p2)) result) (error "vmjmpeq:p1:p2:vr"))  
		   (if (<> (setq vr (= p1 c2)) result) (error "vmjmpeq:p1:c2:vr"))  
             
		   (if (<> (setq vr (= c1 v2)) result) (error "vmjmpeq:c1:v2:vr"))  		   
		   (if (<> (setq vr (= c1 p2)) result) (error "vmjmpeq:c1:p2:vr"))  		   
		   (if (<> (setq vr (= c1 c2)) result) (error "vmjmpeq:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (= v1 v2)) result) (error "vmjmpeq:v1:v2:pr"))  
		   (if (<> (setq pr (= v1 p2)) result) (error "vmjmpeq:v1:p2:pr"))  
		   (if (<> (setq pr (= v1 c2)) result) (error "vmjmpeq:v1:c2:pr"))  
		   
		   (if (<> (setq pr (= p1 v2)) result) (error "vmjmpeq:p1:v2:pr"))  		   
		   (if (<> (setq pr (= p1 p2)) result) (error "vmjmpeq:p1:p2:pr"))  		   
		   (if (<> (setq pr (= p1 c2)) result) (error "vmjmpeq:p1:c2:pr"))  
             
		   (if (<> (setq pr (= c1 v2)) result) (error "vmjmpeq:c1:v2:pr"))  		   
		   (if (<> (setq pr (= c1 p2)) result) (error "vmjmpeq:c1:p2:pr"))  		   
		   (if (<> (setq pr (= c1 c2)) result) (error "vmjmpeq:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (= v1 v2)) result) (error "vmjmpeq:v1:v2:cr"))  
		   (if (<> (setq cr (= v1 p2)) result) (error "vmjmpeq:v1:p2:cr"))  
		   (if (<> (setq cr (= v1 c2)) result) (error "vmjmpeq:v1:c2:cr"))  
		   
		   (if (<> (setq cr (= p1 v2)) result) (error "vmjmpeq:p1:v2:cr"))  		   
		   (if (<> (setq cr (= p1 p2)) result) (error "vmjmpeq:p1:p2:cr"))  		   
		   (if (<> (setq cr (= p1 c2)) result) (error "vmjmpeq:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (= c1 v2)) result) (error "vmjmpeq:c1:v2:cr"))  
		   (if (<> (setq cr (= c1 p2)) result) (error "vmjmpeq:c1:p2:cr"))  		   
		   (if (<> (setq cr (= c1 c2)) result) (error "vmjmpeq:c1:c2:cr"))  
        )) ; end vmjmpeq case        
 
        ;; Test the vmjmpne instruction  
       ((= testId "vmjmpne")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(<> " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (<> v1 v2)) result) (error "vmjmpne:v1:v2:vr"))  		   
		   (if (<> (setq vr (<> v1 p2)) result) (error "vmjmpne:v1:p2:vr"))  
		   (if (<> (setq vr (<> v1 c2)) result) (error "vmjmpne:v1:c2:vr"))  

		   (if (<> (setq vr (<> p1 v2)) result) (error "vmjmpne:p1:v2:vr"))  		   
		   (if (<> (setq vr (<> p1 p2)) result) (error "vmjmpne:p1:p2:vr"))  
		   (if (<> (setq vr (<> p1 c2)) result) (error "vmjmpne:p1:c2:vr"))  
             
		   (if (<> (setq vr (<> c1 v2)) result) (error "vmjmpne:c1:v2:vr"))  		   
		   (if (<> (setq vr (<> c1 p2)) result) (error "vmjmpne:c1:p2:vr"))  		   
		   (if (<> (setq vr (<> c1 c2)) result) (error "vmjmpne:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (<> v1 v2)) result) (error "vmjmpne:v1:v2:pr"))  
		   (if (<> (setq pr (<> v1 p2)) result) (error "vmjmpne:v1:p2:pr"))  
		   (if (<> (setq pr (<> v1 c2)) result) (error "vmjmpne:v1:c2:pr"))  
		   
		   (if (<> (setq pr (<> p1 v2)) result) (error "vmjmpne:p1:v2:pr"))  		   
		   (if (<> (setq pr (<> p1 p2)) result) (error "vmjmpne:p1:p2:pr"))  		   
		   (if (<> (setq pr (<> p1 c2)) result) (error "vmjmpne:p1:c2:pr"))  
             
		   (if (<> (setq pr (<> c1 v2)) result) (error "vmjmpne:c1:v2:pr"))  		   
		   (if (<> (setq pr (<> c1 p2)) result) (error "vmjmpne:c1:p2:pr"))  		   
		   (if (<> (setq pr (<> c1 c2)) result) (error "vmjmpne:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (<> v1 v2)) result) (error "vmjmpne:v1:v2:cr"))  
		   (if (<> (setq cr (<> v1 p2)) result) (error "vmjmpne:v1:p2:cr"))  
		   (if (<> (setq cr (<> v1 c2)) result) (error "vmjmpne:v1:c2:cr"))  
		   
		   (if (<> (setq cr (<> p1 v2)) result) (error "vmjmpne:p1:v2:cr"))  		   
		   (if (<> (setq cr (<> p1 p2)) result) (error "vmjmpne:p1:p2:cr"))  		   
		   (if (<> (setq cr (<> p1 c2)) result) (error "vmjmpne:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (<> c1 v2)) result) (error "vmjmpne:c1:v2:cr"))  
		   (if (<> (setq cr (<> c1 p2)) result) (error "vmjmpne:c1:p2:cr"))  		   
		   (if (<> (setq cr (<> c1 c2)) result) (error "vmjmpne:c1:c2:cr"))  
        )) ; end vmjmpne case  
              
        ;; Test the vmjmple instruction  
       ((= testId "vmjmple")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(<= " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (<= v1 v2)) result) (error "vmjmple:v1:v2:vr"))  		   
		   (if (<> (setq vr (<= v1 p2)) result) (error "vmjmple:v1:p2:vr"))  
		   (if (<> (setq vr (<= v1 c2)) result) (error "vmjmple:v1:c2:vr"))  

		   (if (<> (setq vr (<= p1 v2)) result) (error "vmjmple:p1:v2:vr"))  		   
		   (if (<> (setq vr (<= p1 p2)) result) (error "vmjmple:p1:p2:vr"))  
		   (if (<> (setq vr (<= p1 c2)) result) (error "vmjmple:p1:c2:vr"))  
             
		   (if (<> (setq vr (<= c1 v2)) result) (error "vmjmple:c1:v2:vr"))  		   
		   (if (<> (setq vr (<= c1 p2)) result) (error "vmjmple:c1:p2:vr"))  		   
		   (if (<> (setq vr (<= c1 c2)) result) (error "vmjmple:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (<= v1 v2)) result) (error "vmjmple:v1:v2:pr"))  
		   (if (<> (setq pr (<= v1 p2)) result) (error "vmjmple:v1:p2:pr"))  
		   (if (<> (setq pr (<= v1 c2)) result) (error "vmjmple:v1:c2:pr"))  
		   
		   (if (<> (setq pr (<= p1 v2)) result) (error "vmjmple:p1:v2:pr"))  		   
		   (if (<> (setq pr (<= p1 p2)) result) (error "vmjmple:p1:p2:pr"))  		   
		   (if (<> (setq pr (<= p1 c2)) result) (error "vmjmple:p1:c2:pr"))  
             
		   (if (<> (setq pr (<= c1 v2)) result) (error "vmjmple:c1:v2:pr"))  		   
		   (if (<> (setq pr (<= c1 p2)) result) (error "vmjmple:c1:p2:pr"))  		   
		   (if (<> (setq pr (<= c1 c2)) result) (error "vmjmple:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (<= v1 v2)) result) (error "vmjmple:v1:v2:cr"))  
		   (if (<> (setq cr (<= v1 p2)) result) (error "vmjmple:v1:p2:cr"))  
		   (if (<> (setq cr (<= v1 c2)) result) (error "vmjmple:v1:c2:cr"))  
		   
		   (if (<> (setq cr (<= p1 v2)) result) (error "vmjmple:p1:v2:cr"))  		   
		   (if (<> (setq cr (<= p1 p2)) result) (error "vmjmple:p1:p2:cr"))  		   
		   (if (<> (setq cr (<= p1 c2)) result) (error "vmjmple:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (<= c1 v2)) result) (error "vmjmple:c1:v2:cr"))  
		   (if (<> (setq cr (<= c1 p2)) result) (error "vmjmple:c1:p2:cr"))  		   
		   (if (<> (setq cr (<= c1 c2)) result) (error "vmjmple:c1:c2:cr"))  
        )) ; end vmjmple case               

        ;; Test the vmjmpge instruction  
       ((= testId "vmjmpge")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(>= " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (>= v1 v2)) result) (error "vmjmpge:v1:v2:vr"))  		   
		   (if (<> (setq vr (>= v1 p2)) result) (error "vmjmpge:v1:p2:vr"))  
		   (if (<> (setq vr (>= v1 c2)) result) (error "vmjmpge:v1:c2:vr"))  

		   (if (<> (setq vr (>= p1 v2)) result) (error "vmjmpge:p1:v2:vr"))  		   
		   (if (<> (setq vr (>= p1 p2)) result) (error "vmjmpge:p1:p2:vr"))  
		   (if (<> (setq vr (>= p1 c2)) result) (error "vmjmpge:p1:c2:vr"))  
             
		   (if (<> (setq vr (>= c1 v2)) result) (error "vmjmpge:c1:v2:vr"))  		   
		   (if (<> (setq vr (>= c1 p2)) result) (error "vmjmpge:c1:p2:vr"))  		   
		   (if (<> (setq vr (>= c1 c2)) result) (error "vmjmpge:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (>= v1 v2)) result) (error "vmjmpge:v1:v2:pr"))  
		   (if (<> (setq pr (>= v1 p2)) result) (error "vmjmpge:v1:p2:pr"))  
		   (if (<> (setq pr (>= v1 c2)) result) (error "vmjmpge:v1:c2:pr"))  
		   
		   (if (<> (setq pr (>= p1 v2)) result) (error "vmjmpge:p1:v2:pr"))  		   
		   (if (<> (setq pr (>= p1 p2)) result) (error "vmjmpge:p1:p2:pr"))  		   
		   (if (<> (setq pr (>= p1 c2)) result) (error "vmjmpge:p1:c2:pr"))  
             
		   (if (<> (setq pr (>= c1 v2)) result) (error "vmjmpge:c1:v2:pr"))  		   
		   (if (<> (setq pr (>= c1 p2)) result) (error "vmjmpge:c1:p2:pr"))  		   
		   (if (<> (setq pr (>= c1 c2)) result) (error "vmjmpge:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (>= v1 v2)) result) (error "vmjmpge:v1:v2:cr"))  
		   (if (<> (setq cr (>= v1 p2)) result) (error "vmjmpge:v1:p2:cr"))  
		   (if (<> (setq cr (>= v1 c2)) result) (error "vmjmpge:v1:c2:cr"))  
		   
		   (if (<> (setq cr (>= p1 v2)) result) (error "vmjmpge:p1:v2:cr"))  		   
		   (if (<> (setq cr (>= p1 p2)) result) (error "vmjmpge:p1:p2:cr"))  		   
		   (if (<> (setq cr (>= p1 c2)) result) (error "vmjmpge:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (>= c1 v2)) result) (error "vmjmpge:c1:v2:cr"))  
		   (if (<> (setq cr (>= c1 p2)) result) (error "vmjmpge:c1:p2:cr"))  		   
		   (if (<> (setq cr (>= c1 c2)) result) (error "vmjmpge:c1:c2:cr"))  
        )) ; end vmjmpge case               
        
      ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest12




;;**EXPORTKEY**:CompilerLib:%SELFTEST13
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest13(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmijmplt instruction  
       ((= testId "vmijmplt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareLT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareLT v1 v2)) result) (error "vmijmplt:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLT v1 p2)) result) (error "vmijmplt:v1:p2:vr"))  
		   (if (<> (setq vr (icompareLT v1 c2)) result) (error "vmijmplt:v1:c2:vr"))  

		   (if (<> (setq vr (icompareLT p1 v2)) result) (error "vmijmplt:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLT p1 p2)) result) (error "vmijmplt:p1:p2:vr"))  
		   (if (<> (setq vr (icompareLT p1 c2)) result) (error "vmijmplt:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareLT c1 v2)) result) (error "vmijmplt:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLT c1 p2)) result) (error "vmijmplt:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareLT c1 c2)) result) (error "vmijmplt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareLT v1 v2)) result) (error "vmijmplt:v1:v2:pr"))  
		   (if (<> (setq pr (icompareLT v1 p2)) result) (error "vmijmplt:v1:p2:pr"))  
		   (if (<> (setq pr (icompareLT v1 c2)) result) (error "vmijmplt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareLT p1 v2)) result) (error "vmijmplt:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareLT p1 p2)) result) (error "vmijmplt:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareLT p1 c2)) result) (error "vmijmplt:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareLT c1 v2)) result) (error "vmijmplt:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareLT c1 p2)) result) (error "vmijmplt:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareLT c1 c2)) result) (error "vmijmplt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareLT v1 v2)) result) (error "vmijmplt:v1:v2:cr"))  
		   (if (<> (setq cr (icompareLT v1 p2)) result) (error "vmijmplt:v1:p2:cr"))  
		   (if (<> (setq cr (icompareLT v1 c2)) result) (error "vmijmplt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareLT p1 v2)) result) (error "vmijmplt:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareLT p1 p2)) result) (error "vmijmplt:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareLT p1 c2)) result) (error "vmijmplt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareLT c1 v2)) result) (error "vmijmplt:c1:v2:cr"))  
		   (if (<> (setq cr (icompareLT c1 p2)) result) (error "vmijmplt:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareLT c1 c2)) result) (error "vmijmplt:c1:c2:cr"))  
        )) ; end vmijmplt case 
                  
       ;; Test the vmijmpgt instruction  
       ((= testId "vmijmpgt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareGT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareGT v1 v2)) result) (error "vmijmpgt:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGT v1 p2)) result) (error "vmijmpgt:v1:p2:vr"))  
		   (if (<> (setq vr (icompareGT v1 c2)) result) (error "vmijmpgt:v1:c2:vr"))  

		   (if (<> (setq vr (icompareGT p1 v2)) result) (error "vmijmpgt:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGT p1 p2)) result) (error "vmijmpgt:p1:p2:vr"))  
		   (if (<> (setq vr (icompareGT p1 c2)) result) (error "vmijmpgt:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareGT c1 v2)) result) (error "vmijmpgt:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGT c1 p2)) result) (error "vmijmpgt:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareGT c1 c2)) result) (error "vmijmpgt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareGT v1 v2)) result) (error "vmijmpgt:v1:v2:pr"))  
		   (if (<> (setq pr (icompareGT v1 p2)) result) (error "vmijmpgt:v1:p2:pr"))  
		   (if (<> (setq pr (icompareGT v1 c2)) result) (error "vmijmpgt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareGT p1 v2)) result) (error "vmijmpgt:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareGT p1 p2)) result) (error "vmijmpgt:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareGT p1 c2)) result) (error "vmijmpgt:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareGT c1 v2)) result) (error "vmijmpgt:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareGT c1 p2)) result) (error "vmijmpgt:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareGT c1 c2)) result) (error "vmijmpgt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareGT v1 v2)) result) (error "vmijmpgt:v1:v2:cr"))  
		   (if (<> (setq cr (icompareGT v1 p2)) result) (error "vmijmpgt:v1:p2:cr"))  
		   (if (<> (setq cr (icompareGT v1 c2)) result) (error "vmijmpgt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareGT p1 v2)) result) (error "vmijmpgt:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareGT p1 p2)) result) (error "vmijmpgt:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareGT p1 c2)) result) (error "vmijmpgt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareGT c1 v2)) result) (error "vmijmpgt:c1:v2:cr"))  
		   (if (<> (setq cr (icompareGT c1 p2)) result) (error "vmijmpgt:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareGT c1 c2)) result) (error "vmijmpgt:c1:c2:cr"))  
        )) ; end vmijmpgt case        
        
        ;; Test the vmijmpeq instruction  
       ((= testId "vmijmpeq")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareEQ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareEQ v1 v2)) result) (error "vmijmpeq:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareEQ v1 p2)) result) (error "vmijmpeq:v1:p2:vr"))  
		   (if (<> (setq vr (icompareEQ v1 c2)) result) (error "vmijmpeq:v1:c2:vr"))  

		   (if (<> (setq vr (icompareEQ p1 v2)) result) (error "vmijmpeq:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareEQ p1 p2)) result) (error "vmijmpeq:p1:p2:vr"))  
		   (if (<> (setq vr (icompareEQ p1 c2)) result) (error "vmijmpeq:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareEQ c1 v2)) result) (error "vmijmpeq:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareEQ c1 p2)) result) (error "vmijmpeq:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareEQ c1 c2)) result) (error "vmijmpeq:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareEQ v1 v2)) result) (error "vmijmpeq:v1:v2:pr"))  
		   (if (<> (setq pr (icompareEQ v1 p2)) result) (error "vmijmpeq:v1:p2:pr"))  
		   (if (<> (setq pr (icompareEQ v1 c2)) result) (error "vmijmpeq:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareEQ p1 v2)) result) (error "vmijmpeq:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareEQ p1 p2)) result) (error "vmijmpeq:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareEQ p1 c2)) result) (error "vmijmpeq:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareEQ c1 v2)) result) (error "vmijmpeq:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareEQ c1 p2)) result) (error "vmijmpeq:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareEQ c1 c2)) result) (error "vmijmpeq:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareEQ v1 v2)) result) (error "vmijmpeq:v1:v2:cr"))  
		   (if (<> (setq cr (icompareEQ v1 p2)) result) (error "vmijmpeq:v1:p2:cr"))  
		   (if (<> (setq cr (icompareEQ v1 c2)) result) (error "vmijmpeq:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareEQ p1 v2)) result) (error "vmijmpeq:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareEQ p1 p2)) result) (error "vmijmpeq:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareEQ p1 c2)) result) (error "vmijmpeq:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareEQ c1 v2)) result) (error "vmijmpeq:c1:v2:cr"))  
		   (if (<> (setq cr (icompareEQ c1 p2)) result) (error "vmijmpeq:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareEQ c1 c2)) result) (error "vmijmpeq:c1:c2:cr"))  
        )) ; end vmijmpeq case        
 
        ;; Test the vmijmpne instruction  
       ((= testId "vmijmpne")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareNE  " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareNE v1 v2)) result) (error "vmijmpne:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareNE v1 p2)) result) (error "vmijmpne:v1:p2:vr"))  
		   (if (<> (setq vr (icompareNE v1 c2)) result) (error "vmijmpne:v1:c2:vr"))  

		   (if (<> (setq vr (icompareNE p1 v2)) result) (error "vmijmpne:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareNE p1 p2)) result) (error "vmijmpne:p1:p2:vr"))  
		   (if (<> (setq vr (icompareNE p1 c2)) result) (error "vmijmpne:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareNE c1 v2)) result) (error "vmijmpne:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareNE c1 p2)) result) (error "vmijmpne:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareNE c1 c2)) result) (error "vmijmpne:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareNE v1 v2)) result) (error "vmijmpne:v1:v2:pr"))  
		   (if (<> (setq pr (icompareNE v1 p2)) result) (error "vmijmpne:v1:p2:pr"))  
		   (if (<> (setq pr (icompareNE v1 c2)) result) (error "vmijmpne:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareNE p1 v2)) result) (error "vmijmpne:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareNE p1 p2)) result) (error "vmijmpne:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareNE p1 c2)) result) (error "vmijmpne:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareNE c1 v2)) result) (error "vmijmpne:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareNE c1 p2)) result) (error "vmijmpne:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareNE c1 c2)) result) (error "vmijmpne:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareNE v1 v2)) result) (error "vmijmpne:v1:v2:cr"))  
		   (if (<> (setq cr (icompareNE v1 p2)) result) (error "vmijmpne:v1:p2:cr"))  
		   (if (<> (setq cr (icompareNE v1 c2)) result) (error "vmijmpne:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareNE p1 v2)) result) (error "vmijmpne:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareNE p1 p2)) result) (error "vmijmpne:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareNE p1 c2)) result) (error "vmijmpne:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareNE c1 v2)) result) (error "vmijmpne:c1:v2:cr"))  
		   (if (<> (setq cr (icompareNE c1 p2)) result) (error "vmijmpne:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareNE c1 c2)) result) (error "vmijmpne:c1:c2:cr"))  
        )) ; end vmijmpne case  
              
        ;; Test the vmijmple instruction  
       ((= testId "vmijmple")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareLE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareLE v1 v2)) result) (error "vmijmple:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLE v1 p2)) result) (error "vmijmple:v1:p2:vr"))  
		   (if (<> (setq vr (icompareLE v1 c2)) result) (error "vmijmple:v1:c2:vr"))  

		   (if (<> (setq vr (icompareLE p1 v2)) result) (error "vmijmple:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLE p1 p2)) result) (error "vmijmple:p1:p2:vr"))  
		   (if (<> (setq vr (icompareLE p1 c2)) result) (error "vmijmple:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareLE c1 v2)) result) (error "vmijmple:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareLE c1 p2)) result) (error "vmijmple:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareLE c1 c2)) result) (error "vmijmple:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareLE v1 v2)) result) (error "vmijmple:v1:v2:pr"))  
		   (if (<> (setq pr (icompareLE v1 p2)) result) (error "vmijmple:v1:p2:pr"))  
		   (if (<> (setq pr (icompareLE v1 c2)) result) (error "vmijmple:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareLE p1 v2)) result) (error "vmijmple:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareLE p1 p2)) result) (error "vmijmple:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareLE p1 c2)) result) (error "vmijmple:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareLE c1 v2)) result) (error "vmijmple:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareLE c1 p2)) result) (error "vmijmple:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareLE c1 c2)) result) (error "vmijmple:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareLE v1 v2)) result) (error "vmijmple:v1:v2:cr"))  
		   (if (<> (setq cr (icompareLE v1 p2)) result) (error "vmijmple:v1:p2:cr"))  
		   (if (<> (setq cr (icompareLE v1 c2)) result) (error "vmijmple:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareLE p1 v2)) result) (error "vmijmple:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareLE p1 p2)) result) (error "vmijmple:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareLE p1 c2)) result) (error "vmijmple:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareLE c1 v2)) result) (error "vmijmple:c1:v2:cr"))  
		   (if (<> (setq cr (icompareLE c1 p2)) result) (error "vmijmple:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareLE c1 c2)) result) (error "vmijmple:c1:c2:cr"))  
        )) ; end vmijmple case               

        ;; Test the vmijmpge instruction  
       ((= testId "vmijmpge")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(icompareGE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (icompareGE v1 v2)) result) (error "vmijmpge:v1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGE v1 p2)) result) (error "vmijmpge:v1:p2:vr"))  
		   (if (<> (setq vr (icompareGE v1 c2)) result) (error "vmijmpge:v1:c2:vr"))  

		   (if (<> (setq vr (icompareGE p1 v2)) result) (error "vmijmpge:p1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGE p1 p2)) result) (error "vmijmpge:p1:p2:vr"))  
		   (if (<> (setq vr (icompareGE p1 c2)) result) (error "vmijmpge:p1:c2:vr"))  
             
		   (if (<> (setq vr (icompareGE c1 v2)) result) (error "vmijmpge:c1:v2:vr"))  		   
		   (if (<> (setq vr (icompareGE c1 p2)) result) (error "vmijmpge:c1:p2:vr"))  		   
		   (if (<> (setq vr (icompareGE c1 c2)) result) (error "vmijmpge:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (icompareGE v1 v2)) result) (error "vmijmpge:v1:v2:pr"))  
		   (if (<> (setq pr (icompareGE v1 p2)) result) (error "vmijmpge:v1:p2:pr"))  
		   (if (<> (setq pr (icompareGE v1 c2)) result) (error "vmijmpge:v1:c2:pr"))  
		   
		   (if (<> (setq pr (icompareGE p1 v2)) result) (error "vmijmpge:p1:v2:pr"))  		   
		   (if (<> (setq pr (icompareGE p1 p2)) result) (error "vmijmpge:p1:p2:pr"))  		   
		   (if (<> (setq pr (icompareGE p1 c2)) result) (error "vmijmpge:p1:c2:pr"))  
             
		   (if (<> (setq pr (icompareGE c1 v2)) result) (error "vmijmpge:c1:v2:pr"))  		   
		   (if (<> (setq pr (icompareGE c1 p2)) result) (error "vmijmpge:c1:p2:pr"))  		   
		   (if (<> (setq pr (icompareGE c1 c2)) result) (error "vmijmpge:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (icompareGE v1 v2)) result) (error "vmijmpge:v1:v2:cr"))  
		   (if (<> (setq cr (icompareGE v1 p2)) result) (error "vmijmpge:v1:p2:cr"))  
		   (if (<> (setq cr (icompareGE v1 c2)) result) (error "vmijmpge:v1:c2:cr"))  
		   
		   (if (<> (setq cr (icompareGE p1 v2)) result) (error "vmijmpge:p1:v2:cr"))  		   
		   (if (<> (setq cr (icompareGE p1 p2)) result) (error "vmijmpge:p1:p2:cr"))  		   
		   (if (<> (setq cr (icompareGE p1 c2)) result) (error "vmijmpge:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (icompareGE c1 v2)) result) (error "vmijmpge:c1:v2:cr"))  
		   (if (<> (setq cr (icompareGE c1 p2)) result) (error "vmijmpge:c1:p2:cr"))  		   
		   (if (<> (setq cr (icompareGE c1 c2)) result) (error "vmijmpge:c1:c2:cr"))  
        )) ; end vmijmpge case               
      ) ;; end cond 

    (append "result = " result " vr = " vr)) ;; end selfTest13




;;**EXPORTKEY**:CompilerLib:%SELFTEST14
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest14(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmnjmplt instruction  
       ((= testId "vmnjmplt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareLT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareLT v1 v2)) result) (error "vmnjmplt:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLT v1 p2)) result) (error "vmnjmplt:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareLT v1 c2)) result) (error "vmnjmplt:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareLT p1 v2)) result) (error "vmnjmplt:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLT p1 p2)) result) (error "vmnjmplt:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareLT p1 c2)) result) (error "vmnjmplt:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareLT c1 v2)) result) (error "vmnjmplt:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLT c1 p2)) result) (error "vmnjmplt:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareLT c1 c2)) result) (error "vmnjmplt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareLT v1 v2)) result) (error "vmnjmplt:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareLT v1 p2)) result) (error "vmnjmplt:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareLT v1 c2)) result) (error "vmnjmplt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareLT p1 v2)) result) (error "vmnjmplt:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareLT p1 p2)) result) (error "vmnjmplt:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareLT p1 c2)) result) (error "vmnjmplt:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareLT c1 v2)) result) (error "vmnjmplt:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareLT c1 p2)) result) (error "vmnjmplt:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareLT c1 c2)) result) (error "vmnjmplt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareLT v1 v2)) result) (error "vmnjmplt:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareLT v1 p2)) result) (error "vmnjmplt:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareLT v1 c2)) result) (error "vmnjmplt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareLT p1 v2)) result) (error "vmnjmplt:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareLT p1 p2)) result) (error "vmnjmplt:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareLT p1 c2)) result) (error "vmnjmplt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareLT c1 v2)) result) (error "vmnjmplt:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareLT c1 p2)) result) (error "vmnjmplt:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareLT c1 c2)) result) (error "vmnjmplt:c1:c2:cr"))  
        )) ; end vmnjmplt case 
                  
       ;; Test the vmnjmpgt instruction  
       ((= testId "vmnjmpgt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareGT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareGT v1 v2)) result) (error "vmnjmpgt:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGT v1 p2)) result) (error "vmnjmpgt:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareGT v1 c2)) result) (error "vmnjmpgt:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareGT p1 v2)) result) (error "vmnjmpgt:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGT p1 p2)) result) (error "vmnjmpgt:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareGT p1 c2)) result) (error "vmnjmpgt:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareGT c1 v2)) result) (error "vmnjmpgt:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGT c1 p2)) result) (error "vmnjmpgt:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareGT c1 c2)) result) (error "vmnjmpgt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareGT v1 v2)) result) (error "vmnjmpgt:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareGT v1 p2)) result) (error "vmnjmpgt:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareGT v1 c2)) result) (error "vmnjmpgt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareGT p1 v2)) result) (error "vmnjmpgt:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareGT p1 p2)) result) (error "vmnjmpgt:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareGT p1 c2)) result) (error "vmnjmpgt:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareGT c1 v2)) result) (error "vmnjmpgt:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareGT c1 p2)) result) (error "vmnjmpgt:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareGT c1 c2)) result) (error "vmnjmpgt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareGT v1 v2)) result) (error "vmnjmpgt:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareGT v1 p2)) result) (error "vmnjmpgt:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareGT v1 c2)) result) (error "vmnjmpgt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareGT p1 v2)) result) (error "vmnjmpgt:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareGT p1 p2)) result) (error "vmnjmpgt:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareGT p1 c2)) result) (error "vmnjmpgt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareGT c1 v2)) result) (error "vmnjmpgt:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareGT c1 p2)) result) (error "vmnjmpgt:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareGT c1 c2)) result) (error "vmnjmpgt:c1:c2:cr"))  
        )) ; end vmnjmpgt case        
        
        ;; Test the vmnjmpeq instruction  
       ((= testId "vmnjmpeq")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareEQ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareEQ v1 v2)) result) (error "vmnjmpeq:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareEQ v1 p2)) result) (error "vmnjmpeq:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareEQ v1 c2)) result) (error "vmnjmpeq:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareEQ p1 v2)) result) (error "vmnjmpeq:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareEQ p1 p2)) result) (error "vmnjmpeq:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareEQ p1 c2)) result) (error "vmnjmpeq:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareEQ c1 v2)) result) (error "vmnjmpeq:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareEQ c1 p2)) result) (error "vmnjmpeq:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareEQ c1 c2)) result) (error "vmnjmpeq:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareEQ v1 v2)) result) (error "vmnjmpeq:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareEQ v1 p2)) result) (error "vmnjmpeq:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareEQ v1 c2)) result) (error "vmnjmpeq:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareEQ p1 v2)) result) (error "vmnjmpeq:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareEQ p1 p2)) result) (error "vmnjmpeq:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareEQ p1 c2)) result) (error "vmnjmpeq:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareEQ c1 v2)) result) (error "vmnjmpeq:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareEQ c1 p2)) result) (error "vmnjmpeq:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareEQ c1 c2)) result) (error "vmnjmpeq:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareEQ v1 v2)) result) (error "vmnjmpeq:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareEQ v1 p2)) result) (error "vmnjmpeq:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareEQ v1 c2)) result) (error "vmnjmpeq:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareEQ p1 v2)) result) (error "vmnjmpeq:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareEQ p1 p2)) result) (error "vmnjmpeq:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareEQ p1 c2)) result) (error "vmnjmpeq:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareEQ c1 v2)) result) (error "vmnjmpeq:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareEQ c1 p2)) result) (error "vmnjmpeq:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareEQ c1 c2)) result) (error "vmnjmpeq:c1:c2:cr"))  
        )) ; end vmnjmpeq case        
 
        ;; Test the vmnjmpne instruction  
       ((= testId "vmnjmpne")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareNE  " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareNE v1 v2)) result) (error "vmnjmpne:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareNE v1 p2)) result) (error "vmnjmpne:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareNE v1 c2)) result) (error "vmnjmpne:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareNE p1 v2)) result) (error "vmnjmpne:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareNE p1 p2)) result) (error "vmnjmpne:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareNE p1 c2)) result) (error "vmnjmpne:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareNE c1 v2)) result) (error "vmnjmpne:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareNE c1 p2)) result) (error "vmnjmpne:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareNE c1 c2)) result) (error "vmnjmpne:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareNE v1 v2)) result) (error "vmnjmpne:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareNE v1 p2)) result) (error "vmnjmpne:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareNE v1 c2)) result) (error "vmnjmpne:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareNE p1 v2)) result) (error "vmnjmpne:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareNE p1 p2)) result) (error "vmnjmpne:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareNE p1 c2)) result) (error "vmnjmpne:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareNE c1 v2)) result) (error "vmnjmpne:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareNE c1 p2)) result) (error "vmnjmpne:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareNE c1 c2)) result) (error "vmnjmpne:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareNE v1 v2)) result) (error "vmnjmpne:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareNE v1 p2)) result) (error "vmnjmpne:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareNE v1 c2)) result) (error "vmnjmpne:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareNE p1 v2)) result) (error "vmnjmpne:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareNE p1 p2)) result) (error "vmnjmpne:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareNE p1 c2)) result) (error "vmnjmpne:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareNE c1 v2)) result) (error "vmnjmpne:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareNE c1 p2)) result) (error "vmnjmpne:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareNE c1 c2)) result) (error "vmnjmpne:c1:c2:cr"))  
        )) ; end vmnjmpne case  
              
        ;; Test the vmnjmple instruction  
       ((= testId "vmnjmple")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareLE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareLE v1 v2)) result) (error "vmnjmple:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLE v1 p2)) result) (error "vmnjmple:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareLE v1 c2)) result) (error "vmnjmple:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareLE p1 v2)) result) (error "vmnjmple:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLE p1 p2)) result) (error "vmnjmple:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareLE p1 c2)) result) (error "vmnjmple:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareLE c1 v2)) result) (error "vmnjmple:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareLE c1 p2)) result) (error "vmnjmple:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareLE c1 c2)) result) (error "vmnjmple:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareLE v1 v2)) result) (error "vmnjmple:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareLE v1 p2)) result) (error "vmnjmple:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareLE v1 c2)) result) (error "vmnjmple:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareLE p1 v2)) result) (error "vmnjmple:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareLE p1 p2)) result) (error "vmnjmple:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareLE p1 c2)) result) (error "vmnjmple:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareLE c1 v2)) result) (error "vmnjmple:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareLE c1 p2)) result) (error "vmnjmple:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareLE c1 c2)) result) (error "vmnjmple:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareLE v1 v2)) result) (error "vmnjmple:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareLE v1 p2)) result) (error "vmnjmple:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareLE v1 c2)) result) (error "vmnjmple:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareLE p1 v2)) result) (error "vmnjmple:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareLE p1 p2)) result) (error "vmnjmple:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareLE p1 c2)) result) (error "vmnjmple:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareLE c1 v2)) result) (error "vmnjmple:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareLE c1 p2)) result) (error "vmnjmple:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareLE c1 c2)) result) (error "vmnjmple:c1:c2:cr"))  
        )) ; end vmnjmple case               

        ;; Test the vmijmpge instruction  
       ((= testId "vmnjmpge")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ncompareGE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ncompareGE v1 v2)) result) (error "vmnjmpge:v1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGE v1 p2)) result) (error "vmnjmpge:v1:p2:vr"))  
		   (if (<> (setq vr (ncompareGE v1 c2)) result) (error "vmnjmpge:v1:c2:vr"))  

		   (if (<> (setq vr (ncompareGE p1 v2)) result) (error "vmnjmpge:p1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGE p1 p2)) result) (error "vmnjmpge:p1:p2:vr"))  
		   (if (<> (setq vr (ncompareGE p1 c2)) result) (error "vmnjmpge:p1:c2:vr"))  
             
		   (if (<> (setq vr (ncompareGE c1 v2)) result) (error "vmnjmpge:c1:v2:vr"))  		   
		   (if (<> (setq vr (ncompareGE c1 p2)) result) (error "vmnjmpge:c1:p2:vr"))  		   
		   (if (<> (setq vr (ncompareGE c1 c2)) result) (error "vmnjmpge:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ncompareGE v1 v2)) result) (error "vmnjmpge:v1:v2:pr"))  
		   (if (<> (setq pr (ncompareGE v1 p2)) result) (error "vmnjmpge:v1:p2:pr"))  
		   (if (<> (setq pr (ncompareGE v1 c2)) result) (error "vmnjmpge:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ncompareGE p1 v2)) result) (error "vmnjmpge:p1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareGE p1 p2)) result) (error "vmnjmpge:p1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareGE p1 c2)) result) (error "vmnjmpge:p1:c2:pr"))  
             
		   (if (<> (setq pr (ncompareGE c1 v2)) result) (error "vmnjmpge:c1:v2:pr"))  		   
		   (if (<> (setq pr (ncompareGE c1 p2)) result) (error "vmnjmpge:c1:p2:pr"))  		   
		   (if (<> (setq pr (ncompareGE c1 c2)) result) (error "vmnjmpge:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ncompareGE v1 v2)) result) (error "vmnjmpge:v1:v2:cr"))  
		   (if (<> (setq cr (ncompareGE v1 p2)) result) (error "vmnjmpge:v1:p2:cr"))  
		   (if (<> (setq cr (ncompareGE v1 c2)) result) (error "vmnjmpge:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ncompareGE p1 v2)) result) (error "vmnjmpge:p1:v2:cr"))  		   
		   (if (<> (setq cr (ncompareGE p1 p2)) result) (error "vmnjmpge:p1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareGE p1 c2)) result) (error "vmnjmpge:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ncompareGE c1 v2)) result) (error "vmnjmpge:c1:v2:cr"))  
		   (if (<> (setq cr (ncompareGE c1 p2)) result) (error "vmnjmpge:c1:p2:cr"))  		   
		   (if (<> (setq cr (ncompareGE c1 c2)) result) (error "vmnjmpge:c1:c2:cr"))  
        )) ; end vmnjmpge case               
        
      ) ;; end cond 

    (append "result = " result " vr = " vr)
    ) ;; end selfTest14




;;**EXPORTKEY**:CompilerLib:%SELFTEST15
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest15(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmbjmplt instruction  
       ((= testId "vmbjmplt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareLT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareLT v1 v2)) result) (error "vmbjmplt:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLT v1 p2)) result) (error "vmbjmplt:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareLT v1 c2)) result) (error "vmbjmplt:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareLT p1 v2)) result) (error "vmbjmplt:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLT p1 p2)) result) (error "vmbjmplt:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareLT p1 c2)) result) (error "vmbjmplt:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareLT c1 v2)) result) (error "vmbjmplt:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLT c1 p2)) result) (error "vmbjmplt:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareLT c1 c2)) result) (error "vmbjmplt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareLT v1 v2)) result) (error "vmbjmplt:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareLT v1 p2)) result) (error "vmbjmplt:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareLT v1 c2)) result) (error "vmbjmplt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareLT p1 v2)) result) (error "vmbjmplt:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareLT p1 p2)) result) (error "vmbjmplt:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareLT p1 c2)) result) (error "vmbjmplt:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareLT c1 v2)) result) (error "vmbjmplt:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareLT c1 p2)) result) (error "vmbjmplt:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareLT c1 c2)) result) (error "vmbjmplt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareLT v1 v2)) result) (error "vmbjmplt:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareLT v1 p2)) result) (error "vmbjmplt:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareLT v1 c2)) result) (error "vmbjmplt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareLT p1 v2)) result) (error "vmbjmplt:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareLT p1 p2)) result) (error "vmbjmplt:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareLT p1 c2)) result) (error "vmbjmplt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareLT c1 v2)) result) (error "vmbjmplt:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareLT c1 p2)) result) (error "vmbjmplt:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareLT c1 c2)) result) (error "vmbjmplt:c1:c2:cr"))  
        )) ; end vmbjmplt case 
                  
       ;; Test the vmbjmpgt instruction  
       ((= testId "vmbjmpgt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareGT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareGT v1 v2)) result) (error "vmbjmpgt:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGT v1 p2)) result) (error "vmbjmpgt:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareGT v1 c2)) result) (error "vmbjmpgt:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareGT p1 v2)) result) (error "vmbjmpgt:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGT p1 p2)) result) (error "vmbjmpgt:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareGT p1 c2)) result) (error "vmbjmpgt:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareGT c1 v2)) result) (error "vmbjmpgt:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGT c1 p2)) result) (error "vmbjmpgt:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareGT c1 c2)) result) (error "vmbjmpgt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareGT v1 v2)) result) (error "vmbjmpgt:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareGT v1 p2)) result) (error "vmbjmpgt:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareGT v1 c2)) result) (error "vmbjmpgt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareGT p1 v2)) result) (error "vmbjmpgt:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareGT p1 p2)) result) (error "vmbjmpgt:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareGT p1 c2)) result) (error "vmbjmpgt:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareGT c1 v2)) result) (error "vmbjmpgt:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareGT c1 p2)) result) (error "vmbjmpgt:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareGT c1 c2)) result) (error "vmbjmpgt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareGT v1 v2)) result) (error "vmbjmpgt:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareGT v1 p2)) result) (error "vmbjmpgt:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareGT v1 c2)) result) (error "vmbjmpgt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareGT p1 v2)) result) (error "vmbjmpgt:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareGT p1 p2)) result) (error "vmbjmpgt:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareGT p1 c2)) result) (error "vmbjmpgt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareGT c1 v2)) result) (error "vmbjmpgt:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareGT c1 p2)) result) (error "vmbjmpgt:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareGT c1 c2)) result) (error "vmbjmpgt:c1:c2:cr"))  
        )) ; end vmbjmpgt case        
        
        ;; Test the vmbjmpeq instruction  
       ((= testId "vmbjmpeq")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareEQ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareEQ v1 v2)) result) (error "vmbjmpeq:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareEQ v1 p2)) result) (error "vmbjmpeq:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareEQ v1 c2)) result) (error "vmbjmpeq:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareEQ p1 v2)) result) (error "vmbjmpeq:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareEQ p1 p2)) result) (error "vmbjmpeq:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareEQ p1 c2)) result) (error "vmbjmpeq:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareEQ c1 v2)) result) (error "vmbjmpeq:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareEQ c1 p2)) result) (error "vmbjmpeq:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareEQ c1 c2)) result) (error "vmbjmpeq:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareEQ v1 v2)) result) (error "vmbjmpeq:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareEQ v1 p2)) result) (error "vmbjmpeq:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareEQ v1 c2)) result) (error "vmbjmpeq:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareEQ p1 v2)) result) (error "vmbjmpeq:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareEQ p1 p2)) result) (error "vmbjmpeq:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareEQ p1 c2)) result) (error "vmbjmpeq:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareEQ c1 v2)) result) (error "vmbjmpeq:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareEQ c1 p2)) result) (error "vmbjmpeq:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareEQ c1 c2)) result) (error "vmbjmpeq:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareEQ v1 v2)) result) (error "vmbjmpeq:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareEQ v1 p2)) result) (error "vmbjmpeq:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareEQ v1 c2)) result) (error "vmbjmpeq:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareEQ p1 v2)) result) (error "vmbjmpeq:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareEQ p1 p2)) result) (error "vmbjmpeq:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareEQ p1 c2)) result) (error "vmbjmpeq:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareEQ c1 v2)) result) (error "vmbjmpeq:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareEQ c1 p2)) result) (error "vmbjmpeq:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareEQ c1 c2)) result) (error "vmbjmpeq:c1:c2:cr"))  
        )) ; end vmbjmpeq case        
 
        ;; Test the vmbjmpne instruction  
       ((= testId "vmbjmpne")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareNE  " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareNE v1 v2)) result) (error "vmbjmpne:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareNE v1 p2)) result) (error "vmbjmpne:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareNE v1 c2)) result) (error "vmbjmpne:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareNE p1 v2)) result) (error "vmbjmpne:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareNE p1 p2)) result) (error "vmbjmpne:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareNE p1 c2)) result) (error "vmbjmpne:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareNE c1 v2)) result) (error "vmbjmpne:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareNE c1 p2)) result) (error "vmbjmpne:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareNE c1 c2)) result) (error "vmbjmpne:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareNE v1 v2)) result) (error "vmbjmpne:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareNE v1 p2)) result) (error "vmbjmpne:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareNE v1 c2)) result) (error "vmbjmpne:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareNE p1 v2)) result) (error "vmbjmpne:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareNE p1 p2)) result) (error "vmbjmpne:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareNE p1 c2)) result) (error "vmbjmpne:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareNE c1 v2)) result) (error "vmbjmpne:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareNE c1 p2)) result) (error "vmbjmpne:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareNE c1 c2)) result) (error "vmbjmpne:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareNE v1 v2)) result) (error "vmbjmpne:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareNE v1 p2)) result) (error "vmbjmpne:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareNE v1 c2)) result) (error "vmbjmpne:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareNE p1 v2)) result) (error "vmbjmpne:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareNE p1 p2)) result) (error "vmbjmpne:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareNE p1 c2)) result) (error "vmbjmpne:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareNE c1 v2)) result) (error "vmbjmpne:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareNE c1 p2)) result) (error "vmbjmpne:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareNE c1 c2)) result) (error "vmbjmpne:c1:c2:cr"))  
        )) ; end vmbjmpne case  
              
        ;; Test the vmbjmple instruction  
       ((= testId "vmbjmple")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareLE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareLE v1 v2)) result) (error "vmbjmple:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLE v1 p2)) result) (error "vmbjmple:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareLE v1 c2)) result) (error "vmbjmple:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareLE p1 v2)) result) (error "vmbjmple:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLE p1 p2)) result) (error "vmbjmple:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareLE p1 c2)) result) (error "vmbjmple:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareLE c1 v2)) result) (error "vmbjmple:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareLE c1 p2)) result) (error "vmbjmple:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareLE c1 c2)) result) (error "vmbjmple:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareLE v1 v2)) result) (error "vmbjmple:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareLE v1 p2)) result) (error "vmbjmple:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareLE v1 c2)) result) (error "vmbjmple:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareLE p1 v2)) result) (error "vmbjmple:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareLE p1 p2)) result) (error "vmbjmple:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareLE p1 c2)) result) (error "vmbjmple:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareLE c1 v2)) result) (error "vmbjmple:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareLE c1 p2)) result) (error "vmbjmple:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareLE c1 c2)) result) (error "vmbjmple:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareLE v1 v2)) result) (error "vmbjmple:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareLE v1 p2)) result) (error "vmbjmple:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareLE v1 c2)) result) (error "vmbjmple:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareLE p1 v2)) result) (error "vmbjmple:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareLE p1 p2)) result) (error "vmbjmple:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareLE p1 c2)) result) (error "vmbjmple:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareLE c1 v2)) result) (error "vmbjmple:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareLE c1 p2)) result) (error "vmbjmple:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareLE c1 c2)) result) (error "vmbjmple:c1:c2:cr"))  
        )) ; end vmbjmple case               

        ;; Test the vmbjmpge instruction  
       ((= testId "vmbjmpge")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bcompareGE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bcompareGE v1 v2)) result) (error "vmbjmpge:v1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGE v1 p2)) result) (error "vmbjmpge:v1:p2:vr"))  
		   (if (<> (setq vr (bcompareGE v1 c2)) result) (error "vmbjmpge:v1:c2:vr"))  

		   (if (<> (setq vr (bcompareGE p1 v2)) result) (error "vmbjmpge:p1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGE p1 p2)) result) (error "vmbjmpge:p1:p2:vr"))  
		   (if (<> (setq vr (bcompareGE p1 c2)) result) (error "vmbjmpge:p1:c2:vr"))  
             
		   (if (<> (setq vr (bcompareGE c1 v2)) result) (error "vmbjmpge:c1:v2:vr"))  		   
		   (if (<> (setq vr (bcompareGE c1 p2)) result) (error "vmbjmpge:c1:p2:vr"))  		   
		   (if (<> (setq vr (bcompareGE c1 c2)) result) (error "vmbjmpge:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bcompareGE v1 v2)) result) (error "vmbjmpge:v1:v2:pr"))  
		   (if (<> (setq pr (bcompareGE v1 p2)) result) (error "vmbjmpge:v1:p2:pr"))  
		   (if (<> (setq pr (bcompareGE v1 c2)) result) (error "vmbjmpge:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bcompareGE p1 v2)) result) (error "vmbjmpge:p1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareGE p1 p2)) result) (error "vmbjmpge:p1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareGE p1 c2)) result) (error "vmbjmpge:p1:c2:pr"))  
             
		   (if (<> (setq pr (bcompareGE c1 v2)) result) (error "vmbjmpge:c1:v2:pr"))  		   
		   (if (<> (setq pr (bcompareGE c1 p2)) result) (error "vmbjmpge:c1:p2:pr"))  		   
		   (if (<> (setq pr (bcompareGE c1 c2)) result) (error "vmbjmpge:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bcompareGE v1 v2)) result) (error "vmbjmpge:v1:v2:cr"))  
		   (if (<> (setq cr (bcompareGE v1 p2)) result) (error "vmbjmpge:v1:p2:cr"))  
		   (if (<> (setq cr (bcompareGE v1 c2)) result) (error "vmbjmpge:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bcompareGE p1 v2)) result) (error "vmbjmpge:p1:v2:cr"))  		   
		   (if (<> (setq cr (bcompareGE p1 p2)) result) (error "vmbjmpge:p1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareGE p1 c2)) result) (error "vmbjmpge:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bcompareGE c1 v2)) result) (error "vmbjmpge:c1:v2:cr"))  
		   (if (<> (setq cr (bcompareGE c1 p2)) result) (error "vmbjmpge:c1:p2:cr"))  		   
		   (if (<> (setq cr (bcompareGE c1 c2)) result) (error "vmbjmpge:c1:c2:cr"))  
        )) ; end vmbjmpge case               
      ) ;; end cond 

    (append "result = " result " vr = " vr)
    ) ;; end selfTest15




;;**EXPORTKEY**:CompilerLib:%SELFTEST16
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest16(testId ...) 
   vars:(v1 v2 vr result)  
   pvars:(p1 p2 pr)  
   cvars:(c1 c2 cr)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmcjmplt instruction  
       ((= testId "vmcjmplt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareLT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareLT v1 v2)) result) (error "vmcjmplt:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLT v1 p2)) result) (error "vmcjmplt:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareLT v1 c2)) result) (error "vmcjmplt:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareLT p1 v2)) result) (error "vmcjmplt:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLT p1 p2)) result) (error "vmcjmplt:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareLT p1 c2)) result) (error "vmcjmplt:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareLT c1 v2)) result) (error "vmcjmplt:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLT c1 p2)) result) (error "vmcjmplt:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareLT c1 c2)) result) (error "vmcjmplt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareLT v1 v2)) result) (error "vmcjmplt:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareLT v1 p2)) result) (error "vmcjmplt:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareLT v1 c2)) result) (error "vmcjmplt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareLT p1 v2)) result) (error "vmcjmplt:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareLT p1 p2)) result) (error "vmcjmplt:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareLT p1 c2)) result) (error "vmcjmplt:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareLT c1 v2)) result) (error "vmcjmplt:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareLT c1 p2)) result) (error "vmcjmplt:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareLT c1 c2)) result) (error "vmcjmplt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareLT v1 v2)) result) (error "vmcjmplt:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareLT v1 p2)) result) (error "vmcjmplt:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareLT v1 c2)) result) (error "vmcjmplt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareLT p1 v2)) result) (error "vmcjmplt:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareLT p1 p2)) result) (error "vmcjmplt:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareLT p1 c2)) result) (error "vmcjmplt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareLT c1 v2)) result) (error "vmcjmplt:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareLT c1 p2)) result) (error "vmcjmplt:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareLT c1 c2)) result) (error "vmcjmplt:c1:c2:cr"))  
        )) ; end vmcjmplt case 
                  
       ;; Test the vmcjmpgt instruction  
       ((= testId "vmcjmpgt")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareGT " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareGT v1 v2)) result) (error "vmcjmpgt:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGT v1 p2)) result) (error "vmcjmpgt:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareGT v1 c2)) result) (error "vmcjmpgt:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareGT p1 v2)) result) (error "vmcjmpgt:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGT p1 p2)) result) (error "vmcjmpgt:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareGT p1 c2)) result) (error "vmcjmpgt:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareGT c1 v2)) result) (error "vmcjmpgt:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGT c1 p2)) result) (error "vmcjmpgt:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareGT c1 c2)) result) (error "vmcjmpgt:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareGT v1 v2)) result) (error "vmcjmpgt:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareGT v1 p2)) result) (error "vmcjmpgt:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareGT v1 c2)) result) (error "vmcjmpgt:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareGT p1 v2)) result) (error "vmcjmpgt:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareGT p1 p2)) result) (error "vmcjmpgt:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareGT p1 c2)) result) (error "vmcjmpgt:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareGT c1 v2)) result) (error "vmcjmpgt:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareGT c1 p2)) result) (error "vmcjmpgt:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareGT c1 c2)) result) (error "vmcjmpgt:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareGT v1 v2)) result) (error "vmcjmpgt:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareGT v1 p2)) result) (error "vmcjmpgt:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareGT v1 c2)) result) (error "vmcjmpgt:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareGT p1 v2)) result) (error "vmcjmpgt:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareGT p1 p2)) result) (error "vmcjmpgt:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareGT p1 c2)) result) (error "vmcjmpgt:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareGT c1 v2)) result) (error "vmcjmpgt:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareGT c1 p2)) result) (error "vmcjmpgt:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareGT c1 c2)) result) (error "vmcjmpgt:c1:c2:cr"))  
        )) ; end vmcjmpgt case        
        
        ;; Test the vmcjmpeq instruction  
       ((= testId "vmcjmpeq")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareEQ " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareEQ v1 v2)) result) (error "vmcjmpeq:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareEQ v1 p2)) result) (error "vmcjmpeq:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareEQ v1 c2)) result) (error "vmcjmpeq:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareEQ p1 v2)) result) (error "vmcjmpeq:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareEQ p1 p2)) result) (error "vmcjmpeq:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareEQ p1 c2)) result) (error "vmcjmpeq:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareEQ c1 v2)) result) (error "vmcjmpeq:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareEQ c1 p2)) result) (error "vmcjmpeq:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareEQ c1 c2)) result) (error "vmcjmpeq:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareEQ v1 v2)) result) (error "vmcjmpeq:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareEQ v1 p2)) result) (error "vmcjmpeq:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareEQ v1 c2)) result) (error "vmcjmpeq:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareEQ p1 v2)) result) (error "vmcjmpeq:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareEQ p1 p2)) result) (error "vmcjmpeq:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareEQ p1 c2)) result) (error "vmcjmpeq:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareEQ c1 v2)) result) (error "vmcjmpeq:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareEQ c1 p2)) result) (error "vmcjmpeq:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareEQ c1 c2)) result) (error "vmcjmpeq:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareEQ v1 v2)) result) (error "vmcjmpeq:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareEQ v1 p2)) result) (error "vmcjmpeq:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareEQ v1 c2)) result) (error "vmcjmpeq:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareEQ p1 v2)) result) (error "vmcjmpeq:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareEQ p1 p2)) result) (error "vmcjmpeq:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareEQ p1 c2)) result) (error "vmcjmpeq:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareEQ c1 v2)) result) (error "vmcjmpeq:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareEQ c1 p2)) result) (error "vmcjmpeq:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareEQ c1 c2)) result) (error "vmcjmpeq:c1:c2:cr"))  
        )) ; end vmcjmpeq case        
 
        ;; Test the vmcjmpne instruction  
       ((= testId "vmcjmpne")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareNE  " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareNE v1 v2)) result) (error "vmcjmpne:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareNE v1 p2)) result) (error "vmcjmpne:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareNE v1 c2)) result) (error "vmcjmpne:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareNE p1 v2)) result) (error "vmcjmpne:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareNE p1 p2)) result) (error "vmcjmpne:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareNE p1 c2)) result) (error "vmcjmpne:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareNE c1 v2)) result) (error "vmcjmpne:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareNE c1 p2)) result) (error "vmcjmpne:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareNE c1 c2)) result) (error "vmcjmpne:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareNE v1 v2)) result) (error "vmcjmpne:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareNE v1 p2)) result) (error "vmcjmpne:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareNE v1 c2)) result) (error "vmcjmpne:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareNE p1 v2)) result) (error "vmcjmpne:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareNE p1 p2)) result) (error "vmcjmpne:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareNE p1 c2)) result) (error "vmcjmpne:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareNE c1 v2)) result) (error "vmcjmpne:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareNE c1 p2)) result) (error "vmcjmpne:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareNE c1 c2)) result) (error "vmcjmpne:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareNE v1 v2)) result) (error "vmcjmpne:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareNE v1 p2)) result) (error "vmcjmpne:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareNE v1 c2)) result) (error "vmcjmpne:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareNE p1 v2)) result) (error "vmcjmpne:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareNE p1 p2)) result) (error "vmcjmpne:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareNE p1 c2)) result) (error "vmcjmpne:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareNE c1 v2)) result) (error "vmcjmpne:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareNE c1 p2)) result) (error "vmcjmpne:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareNE c1 c2)) result) (error "vmcjmpne:c1:c2:cr"))  
        )) ; end vmcjmpne case  
              
        ;; Test the vmcjmple instruction  
       ((= testId "vmcjmple")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareLE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareLE v1 v2)) result) (error "vmcjmple:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLE v1 p2)) result) (error "vmcjmple:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareLE v1 c2)) result) (error "vmcjmple:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareLE p1 v2)) result) (error "vmcjmple:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLE p1 p2)) result) (error "vmcjmple:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareLE p1 c2)) result) (error "vmcjmple:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareLE c1 v2)) result) (error "vmcjmple:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareLE c1 p2)) result) (error "vmcjmple:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareLE c1 c2)) result) (error "vmcjmple:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareLE v1 v2)) result) (error "vmcjmple:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareLE v1 p2)) result) (error "vmcjmple:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareLE v1 c2)) result) (error "vmcjmple:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareLE p1 v2)) result) (error "vmcjmple:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareLE p1 p2)) result) (error "vmcjmple:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareLE p1 c2)) result) (error "vmcjmple:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareLE c1 v2)) result) (error "vmcjmple:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareLE c1 p2)) result) (error "vmcjmple:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareLE c1 c2)) result) (error "vmcjmple:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareLE v1 v2)) result) (error "vmcjmple:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareLE v1 p2)) result) (error "vmcjmple:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareLE v1 c2)) result) (error "vmcjmple:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareLE p1 v2)) result) (error "vmcjmple:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareLE p1 p2)) result) (error "vmcjmple:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareLE p1 c2)) result) (error "vmcjmple:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareLE c1 v2)) result) (error "vmcjmple:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareLE c1 p2)) result) (error "vmcjmple:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareLE c1 c2)) result) (error "vmcjmple:c1:c2:cr"))  
        )) ; end vmcjmple case               

        ;; Test the vmcjmpge instruction  
       ((= testId "vmcjmpge")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ccompareGE " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ccompareGE v1 v2)) result) (error "vmcjmpge:v1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGE v1 p2)) result) (error "vmcjmpge:v1:p2:vr"))  
		   (if (<> (setq vr (ccompareGE v1 c2)) result) (error "vmcjmpge:v1:c2:vr"))  

		   (if (<> (setq vr (ccompareGE p1 v2)) result) (error "vmcjmpge:p1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGE p1 p2)) result) (error "vmcjmpge:p1:p2:vr"))  
		   (if (<> (setq vr (ccompareGE p1 c2)) result) (error "vmcjmpge:p1:c2:vr"))  
             
		   (if (<> (setq vr (ccompareGE c1 v2)) result) (error "vmcjmpge:c1:v2:vr"))  		   
		   (if (<> (setq vr (ccompareGE c1 p2)) result) (error "vmcjmpge:c1:p2:vr"))  		   
		   (if (<> (setq vr (ccompareGE c1 c2)) result) (error "vmcjmpge:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ccompareGE v1 v2)) result) (error "vmcjmpge:v1:v2:pr"))  
		   (if (<> (setq pr (ccompareGE v1 p2)) result) (error "vmcjmpge:v1:p2:pr"))  
		   (if (<> (setq pr (ccompareGE v1 c2)) result) (error "vmcjmpge:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ccompareGE p1 v2)) result) (error "vmcjmpge:p1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareGE p1 p2)) result) (error "vmcjmpge:p1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareGE p1 c2)) result) (error "vmcjmpge:p1:c2:pr"))  
             
		   (if (<> (setq pr (ccompareGE c1 v2)) result) (error "vmcjmpge:c1:v2:pr"))  		   
		   (if (<> (setq pr (ccompareGE c1 p2)) result) (error "vmcjmpge:c1:p2:pr"))  		   
		   (if (<> (setq pr (ccompareGE c1 c2)) result) (error "vmcjmpge:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ccompareGE v1 v2)) result) (error "vmcjmpge:v1:v2:cr"))  
		   (if (<> (setq cr (ccompareGE v1 p2)) result) (error "vmcjmpge:v1:p2:cr"))  
		   (if (<> (setq cr (ccompareGE v1 c2)) result) (error "vmcjmpge:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ccompareGE p1 v2)) result) (error "vmcjmpge:p1:v2:cr"))  		   
		   (if (<> (setq cr (ccompareGE p1 p2)) result) (error "vmcjmpge:p1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareGE p1 c2)) result) (error "vmcjmpge:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ccompareGE c1 v2)) result) (error "vmcjmpge:c1:v2:cr"))  
		   (if (<> (setq cr (ccompareGE c1 p2)) result) (error "vmcjmpge:c1:p2:cr"))  		   
		   (if (<> (setq cr (ccompareGE c1 c2)) result) (error "vmcjmpge:c1:c2:cr"))  
        )) ; end vmcjmpge case               
      ) ;; end cond 

    (append "result = " result " vr = " vr)
    ) ;; end selfTest16




;;**EXPORTKEY**:CompilerLib:%SELFTEST2
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest2 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest2(testId ...) 
   vars: (v1 v2 vr result vintvec vnumvec vbytevec vfltvec vbitvec vvec) 
   pvars:(p1 p2 pr pintvec pnumvec pbytevec pfltvec pbitvec pvec)  
   cvars:(c1 c2 cr cintvec cnumvec cbytevec cfltvec cbitvec cvec)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmrefIntVector instruction  
                   
        ((= testId "vmrefIntVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vintvec (setq cintvec (setq pintvec (new Vector: integer: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refIntVector " vintvec " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refIntVector vintvec v1)) result) (error "refIntVector:vintvec:v1:vr"))  		   
   		 (if (<> (setq vr (refIntVector vintvec p1)) result) (error "refIntVector:vintvec:p1:vr"))  		   
   		 (if (<> (setq vr (refIntVector vintvec c1)) result) (error "refIntVector:vintvec:c1:vr"))  		   

   		 (if (<> (setq pr (refIntVector vintvec v1)) result) (error "refIntVector:vintvec:v1:vr"))  		   
   		 (if (<> (setq pr (refIntVector vintvec p1)) result) (error "refIntVector:vintvec:p1:vr"))  		   
   		 (if (<> (setq pr (refIntVector vintvec c1)) result) (error "refIntVector:vintvec:c1:vr"))  		   

    	 (if (<> (setq cr (refIntVector vintvec v1)) result) (error "refIntVector:vintvec:v1:vr"))  		   
   		 (if (<> (setq cr (refIntVector vintvec p1)) result) (error "refIntVector:vintvec:p1:vr"))  		   
   		 (if (<> (setq cr (refIntVector vintvec c1)) result) (error "refIntVector:vintvec:c1:vr")) 
     	 
     	 (if (<> (setq vr (refIntVector pintvec v1)) result) (error "refIntVector:pintvec:v1:vr"))  		   
   		 (if (<> (setq vr (refIntVector pintvec p1)) result) (error "refIntVector:pintvec:p1:vr"))  		   
   		 (if (<> (setq vr (refIntVector pintvec c1)) result) (error "refIntVector:pintvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refIntVector pintvec v1)) result) (error "refIntVector:pintvec:v1:vr"))  		   
   		 (if (<> (setq pr (refIntVector pintvec p1)) result) (error "refIntVector:pintvec:p1:vr"))  		   
   		 (if (<> (setq pr (refIntVector pintvec c1)) result) (error "refIntVector:pintvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refIntVector pintvec v1)) result) (error "refIntVector:pintvec:v1:vr"))  		   
   		 (if (<> (setq cr (refIntVector pintvec p1)) result) (error "refIntVector:pintvec:p1:vr"))  		   
   		 (if (<> (setq cr (refIntVector pintvec c1)) result) (error "refIntVector:pintvec:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refIntVector cintvec v1)) result) (error "refIntVector:cintvec:v1:vr"))  		   
   		 (if (<> (setq vr (refIntVector cintvec p1)) result) (error "refIntVector:cintvec:p1:vr"))  		   
   		 (if (<> (setq vr (refIntVector cintvec c1)) result) (error "refIntVector:cintvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refIntVector cintvec v1)) result) (error "refIntVector:cintvec:v1:vr"))  		   
   		 (if (<> (setq pr (refIntVector cintvec p1)) result) (error "refIntVector:cintvec:p1:vr"))  		   
   		 (if (<> (setq pr (refIntVector cintvec c1)) result) (error "refIntVector:cintvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refIntVector cintvec v1)) result) (error "refIntVector:cintvec:v1:vr"))  		   
   		 (if (<> (setq cr (refIntVector cintvec p1)) result) (error "refIntVector:cintvec:p1:vr"))  		   
   		 (if (<> (setq cr (refIntVector cintvec c1)) result) (error "refIntVector:cintvec:c1:vr"))
   		  
        )) ; end vmrefIntVector case           
        
         ;; Reference a NumVector          
        ((= testId "vmrefNumVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vnumvec (setq cnumvec (setq pnumvec (new Vector: number: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refNumVector " vnumvec " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refNumVector vnumvec v1)) result) (error "refNumVector:vnumvec:v1:vr"))  		   
   		 (if (<> (setq vr (refNumVector vnumvec p1)) result) (error "refNumVector:vnumvec:p1:vr"))  		   
   		 (if (<> (setq vr (refNumVector vnumvec c1)) result) (error "refNumVector:vnumvec:c1:vr"))  		   

   		 (if (<> (setq pr (refNumVector vnumvec v1)) result) (error "refNumVector:vnumvec:v1:vr"))  		   
   		 (if (<> (setq pr (refNumVector vnumvec p1)) result) (error "refNumVector:vnumvec:p1:vr"))  		   
   		 (if (<> (setq pr (refNumVector vnumvec c1)) result) (error "refNumVector:vnumvec:c1:vr"))  		   

    	 (if (<> (setq cr (refNumVector vnumvec v1)) result) (error "refNumVector:vnumvec:v1:vr"))  		   
   		 (if (<> (setq cr (refNumVector vnumvec p1)) result) (error "refNumVector:vnumvec:p1:vr"))  		   
   		 (if (<> (setq cr (refNumVector vnumvec c1)) result) (error "refNumVector:vnumvec:c1:vr"))  		   

   		 (if (<> (setq vr (refNumVector pnumvec v1)) result) (error "refNumVector:pnumvec:v1:vr"))  		   
   		 (if (<> (setq vr (refNumVector pnumvec p1)) result) (error "refNumVector:pnumvec:p1:vr"))  		   
   		 (if (<> (setq vr (refNumVector pnumvec c1)) result) (error "refNumVector:pnumvec:c1:vr"))  		   

   		 (if (<> (setq pr (refNumVector pnumvec v1)) result) (error "refNumVector:pnumvec:v1:vr"))  		   
   		 (if (<> (setq pr (refNumVector pnumvec p1)) result) (error "refNumVector:pnumvec:p1:vr"))  		   
   		 (if (<> (setq pr (refNumVector pnumvec c1)) result) (error "refNumVector:pnumvec:c1:vr"))  		   

    	 (if (<> (setq cr (refNumVector pnumvec v1)) result) (error "refNumVector:pnumvec:v1:vr"))  		   
   		 (if (<> (setq cr (refNumVector pnumvec p1)) result) (error "refNumVector:pnumvec:p1:vr"))  		   
   		 (if (<> (setq cr (refNumVector pnumvec c1)) result) (error "refNumVector:pnumvec:c1:vr"))  		   

   		 (if (<> (setq vr (refNumVector cnumvec v1)) result) (error "refNumVector:cnumvec:v1:vr"))  		   
   		 (if (<> (setq vr (refNumVector cnumvec p1)) result) (error "refNumVector:cnumvec:p1:vr"))  		   
   		 (if (<> (setq vr (refNumVector cnumvec c1)) result) (error "refNumVector:cnumvec:c1:vr"))  		   

   		 (if (<> (setq pr (refNumVector cnumvec v1)) result) (error "refNumVector:cnumvec:v1:vr"))  		   
   		 (if (<> (setq pr (refNumVector cnumvec p1)) result) (error "refNumVector:cnumvec:p1:vr"))  		   
   		 (if (<> (setq pr (refNumVector cnumvec c1)) result) (error "refNumVector:cnumvec:c1:vr"))  		   

    	 (if (<> (setq cr (refNumVector cnumvec v1)) result) (error "refNumVector:cnumvec:v1:vr"))  		   
   		 (if (<> (setq cr (refNumVector cnumvec p1)) result) (error "refNumVector:cnumvec:p1:vr"))  		   
   		 (if (<> (setq cr (refNumVector cnumvec c1)) result) (error "refNumVector:cnumvec:c1:vr"))  		   
        )) ; end vmrefNumVector case           

          ;; Reference a Vector          
        ((= testId "vmrefVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vvec (setq cvec (setq pvec (new Vector: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refVector " vvec " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refVector vvec v1)) result) (error "refVector:vvec:v1:vr"))  		   
   		 (if (<> (setq vr (refVector vvec p1)) result) (error "refVector:vvec:p1:vr"))  		   
   		 (if (<> (setq vr (refVector vvec c1)) result) (error "refVector:vvec:c1:vr"))  		   

   		 (if (<> (setq pr (refVector vvec v1)) result) (error "refVector:vvec:v1:vr"))  		   
   		 (if (<> (setq pr (refVector vvec p1)) result) (error "refVector:vvec:p1:vr"))  		   
   		 (if (<> (setq pr (refVector vvec c1)) result) (error "refVector:vvec:c1:vr"))  		   

    	 (if (<> (setq cr (refVector vvec v1)) result) (error "refVector:vvec:v1:vr"))  		   
   		 (if (<> (setq cr (refVector vvec p1)) result) (error "refVector:vvec:p1:vr"))  		   
   		 (if (<> (setq cr (refVector vvec c1)) result) (error "refVector:vvec:c1:vr"))  		   

   		 (if (<> (setq vr (refVector pvec v1)) result) (error "refVector:pvec:v1:vr"))  		   
   		 (if (<> (setq vr (refVector pvec p1)) result) (error "refVector:pvec:p1:vr"))  		   
   		 (if (<> (setq vr (refVector pvec c1)) result) (error "refVector:pvec:c1:vr"))  		   

   		 (if (<> (setq pr (refVector pvec v1)) result) (error "refVector:pvec:v1:vr"))  		   
   		 (if (<> (setq pr (refVector pvec p1)) result) (error "refVector:pvec:p1:vr"))  		   
   		 (if (<> (setq pr (refVector pvec c1)) result) (error "refVector:pvec:c1:vr"))  		   

    	 (if (<> (setq cr (refVector pvec v1)) result) (error "refVector:pvec:v1:vr"))  		   
   		 (if (<> (setq cr (refVector pvec p1)) result) (error "refVector:pvec:p1:vr"))  		   
   		 (if (<> (setq cr (refVector pvec c1)) result) (error "refVector:pvec:c1:vr"))  		   
 
    	 (if (<> (setq vr (refVector cvec v1)) result) (error "refVector:cvec:v1:vr"))  		   
   		 (if (<> (setq vr (refVector cvec p1)) result) (error "refVector:cvec:p1:vr"))  		   
   		 (if (<> (setq vr (refVector cvec c1)) result) (error "refVector:cvec:c1:vr"))  		   

   		 (if (<> (setq pr (refVector cvec v1)) result) (error "refVector:cvec:v1:vr"))  		   
   		 (if (<> (setq pr (refVector cvec p1)) result) (error "refVector:cvec:p1:vr"))  		   
   		 (if (<> (setq pr (refVector cvec c1)) result) (error "refVector:cvec:c1:vr"))  		   

    	 (if (<> (setq cr (refVector cvec v1)) result) (error "refVector:cvec:v1:vr"))  		   
   		 (if (<> (setq cr (refVector cvec p1)) result) (error "refVector:cvec:p1:vr"))  		   
   		 (if (<> (setq cr (refVector cvec c1)) result) (error "refVector:cvec:c1:vr"))  		   

        )) ; end vmrefVector case           
    
          ;; Reference a Byte Vector          
        ((= testId "vmrefBytVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vbytevec (setq cbytevec (setq pbytevec (new Vector: byte: 6 #\H #\e #\l #\l #\o 0))))
         
         ;; Use the emulator to compute the correct result.                      
         (setq result (inspect vbytevec))         
         (setq result (eval (append "(refBytVector #<ByteVector " result ">"  v1 ")")))
                  
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refBytVector  vbytevec v1)) result) (error "refBytVector :vbytevec:v1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  vbytevec p1)) result) (error "refBytVector :vbytevec:p1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  vbytevec c1)) result) (error "refBytVector :vbytevec:c1:vr"))  		   

   		 (if (<> (setq pr (refBytVector  vbytevec v1)) result) (error "refBytVector :vbytevec:v1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  vbytevec p1)) result) (error "refBytVector :vbytevec:p1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  vbytevec c1)) result) (error "refBytVector :vbytevec:c1:vr"))  		   

    	 (if (<> (setq cr (refBytVector  vbytevec v1)) result) (error "refBytVector :vbytevec:v1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  vbytevec p1)) result) (error "refBytVector :vbytevec:p1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  vbytevec c1)) result) (error "refBytVector :vbytevec:c1:vr"))  		   

   		 (if (<> (setq vr (refBytVector  pbytevec v1)) result) (error "refBytVector :pbytevec:v1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  pbytevec p1)) result) (error "refBytVector :pbytevec:p1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  pbytevec c1)) result) (error "refBytVector :pbytevec:c1:vr"))  		   

   		 (if (<> (setq pr (refBytVector  pbytevec v1)) result) (error "refBytVector :pbytevec:v1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  pbytevec p1)) result) (error "refBytVector :pbytevec:p1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  pbytevec c1)) result) (error "refBytVector :pbytevec:c1:vr"))  		   

    	 (if (<> (setq cr (refBytVector  pbytevec v1)) result) (error "refBytVector :pbytevec:v1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  pbytevec p1)) result) (error "refBytVector :pbytevec:p1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  pbytevec c1)) result) (error "refBytVector :pbytevec:c1:vr"))  		   
 
    	 (if (<> (setq vr (refBytVector  cbytevec v1)) result) (error "refBytVector :cbytevec:v1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  cbytevec p1)) result) (error "refBytVector :cbytevec:p1:vr"))  		   
   		 (if (<> (setq vr (refBytVector  cbytevec c1)) result) (error "refBytVector :cbytevec:c1:vr"))  		   

   		 (if (<> (setq pr (refBytVector  cbytevec v1)) result) (error "refBytVector :cbytevec:v1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  cbytevec p1)) result) (error "refBytVector :cbytevec:p1:vr"))  		   
   		 (if (<> (setq pr (refBytVector  cbytevec c1)) result) (error "refBytVector :cbytevec:c1:vr"))  		   

    	 (if (<> (setq cr (refBytVector  cbytevec v1)) result) (error "refBytVector :cbytevec:v1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  cbytevec p1)) result) (error "refBytVector :cbytevec:p1:vr"))  		   
   		 (if (<> (setq cr (refBytVector  cbytevec c1)) result) (error "refBytVector :cbytevec:c1:vr"))  		   

        )) ; end vmrefByteVector case           
  
          ;; Reference a float Vector  
          
        ((= testId "vmrefFltVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vfltvec (setq cfltvec (setq pfltvec (new Vector: float: 5 1.1 2.2 3.3 4.4 5.5))))
         ;; Use the emulator to compute the correct result.       
               
         (setq result (eval (append "(refFltVector " vfltvec " "  v1 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refFltVector  vfltvec v1)) result) (error "refFltVector :vfltvec:v1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  vfltvec p1)) result) (error "refFltVector :vfltvec:p1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  vfltvec c1)) result) (error "refFltVector :vfltvec:c1:vr"))  		   

   		 (if (<> (setq pr (refFltVector  vfltvec v1)) result) (error "refFltVector :vfltvec:v1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  vfltvec p1)) result) (error "refFltVector :vfltvec:p1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  vfltvec c1)) result) (error "refFltVector :vfltvec:c1:vr"))  		   

    	 (if (<> (setq cr (refFltVector  vfltvec v1)) result) (error "refFltVector :vfltvec:v1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  vfltvec p1)) result) (error "refFltVector :vfltvec:p1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  vfltvec c1)) result) (error "refFltVector :vfltvec:c1:vr"))  		   

   		 (if (<> (setq vr (refFltVector  pfltvec v1)) result) (error "refFltVector :pfltvec:v1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  pfltvec p1)) result) (error "refFltVector :pfltvec:p1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  pfltvec c1)) result) (error "refFltVector :pfltvec:c1:vr"))  		   

   		 (if (<> (setq pr (refFltVector  pfltvec v1)) result) (error "refFltVector :pfltvec:v1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  pfltvec p1)) result) (error "refFltVector :pfltvec:p1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  pfltvec c1)) result) (error "refFltVector :pfltvec:c1:vr"))  		   

    	 (if (<> (setq cr (refFltVector  pfltvec v1)) result) (error "refFltVector :pfltvec:v1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  pfltvec p1)) result) (error "refFltVector :pfltvec:p1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  pfltvec c1)) result) (error "refFltVector :pfltvec:c1:vr"))  		   
 
    	 (if (<> (setq vr (refFltVector  cfltvec v1)) result) (error "refFltVector :cfltvec:v1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  cfltvec p1)) result) (error "refFltVector :cfltvec:p1:vr"))  		   
   		 (if (<> (setq vr (refFltVector  cfltvec c1)) result) (error "refFltVector :cfltvec:c1:vr"))  		   

   		 (if (<> (setq pr (refFltVector  cfltvec v1)) result) (error "refFltVector :cfltvec:v1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  cfltvec p1)) result) (error "refFltVector :cfltvec:p1:vr"))  		   
   		 (if (<> (setq pr (refFltVector  cfltvec c1)) result) (error "refFltVector :cfltvec:c1:vr"))  		   

    	 (if (<> (setq cr (refFltVector  cfltvec v1)) result) (error "refFltVector :cfltvec:v1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  cfltvec p1)) result) (error "refFltVector :cfltvec:p1:vr"))  		   
   		 (if (<> (setq cr (refFltVector  cfltvec c1)) result) (error "refFltVector :cfltvec:c1:vr"))  		   

        )) ; end vmrefFltVector case           
  
          ;; Reference a bit Vector  

        ((= testId "vmrefBitVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vbitvec (setq cbitvec (setq pbitvec (new Vector: bit: 4 1 0 1 0))))
         ;; Use the emulator to compute the correct result.       
               
         (setq result (eval (append "(refBitVector " vbitvec " "  v1 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refBitVector  vbitvec v1)) result) (error "refBitVector :vbitvec:v1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  vbitvec p1)) result) (error "refBitVector :vbitvec:p1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  vbitvec c1)) result) (error "refBitVector :vbitvec:c1:vr"))  		   

   		 (if (<> (setq pr (refBitVector  vbitvec v1)) result) (error "refBitVector :vbitvec:v1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  vbitvec p1)) result) (error "refBitVector :vbitvec:p1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  vbitvec c1)) result) (error "refBitVector :vbitvec:c1:vr"))  		   

    	 (if (<> (setq cr (refBitVector  vbitvec v1)) result) (error "refBitVector :vbitvec:v1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  vbitvec p1)) result) (error "refBitVector :vbitvec:p1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  vbitvec c1)) result) (error "refBitVector :vbitvec:c1:vr"))  		   

   		 (if (<> (setq vr (refBitVector  pbitvec v1)) result) (error "refBitVector :pbitvec:v1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  pbitvec p1)) result) (error "refBitVector :pbitvec:p1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  pbitvec c1)) result) (error "refBitVector :pbitvec:c1:vr"))  		   

   		 (if (<> (setq pr (refBitVector  pbitvec v1)) result) (error "refBitVector :pbitvec:v1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  pbitvec p1)) result) (error "refBitVector :pbitvec:p1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  pbitvec c1)) result) (error "refBitVector :pbitvec:c1:vr"))  		   

    	 (if (<> (setq cr (refBitVector  pbitvec v1)) result) (error "refBitVector :pbitvec:v1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  pbitvec p1)) result) (error "refBitVector :pbitvec:p1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  pbitvec c1)) result) (error "refBitVector :pbitvec:c1:vr"))  		   
 
    	 (if (<> (setq vr (refBitVector  cbitvec v1)) result) (error "refBitVector :cbitvec:v1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  cbitvec p1)) result) (error "refBitVector :cbitvec:p1:vr"))  		   
   		 (if (<> (setq vr (refBitVector  cbitvec c1)) result) (error "refBitVector :cbitvec:c1:vr"))  		   

   		 (if (<> (setq pr (refBitVector  cbitvec v1)) result) (error "refBitVector :cbitvec:v1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  cbitvec p1)) result) (error "refBitVector :cbitvec:p1:vr"))  		   
   		 (if (<> (setq pr (refBitVector  cbitvec c1)) result) (error "refBitVector :cbitvec:c1:vr"))  		   

    	 (if (<> (setq cr (refBitVector  cbitvec v1)) result) (error "refBitVector :cbitvec:v1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  cbitvec p1)) result) (error "refBitVector :cbitvec:p1:vr"))  		   
   		 (if (<> (setq cr (refBitVector  cbitvec c1)) result) (error "refBitVector :cbitvec:c1:vr"))  		   

        )) ; end vmrefBitVector case           
 
       ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest




;;**EXPORTKEY**:CompilerLib:%SELFTEST3
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest3 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest3(testId ...) 
   vars: (v1 v2 vr result vobjvec vpcdvec vtext vsym vstring) 
   pvars:(p1 p2 pr pobjvec ppcdvec ptext psym pstring )  
   cvars:(c1 c2 cr cobjvec cpcdvec ctext csym cstring ) 
    
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmrefText instruction  
                          
        ((= testId "vmrefText")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vtext (setq ctext (setq ptext "Hello")))
         ;; Use the emulator to compute the correct result.
         ;; (setq result (eval (append "(refText " vtext " "  v1 ")"))) 
         
          ;; Use the emulator to compute the correct result.                      
         (setq result (eval (append "(refText " (char 34)  vtext (char 34) " "  v1 ")")))
                
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refText vtext v1)) result) (error "refText:vtext:v1:vr"))  		   
   		 (if (<> (setq vr (refText vtext p1)) result) (error "refText:vtext:p1:vr"))  		   
   		 (if (<> (setq vr (refText vtext c1)) result) (error "refText:vtext:c1:vr"))  		   

   		 (if (<> (setq pr (refText vtext v1)) result) (error "refText:vtext:v1:vr"))  		   
   		 (if (<> (setq pr (refText vtext p1)) result) (error "refText:vtext:p1:vr"))  		   
   		 (if (<> (setq pr (refText vtext c1)) result) (error "refText:vtext:c1:vr"))  		   

    	 (if (<> (setq cr (refText vtext v1)) result) (error "refText:vtext:v1:vr"))  		   
   		 (if (<> (setq cr (refText vtext p1)) result) (error "refText:vtext:p1:vr"))  		   
   		 (if (<> (setq cr (refText vtext c1)) result) (error "refText:vtext:c1:vr")) 
     	 
     	 (if (<> (setq vr (refText ptext v1)) result) (error "refText:ptext:v1:vr"))  		   
   		 (if (<> (setq vr (refText ptext p1)) result) (error "refText:ptext:p1:vr"))  		   
   		 (if (<> (setq vr (refText ptext c1)) result) (error "refText:ptext:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refText ptext v1)) result) (error "refText:ptext:v1:vr"))  		   
   		 (if (<> (setq pr (refText ptext p1)) result) (error "refText:ptext:p1:vr"))  		   
   		 (if (<> (setq pr (refText ptext c1)) result) (error "refText:ptext:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refText ptext v1)) result) (error "refText:ptext:v1:vr"))  		   
   		 (if (<> (setq cr (refText ptext p1)) result) (error "refText:ptext:p1:vr"))  		   
   		 (if (<> (setq cr (refText ptext c1)) result) (error "refText:ptext:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refText ctext v1)) result) (error "refText:ctext:v1:vr"))  		   
   		 (if (<> (setq vr (refText ctext p1)) result) (error "refText:ctext:p1:vr"))  		   
   		 (if (<> (setq vr (refText ctext c1)) result) (error "refText:ctext:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refText ctext v1)) result) (error "refText:ctext:v1:vr"))  		   
   		 (if (<> (setq pr (refText ctext p1)) result) (error "refText:ctext:p1:vr"))  		   
   		 (if (<> (setq pr (refText ctext c1)) result) (error "refText:ctext:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refText ctext v1)) result) (error "refText:ctext:v1:vr"))  		   
   		 (if (<> (setq cr (refText ctext p1)) result) (error "refText:ctext:p1:vr"))  		   
   		 (if (<> (setq cr (refText ctext c1)) result) (error "refText:ctext:c1:vr"))
   		  
        )) ; end vmrefText case           
      
      ;; Test the vmrefSymbol instruction
        
        ((= testId "vmrefSymbol")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vsym (setq csym (setq psym Hello:)))
       
         ;; Use the emulator to compute the correct result.                      
         (setq result (inspect vsym))         
         (setq result (eval (append "(refSymbol #<Symbol " result ">"  v1 ")")))
           
        ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refSymbol vsym v1)) result) (error "refSymbol:vsym:v1:vr"))  		   
   		 (if (<> (setq vr (refSymbol vsym p1)) result) (error "refSymbol:vsym:p1:vr"))  		   
   		 (if (<> (setq vr (refSymbol vsym c1)) result) (error "refSymbol:vsym:c1:vr"))  		   

   		 (if (<> (setq pr (refSymbol vsym v1)) result) (error "refSymbol:vsym:v1:vr"))  		   
   		 (if (<> (setq pr (refSymbol vsym p1)) result) (error "refSymbol:vsym:p1:vr"))  		   
   		 (if (<> (setq pr (refSymbol vsym c1)) result) (error "refSymbol:vsym:c1:vr"))  		   

    	 (if (<> (setq cr (refSymbol vsym v1)) result) (error "refSymbol:vsym:v1:vr"))  		   
   		 (if (<> (setq cr (refSymbol vsym p1)) result) (error "refSymbol:vsym:p1:vr"))  		   
   		 (if (<> (setq cr (refSymbol vsym c1)) result) (error "refSymbol:vsym:c1:vr")) 
     	 
     	 (if (<> (setq vr (refSymbol psym v1)) result) (error "refSymbol:psym:v1:vr"))  		   
   		 (if (<> (setq vr (refSymbol psym p1)) result) (error "refSymbol:psym:p1:vr"))  		   
   		 (if (<> (setq vr (refSymbol psym c1)) result) (error "refSymbol:psym:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refSymbol psym v1)) result) (error "refSymbol:psym:v1:vr"))  		   
   		 (if (<> (setq pr (refSymbol psym p1)) result) (error "refSymbol:psym:p1:vr"))  		   
   		 (if (<> (setq pr (refSymbol psym c1)) result) (error "refSymbol:psym:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refSymbol psym v1)) result) (error "refSymbol:psym:v1:vr"))  		   
   		 (if (<> (setq cr (refSymbol psym p1)) result) (error "refSymbol:psym:p1:vr"))  		   
   		 (if (<> (setq cr (refSymbol psym c1)) result) (error "refSymbol:psym:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refSymbol csym v1)) result) (error "refSymbol:csym:v1:vr"))  		   
   		 (if (<> (setq vr (refSymbol csym p1)) result) (error "refSymbol:csym:p1:vr"))  		   
   		 (if (<> (setq vr (refSymbol csym c1)) result) (error "refSymbol:csym:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refSymbol csym v1)) result) (error "refSymbol:csym:v1:vr"))  		   
   		 (if (<> (setq pr (refSymbol csym p1)) result) (error "refSymbol:csym:p1:vr"))  		   
   		 (if (<> (setq pr (refSymbol csym c1)) result) (error "refSymbol:csym:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refSymbol csym v1)) result) (error "refSymbol:csym:v1:vr"))  		   
   		 (if (<> (setq cr (refSymbol csym p1)) result) (error "refSymbol:csym:p1:vr"))  		   
   		 (if (<> (setq cr (refSymbol csym c1)) result) (error "refSymbol:csym:c1:vr"))
   		  
        )) ; end vmrefSymbol case           
   
         ;; Test the vmrefString instruction
     
         ((= testId "vmrefString")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vstring (setq cstring (setq pstring "Hello World!")))
 
         ;; Use the emulator to compute the correct result.
         ;; (setq result (eval (append "(refString " vstring " "  v1 ")"))) 

         ;; Use the emulator to compute the correct result.                      
         (setq result (inspect vstring))         
         (setq result (eval (append "(refString #<" (type vstring) " " result "> "  v1 ")")))
              
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refString vstring v1)) result) (error "refString:vstring:v1:vr"))  		   
   		 (if (<> (setq vr (refString vstring p1)) result) (error "refString:vstring:p1:vr"))  		   
   		 (if (<> (setq vr (refString vstring c1)) result) (error "refString:vstring:c1:vr"))  		   

   		 (if (<> (setq pr (refString vstring v1)) result) (error "refString:vstring:v1:vr"))  		   
   		 (if (<> (setq pr (refString vstring p1)) result) (error "refString:vstring:p1:vr"))  		   
   		 (if (<> (setq pr (refString vstring c1)) result) (error "refString:vstring:c1:vr"))  		   

    	 (if (<> (setq cr (refString vstring v1)) result) (error "refString:vstring:v1:vr"))  		   
   		 (if (<> (setq cr (refString vstring p1)) result) (error "refString:vstring:p1:vr"))  		   
   		 (if (<> (setq cr (refString vstring c1)) result) (error "refString:vstring:c1:vr")) 
     	 
     	 (if (<> (setq vr (refString pstring v1)) result) (error "refString:pstring:v1:vr"))  		   
   		 (if (<> (setq vr (refString pstring p1)) result) (error "refString:pstring:p1:vr"))  		   
   		 (if (<> (setq vr (refString pstring c1)) result) (error "refString:pstring:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refString pstring v1)) result) (error "refString:pstring:v1:vr"))  		   
   		 (if (<> (setq pr (refString pstring p1)) result) (error "refString:pstring:p1:vr"))  		   
   		 (if (<> (setq pr (refString pstring c1)) result) (error "refString:pstring:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refString pstring v1)) result) (error "refString:pstring:v1:vr"))  		   
   		 (if (<> (setq cr (refString pstring p1)) result) (error "refString:pstring:p1:vr"))  		   
   		 (if (<> (setq cr (refString pstring c1)) result) (error "refString:pstring:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refString cstring v1)) result) (error "refString:cstring:v1:vr"))  		   
   		 (if (<> (setq vr (refString cstring p1)) result) (error "refString:cstring:p1:vr"))  		   
   		 (if (<> (setq vr (refString cstring c1)) result) (error "refString:cstring:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refString cstring v1)) result) (error "refString:cstring:v1:vr"))  		   
   		 (if (<> (setq pr (refString cstring p1)) result) (error "refString:cstring:p1:vr"))  		   
   		 (if (<> (setq pr (refString cstring c1)) result) (error "refString:cstring:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refString cstring v1)) result) (error "refString:cstring:v1:vr"))  		   
   		 (if (<> (setq cr (refString cstring p1)) result) (error "refString:cstring:p1:vr"))  		   
   		 (if (<> (setq cr (refString cstring c1)) result) (error "refString:cstring:c1:vr"))
   		  
        )) ; end vmrefString case           
    
       ;; Test the vmrefObjVector instruction

       ((= testId "vmrefObjVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vobjvec (setq cobjvec (setq pobjvec (new Vector: object: 5 H: e: l: l: o:))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refObjVector " vobjvec " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refObjVector vobjvec v1)) result) (error "refObjVector:vobjvec:v1:vr"))  		   
   		 (if (<> (setq vr (refObjVector vobjvec p1)) result) (error "refObjVector:vobjvec:p1:vr"))  		   
   		 (if (<> (setq vr (refObjVector vobjvec c1)) result) (error "refObjVector:vobjvec:c1:vr"))  		   

   		 (if (<> (setq pr (refObjVector vobjvec v1)) result) (error "refObjVector:vobjvec:v1:vr"))  		   
   		 (if (<> (setq pr (refObjVector vobjvec p1)) result) (error "refObjVector:vobjvec:p1:vr"))  		   
   		 (if (<> (setq pr (refObjVector vobjvec c1)) result) (error "refObjVector:vobjvec:c1:vr"))  		   

    	 (if (<> (setq cr (refObjVector vobjvec v1)) result) (error "refObjVector:vobjvec:v1:vr"))  		   
   		 (if (<> (setq cr (refObjVector vobjvec p1)) result) (error "refObjVector:vobjvec:p1:vr"))  		   
   		 (if (<> (setq cr (refObjVector vobjvec c1)) result) (error "refObjVector:vobjvec:c1:vr")) 
     	 
     	 (if (<> (setq vr (refObjVector pobjvec v1)) result) (error "refObjVector:pobjvec:v1:vr"))  		   
   		 (if (<> (setq vr (refObjVector pobjvec p1)) result) (error "refObjVector:pobjvec:p1:vr"))  		   
   		 (if (<> (setq vr (refObjVector pobjvec c1)) result) (error "refObjVector:pobjvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refObjVector pobjvec v1)) result) (error "refObjVector:pobjvec:v1:vr"))  		   
   		 (if (<> (setq pr (refObjVector pobjvec p1)) result) (error "refObjVector:pobjvec:p1:vr"))  		   
   		 (if (<> (setq pr (refObjVector pobjvec c1)) result) (error "refObjVector:pobjvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refObjVector pobjvec v1)) result) (error "refObjVector:pobjvec:v1:vr"))  		   
   		 (if (<> (setq cr (refObjVector pobjvec p1)) result) (error "refObjVector:pobjvec:p1:vr"))  		   
   		 (if (<> (setq cr (refObjVector pobjvec c1)) result) (error "refObjVector:pobjvec:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refObjVector cobjvec v1)) result) (error "refObjVector:cobjvec:v1:vr"))  		   
   		 (if (<> (setq vr (refObjVector cobjvec p1)) result) (error "refObjVector:cobjvec:p1:vr"))  		   
   		 (if (<> (setq vr (refObjVector cobjvec c1)) result) (error "refObjVector:cobjvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refObjVector cobjvec v1)) result) (error "refObjVector:cobjvec:v1:vr"))  		   
   		 (if (<> (setq pr (refObjVector cobjvec p1)) result) (error "refObjVector:cobjvec:p1:vr"))  		   
   		 (if (<> (setq pr (refObjVector cobjvec c1)) result) (error "refObjVector:cobjvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refObjVector cobjvec v1)) result) (error "refObjVector:cobjvec:v1:vr"))  		   
   		 (if (<> (setq cr (refObjVector cobjvec p1)) result) (error "refObjVector:cobjvec:p1:vr"))  		   
   		 (if (<> (setq cr (refObjVector cobjvec c1)) result) (error "refObjVector:cobjvec:c1:vr"))
   		  
        )) ; end vmrefobjVector case           
       ((= testId "vmrefPcdVector") 		
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vpcdvec (setq cpcdvec (setq ppcdvec (lambda() true)[Pc:])))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refPcdVector " vpcdvec " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refPcdVector vpcdvec v1)) result) (error "refPcdVector:vpcdvec:v1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector vpcdvec p1)) result) (error "refPcdVector:vpcdvec:p1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector vpcdvec c1)) result) (error "refPcdVector:vpcdvec:c1:vr"))  		   

   		 (if (<> (setq pr (refPcdVector vpcdvec v1)) result) (error "refPcdVector:vpcdvec:v1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector vpcdvec p1)) result) (error "refPcdVector:vpcdvec:p1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector vpcdvec c1)) result) (error "refPcdVector:vpcdvec:c1:vr"))  		   

    	 (if (<> (setq cr (refPcdVector vpcdvec v1)) result) (error "refPcdVector:vpcdvec:v1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector vpcdvec p1)) result) (error "refPcdVector:vpcdvec:p1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector vpcdvec c1)) result) (error "refPcdVector:vpcdvec:c1:vr")) 
     	 
     	 (if (<> (setq vr (refPcdVector ppcdvec v1)) result) (error "refPcdVector:ppcdvec:v1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector ppcdvec p1)) result) (error "refPcdVector:ppcdvec:p1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector ppcdvec c1)) result) (error "refPcdVector:ppcdvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refPcdVector ppcdvec v1)) result) (error "refPcdVector:ppcdvec:v1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector ppcdvec p1)) result) (error "refPcdVector:ppcdvec:p1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector ppcdvec c1)) result) (error "refPcdVector:ppcdvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refPcdVector ppcdvec v1)) result) (error "refPcdVector:ppcdvec:v1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector ppcdvec p1)) result) (error "refPcdVector:ppcdvec:p1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector ppcdvec c1)) result) (error "refPcdVector:ppcdvec:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refPcdVector cpcdvec v1)) result) (error "refPcdVector:cpcdvec:v1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector cpcdvec p1)) result) (error "refPcdVector:cpcdvec:p1:vr"))  		   
   		 (if (<> (setq vr (refPcdVector cpcdvec c1)) result) (error "refPcdVector:cpcdvec:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refPcdVector cpcdvec v1)) result) (error "refPcdVector:cpcdvec:v1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector cpcdvec p1)) result) (error "refPcdVector:cpcdvec:p1:vr"))  		   
   		 (if (<> (setq pr (refPcdVector cpcdvec c1)) result) (error "refPcdVector:cpcdvec:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refPcdVector cpcdvec v1)) result) (error "refPcdVector:cpcdvec:v1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector cpcdvec p1)) result) (error "refPcdVector:cpcdvec:p1:vr"))  		   
   		 (if (<> (setq cr (refPcdVector cpcdvec c1)) result) (error "refPcdVector:cpcdvec:c1:vr"))
   		  
        )) ; end vmrefPcdVector case             
      ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest




;;**EXPORTKEY**:CompilerLib:%SELFTEST4
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest4 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest4(testId ...) 
   vars: (v1 v2 vr result vmat vnummat vstruc vdir vdic) 
   pvars:(p1 p2 pr  pmat pnummat pstruc pdir pdic)  
   cvars:(c1 c2 cr  cmat cnummat cstruc cdir cdic) 
    
   ;; Generate a separate test for each of the vm instruction types.
   (cond

       ;; Test the vmrefStrValue instruction   
        ((= testId "vmrefStrValue")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refStrValue " vstruc " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refStrValue vstruc v1)) result) (error "refStrValue:vstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrValue vstruc p1)) result) (error "refStrValue:vstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrValue vstruc c1)) result) (error "refStrValue:vstruc:c1:vr"))  		   

   		 (if (<> (setq pr (refStrValue vstruc v1)) result) (error "refStrValue:vstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrValue vstruc p1)) result) (error "refStrValue:vstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrValue vstruc c1)) result) (error "refStrValue:vstruc:c1:vr"))  		   

    	 (if (<> (setq cr (refStrValue vstruc v1)) result) (error "refStrValue:vstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrValue vstruc p1)) result) (error "refStrValue:vstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrValue vstruc c1)) result) (error "refStrValue:vstruc:c1:vr")) 
     	 
     	 (if (<> (setq vr (refStrValue pstruc v1)) result) (error "refStrValue:pstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrValue pstruc p1)) result) (error "refStrValue:pstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrValue pstruc c1)) result) (error "refStrValue:pstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refStrValue pstruc v1)) result) (error "refStrValue:pstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrValue pstruc p1)) result) (error "refStrValue:pstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrValue pstruc c1)) result) (error "refStrValue:pstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refStrValue pstruc v1)) result) (error "refStrValue:pstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrValue pstruc p1)) result) (error "refStrValue:pstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrValue pstruc c1)) result) (error "refStrValue:pstruc:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refStrValue cstruc v1)) result) (error "refStrValue:cstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrValue cstruc p1)) result) (error "refStrValue:cstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrValue cstruc c1)) result) (error "refStrValue:cstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refStrValue cstruc v1)) result) (error "refStrValue:cstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrValue cstruc p1)) result) (error "refStrValue:cstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrValue cstruc c1)) result) (error "refStrValue:cstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refStrValue cstruc v1)) result) (error "refStrValue:cstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrValue cstruc p1)) result) (error "refStrValue:cstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrValue cstruc c1)) result) (error "refStrValue:cstruc:c1:vr"))
   		  
        )) ; end vmrefStrValue case 
        
         ;; Test the vmrefStrKey instruction
         ((= testId "vmrefStrKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refStrKey " vstruc " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refStrKey vstruc v1)) result) (error "refStrKey:vstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrKey vstruc p1)) result) (error "refStrKey:vstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrKey vstruc c1)) result) (error "refStrKey:vstruc:c1:vr"))  		   

   		 (if (<> (setq pr (refStrKey vstruc v1)) result) (error "refStrKey:vstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrKey vstruc p1)) result) (error "refStrKey:vstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrKey vstruc c1)) result) (error "refStrKey:vstruc:c1:vr"))  		   

    	 (if (<> (setq cr (refStrKey vstruc v1)) result) (error "refStrKey:vstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrKey vstruc p1)) result) (error "refStrKey:vstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrKey vstruc c1)) result) (error "refStrKey:vstruc:c1:vr")) 
     	 
     	 (if (<> (setq vr (refStrKey pstruc v1)) result) (error "refStrKey:pstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrKey pstruc p1)) result) (error "refStrKey:pstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrKey pstruc c1)) result) (error "refStrKey:pstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refStrKey pstruc v1)) result) (error "refStrKey:pstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrKey pstruc p1)) result) (error "refStrKey:pstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrKey pstruc c1)) result) (error "refStrKey:pstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refStrKey pstruc v1)) result) (error "refStrKey:pstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrKey pstruc p1)) result) (error "refStrKey:pstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrKey pstruc c1)) result) (error "refStrKey:pstruc:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refStrKey cstruc v1)) result) (error "refStrKey:cstruc:v1:vr"))  		   
   		 (if (<> (setq vr (refStrKey cstruc p1)) result) (error "refStrKey:cstruc:p1:vr"))  		   
   		 (if (<> (setq vr (refStrKey cstruc c1)) result) (error "refStrKey:cstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refStrKey cstruc v1)) result) (error "refStrKey:cstruc:v1:vr"))  		   
   		 (if (<> (setq pr (refStrKey cstruc p1)) result) (error "refStrKey:cstruc:p1:vr"))  		   
   		 (if (<> (setq pr (refStrKey cstruc c1)) result) (error "refStrKey:cstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refStrKey cstruc v1)) result) (error "refStrKey:cstruc:v1:vr"))  		   
   		 (if (<> (setq cr (refStrKey cstruc p1)) result) (error "refStrKey:cstruc:p1:vr"))  		   
   		 (if (<> (setq cr (refStrKey cstruc c1)) result) (error "refStrKey:cstruc:c1:vr"))
   		  
        )) ; end vmrefStrKey case 

       ;; Test the vmrefDirValue instruction   
        ((= testId "vmrefDirValue")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vdir (setq cdir (setq pdir (new Directory: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refDirValue " vdir " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refDirValue vdir v1)) result) (error "refDirValue:vdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirValue vdir p1)) result) (error "refDirValue:vdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirValue vdir c1)) result) (error "refDirValue:vdir:c1:vr"))  		   

   		 (if (<> (setq pr (refDirValue vdir v1)) result) (error "refDirValue:vdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirValue vdir p1)) result) (error "refDirValue:vdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirValue vdir c1)) result) (error "refDirValue:vdir:c1:vr"))  		   

    	 (if (<> (setq cr (refDirValue vdir v1)) result) (error "refDirValue:vdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirValue vdir p1)) result) (error "refDirValue:vdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirValue vdir c1)) result) (error "refDirValue:vdir:c1:vr")) 
     	 
     	 (if (<> (setq vr (refDirValue pdir v1)) result) (error "refDirValue:pdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirValue pdir p1)) result) (error "refDirValue:pdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirValue pdir c1)) result) (error "refDirValue:pdir:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDirValue pdir v1)) result) (error "refDirValue:pdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirValue pdir p1)) result) (error "refDirValue:pdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirValue pdir c1)) result) (error "refDirValue:pdir:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDirValue pdir v1)) result) (error "refDirValue:pdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirValue pdir p1)) result) (error "refDirValue:pdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirValue pdir c1)) result) (error "refDirValue:pdir:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refDirValue cdir v1)) result) (error "refDirValue:cdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirValue cdir p1)) result) (error "refDirValue:cdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirValue cdir c1)) result) (error "refDirValue:cdir:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDirValue cdir v1)) result) (error "refDirValue:cdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirValue cdir p1)) result) (error "refDirValue:cdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirValue cdir c1)) result) (error "refDirValue:cdir:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDirValue cdir v1)) result) (error "refDirValue:cdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirValue cdir p1)) result) (error "refDirValue:cdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirValue cdir c1)) result) (error "refDirValue:cdir:c1:vr"))   		  
        )) ; end vmrefDirValue case 
        
       ;; Test the vmrefDirKey instruction   
        ((= testId "vmrefDirKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vdir (setq cdir (setq pdir (new Directory: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refDirKey " vdir " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refDirKey vdir v1)) result) (error "refDirKey:vdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirKey vdir p1)) result) (error "refDirKey:vdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirKey vdir c1)) result) (error "refDirKey:vdir:c1:vr"))  		   

   		 (if (<> (setq pr (refDirKey vdir v1)) result) (error "refDirKey:vdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirKey vdir p1)) result) (error "refDirKey:vdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirKey vdir c1)) result) (error "refDirKey:vdir:c1:vr"))  		   

    	 (if (<> (setq cr (refDirKey vdir v1)) result) (error "refDirKey:vdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirKey vdir p1)) result) (error "refDirKey:vdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirKey vdir c1)) result) (error "refDirKey:vdir:c1:vr")) 
     	 
     	 (if (<> (setq vr (refDirKey pdir v1)) result) (error "refDirKey:pdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirKey pdir p1)) result) (error "refDirKey:pdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirKey pdir c1)) result) (error "refDirKey:pdir:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDirKey pdir v1)) result) (error "refDirKey:pdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirKey pdir p1)) result) (error "refDirKey:pdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirKey pdir c1)) result) (error "refDirKey:pdir:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDirKey pdir v1)) result) (error "refDirKey:pdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirKey pdir p1)) result) (error "refDirKey:pdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirKey pdir c1)) result) (error "refDirKey:pdir:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refDirKey cdir v1)) result) (error "refDirKey:cdir:v1:vr"))  		   
   		 (if (<> (setq vr (refDirKey cdir p1)) result) (error "refDirKey:cdir:p1:vr"))  		   
   		 (if (<> (setq vr (refDirKey cdir c1)) result) (error "refDirKey:cdir:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDirKey cdir v1)) result) (error "refDirKey:cdir:v1:vr"))  		   
   		 (if (<> (setq pr (refDirKey cdir p1)) result) (error "refDirKey:cdir:p1:vr"))  		   
   		 (if (<> (setq pr (refDirKey cdir c1)) result) (error "refDirKey:cdir:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDirKey cdir v1)) result) (error "refDirKey:cdir:v1:vr"))  		   
   		 (if (<> (setq cr (refDirKey cdir p1)) result) (error "refDirKey:cdir:p1:vr"))  		   
   		 (if (<> (setq cr (refDirKey cdir c1)) result) (error "refDirKey:cdir:c1:vr"))   		  
        )) ; end vmrefDirKey case  
        
       ;; Test the vmrefDicValue instruction   
        ((= testId "vmrefDicValue")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vdic (setq cdic (setq pdic (new Dictionary: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refDicValue " vdic " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refDicValue vdic v1)) result) (error "refDicValue:vdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicValue vdic p1)) result) (error "refDicValue:vdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicValue vdic c1)) result) (error "refDicValue:vdic:c1:vr"))  		   

   		 (if (<> (setq pr (refDicValue vdic v1)) result) (error "refDicValue:vdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicValue vdic p1)) result) (error "refDicValue:vdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicValue vdic c1)) result) (error "refDicValue:vdic:c1:vr"))  		   

    	 (if (<> (setq cr (refDicValue vdic v1)) result) (error "refDicValue:vdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicValue vdic p1)) result) (error "refDicValue:vdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicValue vdic c1)) result) (error "refDicValue:vdic:c1:vr")) 
     	 
     	 (if (<> (setq vr (refDicValue pdic v1)) result) (error "refDicValue:pdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicValue pdic p1)) result) (error "refDicValue:pdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicValue pdic c1)) result) (error "refDicValue:pdic:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDicValue pdic v1)) result) (error "refDicValue:pdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicValue pdic p1)) result) (error "refDicValue:pdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicValue pdic c1)) result) (error "refDicValue:pdic:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDicValue pdic v1)) result) (error "refDicValue:pdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicValue pdic p1)) result) (error "refDicValue:pdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicValue pdic c1)) result) (error "refDicValue:pdic:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refDicValue cdic v1)) result) (error "refDicValue:cdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicValue cdic p1)) result) (error "refDicValue:cdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicValue cdic c1)) result) (error "refDicValue:cdic:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDicValue cdic v1)) result) (error "refDicValue:cdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicValue cdic p1)) result) (error "refDicValue:cdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicValue cdic c1)) result) (error "refDicValue:cdic:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDicValue cdic v1)) result) (error "refDicValue:cdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicValue cdic p1)) result) (error "refDicValue:cdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicValue cdic c1)) result) (error "refDicValue:cdic:c1:vr"))   		  
        )) ; end vmrefDicValue case 

       ;; Test the vmrefDicKey instruction   
        ((= testId "vmrefDicKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vdic (setq cdic (setq pdic (new Dictionary: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refDicKey " vdic " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refDicKey vdic v1)) result) (error "refDicKey:vdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicKey vdic p1)) result) (error "refDicKey:vdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicKey vdic c1)) result) (error "refDicKey:vdic:c1:vr"))  		   

   		 (if (<> (setq pr (refDicKey vdic v1)) result) (error "refDicKey:vdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicKey vdic p1)) result) (error "refDicKey:vdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicKey vdic c1)) result) (error "refDicKey:vdic:c1:vr"))  		   

    	 (if (<> (setq cr (refDicKey vdic v1)) result) (error "refDicKey:vdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicKey vdic p1)) result) (error "refDicKey:vdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicKey vdic c1)) result) (error "refDicKey:vdic:c1:vr")) 
     	 
     	 (if (<> (setq vr (refDicKey pdic v1)) result) (error "refDicKey:pdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicKey pdic p1)) result) (error "refDicKey:pdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicKey pdic c1)) result) (error "refDicKey:pdic:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDicKey pdic v1)) result) (error "refDicKey:pdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicKey pdic p1)) result) (error "refDicKey:pdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicKey pdic c1)) result) (error "refDicKey:pdic:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDicKey pdic v1)) result) (error "refDicKey:pdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicKey pdic p1)) result) (error "refDicKey:pdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicKey pdic c1)) result) (error "refDicKey:pdic:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refDicKey cdic v1)) result) (error "refDicKey:cdic:v1:vr"))  		   
   		 (if (<> (setq vr (refDicKey cdic p1)) result) (error "refDicKey:cdic:p1:vr"))  		   
   		 (if (<> (setq vr (refDicKey cdic c1)) result) (error "refDicKey:cdic:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refDicKey cdic v1)) result) (error "refDicKey:cdic:v1:vr"))  		   
   		 (if (<> (setq pr (refDicKey cdic p1)) result) (error "refDicKey:cdic:p1:vr"))  		   
   		 (if (<> (setq pr (refDicKey cdic c1)) result) (error "refDicKey:cdic:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refDicKey cdic v1)) result) (error "refDicKey:cdic:v1:vr"))  		   
   		 (if (<> (setq cr (refDicKey cdic p1)) result) (error "refDicKey:cdic:p1:vr"))  		   
   		 (if (<> (setq cr (refDicKey cdic c1)) result) (error "refDicKey:cdic:c1:vr"))   		  
        )) ; end vmrefDicKey case  
        
       ;; Test the vmrefMatrix instruction   
        ((= testId "vmrefMatrix")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vmat (setq cmat (setq pmat (new Matrix: 1 4 1 2 3 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refMatrix " vmat " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refMatrix vmat v1)) result) (error "refMatrix:vmat:v1:vr"))  		   
   		 (if (<> (setq vr (refMatrix vmat p1)) result) (error "refMatrix:vmat:p1:vr"))  		   
   		 (if (<> (setq vr (refMatrix vmat c1)) result) (error "refMatrix:vmat:c1:vr"))  		   

   		 (if (<> (setq pr (refMatrix vmat v1)) result) (error "refMatrix:vmat:v1:vr"))  		   
   		 (if (<> (setq pr (refMatrix vmat p1)) result) (error "refMatrix:vmat:p1:vr"))  		   
   		 (if (<> (setq pr (refMatrix vmat c1)) result) (error "refMatrix:vmat:c1:vr"))  		   

    	 (if (<> (setq cr (refMatrix vmat v1)) result) (error "refMatrix:vmat:v1:vr"))  		   
   		 (if (<> (setq cr (refMatrix vmat p1)) result) (error "refMatrix:vmat:p1:vr"))  		   
   		 (if (<> (setq cr (refMatrix vmat c1)) result) (error "refMatrix:vmat:c1:vr")) 
     	 
     	 (if (<> (setq vr (refMatrix pmat v1)) result) (error "refMatrix:pmat:v1:vr"))  		   
   		 (if (<> (setq vr (refMatrix pmat p1)) result) (error "refMatrix:pmat:p1:vr"))  		   
   		 (if (<> (setq vr (refMatrix pmat c1)) result) (error "refMatrix:pmat:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refMatrix pmat v1)) result) (error "refMatrix:pmat:v1:vr"))  		   
   		 (if (<> (setq pr (refMatrix pmat p1)) result) (error "refMatrix:pmat:p1:vr"))  		   
   		 (if (<> (setq pr (refMatrix pmat c1)) result) (error "refMatrix:pmat:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refMatrix pmat v1)) result) (error "refMatrix:pmat:v1:vr"))  		   
   		 (if (<> (setq cr (refMatrix pmat p1)) result) (error "refMatrix:pmat:p1:vr"))  		   
   		 (if (<> (setq cr (refMatrix pmat c1)) result) (error "refMatrix:pmat:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refMatrix cmat v1)) result) (error "refMatrix:cmat:v1:vr"))  		   
   		 (if (<> (setq vr (refMatrix cmat p1)) result) (error "refMatrix:cmat:p1:vr"))  		   
   		 (if (<> (setq vr (refMatrix cmat c1)) result) (error "refMatrix:cmat:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refMatrix cmat v1)) result) (error "refMatrix:cmat:v1:vr"))  		   
   		 (if (<> (setq pr (refMatrix cmat p1)) result) (error "refMatrix:cmat:p1:vr"))  		   
   		 (if (<> (setq pr (refMatrix cmat c1)) result) (error "refMatrix:cmat:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refMatrix cmat v1)) result) (error "refMatrix:cmat:v1:vr"))  		   
   		 (if (<> (setq cr (refMatrix cmat p1)) result) (error "refMatrix:cmat:p1:vr"))  		   
   		 (if (<> (setq cr (refMatrix cmat c1)) result) (error "refMatrix:cmat:c1:vr"))   		  
        )) ; end vmrefMatrix case  
                
       ;; Test the vmrefNumMatrix instruction   
        ((= testId "vmrefNumMatrix")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vnummat (setq cnummat (setq pnummat (new Matrix: number: 1 4 1 2 3 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(refNumMatrix " vnummat " "  v1 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (refNumMatrix vnummat v1)) result) (error "refNumMatrix:vnummat:v1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix vnummat p1)) result) (error "refNumMatrix:vnummat:p1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix vnummat c1)) result) (error "refNumMatrix:vnummat:c1:vr"))  		   

   		 (if (<> (setq pr (refNumMatrix vnummat v1)) result) (error "refNumMatrix:vnummat:v1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix vnummat p1)) result) (error "refNumMatrix:vnummat:p1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix vnummat c1)) result) (error "refNumMatrix:vnummat:c1:vr"))  		   

    	 (if (<> (setq cr (refNumMatrix vnummat v1)) result) (error "refNumMatrix:vnummat:v1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix vnummat p1)) result) (error "refNumMatrix:vnummat:p1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix vnummat c1)) result) (error "refNumMatrix:vnummat:c1:vr")) 
     	 
     	 (if (<> (setq vr (refNumMatrix pnummat v1)) result) (error "refNumMatrix:pnummat:v1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix pnummat p1)) result) (error "refNumMatrix:pnummat:p1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix pnummat c1)) result) (error "refNumMatrix:pnummat:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refNumMatrix pnummat v1)) result) (error "refNumMatrix:pnummat:v1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix pnummat p1)) result) (error "refNumMatrix:pnummat:p1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix pnummat c1)) result) (error "refNumMatrix:pnummat:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refNumMatrix pnummat v1)) result) (error "refNumMatrix:pnummat:v1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix pnummat p1)) result) (error "refNumMatrix:pnummat:p1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix pnummat c1)) result) (error "refNumMatrix:pnummat:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (refNumMatrix cnummat v1)) result) (error "refNumMatrix:cnummat:v1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix cnummat p1)) result) (error "refNumMatrix:cnummat:p1:vr"))  		   
   		 (if (<> (setq vr (refNumMatrix cnummat c1)) result) (error "refNumMatrix:cnummat:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (refNumMatrix cnummat v1)) result) (error "refNumMatrix:cnummat:v1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix cnummat p1)) result) (error "refNumMatrix:cnummat:p1:vr"))  		   
   		 (if (<> (setq pr (refNumMatrix cnummat c1)) result) (error "refNumMatrix:cnummat:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (refNumMatrix cnummat v1)) result) (error "refNumMatrix:cnummat:v1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix cnummat p1)) result) (error "refNumMatrix:cnummat:p1:vr"))  		   
   		 (if (<> (setq cr (refNumMatrix cnummat c1)) result) (error "refNumMatrix:cnummat:c1:vr"))   		  
        )) ; end vmrefNumMatrix case  
                
        
             
        ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest




;;**EXPORTKEY**:CompilerLib:%SELFTEST5
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest5 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest5(testId ...) 
   vars: (v1 v2 vr result vintvec vnumvec vbytevec vfltvec vbitvec vvec) 
   pvars:(p1 p2 pr pintvec pnumvec pbytevec pfltvec pbitvec pvec)  
   cvars:(c1 c2 cr cintvec cnumvec cbytevec cfltvec cbitvec cvec)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmsetIntVector instruction  
                   
        ((= testId "vmsetIntVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))         
		 (setq vintvec (setq cintvec (setq pintvec (new Vector: integer: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setIntVector " vintvec " "  v1 " " v2 ")")))         
         ;; Test the compiler and compare with the correct result. 
         (setq vr (setIntVector vintvec v1 v2))
   		 (if (<> vr[v2] result[v2]) (error "setIntVector:vintvec:v1:v2:vr"))
   		 (setq vr (setIntVector vintvec p1 v2))  		   
   		 (if (<> vr[v2] result[v2]) (error "setIntVector:vintvec:p1:v2:vr"))
   		 (setq vr (setIntVector vintvec c1 v2))  		   
   		 (if (<> vr[v2] result[v2]) (error "setIntVector:vintvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setIntVector vintvec v1 v2)) result) (error "setIntVector:vintvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector vintvec p1 v2)) result) (error "setIntVector:vintvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector vintvec c1 v2)) result) (error "setIntVector:vintvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setIntVector vintvec v1 v2)) result) (error "setIntVector:vintvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector vintvec p1 v2)) result) (error "setIntVector:vintvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector vintvec c1 v2)) result) (error "setIntVector:vintvec:c1:v2:vr")) 
     	 
     	 (if (<> (setq vr (setIntVector pintvec v1 v2)) result) (error "setIntVector:pintvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setIntVector pintvec p1 v2)) result) (error "setIntVector:pintvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setIntVector pintvec c1 v2)) result) (error "setIntVector:pintvec:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setIntVector pintvec v1 v2)) result) (error "setIntVector:pintvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector pintvec p1 v2)) result) (error "setIntVector:pintvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector pintvec c1 v2)) result) (error "setIntVector:pintvec:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setIntVector pintvec v1 v2)) result) (error "setIntVector:pintvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector pintvec p1 v2)) result) (error "setIntVector:pintvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector pintvec c1 v2)) result) (error "setIntVector:pintvec:c1:v2:vr")) 
   		  		   
     	 (if (<> (setq vr (setIntVector cintvec v1 v2)) result) (error "setIntVector:cintvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setIntVector cintvec p1 v2)) result) (error "setIntVector:cintvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setIntVector cintvec c1 v2)) result) (error "setIntVector:cintvec:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setIntVector cintvec v1 v2)) result) (error "setIntVector:cintvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector cintvec p1 v2)) result) (error "setIntVector:cintvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setIntVector cintvec c1 v2)) result) (error "setIntVector:cintvec:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setIntVector cintvec v1 v2)) result) (error "setIntVector:cintvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector cintvec p1 v2)) result) (error "setIntVector:cintvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setIntVector cintvec c1 v2)) result) (error "setIntVector:cintvec:c1:v2:vr"))
   		  
        )) ; end vmsetIntVector case           
        
         ;; Reference a NumVector          
        ((= testId "vmsetNumVector")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                 
		 (setq vnumvec (setq cnumvec (setq pnumvec (new Vector: number: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setNumVector " vnumvec " "  v1 " " v2 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setNumVector vnumvec v1 v2)) result) (error "setNumVector:vnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector vnumvec p1 v2)) result) (error "setNumVector:vnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector vnumvec c1 v2)) result) (error "setNumVector:vnumvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setNumVector vnumvec v1 v2)) result) (error "setNumVector:vnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector vnumvec p1 v2)) result) (error "setNumVector:vnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector vnumvec c1 v2)) result) (error "setNumVector:vnumvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setNumVector vnumvec v1 v2)) result) (error "setNumVector:vnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector vnumvec p1 v2)) result) (error "setNumVector:vnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector vnumvec c1 v2)) result) (error "setNumVector:vnumvec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setNumVector pnumvec v1 v2)) result) (error "setNumVector:pnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector pnumvec p1 v2)) result) (error "setNumVector:pnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector pnumvec c1 v2)) result) (error "setNumVector:pnumvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setNumVector pnumvec v1 v2)) result) (error "setNumVector:pnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector pnumvec p1 v2)) result) (error "setNumVector:pnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector pnumvec c1 v2)) result) (error "setNumVector:pnumvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setNumVector pnumvec v1 v2)) result) (error "setNumVector:pnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector pnumvec p1 v2)) result) (error "setNumVector:pnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector pnumvec c1 v2)) result) (error "setNumVector:pnumvec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setNumVector cnumvec v1 v2)) result) (error "setNumVector:cnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector cnumvec p1 v2)) result) (error "setNumVector:cnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumVector cnumvec c1 v2)) result) (error "setNumVector:cnumvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setNumVector cnumvec v1 v2)) result) (error "setNumVector:cnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector cnumvec p1 v2)) result) (error "setNumVector:cnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumVector cnumvec c1 v2)) result) (error "setNumVector:cnumvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setNumVector cnumvec v1 v2)) result) (error "setNumVector:cnumvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector cnumvec p1 v2)) result) (error "setNumVector:cnumvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumVector cnumvec c1 v2)) result) (error "setNumVector:cnumvec:c1:v2:vr"))  		   
        )) ; end vmsetNumVector case           

          ;; Reference a Vector          
        ((= testId "vmsetVector")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                  
		 (setq vvec (setq cvec (setq pvec (new Vector: 5 1 2 3 4 5))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setVector " vvec " "  v1 " " v2 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setVector vvec v1 v2)) result) (error "setVector:vvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector vvec p1 v2)) result) (error "setVector:vvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector vvec c1 v2)) result) (error "setVector:vvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setVector vvec v1 v2)) result) (error "setVector:vvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector vvec p1 v2)) result) (error "setVector:vvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector vvec c1 v2 )) result) (error "setVector:vvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setVector vvec v1 v2)) result) (error "setVector:vvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector vvec p1 v2)) result) (error "setVector:vvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector vvec c1 v2)) result) (error "setVector:vvec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setVector pvec v1 v2)) result) (error "setVector:pvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector pvec p1 v2)) result) (error "setVector:pvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector pvec c1 v2)) result) (error "setVector:pvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setVector pvec v1 v2)) result) (error "setVector:pvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector pvec p1 v2)) result) (error "setVector:pvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector pvec c1 v2)) result) (error "setVector:pvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setVector pvec v1 v2)) result) (error "setVector:pvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector pvec p1 v2)) result) (error "setVector:pvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector pvec c1 v2)) result) (error "setVector:pvec:c1:v2:vr"))  		   
 
    	 (if (<> (setq vr (setVector cvec v1 v2)) result) (error "setVector:cvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector cvec p1 v2)) result) (error "setVector:cvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setVector cvec c1 v2)) result) (error "setVector:cvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setVector cvec v1 v2)) result) (error "setVector:cvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector cvec p1 v2)) result) (error "setVector:cvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setVector cvec c1 v2)) result) (error "setVector:cvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setVector cvec v1 v2)) result) (error "setVector:cvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector cvec p1 v2)) result) (error "setVector:cvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setVector cvec c1 v2)) result) (error "setVector:cvec:c1:v2:vr"))  		   

        )) ; end vmsetVector case           
    
          ;; Reference a Byte Vector          
        ((= testId "vmsetBytVector")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                  
		 (setq vbytevec (setq cbytevec (setq pbytevec (new Vector: byte: 6 #\H #\e #\l #\l #\o 0))))
         
         ;; Use the emulator to compute the correct result.                      
         (setq result (inspect vbytevec))         
         (setq result (eval (append "(setBytVector #<ByteVector " result ">"  v1 " " v2 ")")))
                  
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setBytVector  vbytevec v1 v2)) result) (error "setBytVector :vbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  vbytevec p1 v2)) result) (error "setBytVector :vbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  vbytevec c1 v2)) result) (error "setBytVector :vbytevec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBytVector  vbytevec v1 v2)) result) (error "setBytVector :vbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  vbytevec p1 v2)) result) (error "setBytVector :vbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  vbytevec c1 v2)) result) (error "setBytVector :vbytevec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBytVector  vbytevec v1 v2)) result) (error "setBytVector :vbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  vbytevec p1 v2)) result) (error "setBytVector :vbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  vbytevec c1 v2)) result) (error "setBytVector :vbytevec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setBytVector  pbytevec v1 v2)) result) (error "setBytVector :pbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  pbytevec p1 v2)) result) (error "setBytVector :pbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  pbytevec c1 v2)) result) (error "setBytVector :pbytevec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBytVector  pbytevec v1 v2)) result) (error "setBytVector :pbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  pbytevec p1 v2)) result) (error "setBytVector :pbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  pbytevec c1 v2)) result) (error "setBytVector :pbytevec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBytVector  pbytevec v1 v2)) result) (error "setBytVector :pbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  pbytevec p1 v2)) result) (error "setBytVector :pbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  pbytevec c1 v2)) result) (error "setBytVector :pbytevec:c1:v2:vr"))  		   
 
    	 (if (<> (setq vr (setBytVector  cbytevec v1 v2)) result) (error "setBytVector :cbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  cbytevec p1 v2)) result) (error "setBytVector :cbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBytVector  cbytevec c1 v2)) result) (error "setBytVector :cbytevec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBytVector  cbytevec v1 v2)) result) (error "setBytVector :cbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  cbytevec p1 v2)) result) (error "setBytVector :cbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBytVector  cbytevec c1 v2)) result) (error "setBytVector :cbytevec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBytVector  cbytevec v1 v2)) result) (error "setBytVector :cbytevec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  cbytevec p1 v2)) result) (error "setBytVector :cbytevec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBytVector  cbytevec c1 v2)) result) (error "setBytVector :cbytevec:c1:v2:vr"))  		   

        )) ; end vmsetByteVector case           
  
          ;; Reference a float Vector  
          
        ((= testId "vmsetFltVector")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                  
		 (setq vfltvec (setq cfltvec (setq pfltvec (new Vector: float: 5 1.1 2.2 3.3 4.4 5.5))))
         ;; Use the emulator to compute the correct result.       
               
         (setq result (eval (append "(setFltVector " vfltvec " "  v1 " " v2 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setFltVector  vfltvec v1 v2)) result) (error "setFltVector :vfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  vfltvec p1 v2)) result) (error "setFltVector :vfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  vfltvec c1 v2)) result) (error "setFltVector :vfltvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setFltVector  vfltvec v1 v2)) result) (error "setFltVector :vfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  vfltvec p1 v2)) result) (error "setFltVector :vfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  vfltvec c1 v2)) result) (error "setFltVector :vfltvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setFltVector  vfltvec v1 v2)) result) (error "setFltVector :vfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  vfltvec p1 v2)) result) (error "setFltVector :vfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  vfltvec c1 v2)) result) (error "setFltVector :vfltvec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setFltVector  pfltvec v1 v2)) result) (error "setFltVector :pfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  pfltvec p1 v2)) result) (error "setFltVector :pfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  pfltvec c1 v2)) result) (error "setFltVector :pfltvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setFltVector  pfltvec v1 v2)) result) (error "setFltVector :pfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  pfltvec p1 v2)) result) (error "setFltVector :pfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  pfltvec c1 v2)) result) (error "setFltVector :pfltvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setFltVector  pfltvec v1 v2)) result) (error "setFltVector :pfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  pfltvec p1 v2)) result) (error "setFltVector :pfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  pfltvec c1 v2)) result) (error "setFltVector :pfltvec:c1:v2:vr"))  		   
 
    	 (if (<> (setq vr (setFltVector  cfltvec v1 v2)) result) (error "setFltVector :cfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  cfltvec p1 v2)) result) (error "setFltVector :cfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setFltVector  cfltvec c1 v2)) result) (error "setFltVector :cfltvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setFltVector  cfltvec v1 v2)) result) (error "setFltVector :cfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  cfltvec p1 v2)) result) (error "setFltVector :cfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setFltVector  cfltvec c1 v2)) result) (error "setFltVector :cfltvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setFltVector  cfltvec v1 v2)) result) (error "setFltVector :cfltvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  cfltvec p1 v2)) result) (error "setFltVector :cfltvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setFltVector  cfltvec c1 v2)) result) (error "setFltVector :cfltvec:c1:v2:vr"))  		   

        )) ; end vmsetFltVector case           
  
          ;; Reference a bit Vector  

        ((= testId "vmsetBitVector")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                 
		 (setq vbitvec (setq cbitvec (setq pbitvec (new Vector: bit: 4 1 0 1 0))))
         ;; Use the emulator to compute the correct result.       
               
         (setq result (eval (append "(setBitVector " vbitvec " "  v1 " " v2 ")")))         
         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setBitVector  vbitvec v1 v2)) result) (error "setBitVector :vbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  vbitvec p1 v2)) result) (error "setBitVector :vbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  vbitvec c1 v2)) result) (error "setBitVector :vbitvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBitVector  vbitvec v1 v2)) result) (error "setBitVector :vbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  vbitvec p1 v2)) result) (error "setBitVector :vbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  vbitvec c1 v2)) result) (error "setBitVector :vbitvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBitVector  vbitvec v1 v2)) result) (error "setBitVector :vbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  vbitvec p1 v2)) result) (error "setBitVector :vbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  vbitvec c1 v2)) result) (error "setBitVector :vbitvec:c1:v2:vr"))  		   

   		 (if (<> (setq vr (setBitVector  pbitvec v1 v2)) result) (error "setBitVector :pbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  pbitvec p1 v2)) result) (error "setBitVector :pbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  pbitvec c1 v2)) result) (error "setBitVector :pbitvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBitVector  pbitvec v1 v2)) result) (error "setBitVector :pbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  pbitvec p1 v2)) result) (error "setBitVector :pbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  pbitvec c1 v2)) result) (error "setBitVector :pbitvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBitVector  pbitvec v1 v2)) result) (error "setBitVector :pbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  pbitvec p1 v2)) result) (error "setBitVector :pbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  pbitvec c1 v2)) result) (error "setBitVector :pbitvec:c1:v2:vr"))  		   
 
    	 (if (<> (setq vr (setBitVector  cbitvec v1 v2)) result) (error "setBitVector :cbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  cbitvec p1 v2)) result) (error "setBitVector :cbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setBitVector  cbitvec c1 v2)) result) (error "setBitVector :cbitvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setBitVector  cbitvec v1 v2)) result) (error "setBitVector :cbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  cbitvec p1 v2)) result) (error "setBitVector :cbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setBitVector  cbitvec c1 v2)) result) (error "setBitVector :cbitvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setBitVector  cbitvec v1 v2)) result) (error "setBitVector :cbitvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  cbitvec p1 v2)) result) (error "setBitVector :cbitvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setBitVector  cbitvec c1 v2)) result) (error "setBitVector :cbitvec:c1:v2:vr"))  		   

        )) ; end vmsetBitVector case           
 
       ) ;; end cond 
    (append "result[v1] = " result[v1] " vr[v1] = " vr[v1]) 
    )   ; end selfTest5




;;**EXPORTKEY**:CompilerLib:%SELFTEST6
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest3 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest6(testId ...) 
   vars: (v1 v2 vr result vobjvec vpcdvec vtext vsym vstring vstruc) 
   pvars:(p1 p2 pr pobjvec ppcdvec ptext psym pstring pstruc)  
   cvars:(c1 c2 cr cobjvec cpcdvec ctext csym cstring cstruc) 
    
   ;; Generate a separate test for each of the vm instruction types.
   (cond 
         ;; Test the vmset instruction   
         ((= testId "vmset")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))                 
         
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setq " vstruc "["  v1 "] " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setq vstruc[v1] v2)) result) (error "vmset:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq vstruc[p1] v2)) result) (error "vmset:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq vstruc[c1] v2)) result) (error "vmset:vstruc:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setq vstruc[v1] v2)) result) (error "vmset:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq vstruc[p1] v2)) result) (error "vmset:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq vstruc[c1] v2)) result) (error "vmset:vstruc:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setq vstruc[v1] v2)) result) (error "vmset:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq vstruc[p1] v2)) result) (error "vmset:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq vstruc[c1] v2)) result) (error "vmset:vstruc:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setq pstruc[v1] v2)) result) (error "vmset:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq pstruc[p1] v2)) result) (error "vmset:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq pstruc[c1] v2)) result) (error "vmset:pstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setq pstruc[v1] v2)) result) (error "vmset:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq pstruc[p1] v2)) result) (error "vmset:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq pstruc[c1] v2)) result) (error "vmset:pstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setq pstruc[v1] v2)) result) (error "vmset:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq pstruc[p1] v2)) result) (error "vmset:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq pstruc[c1] v2)) result) (error "vmset:pstruc:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setq cstruc[v1] v2)) result) (error "vmset:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq cstruc[p1] v2)) result) (error "vmset:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq cstruc[c1] v2)) result) (error "vmset:cstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setq cstruc[v1] v2)) result) (error "vmset:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq cstruc[p1] v2)) result) (error "vmset:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq cstruc[c1] v2)) result) (error "vmset:cstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setq cstruc[v1] v2)) result) (error "vmset:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq cstruc[p1] v2)) result) (error "vmset:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq cstruc[c1] v2)) result) (error "vmset:cstruc:c1:c2:vr"))
   		  
        )) ; end vmset case 
         ;; Test the vmset instruction  (two indices  
         ((= testId "vmset2")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))                 
         
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setq " vstruc "[" v1  "  1] " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setq vstruc[v1 1] v2)) result) (error "vmset2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq vstruc[p1 1] v2)) result) (error "vmset2:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq vstruc[c1 1] v2)) result) (error "vmset2:vstruc:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setq vstruc[v1 1] v2)) result) (error "vmset2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq vstruc[p1 1] v2)) result) (error "vmset2:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq vstruc[c1 1] v2)) result) (error "vmset2:vstruc:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setq vstruc[v1 1] v2)) result) (error "vmset2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq vstruc[p1 1] v2)) result) (error "vmset2:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq vstruc[c1 1] v2)) result) (error "vmset2:vstruc:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setq pstruc[v1 1] v2)) result) (error "vmset2:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq pstruc[p1 1] v2)) result) (error "vmset2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq pstruc[c1 1] v2)) result) (error "vmset2:pstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setq pstruc[v1 1] v2)) result) (error "vmset2:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq pstruc[p1 1] v2)) result) (error "vmset2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq pstruc[c1 1] v2)) result) (error "vmset2:pstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setq pstruc[v1 1] v2)) result) (error "vmset2:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq pstruc[p1 1] v2)) result) (error "vmset2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq pstruc[c1 1] v2)) result) (error "vmset2:pstruc:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setq cstruc[v1 1] v2)) result) (error "vmset2:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setq cstruc[p1 1] v2)) result) (error "vmset2:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setq cstruc[c1 1] v2)) result) (error "vmset2:cstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setq cstruc[v1 1] v2)) result) (error "vmset2:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setq cstruc[p1 1] v2)) result) (error "vmset2:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setq cstruc[c1 1] v2)) result) (error "vmset2:cstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setq cstruc[v1 1] v2)) result) (error "vmset2:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setq cstruc[p1 1] v2)) result) (error "vmset2:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setq cstruc[c1 1] v2)) result) (error "vmset2:cstruc:c1:c2:vr"))
   		  
        )) ; end vmset case 

         ;; Test the vmref instruction  
         ((= testId "vmref")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
                        
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(ref " vstruc " "  v1  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (ref vstruc v1)) result) (error "vmref:vstruc:v1:vr"))  		   
   		 (if (<> (setq vr (ref vstruc p1)) result) (error "vmref:vstruc:p1:vr"))  		   
   		 (if (<> (setq vr (ref vstruc c1)) result) (error "vmref:vstruc:c1:vr"))  		   

   		 (if (<> (setq pr (ref vstruc v1)) result) (error "vmref:vstruc:v1:vr"))  		   
   		 (if (<> (setq pr (ref vstruc p1)) result) (error "vmref:vstruc:p1:vr"))  		   
   		 (if (<> (setq pr (ref vstruc c1)) result) (error "vmref:vstruc:c1:vr"))  		   

    	 (if (<> (setq cr (ref vstruc v1)) result) (error "vmref:vstruc:v1:vr"))  		   
   		 (if (<> (setq cr (ref vstruc p1)) result) (error "vmref:vstruc:p1:vr"))  		   
   		 (if (<> (setq cr (ref vstruc c1)) result) (error "vmref:vstruc:c1:vr")) 
     	 
     	 (if (<> (setq vr (ref pstruc v1)) result) (error "vmref:pstruc:v1:vr"))  		   
   		 (if (<> (setq vr (ref pstruc p1)) result) (error "vmref:pstruc:p1:vr"))  		   
   		 (if (<> (setq vr (ref pstruc c1)) result) (error "vmref:pstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (ref pstruc v1)) result) (error "vmref:pstruc:v1:vr"))  		   
   		 (if (<> (setq pr (ref pstruc p1)) result) (error "vmref:pstruc:p1:vr"))  		   
   		 (if (<> (setq pr (ref pstruc v1)) result) (error "vmref:pstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (ref pstruc v1)) result) (error "vmref:pstruc:v1:vr"))  		   
   		 (if (<> (setq cr (ref pstruc p1)) result) (error "vmref:pstruc:p1:vr"))  		   
   		 (if (<> (setq cr (ref pstruc c1)) result) (error "vmref:pstruc:c1:vr")) 
   		  		   
     	 (if (<> (setq vr (ref cstruc v1)) result) (error "vmref:cstruc:v1:vr"))  		   
   		 (if (<> (setq vr (ref cstruc p1)) result) (error "vmref:cstruc:p1:vr"))  		   
   		 (if (<> (setq vr (ref cstruc c1)) result) (error "vmref:cstruc:c1:vr"))  		   
 		 
    	 (if (<> (setq pr (ref cstruc v1)) result) (error "vmref:cstruc:v1:vr"))  		   
   		 (if (<> (setq pr (ref cstruc p1)) result) (error "vmref:cstruc:p1:vr"))  		   
   		 (if (<> (setq pr (ref cstruc c1)) result) (error "vmref:cstruc:c1:vr"))  		   
  		 
    	 (if (<> (setq cr (ref cstruc v1)) result) (error "vmref:cstruc:v1:vr"))  		   
   		 (if (<> (setq cr (ref cstruc p1)) result) (error "vmref:cstruc:p1:vr"))  		   
   		 (if (<> (setq cr (ref cstruc c1)) result) (error "vmref:cstruc:c1:vr"))   		  
        )) ; end vmref case 
        
        
        ;; Test the vmref instruction (two indices)   
        ((= testId "vmref2")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))  
                        
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(ref " vstruc " "  v1 " "  v2 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (ref vstruc v1 v2)) result) (error "vmref2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (ref vstruc v1 p2)) result) (error "vmref2:vstruc:v1:p2:vr"))  		   
   		 (if (<> (setq vr (ref vstruc v1 c2)) result) (error "vmref2:vstruc:v1:c2:vr"))  		   

   		 (if (<> (setq pr (ref vstruc p1 v2)) result) (error "vmref2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (ref vstruc p1 p2)) result) (error "vmref2:vstruc:v1:p2:vr"))  		   
   		 (if (<> (setq pr (ref vstruc p1 c2)) result) (error "vmref2:vstruc:v1:c2:vr"))  		   

    	 (if (<> (setq cr (ref vstruc c1 v2)) result) (error "vmref2:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (ref vstruc c1 p2)) result) (error "vmref2:vstruc:v1:p2:vr"))  		   
   		 (if (<> (setq cr (ref vstruc c1 c2)) result) (error "vmref2:vstruc:v1:c2:vr")) 
     	 
     	 (if (<> (setq vr (ref pstruc v1 v2)) result) (error "vmref2:pstruc:p1:v2:vr"))  		   
   		 (if (<> (setq vr (ref pstruc v1 p2)) result) (error "vmref2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (ref pstruc v1 c2)) result) (error "vmref2:pstruc:p1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (ref pstruc p1 v2)) result) (error "vmref2:pstruc:p1:v2:vr"))  		   
   		 (if (<> (setq pr (ref pstruc p1 p2)) result) (error "vmref2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (ref pstruc p1 c2)) result) (error "vmref2:pstruc:p1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (ref pstruc v1 v2)) result) (error "vmref2:pstruc:p1:v2:vr"))  		   
   		 (if (<> (setq cr (ref pstruc p1 p2)) result) (error "vmref2:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (ref pstruc c1 c2)) result) (error "vmref2:pstruc:p1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (ref cstruc v1 v2)) result) (error "vmref2:cstruc:c1:v2:vr"))  		   
   		 (if (<> (setq vr (ref cstruc p1 p2)) result) (error "vmref2:cstruc:c1:p2:vr"))  		   
   		 (if (<> (setq vr (ref cstruc c1 c2)) result) (error "vmref2:cstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (ref cstruc v1 v2)) result) (error "vmref2:cstruc:c1:v2:vr"))  		   
   		 (if (<> (setq pr (ref cstruc p1 p2)) result) (error "vmref2:cstruc:c1:p2:vr"))  		   
   		 (if (<> (setq pr (ref cstruc c1 c2)) result) (error "vmref2:cstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (ref cstruc v1 v2)) result) (error "vmref2:cstruc:c1:v2:vr"))  		   
   		 (if (<> (setq cr (ref cstruc p1 p2)) result) (error "vmref2:cstruc:c1:p2:vr"))  		   
   		 (if (<> (setq cr (ref cstruc c1 c2)) result) (error "vmref2:cstruc:c1:c2:vr"))   		  
        )) ; end vmref2 case 
        
        
         ;; Test the bitwiseShiftRight instruction        
        ((= testId "vmshr")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseShiftRight " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseShiftRight v1 v2)) result) (error "vmshr:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftRight v1 p2)) result) (error "vmshr:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseShiftRight v1 c2)) result) (error "vmshr:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseShiftRight p1 v2)) result) (error "vmshr:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftRight p1 p2)) result) (error "vmshr:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseShiftRight p1 c2)) result) (error "vmshr:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseShiftRight c1 v2)) result) (error "vmshr:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftRight c1 p2)) result) (error "vmshr:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftRight c1 c2)) result) (error "vmshr:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseShiftRight v1 v2)) result) (error "vmshr:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseShiftRight v1 p2)) result) (error "vmshr:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseShiftRight v1 c2)) result) (error "vmshr:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseShiftRight p1 v2)) result) (error "vmshr:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftRight p1 p2)) result) (error "vmshr:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftRight p1 c2)) result) (error "vmshr:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseShiftRight c1 v2)) result) (error "vmshr:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftRight c1 p2)) result) (error "vmshr:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftRight c1 c2)) result) (error "vmshr:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseShiftRight v1 v2)) result) (error "vmshr:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseShiftRight v1 p2)) result) (error "vmshr:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseShiftRight v1 c2)) result) (error "vmshr:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseShiftRight p1 v2)) result) (error "vmshr:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftRight p1 p2)) result) (error "vmshr:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftRight p1 c2)) result) (error "vmshr:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseShiftRight c1 v2)) result) (error "vmshr:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseShiftRight c1 p2)) result) (error "vmshr:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftRight c1 c2)) result) (error "vmshr:c1:c2:cr"))  
        )) ; end vmshr case           

         ;; Test the bitwiseShiftleft instruction        
          ((= testId "vmshl")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseShiftLeft " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseShiftLeft v1 v2)) result) (error "vmshl:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftLeft v1 p2)) result) (error "vmshl:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseShiftLeft v1 c2)) result) (error "vmshl:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseShiftLeft p1 v2)) result) (error "vmshl:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftLeft p1 p2)) result) (error "vmshl:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseShiftLeft p1 c2)) result) (error "vmshl:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseShiftLeft c1 v2)) result) (error "vmshl:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftLeft c1 p2)) result) (error "vmshl:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseShiftLeft c1 c2)) result) (error "vmshl:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseShiftLeft v1 v2)) result) (error "vmshl:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseShiftLeft v1 p2)) result) (error "vmshl:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseShiftLeft v1 c2)) result) (error "vmshl:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseShiftLeft p1 v2)) result) (error "vmshl:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftLeft p1 p2)) result) (error "vmshl:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftLeft p1 c2)) result) (error "vmshl:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseShiftLeft c1 v2)) result) (error "vmshl:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftLeft c1 p2)) result) (error "vmshl:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseShiftLeft c1 c2)) result) (error "vmshl:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseShiftLeft v1 v2)) result) (error "vmshl:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseShiftLeft v1 p2)) result) (error "vmshl:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseShiftLeft v1 c2)) result) (error "vmshl:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseShiftLeft p1 v2)) result) (error "vmshl:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftLeft p1 p2)) result) (error "vmshl:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftLeft p1 c2)) result) (error "vmshl:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseShiftLeft c1 v2)) result) (error "vmshl:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseShiftLeft c1 p2)) result) (error "vmshl:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseShiftLeft c1 c2)) result) (error "vmshl:c1:c2:cr"))  
        )) ; end vmshl case                   

         ;; Test the vmsetString instruction
         ((= testId "vmsetString")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))                 
		 (setq vstring (setq cstring (setq pstring "Hello World!")))
 
         ;; Use the emulator to compute the correct result.                      
         (setq result (inspect vstring))         
         (setq result (eval (append "(setString #<" (type vstring) " " result "> " v1 " " v2 ")")))
              
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setString vstring v1 v2)) result) (error "vmsetString:vstring:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setString vstring p1 v2)) result) (error "vmsetString:vstring:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setString vstring c1 v2)) result) (error "vmsetString:vstring:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setString vstring v1 v2)) result) (error "vmsetString:vstring:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setString vstring p1 v2)) result) (error "vmsetString:vstring:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setString vstring c1 v2)) result) (error "vmsetString:vstring:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setString vstring v1 v2)) result) (error "vmsetString:vstring:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setString vstring p1 v2)) result) (error "vmsetString:vstring:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setString vstring c1 v2)) result) (error "vmsetString:vstring:c1:v2:vr")) 
     	 
     	 (if (<> (setq vr (setString pstring v1 v2)) result) (error "vmsetString:pstring:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setString pstring p1 v2)) result) (error "vmsetString:pstring:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setString pstring c1 v2)) result) (error "vmsetString:pstring:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setString pstring v1 v2)) result) (error "vmsetString:pstring:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setString pstring p1 v2)) result) (error "vmsetString:pstring:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setString pstring c1 v2)) result) (error "vmsetString:pstring:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setString pstring v1 v2)) result) (error "vmsetString:pstring:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setString pstring p1 v2)) result) (error "vmsetString:pstring:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setString pstring c1 v2)) result) (error "vmsetString:pstring:c1:v2:vr")) 
   		  		   
     	 (if (<> (setq vr (setString cstring v1 v2)) result) (error "vmsetString:cstring:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setString cstring p1 v2)) result) (error "vmsetString:cstring:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setString cstring c1 v2)) result) (error "vmsetString:cstring:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setString cstring v1 v2)) result) (error "vmsetString:cstring:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setString cstring p1 v2)) result) (error "vmsetString:cstring:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setString cstring c1 v2)) result) (error "vmsetString:cstring:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setString cstring v1 v2)) result) (error "vmsetString:cstring:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setString cstring p1 v2)) result) (error "vmsetString:cstring:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setString cstring c1 v2)) result) (error "vmsetString:cstring:c1:v2:vr"))
   		  
        )) ; end vmsetString case           
    
       ;; Test the vmsetObjVector instruction

       ((= testId "vmsetObjVector")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))         
		 (setq vobjvec (setq cobjvec (setq pobjvec (new Vector: object: 5 H: e: l: l: o:))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setObjVector " vobjvec " "  v1 " " v2 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setObjVector vobjvec v1 v2)) result) (error "vmsetObjVector:vobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector vobjvec p1 v2)) result) (error "vmsetObjVector:vobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector vobjvec c1 v2)) result) (error "vmsetObjVector:vobjvec:c1:v2:vr"))  		   

   		 (if (<> (setq pr (setObjVector vobjvec v1 v2)) result) (error "vmsetObjVector:vobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector vobjvec p1 v2)) result) (error "vmsetObjVector:vobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector vobjvec c1 v2)) result) (error "vmsetObjVector:vobjvec:c1:v2:vr"))  		   

    	 (if (<> (setq cr (setObjVector vobjvec v1 v2)) result) (error "vmsetObjVector:vobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector vobjvec p1 v2)) result) (error "vmsetObjVector:vobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector vobjvec c1 v2)) result) (error "vmsetObjVector:vobjvec:c1:v2:vr")) 
     	 
     	 (if (<> (setq vr (setObjVector pobjvec v1 v2)) result) (error "vmsetObjVector:pobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector pobjvec p1 v2)) result) (error "vmsetObjVector:pobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector pobjvec c1 v2)) result) (error "vmsetObjVector:pobjvec:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setObjVector pobjvec v1 v2)) result) (error "vmsetObjVector:pobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector pobjvec p1 v2)) result) (error "vmsetObjVector:pobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector pobjvec c1 v2)) result) (error "vmsetObjVector:pobjvec:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setObjVector pobjvec v1 v2)) result) (error "vmsetObjVector:pobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector pobjvec p1 v2)) result) (error "vmsetObjVector:pobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector pobjvec c1 v2)) result) (error "vmsetObjVector:pobjvec:c1:v2:vr")) 
   		  		   
     	 (if (<> (setq vr (setObjVector cobjvec v1 v2)) result) (error "vmsetObjVector:cobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector cobjvec p1 v2)) result) (error "vmsetObjVector:cobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq vr (setObjVector cobjvec c1 v2)) result) (error "vmsetObjVector:cobjvec:c1:v2:vr"))  		   
 		 
    	 (if (<> (setq pr (setObjVector cobjvec v1 v2)) result) (error "vmsetObjVector:cobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector cobjvec p1 v2)) result) (error "vmsetObjVector:cobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq pr (setObjVector cobjvec c1 v2)) result) (error "vmsetObjVector:cobjvec:c1:v2:vr"))  		   
  		 
    	 (if (<> (setq cr (setObjVector cobjvec v1 v2)) result) (error "vmsetObjVector:cobjvec:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector cobjvec p1 v2)) result) (error "vmsetObjVector:cobjvec:p1:v2:vr"))  		   
   		 (if (<> (setq cr (setObjVector cobjvec c1 v2)) result) (error "vmsetObjVector:cobjvec:c1:v2:vr")) 		  
        )) ; end vmsetObjVector case 
        
         
        
       ;; Test the vmsetPcdVector instruction           
       ((= testId "vmsetPcdVector") 		
         (begin
         ;; reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq v2 (argFetch 3))         
		 ;;(setq vpcdvec (setq cpcdvec (setq ppcdvec (lambda() true)[Pc:])))
         ;; Use the emulator to compute the correct result.
         ;;(setq result (eval (append "(setPcdVector " vpcdvec " "  v1 " " v2 ")")))         
         ;; Test the compiler and compare with the correct result.
   		 ;;(if (<> (setq vr (setPcdVector vpcdvec v1 v2)) result) (error "setPcdVector:vpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector vpcdvec p1 v2)) result) (error "setPcdVector:vpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector vpcdvec c1 v2)) result) (error "setPcdVector:vpcdvec:c1:v2:vr"))  		   

   		 ;;(if (<> (setq pr (setPcdVector vpcdvec v1 v2)) result) (error "setPcdVector:vpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector vpcdvec p1 v2)) result) (error "setPcdVector:vpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector vpcdvec c1 v2)) result) (error "setPcdVector:vpcdvec:c1:v2:vr"))  		   

    	 ;;(if (<> (setq cr (setPcdVector vpcdvec v1 v2)) result) (error "setPcdVector:vpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector vpcdvec p1 v2)) result) (error "setPcdVector:vpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector vpcdvec c1 v2)) result) (error "setPcdVector:vpcdvec:c1:v2:vr")) 
     	 
     	 ;;(if (<> (setq vr (setPcdVector ppcdvec v1 v2)) result) (error "setPcdVector:ppcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector ppcdvec p1 v2)) result) (error "setPcdVector:ppcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector ppcdvec c1 v2)) result) (error "setPcdVector:ppcdvec:c1:v2:vr"))  		   
 		 
    	 ;;(if (<> (setq pr (setPcdVector ppcdvec v1 v2)) result) (error "setPcdVector:ppcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector ppcdvec p1 v2)) result) (error "setPcdVector:ppcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector ppcdvec c1 v2)) result) (error "setPcdVector:ppcdvec:c1:v2:vr"))  		   
  		 
    	 ;;(if (<> (setq cr (setPcdVector ppcdvec v1 v2)) result) (error "setPcdVector:ppcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector ppcdvec p1 v2)) result) (error "setPcdVector:ppcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector ppcdvec c1 v2)) result) (error "setPcdVector:ppcdvec:c1:v2:vr")) 
   		  		   
     	 ;;(if (<> (setq vr (setPcdVector cpcdvec v1 v2)) result) (error "setPcdVector:cpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector cpcdvec p1 v2)) result) (error "setPcdVector:cpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq vr (setPcdVector cpcdvec c1 v2)) result) (error "setPcdVector:cpcdvec:c1:v2:vr"))  		   
 		 
    	 ;;(if (<> (setq pr (setPcdVector cpcdvec v1 v2)) result) (error "setPcdVector:cpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector cpcdvec p1 v2)) result) (error "setPcdVector:cpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq pr (setPcdVector cpcdvec c1 v2)) result) (error "setPcdVector:cpcdvec:c1:v2:vr"))  		   
  		 
    	 ;;(if (<> (setq cr (setPcdVector cpcdvec v1 v2)) result) (error "setPcdVector:cpcdvec:v1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector cpcdvec p1 v2)) result) (error "setPcdVector:cpcdvec:p1:v2:vr"))  		   
   		 ;;(if (<> (setq cr (setPcdVector cpcdvec c1 v2)) result) (error "setPcdVector:cpcdvec:c1:v2:vr"))
   		  
        )) ; end vmsetPcdVector case             
      ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest6




;;**EXPORTKEY**:CompilerLib:%SELFTEST7
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest7 must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest7(testId ...) 
   vars: (v1 v2 vr result vmat vnummat vstruc vdir vdic) 
   pvars:(p1 p2 pr  pmat pnummat pstruc pdir pdic)  
   cvars:(c1 c2 cr  cmat cnummat cstruc cdir cdic) 
    
   ;; Generate a separate test for each of the vm instruction types.
   (cond

       ;; Test the vmsetStrValue instruction   
        ((= testId "vmsetStrValue")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))                 
         
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setStrValue " vstruc " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setStrValue vstruc v1 v2)) result) (error "setStrValue:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrValue vstruc p1 v2)) result) (error "setStrValue:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrValue vstruc c1 v2)) result) (error "setStrValue:vstruc:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setStrValue vstruc v1 v2)) result) (error "setStrValue:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrValue vstruc p1 v2)) result) (error "setStrValue:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrValue vstruc c1 v2)) result) (error "setStrValue:vstruc:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setStrValue vstruc v1 v2)) result) (error "setStrValue:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrValue vstruc p1 v2)) result) (error "setStrValue:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrValue vstruc c1 v2)) result) (error "setStrValue:vstruc:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setStrValue pstruc v1 v2)) result) (error "setStrValue:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrValue pstruc p1 v2)) result) (error "setStrValue:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrValue pstruc c1 v2)) result) (error "setStrValue:pstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setStrValue pstruc v1 v2)) result) (error "setStrValue:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrValue pstruc p1 v2)) result) (error "setStrValue:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrValue pstruc c1 v2)) result) (error "setStrValue:pstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setStrValue pstruc v1 v2)) result) (error "setStrValue:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrValue pstruc p1 v2)) result) (error "setStrValue:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrValue pstruc c1 v2)) result) (error "setStrValue:pstruc:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setStrValue cstruc v1 v2)) result) (error "setStrValue:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrValue cstruc p1 v2)) result) (error "setStrValue:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrValue cstruc c1 v2)) result) (error "setStrValue:cstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setStrValue cstruc v1 v2)) result) (error "setStrValue:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrValue cstruc p1 v2)) result) (error "setStrValue:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrValue cstruc c1 v2)) result) (error "setStrValue:cstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setStrValue cstruc v1 v2)) result) (error "setStrValue:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrValue cstruc p1 v2)) result) (error "setStrValue:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrValue cstruc c1 v2)) result) (error "setStrValue:cstruc:c1:c2:vr"))
   		  
        )) ; end vmsetStrValue case 
        
         ;; Test the vmsetStrKey instruction
         ((= testId "vmsetStrKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))           
		 (setq vstruc (setq cstruc (setq pstruc (new Structure: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setStrKey " vstruc " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setStrKey vstruc v1 v2)) result) (error "setStrKey:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrKey vstruc p1 v2)) result) (error "setStrKey:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrKey vstruc c1 v2)) result) (error "setStrKey:vstruc:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setStrKey vstruc v1 v2)) result) (error "setStrKey:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrKey vstruc p1 v2)) result) (error "setStrKey:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrKey vstruc c1 v2)) result) (error "setStrKey:vstruc:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setStrKey vstruc v1 v2)) result) (error "setStrKey:vstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrKey vstruc p1 v2)) result) (error "setStrKey:vstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrKey vstruc c1 v2)) result) (error "setStrKey:vstruc:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setStrKey pstruc v1 v2)) result) (error "setStrKey:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrKey pstruc p1 v2)) result) (error "setStrKey:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrKey pstruc c1 v2)) result) (error "setStrKey:pstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setStrKey pstruc v1 v2)) result) (error "setStrKey:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrKey pstruc p1 v2)) result) (error "setStrKey:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrKey pstruc c1 v2)) result) (error "setStrKey:pstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setStrKey pstruc v1 v2)) result) (error "setStrKey:pstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrKey pstruc p1 v2)) result) (error "setStrKey:pstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrKey pstruc c1 v2)) result) (error "setStrKey:pstruc:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setStrKey cstruc v1 v2)) result) (error "setStrKey:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setStrKey cstruc p1 v2)) result) (error "setStrKey:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setStrKey cstruc c1 v2)) result) (error "setStrKey:cstruc:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setStrKey cstruc v1 v2)) result) (error "setStrKey:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setStrKey cstruc p1 v2)) result) (error "setStrKey:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setStrKey cstruc c1 v2)) result) (error "setStrKey:cstruc:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setStrKey cstruc v1 v2)) result) (error "setStrKey:cstruc:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setStrKey cstruc p1 v2)) result) (error "setStrKey:cstruc:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setStrKey cstruc c1 v2)) result) (error "setStrKey:cstruc:c1:c2:vr"))
   		  
        )) ; end vmsetStrKey case 

       ;; Test the vmsetDirValue instruction   
        ((= testId "vmsetDirValue")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))           
		 (setq vdir (setq cdir (setq pdir (new Directory: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setDirValue " vdir " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setDirValue vdir v1 v2)) result) (error "setDirValue:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirValue vdir p1 v2)) result) (error "setDirValue:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirValue vdir c1 v2)) result) (error "setDirValue:vdir:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setDirValue vdir v1 v2)) result) (error "setDirValue:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirValue vdir p1 v2)) result) (error "setDirValue:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirValue vdir c1 v2)) result) (error "setDirValue:vdir:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setDirValue vdir v1 v2)) result) (error "setDirValue:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirValue vdir p1 v2)) result) (error "setDirValue:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirValue vdir c1 v2)) result) (error "setDirValue:vdir:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setDirValue pdir v1 v2)) result) (error "setDirValue:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirValue pdir p1 v2)) result) (error "setDirValue:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirValue pdir c1 v2)) result) (error "setDirValue:pdir:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDirValue pdir v1 v2)) result) (error "setDirValue:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirValue pdir p1 v2)) result) (error "setDirValue:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirValue pdir c1 v2)) result) (error "setDirValue:pdir:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDirValue pdir v1 v2)) result) (error "setDirValue:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirValue pdir p1 v2)) result) (error "setDirValue:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirValue pdir c1 v2)) result) (error "setDirValue:pdir:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setDirValue cdir v1 v2)) result) (error "setDirValue:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirValue cdir p1 v2)) result) (error "setDirValue:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirValue cdir c1 v2)) result) (error "setDirValue:cdir:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDirValue cdir v1 v2)) result) (error "setDirValue:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirValue cdir p1 v2)) result) (error "setDirValue:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirValue cdir c1 v2)) result) (error "setDirValue:cdir:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDirValue cdir v1 v2)) result) (error "setDirValue:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirValue cdir p1 v2)) result) (error "setDirValue:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirValue cdir c1 v2)) result) (error "setDirValue:cdir:c1:c2:vr"))   		  
        )) ; end vmsetDirValue case 
        
       ;; Test the vmsetDirKey instruction   
        ((= testId "vmsetDirKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))          
		 (setq vdir (setq cdir (setq pdir (new Directory: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setDirKey " vdir " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setDirKey vdir v1 v2)) result) (error "setDirKey:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirKey vdir p1 v2)) result) (error "setDirKey:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirKey vdir c1 v2)) result) (error "setDirKey:vdir:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setDirKey vdir v1 v2)) result) (error "setDirKey:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirKey vdir p1 v2)) result) (error "setDirKey:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirKey vdir c1 v2)) result) (error "setDirKey:vdir:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setDirKey vdir v1 v2)) result) (error "setDirKey:vdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirKey vdir p1 v2)) result) (error "setDirKey:vdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirKey vdir c1 v2)) result) (error "setDirKey:vdir:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setDirKey pdir v1 v2)) result) (error "setDirKey:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirKey pdir p1 v2)) result) (error "setDirKey:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirKey pdir c1 v2)) result) (error "setDirKey:pdir:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDirKey pdir v1 v2)) result) (error "setDirKey:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirKey pdir p1 v2)) result) (error "setDirKey:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirKey pdir c1 v2)) result) (error "setDirKey:pdir:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDirKey pdir v1 v2)) result) (error "setDirKey:pdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirKey pdir p1 v2)) result) (error "setDirKey:pdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirKey pdir c1 v2)) result) (error "setDirKey:pdir:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setDirKey cdir v1 v2)) result) (error "setDirKey:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDirKey cdir p1 v2)) result) (error "setDirKey:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDirKey cdir c1 v2)) result) (error "setDirKey:cdir:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDirKey cdir v1 v2)) result) (error "setDirKey:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDirKey cdir p1 v2)) result) (error "setDirKey:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDirKey cdir c1 v2)) result) (error "setDirKey:cdir:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDirKey cdir v1 v2)) result) (error "setDirKey:cdir:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDirKey cdir p1 v2)) result) (error "setDirKey:cdir:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDirKey cdir c1 v2)) result) (error "setDirKey:cdir:c1:c2:vr"))   		  
        )) ; end vmsetDirKey case  
        
       ;; Test the vmsetDicValue instruction   
        ((= testId "vmsetDicValue")
         (begin
         ;; seterence the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))           
		 (setq vdic (setq cdic (setq pdic (new Dictionary: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         ;; (setq result (eval (append "(setDicValue " vdic " "  v1 " " v2  ")")))  
         (setq result (eval (append "(setDicValue " vdic " "  v1 " " 22  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setDicValue vdic v1 v2)) result) (error "setDicValue:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicValue vdic p1 v2)) result) (error "setDicValue:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicValue vdic c1 v2)) result) (error "setDicValue:vdic:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setDicValue vdic v1 v2)) result) (error "setDicValue:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicValue vdic p1 v2)) result) (error "setDicValue:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicValue vdic c1 v2)) result) (error "setDicValue:vdic:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setDicValue vdic v1 v2)) result) (error "setDicValue:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicValue vdic p1 v2)) result) (error "setDicValue:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicValue vdic c1 v2)) result) (error "setDicValue:vdic:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setDicValue pdic v1 v2)) result) (error "setDicValue:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicValue pdic p1 v2)) result) (error "setDicValue:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicValue pdic c1 v2)) result) (error "setDicValue:pdic:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDicValue pdic v1 v2)) result) (error "setDicValue:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicValue pdic p1 v2)) result) (error "setDicValue:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicValue pdic c1 v2)) result) (error "setDicValue:pdic:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDicValue pdic v1 v2)) result) (error "setDicValue:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicValue pdic p1 v2)) result) (error "setDicValue:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicValue pdic c1 v2)) result) (error "setDicValue:pdic:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setDicValue cdic v1 v2)) result) (error "setDicValue:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicValue cdic p1 v2)) result) (error "setDicValue:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicValue cdic c1 v2)) result) (error "setDicValue:cdic:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDicValue cdic v1 v2)) result) (error "setDicValue:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicValue cdic p1 v2)) result) (error "setDicValue:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicValue cdic c1 v2)) result) (error "setDicValue:cdic:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDicValue cdic v1 v2)) result) (error "setDicValue:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicValue cdic p1 v2)) result) (error "setDicValue:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicValue cdic c1 v2)) result) (error "setDicValue:cdic:c1:c2:vr"))   		  
        )) ; end vmsetDicValue case 

       ;; Test the vmsetDicKey instruction   
        ((= testId "vmsetDicKey")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))
         (setq p2 (setq c2 (setq v2 (argFetch 3))))           
		 (setq vdic (setq cdic (setq pdic (new Dictionary: a 1 b 2 c 3 d 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setDicKey " vdic " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setDicKey vdic v1 v2)) result) (error "setDicKey:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicKey vdic p1 p2)) result) (error "setDicKey:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicKey vdic c1 c2)) result) (error "setDicKey:vdic:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setDicKey vdic v1 v2)) result) (error "setDicKey:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicKey vdic p1 p2)) result) (error "setDicKey:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicKey vdic c1 c2)) result) (error "setDicKey:vdic:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setDicKey vdic v1 v2)) result) (error "setDicKey:vdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicKey vdic p1 p2)) result) (error "setDicKey:vdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicKey vdic c1 c2)) result) (error "setDicKey:vdic:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setDicKey pdic v1 v2)) result) (error "setDicKey:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicKey pdic p1 p2)) result) (error "setDicKey:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicKey pdic c1 c2)) result) (error "setDicKey:pdic:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDicKey pdic v1 v2)) result) (error "setDicKey:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicKey pdic p1 p2)) result) (error "setDicKey:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicKey pdic c1 c2)) result) (error "setDicKey:pdic:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDicKey pdic v1 v2)) result) (error "setDicKey:pdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicKey pdic p1 p2)) result) (error "setDicKey:pdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicKey pdic c1 c2)) result) (error "setDicKey:pdic:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setDicKey cdic v1 v2)) result) (error "setDicKey:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setDicKey cdic p1 p2)) result) (error "setDicKey:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setDicKey cdic c1 c2)) result) (error "setDicKey:cdic:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setDicKey cdic v1 v2)) result) (error "setDicKey:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setDicKey cdic p1 p2)) result) (error "setDicKey:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setDicKey cdic c1 c2)) result) (error "setDicKey:cdic:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setDicKey cdic v1 v2)) result) (error "setDicKey:cdic:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setDicKey cdic p1 p2)) result) (error "setDicKey:cdic:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setDicKey cdic c1 c2)) result) (error "setDicKey:cdic:c1:c2:vr"))   		  
        )) ; end vmsetDicKey case  
        
       ;; Test the vmsetMatrix instruction   
        ((= testId "vmsetMatrix")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vmat (setq cmat (setq pmat (new Matrix: 1 4 1 2 3 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setMatrix " vmat " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setMatrix vmat v1 v2)) result) (error "setMatrix:vmat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setMatrix vmat p1 p2)) result) (error "setMatrix:vmat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setMatrix vmat c1 c2)) result) (error "setMatrix:vmat:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setMatrix vmat v1 v2)) result) (error "setMatrix:vmat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setMatrix vmat p1 p2)) result) (error "setMatrix:vmat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setMatrix vmat c1 c2)) result) (error "setMatrix:vmat:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setMatrix vmat v1 v2)) result) (error "setMatrix:vmat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setMatrix vmat p1 p2)) result) (error "setMatrix:vmat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setMatrix vmat c1 c2)) result) (error "setMatrix:vmat:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setMatrix pmat v1 v2)) result) (error "setMatrix:pmat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setMatrix pmat p1 p2)) result) (error "setMatrix:pmat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setMatrix pmat c1 c2)) result) (error "setMatrix:pmat:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setMatrix pmat v1 v2)) result) (error "setMatrix:pmat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setMatrix pmat p1 p2)) result) (error "setMatrix:pmat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setMatrix pmat c1 c2)) result) (error "setMatrix:pmat:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setMatrix pmat v1 v2)) result) (error "setMatrix:pmat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setMatrix pmat p1 p2)) result) (error "setMatrix:pmat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setMatrix pmat c1 c2)) result) (error "setMatrix:pmat:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setMatrix cmat v1 v2)) result) (error "setMatrix:cmat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setMatrix cmat p1 p2)) result) (error "setMatrix:cmat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setMatrix cmat c1 c2)) result) (error "setMatrix:cmat:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setMatrix cmat v1 v2)) result) (error "setMatrix:cmat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setMatrix cmat p1 p2)) result) (error "setMatrix:cmat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setMatrix cmat c1 c2)) result) (error "setMatrix:cmat:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setMatrix cmat v1 v2)) result) (error "setMatrix:cmat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setMatrix cmat p1 p2)) result) (error "setMatrix:cmat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setMatrix cmat c1 c2)) result) (error "setMatrix:cmat:c1:c2:vr"))   		  
        )) ; end vmsetMatrix case  
                
       ;; Test the vmsetNumMatrix instruction   
        ((= testId "vmsetNumMatrix")
         (begin
         ;; Reference the arguments for this test.
         (setq p1 (setq c1 (setq v1 (argFetch 2))))         
		 (setq vnummat (setq cnummat (setq pnummat (new Matrix: number: 1 4 1 2 3 4))))
         ;; Use the emulator to compute the correct result.
         (setq result (eval (append "(setNumMatrix " vnummat " "  v1 " " v2  ")")))         
         ;; Test the compiler and compare with the correct result.
   		 (if (<> (setq vr (setNumMatrix vnummat v1 v2)) result) (error "setNumMatrix:vnummat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix vnummat p1 p2)) result) (error "setNumMatrix:vnummat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix vnummat c1 c2)) result) (error "setNumMatrix:vnummat:c1:c2:vr"))  		   

   		 (if (<> (setq pr (setNumMatrix vnummat v1 v2)) result) (error "setNumMatrix:vnummat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix vnummat p1 p2)) result) (error "setNumMatrix:vnummat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix vnummat c1 c2)) result) (error "setNumMatrix:vnummat:c1:c2:vr"))  		   

    	 (if (<> (setq cr (setNumMatrix vnummat v1 v2)) result) (error "setNumMatrix:vnummat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix vnummat p1 p2)) result) (error "setNumMatrix:vnummat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix vnummat c1 c2)) result) (error "setNumMatrix:vnummat:c1:c2:vr")) 
     	 
     	 (if (<> (setq vr (setNumMatrix pnummat v1 v2)) result) (error "setNumMatrix:pnummat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix pnummat p1 p2)) result) (error "setNumMatrix:pnummat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix pnummat c1 c2)) result) (error "setNumMatrix:pnummat:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setNumMatrix pnummat v1 v2)) result) (error "setNumMatrix:pnummat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix pnummat p1 p2)) result) (error "setNumMatrix:pnummat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix pnummat c1 c2)) result) (error "setNumMatrix:pnummat:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setNumMatrix pnummat v1 v2)) result) (error "setNumMatrix:pnummat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix pnummat p1 p2)) result) (error "setNumMatrix:pnummat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix pnummat c1 c2)) result) (error "setNumMatrix:pnummat:c1:c2:vr")) 
   		  		   
     	 (if (<> (setq vr (setNumMatrix cnummat v1 v2)) result) (error "setNumMatrix:cnummat:v1:v2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix cnummat p1 p2)) result) (error "setNumMatrix:cnummat:p1:p2:vr"))  		   
   		 (if (<> (setq vr (setNumMatrix cnummat c1 c2)) result) (error "setNumMatrix:cnummat:c1:c2:vr"))  		   
 		 
    	 (if (<> (setq pr (setNumMatrix cnummat v1 v2)) result) (error "setNumMatrix:cnummat:v1:v2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix cnummat p1 p2)) result) (error "setNumMatrix:cnummat:p1:p2:vr"))  		   
   		 (if (<> (setq pr (setNumMatrix cnummat c1 c2)) result) (error "setNumMatrix:cnummat:c1:c2:vr"))  		   
  		 
    	 (if (<> (setq cr (setNumMatrix cnummat v1 v2)) result) (error "setNumMatrix:cnummat:v1:v2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix cnummat p1 p2)) result) (error "setNumMatrix:cnummat:p1:p2:vr"))  		   
   		 (if (<> (setq cr (setNumMatrix cnummat c1 c2)) result) (error "setNumMatrix:cnummat:c1:c2:vr"))   		  
        )) ; end vmsetNumMatrix case  
                
        
             
        ) ;; end cond 

    (append "result = " result " vr = " vr) 
    ) ; end selfTest




;;**EXPORTKEY**:CompilerLib:%SELFTEST8
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest8(testId ...) 
   vars:(v1 v2 vr result vintvec )  
   pvars:(p1 p2 pr pintvec )  
   cvars:(c1 c2 cr cintvec)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond

          ((= testId "vmand")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseAnd " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseAnd v1 v2)) result) (error "vmand:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseAnd v1 p2)) result) (error "vmand:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseAnd v1 c2)) result) (error "vmand:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseAnd p1 v2)) result) (error "vmand:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseAnd p1 p2)) result) (error "vmand:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseAnd p1 c2)) result) (error "vmand:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseAnd c1 v2)) result) (error "vmand:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseAnd c1 p2)) result) (error "vmand:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseAnd c1 c2)) result) (error "vmand:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseAnd v1 v2)) result) (error "vmand:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseAnd v1 p2)) result) (error "vmand:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseAnd v1 c2)) result) (error "vmand:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseAnd p1 v2)) result) (error "vmand:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseAnd p1 p2)) result) (error "vmand:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseAnd p1 c2)) result) (error "vmand:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseAnd c1 v2)) result) (error "vmand:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseAnd c1 p2)) result) (error "vmand:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseAnd c1 c2)) result) (error "vmand:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseAnd v1 v2)) result) (error "vmand:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseAnd v1 p2)) result) (error "vmand:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseAnd v1 c2)) result) (error "vmand:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseAnd p1 v2)) result) (error "vmand:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseAnd p1 p2)) result) (error "vmand:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseAnd p1 c2)) result) (error "vmand:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseAnd c1 v2)) result) (error "vmand:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseAnd c1 p2)) result) (error "vmand:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseAnd c1 c2)) result) (error "vmand:c1:c2:cr"))  
        )) ; end vmand case           

        ((= testId "vmor")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseOr " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseOr v1 v2)) result) (error "vmor:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseOr v1 p2)) result) (error "vmor:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseOr v1 c2)) result) (error "vmor:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseOr p1 v2)) result) (error "vmor:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseOr p1 p2)) result) (error "vmor:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseOr p1 c2)) result) (error "vmor:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseOr c1 v2)) result) (error "vmor:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseOr c1 p2)) result) (error "vmor:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseOr c1 c2)) result) (error "vmor:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseOr v1 v2)) result) (error "vmor:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseOr v1 p2)) result) (error "vmor:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseOr v1 c2)) result) (error "vmor:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseOr p1 v2)) result) (error "vmor:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseOr p1 p2)) result) (error "vmor:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseOr p1 c2)) result) (error "vmor:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseOr c1 v2)) result) (error "vmor:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseOr c1 p2)) result) (error "vmor:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseOr c1 c2)) result) (error "vmor:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseOr v1 v2)) result) (error "vmor:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseOr v1 p2)) result) (error "vmor:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseOr v1 c2)) result) (error "vmor:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseOr p1 v2)) result) (error "vmor:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseOr p1 p2)) result) (error "vmor:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseOr p1 c2)) result) (error "vmor:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseOr c1 v2)) result) (error "vmor:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseOr c1 p2)) result) (error "vmor:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseOr c1 c2)) result) (error "vmor:c1:c2:cr"))  
        )) ; end vmor case  
        ;; Test the  bitwise exclusive or opcode
        ((= testId "vmxor")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseXor " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseXor v1 v2)) result) (error "vmxor:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseXor v1 p2)) result) (error "vmxor:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseXor v1 c2)) result) (error "vmxor:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseXor p1 v2)) result) (error "vmxor:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseXor p1 p2)) result) (error "vmxor:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseXor p1 c2)) result) (error "vmxor:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseXor c1 v2)) result) (error "vmxor:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseXor c1 p2)) result) (error "vmxor:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseXor c1 c2)) result) (error "vmxor:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseXor v1 v2)) result) (error "vmxor:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseXor v1 p2)) result) (error "vmxor:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseXor v1 c2)) result) (error "vmxor:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseXor p1 v2)) result) (error "vmxor:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseXor p1 p2)) result) (error "vmxor:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseXor p1 c2)) result) (error "vmxor:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseXor c1 v2)) result) (error "vmxor:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseXor c1 p2)) result) (error "vmxor:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseXor c1 c2)) result) (error "vmxor:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseXor v1 v2)) result) (error "vmxor:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseXor v1 p2)) result) (error "vmxor:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseXor v1 c2)) result) (error "vmxor:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseXor p1 v2)) result) (error "vmxor:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseXor p1 p2)) result) (error "vmxor:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseXor p1 c2)) result) (error "vmxor:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseXor c1 v2)) result) (error "vmxor:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseXor c1 p2)) result) (error "vmxor:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseXor c1 c2)) result) (error "vmxor:c1:c2:cr"))  
        )) ; end vmxor case  

        ;; Test the bitwise nand opcode
        ((= testId "vmnand")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseNand " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseNand v1 v2)) result) (error "vmnand:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNand v1 p2)) result) (error "vmnand:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNand v1 c2)) result) (error "vmnand:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseNand p1 v2)) result) (error "vmnand:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNand p1 p2)) result) (error "vmnand:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNand p1 c2)) result) (error "vmnand:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseNand c1 v2)) result) (error "vmnand:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNand c1 p2)) result) (error "vmnand:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseNand c1 c2)) result) (error "vmnand:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseNand v1 v2)) result) (error "vmnand:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseNand v1 p2)) result) (error "vmnand:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseNand v1 c2)) result) (error "vmnand:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseNand p1 v2)) result) (error "vmnand:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNand p1 p2)) result) (error "vmnand:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNand p1 c2)) result) (error "vmnand:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseNand c1 v2)) result) (error "vmnand:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNand c1 p2)) result) (error "vmnand:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNand c1 c2)) result) (error "vmnand:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseNand v1 v2)) result) (error "vmnand:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNand v1 p2)) result) (error "vmnand:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseNand v1 c2)) result) (error "vmnand:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseNand p1 v2)) result) (error "vmnand:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseNand p1 p2)) result) (error "vmnand:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNand p1 c2)) result) (error "vmnand:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseNand c1 v2)) result) (error "vmnand:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNand c1 p2)) result) (error "vmnand:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNand c1 c2)) result) (error "vmnand:c1:c2:cr"))  
        )) ; end vmnand case  
        
        ;; Test the binary nand opcode
        ((= testId "vmnandb")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(binaryNand " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (binaryNand v1 v2)) result) (error "vmnandb:v1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNand v1 p2)) result) (error "vmnandb:v1:p2:vr"))  
		   (if (<> (setq vr (binaryNand v1 c2)) result) (error "vmnandb:v1:c2:vr"))  

		   (if (<> (setq vr (binaryNand p1 v2)) result) (error "vmnandb:p1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNand p1 p2)) result) (error "vmnandb:p1:p2:vr"))  
		   (if (<> (setq vr (binaryNand p1 c2)) result) (error "vmnandb:p1:c2:vr"))  
             
		   (if (<> (setq vr (binaryNand c1 v2)) result) (error "vmnandb:c1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNand c1 p2)) result) (error "vmnandb:c1:p2:vr"))  		   
		   (if (<> (setq vr (binaryNand c1 c2)) result) (error "vmnandb:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (binaryNand v1 v2)) result) (error "vmnandb:v1:v2:pr"))  
		   (if (<> (setq pr (binaryNand v1 p2)) result) (error "vmnandb:v1:p2:pr"))  
		   (if (<> (setq pr (binaryNand v1 c2)) result) (error "vmnandb:v1:c2:pr"))  
		   
		   (if (<> (setq pr (binaryNand p1 v2)) result) (error "vmnandb:p1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNand p1 p2)) result) (error "vmnandb:p1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNand p1 c2)) result) (error "vmnandb:p1:c2:pr"))  
             
		   (if (<> (setq pr (binaryNand c1 v2)) result) (error "vmnandb:c1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNand c1 p2)) result) (error "vmnandb:c1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNand c1 c2)) result) (error "vmnandb:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (binaryNand v1 v2)) result) (error "vmnandb:v1:v2:cr"))  
		   (if (<> (setq cr (binaryNand v1 p2)) result) (error "vmnandb:v1:p2:cr"))  
		   (if (<> (setq cr (binaryNand v1 c2)) result) (error "vmnandb:v1:c2:cr"))  
		   
		   (if (<> (setq cr (binaryNand p1 v2)) result) (error "vmnandb:p1:v2:cr"))  		   
		   (if (<> (setq cr (binaryNand p1 p2)) result) (error "vmnandb:p1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNand p1 c2)) result) (error "vmnandb:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (binaryNand c1 v2)) result) (error "vmnandb:c1:v2:cr"))  
		   (if (<> (setq cr (binaryNand c1 p2)) result) (error "vmnandb:c1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNand c1 c2)) result) (error "vmnandb:c1:c2:cr"))  
        )) ; end vmnandb case  
           ;; Test the bitwise nand opcode  
           
        ((= testId "vmnor")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseNor " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseNor v1 v2)) result) (error "vmnor:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNor v1 p2)) result) (error "vmnor:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNor v1 c2)) result) (error "vmnor:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseNor p1 v2)) result) (error "vmnor:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNor p1 p2)) result) (error "vmnor:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNor p1 c2)) result) (error "vmnor:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseNor c1 v2)) result) (error "vmnor:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNor c1 p2)) result) (error "vmnor:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseNor c1 c2)) result) (error "vmnor:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseNor v1 v2)) result) (error "vmnor:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseNor v1 p2)) result) (error "vmnor:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseNor v1 c2)) result) (error "vmnor:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseNor p1 v2)) result) (error "vmnor:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNor p1 p2)) result) (error "vmnor:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNor p1 c2)) result) (error "vmnor:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseNor c1 v2)) result) (error "vmnor:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNor c1 p2)) result) (error "vmnor:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNor c1 c2)) result) (error "vmnor:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseNor v1 v2)) result) (error "vmnor:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNor v1 p2)) result) (error "vmnor:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseNor v1 c2)) result) (error "vmnor:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseNor p1 v2)) result) (error "vmnor:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseNor p1 p2)) result) (error "vmnor:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNor p1 c2)) result) (error "vmnor:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseNor c1 v2)) result) (error "vmnor:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNor c1 p2)) result) (error "vmnor:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNor c1 c2)) result) (error "vmnor:c1:c2:cr"))  
        )) ; end vmnor case  
        
        ;; Test the binary nand opcode
        ((= testId "vmnorb")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(binaryNor " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (binaryNor v1 v2)) result) (error "vmnorb:v1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNor v1 p2)) result) (error "vmnorb:v1:p2:vr"))  
		   (if (<> (setq vr (binaryNor v1 c2)) result) (error "vmnorb:v1:c2:vr"))  

		   (if (<> (setq vr (binaryNor p1 v2)) result) (error "vmnorb:p1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNor p1 p2)) result) (error "vmnorb:p1:p2:vr"))  
		   (if (<> (setq vr (binaryNor p1 c2)) result) (error "vmnorb:p1:c2:vr"))  
             
		   (if (<> (setq vr (binaryNor c1 v2)) result) (error "vmnorb:c1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNor c1 p2)) result) (error "vmnorb:c1:p2:vr"))  		   
		   (if (<> (setq vr (binaryNor c1 c2)) result) (error "vmnorb:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (binaryNor v1 v2)) result) (error "vmnorb:v1:v2:pr"))  
		   (if (<> (setq pr (binaryNor v1 p2)) result) (error "vmnorb:v1:p2:pr"))  
		   (if (<> (setq pr (binaryNor v1 c2)) result) (error "vmnorb:v1:c2:pr"))  
		   
		   (if (<> (setq pr (binaryNor p1 v2)) result) (error "vmnorb:p1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNor p1 p2)) result) (error "vmnorb:p1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNor p1 c2)) result) (error "vmnorb:p1:c2:pr"))  
             
		   (if (<> (setq pr (binaryNor c1 v2)) result) (error "vmnorb:c1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNor c1 p2)) result) (error "vmnorb:c1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNor c1 c2)) result) (error "vmnorb:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (binaryNor v1 v2)) result) (error "vmnorb:v1:v2:cr"))  
		   (if (<> (setq cr (binaryNor v1 p2)) result) (error "vmnorb:v1:p2:cr"))  
		   (if (<> (setq cr (binaryNor v1 c2)) result) (error "vmnorb:v1:c2:cr"))  
		   
		   (if (<> (setq cr (binaryNor p1 v2)) result) (error "vmnorb:p1:v2:cr"))  		   
		   (if (<> (setq cr (binaryNor p1 p2)) result) (error "vmnorb:p1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNor p1 c2)) result) (error "vmnorb:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (binaryNor c1 v2)) result) (error "vmnorb:c1:v2:cr"))  
		   (if (<> (setq cr (binaryNor c1 p2)) result) (error "vmnorb:c1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNor c1 c2)) result) (error "vmnorb:c1:c2:cr"))  
        )) ; end vmnorb case  
       
       ;; Test the bitwise Nxor 
        ((= testId "vmnxor")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(bitwiseNxor " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (bitwiseNxor v1 v2)) result) (error "vmnxor:v1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNxor v1 p2)) result) (error "vmnxor:v1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNxor v1 c2)) result) (error "vmnxor:v1:c2:vr"))  

		   (if (<> (setq vr (bitwiseNxor p1 v2)) result) (error "vmnxor:p1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNxor p1 p2)) result) (error "vmnxor:p1:p2:vr"))  
		   (if (<> (setq vr (bitwiseNxor p1 c2)) result) (error "vmnxor:p1:c2:vr"))  
             
		   (if (<> (setq vr (bitwiseNxor c1 v2)) result) (error "vmnxor:c1:v2:vr"))  		   
		   (if (<> (setq vr (bitwiseNxor c1 p2)) result) (error "vmnxor:c1:p2:vr"))  		   
		   (if (<> (setq vr (bitwiseNxor c1 c2)) result) (error "vmnxor:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (bitwiseNxor v1 v2)) result) (error "vmnxor:v1:v2:pr"))  
		   (if (<> (setq pr (bitwiseNxor v1 p2)) result) (error "vmnxor:v1:p2:pr"))  
		   (if (<> (setq pr (bitwiseNxor v1 c2)) result) (error "vmnxor:v1:c2:pr"))  
		   
		   (if (<> (setq pr (bitwiseNxor p1 v2)) result) (error "vmnxor:p1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNxor p1 p2)) result) (error "vmnxor:p1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNxor p1 c2)) result) (error "vmnxor:p1:c2:pr"))  
             
		   (if (<> (setq pr (bitwiseNxor c1 v2)) result) (error "vmnxor:c1:v2:pr"))  		   
		   (if (<> (setq pr (bitwiseNxor c1 p2)) result) (error "vmnxor:c1:p2:pr"))  		   
		   (if (<> (setq pr (bitwiseNxor c1 c2)) result) (error "vmnxor:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (bitwiseNxor v1 v2)) result) (error "vmnxor:v1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNxor v1 p2)) result) (error "vmnxor:v1:p2:cr"))  
		   (if (<> (setq cr (bitwiseNxor v1 c2)) result) (error "vmnxor:v1:c2:cr"))  
		   
		   (if (<> (setq cr (bitwiseNxor p1 v2)) result) (error "vmnxor:p1:v2:cr"))  		   
		   (if (<> (setq cr (bitwiseNxor p1 p2)) result) (error "vmnxor:p1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNxor p1 c2)) result) (error "vmnxor:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (bitwiseNxor c1 v2)) result) (error "vmnxor:c1:v2:cr"))  
		   (if (<> (setq cr (bitwiseNxor c1 p2)) result) (error "vmnxor:c1:p2:cr"))  		   
		   (if (<> (setq cr (bitwiseNxor c1 c2)) result) (error "vmnxor:c1:c2:cr"))  
        )) ; end vmnxor case  
        ;; Test the  bitwise exclusive or opcode
        ((= testId "vmnxorb")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(binaryNxor " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (binaryNxor v1 v2)) result) (error "vmnxorb:v1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNxor v1 p2)) result) (error "vmnxorb:v1:p2:vr"))  
		   (if (<> (setq vr (binaryNxor v1 c2)) result) (error "vmnxorb:v1:c2:vr"))  

		   (if (<> (setq vr (binaryNxor p1 v2)) result) (error "vmnxorb:p1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNxor p1 p2)) result) (error "vmnxorb:p1:p2:vr"))  
		   (if (<> (setq vr (binaryNxor p1 c2)) result) (error "vmnxorb:p1:c2:vr"))  
             
		   (if (<> (setq vr (binaryNxor c1 v2)) result) (error "vmnxorb:c1:v2:vr"))  		   
		   (if (<> (setq vr (binaryNxor c1 p2)) result) (error "vmnxorb:c1:p2:vr"))  		   
		   (if (<> (setq vr (binaryNxor c1 c2)) result) (error "vmnxorb:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (binaryNxor v1 v2)) result) (error "vmnxorb:v1:v2:pr"))  
		   (if (<> (setq pr (binaryNxor v1 p2)) result) (error "vmnxorb:v1:p2:pr"))  
		   (if (<> (setq pr (binaryNxor v1 c2)) result) (error "vmnxorb:v1:c2:pr"))  
		   
		   (if (<> (setq pr (binaryNxor p1 v2)) result) (error "vmnxorb:p1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNxor p1 p2)) result) (error "vmnxorb:p1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNxor p1 c2)) result) (error "vmnxorb:p1:c2:pr"))  
             
		   (if (<> (setq pr (binaryNxor c1 v2)) result) (error "vmnxorb:c1:v2:pr"))  		   
		   (if (<> (setq pr (binaryNxor c1 p2)) result) (error "vmnxorb:c1:p2:pr"))  		   
		   (if (<> (setq pr (binaryNxor c1 c2)) result) (error "vmnxorb:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (binaryNxor v1 v2)) result) (error "vmnxorb:v1:v2:cr"))  
		   (if (<> (setq cr (binaryNxor v1 p2)) result) (error "vmnxorb:v1:p2:cr"))  
		   (if (<> (setq cr (binaryNxor v1 c2)) result) (error "vmnxorb:v1:c2:cr"))  
		   
		   (if (<> (setq cr (binaryNxor p1 v2)) result) (error "vmnxorb:p1:v2:cr"))  		   
		   (if (<> (setq cr (binaryNxor p1 p2)) result) (error "vmnxorb:p1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNxor p1 c2)) result) (error "vmnxorb:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (binaryNxor c1 v2)) result) (error "vmnxorb:c1:v2:cr"))  
		   (if (<> (setq cr (binaryNxor c1 p2)) result) (error "vmnxorb:c1:p2:cr"))  		   
		   (if (<> (setq cr (binaryNxor c1 c2)) result) (error "vmnxorb:c1:c2:cr"))  
        )) ; end vmnxorb case  
    
       ) ;; end cond 

    (append "result = " result " vr = " vr)) ; end selfTest8




;;**EXPORTKEY**:CompilerLib:%SELFTEST9
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTest9(testId ...) 
   vars:(v1 v2 vr result vintvec )  
   pvars:(p1 p2 pr pintvec )  
   cvars:(c1 c2 cr cintvec)  
     
   ;; Generate a separate test for each of the vm instruction types.
   (cond
       ;; Test the vmiadd instruction  
       ((= testId "vmiadd")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(iadd " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (iadd v1 v2)) result) (error "vmiadd:v1:v2:vr"))  		   
		   (if (<> (setq vr (iadd v1 p2)) result) (error "vmiadd:v1:p2:vr"))  
		   (if (<> (setq vr (iadd v1 c2)) result) (error "vmiadd:v1:c2:vr"))  

		   (if (<> (setq vr (iadd p1 v2)) result) (error "vmiadd:p1:v2:vr"))  		   
		   (if (<> (setq vr (iadd p1 p2)) result) (error "vmiadd:p1:p2:vr"))  
		   (if (<> (setq vr (iadd p1 c2)) result) (error "vmiadd:p1:c2:vr"))  
             
		   (if (<> (setq vr (iadd c1 v2)) result) (error "vmiadd:c1:v2:vr"))  		   
		   (if (<> (setq vr (iadd c1 p2)) result) (error "vmiadd:c1:p2:vr"))  		   
		   (if (<> (setq vr (iadd c1 c2)) result) (error "vmiadd:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (iadd v1 v2)) result) (error "vmiadd:v1:v2:pr"))  
		   (if (<> (setq pr (iadd v1 p2)) result) (error "vmiadd:v1:p2:pr"))  
		   (if (<> (setq pr (iadd v1 c2)) result) (error "vmiadd:v1:c2:pr"))  
		   
		   (if (<> (setq pr (iadd p1 v2)) result) (error "vmiadd:p1:v2:pr"))  		   
		   (if (<> (setq pr (iadd p1 p2)) result) (error "vmiadd:p1:p2:pr"))  		   
		   (if (<> (setq pr (iadd p1 c2)) result) (error "vmiadd:p1:c2:pr"))  
             
		   (if (<> (setq pr (iadd c1 v2)) result) (error "vmiadd:c1:v2:pr"))  		   
		   (if (<> (setq pr (iadd c1 p2)) result) (error "vmiadd:c1:p2:pr"))  		   
		   (if (<> (setq pr (iadd c1 c2)) result) (error "vmiadd:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (iadd v1 v2)) result) (error "vmiadd:v1:v2:cr"))  
		   (if (<> (setq cr (iadd v1 p2)) result) (error "vmiadd:v1:p2:cr"))  
		   (if (<> (setq cr (iadd v1 c2)) result) (error "vmiadd:v1:c2:cr"))  
		   
		   (if (<> (setq cr (iadd p1 v2)) result) (error "vmiadd:p1:v2:cr"))  		   
		   (if (<> (setq cr (iadd p1 p2)) result) (error "vmiadd:p1:p2:cr"))  		   
		   (if (<> (setq cr (iadd p1 c2)) result) (error "vmiadd:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (iadd c1 v2)) result) (error "vmiadd:c1:v2:cr"))  
		   (if (<> (setq cr (iadd c1 p2)) result) (error "vmiadd:c1:p2:cr"))  		   
		   (if (<> (setq cr (iadd c1 c2)) result) (error "vmiadd:c1:c2:cr"))  
        )) ; end vmiadd case           
       ;; Test the vmisub instruction  
       ((= testId "vmisub")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(isub " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (isub v1 v2)) result) (error "vmisub:v1:v2:vr"))  		   
		   (if (<> (setq vr (isub v1 p2)) result) (error "vmisub:v1:p2:vr"))  
		   (if (<> (setq vr (isub v1 c2)) result) (error "vmisub:v1:c2:vr"))  

		   (if (<> (setq vr (isub p1 v2)) result) (error "vmisub:p1:v2:vr"))  		   
		   (if (<> (setq vr (isub p1 p2)) result) (error "vmisub:p1:p2:vr"))  
		   (if (<> (setq vr (isub p1 c2)) result) (error "vmisub:p1:c2:vr"))  
             
		   (if (<> (setq vr (isub c1 v2)) result) (error "vmisub:c1:v2:vr"))  		   
		   (if (<> (setq vr (isub c1 p2)) result) (error "vmisub:c1:p2:vr"))  		   
		   (if (<> (setq vr (isub c1 c2)) result) (error "vmisub:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (isub v1 v2)) result) (error "vmisub:v1:v2:pr"))  
		   (if (<> (setq pr (isub v1 p2)) result) (error "vmisub:v1:p2:pr"))  
		   (if (<> (setq pr (isub v1 c2)) result) (error "vmisub:v1:c2:pr"))  
		   
		   (if (<> (setq pr (isub p1 v2)) result) (error "vmisub:p1:v2:pr"))  		   
		   (if (<> (setq pr (isub p1 p2)) result) (error "vmisub:p1:p2:pr"))  		   
		   (if (<> (setq pr (isub p1 c2)) result) (error "vmisub:p1:c2:pr"))  
             
		   (if (<> (setq pr (isub c1 v2)) result) (error "vmisub:c1:v2:pr"))  		   
		   (if (<> (setq pr (isub c1 p2)) result) (error "vmisub:c1:p2:pr"))  		   
		   (if (<> (setq pr (isub c1 c2)) result) (error "vmisub:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (isub v1 v2)) result) (error "vmisub:v1:v2:cr"))  
		   (if (<> (setq cr (isub v1 p2)) result) (error "vmisub:v1:p2:cr"))  
		   (if (<> (setq cr (isub v1 c2)) result) (error "vmisub:v1:c2:cr"))  
		   
		   (if (<> (setq cr (isub p1 v2)) result) (error "vmisub:p1:v2:cr"))  		   
		   (if (<> (setq cr (isub p1 p2)) result) (error "vmisub:p1:p2:cr"))  		   
		   (if (<> (setq cr (isub p1 c2)) result) (error "vmisub:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (isub c1 v2)) result) (error "vmisub:c1:v2:cr"))  
		   (if (<> (setq cr (isub c1 p2)) result) (error "vmisub:c1:p2:cr"))  		   
		   (if (<> (setq cr (isub c1 c2)) result) (error "vmisub:c1:c2:cr"))  
        )) ; end vmisub case           
       ;; Test the vmimul instruction  
         ((= testId "vmimul")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(imul " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (imul v1 v2)) result) (error "vmimul:v1:v2:vr"))  		   
		   (if (<> (setq vr (imul v1 p2)) result) (error "vmimul:v1:p2:vr"))  
		   (if (<> (setq vr (imul v1 c2)) result) (error "vmimul:v1:c2:vr"))  

		   (if (<> (setq vr (imul p1 v2)) result) (error "vmimul:p1:v2:vr"))  		   
		   (if (<> (setq vr (imul p1 p2)) result) (error "vmimul:p1:p2:vr"))  
		   (if (<> (setq vr (imul p1 c2)) result) (error "vmimul:p1:c2:vr"))  
             
		   (if (<> (setq vr (imul c1 v2)) result) (error "vmimul:c1:v2:vr"))  		   
		   (if (<> (setq vr (imul c1 p2)) result) (error "vmimul:c1:p2:vr"))  		   
		   (if (<> (setq vr (imul c1 c2)) result) (error "vmimul:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (imul v1 v2)) result) (error "vmimul:v1:v2:pr"))  
		   (if (<> (setq pr (imul v1 p2)) result) (error "vmimul:v1:p2:pr"))  
		   (if (<> (setq pr (imul v1 c2)) result) (error "vmimul:v1:c2:pr"))  
		   
		   (if (<> (setq pr (imul p1 v2)) result) (error "vmimul:p1:v2:pr"))  		   
		   (if (<> (setq pr (imul p1 p2)) result) (error "vmimul:p1:p2:pr"))  		   
		   (if (<> (setq pr (imul p1 c2)) result) (error "vmimul:p1:c2:pr"))  
             
		   (if (<> (setq pr (imul c1 v2)) result) (error "vmimul:c1:v2:pr"))  		   
		   (if (<> (setq pr (imul c1 p2)) result) (error "vmimul:c1:p2:pr"))  		   
		   (if (<> (setq pr (imul c1 c2)) result) (error "vmimul:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (imul v1 v2)) result) (error "vmimul:v1:v2:cr"))  
		   (if (<> (setq cr (imul v1 p2)) result) (error "vmimul:v1:p2:cr"))  
		   (if (<> (setq cr (imul v1 c2)) result) (error "vmimul:v1:c2:cr"))  
		   
		   (if (<> (setq cr (imul p1 v2)) result) (error "vmimul:p1:v2:cr"))  		   
		   (if (<> (setq cr (imul p1 p2)) result) (error "vmimul:p1:p2:cr"))  		   
		   (if (<> (setq cr (imul p1 c2)) result) (error "vmimul:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (imul c1 v2)) result) (error "vmimul:c1:v2:cr"))  
		   (if (<> (setq cr (imul c1 p2)) result) (error "vmimul:c1:p2:cr"))  		   
		   (if (<> (setq cr (imul c1 c2)) result) (error "vmimul:c1:c2:cr"))  
        )) ; end vmimul case           

         ((= testId "vmidiv")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(idiv " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (idiv v1 v2)) result) (error "vmidiv:v1:v2:vr"))  		   
		   (if (<> (setq vr (idiv v1 p2)) result) (error "vmidiv:v1:p2:vr"))  
		   (if (<> (setq vr (idiv v1 c2)) result) (error "vmidiv:v1:c2:vr"))  

		   (if (<> (setq vr (idiv p1 v2)) result) (error "vmidiv:p1:v2:vr"))  		   
		   (if (<> (setq vr (idiv p1 p2)) result) (error "vmidiv:p1:p2:vr"))  
		   (if (<> (setq vr (idiv p1 c2)) result) (error "vmidiv:p1:c2:vr"))  
             
		   (if (<> (setq vr (idiv c1 v2)) result) (error "vmidiv:c1:v2:vr"))  		   
		   (if (<> (setq vr (idiv c1 p2)) result) (error "vmidiv:c1:p2:vr"))  		   
		   (if (<> (setq vr (idiv c1 c2)) result) (error "vmidiv:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (idiv v1 v2)) result) (error "vmidiv:v1:v2:pr"))  
		   (if (<> (setq pr (idiv v1 p2)) result) (error "vmidiv:v1:p2:pr"))  
		   (if (<> (setq pr (idiv v1 c2)) result) (error "vmidiv:v1:c2:pr"))  
		   
		   (if (<> (setq pr (idiv p1 v2)) result) (error "vmidiv:p1:v2:pr"))  		   
		   (if (<> (setq pr (idiv p1 p2)) result) (error "vmidiv:p1:p2:pr"))  		   
		   (if (<> (setq pr (idiv p1 c2)) result) (error "vmidiv:p1:c2:pr"))  
             
		   (if (<> (setq pr (idiv c1 v2)) result) (error "vmidiv:c1:v2:pr"))  		   
		   (if (<> (setq pr (idiv c1 p2)) result) (error "vmidiv:c1:p2:pr"))  		   
		   (if (<> (setq pr (idiv c1 c2)) result) (error "vmidiv:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (idiv v1 v2)) result) (error "vmidiv:v1:v2:cr"))  
		   (if (<> (setq cr (idiv v1 p2)) result) (error "vmidiv:v1:p2:cr"))  
		   (if (<> (setq cr (idiv v1 c2)) result) (error "vmidiv:v1:c2:cr"))  
		   
		   (if (<> (setq cr (idiv p1 v2)) result) (error "vmidiv:p1:v2:cr"))  		   
		   (if (<> (setq cr (idiv p1 p2)) result) (error "vmidiv:p1:p2:cr"))  		   
		   (if (<> (setq cr (idiv p1 c2)) result) (error "vmidiv:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (idiv c1 v2)) result) (error "vmidiv:c1:v2:cr"))  
		   (if (<> (setq cr (idiv c1 p2)) result) (error "vmidiv:c1:p2:cr"))  		   
		   (if (<> (setq cr (idiv c1 c2)) result) (error "vmidiv:c1:c2:cr"))  
        )) ; end vmidiv case           
                   
        ((= testId "vmimod")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(imod " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (imod v1 v2)) result) (error "vmimod:v1:v2:vr"))  		   
		   (if (<> (setq vr (imod v1 p2)) result) (error "vmimod:v1:p2:vr"))  
		   (if (<> (setq vr (imod v1 c2)) result) (error "vmimod:v1:c2:vr"))  

		   (if (<> (setq vr (imod p1 v2)) result) (error "vmimod:p1:v2:vr"))  		   
		   (if (<> (setq vr (imod p1 p2)) result) (error "vmimod:p1:p2:vr"))  
		   (if (<> (setq vr (imod p1 c2)) result) (error "vmimod:p1:c2:vr"))  
             
		   (if (<> (setq vr (imod c1 v2)) result) (error "vmimod:c1:v2:vr"))  		   
		   (if (<> (setq vr (imod c1 p2)) result) (error "vmimod:c1:p2:vr"))  		   
		   (if (<> (setq vr (imod c1 c2)) result) (error "vmimod:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (imod v1 v2)) result) (error "vmimod:v1:v2:pr"))  
		   (if (<> (setq pr (imod v1 p2)) result) (error "vmimod:v1:p2:pr"))  
		   (if (<> (setq pr (imod v1 c2)) result) (error "vmimod:v1:c2:pr"))  
		   
		   (if (<> (setq pr (imod p1 v2)) result) (error "vmimod:p1:v2:pr"))  		   
		   (if (<> (setq pr (imod p1 p2)) result) (error "vmimod:p1:p2:pr"))  		   
		   (if (<> (setq pr (imod p1 c2)) result) (error "vmimod:p1:c2:pr"))  
             
		   (if (<> (setq pr (imod c1 v2)) result) (error "vmimod:c1:v2:pr"))  		   
		   (if (<> (setq pr (imod c1 p2)) result) (error "vmimod:c1:p2:pr"))  		   
		   (if (<> (setq pr (imod c1 c2)) result) (error "vmimod:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (imod v1 v2)) result) (error "vmimod:v1:v2:cr"))  
		   (if (<> (setq cr (imod v1 p2)) result) (error "vmimod:v1:p2:cr"))  
		   (if (<> (setq cr (imod v1 c2)) result) (error "vmimod:v1:c2:cr"))  
		   
		   (if (<> (setq cr (imod p1 v2)) result) (error "vmimod:p1:v2:cr"))  		   
		   (if (<> (setq cr (imod p1 p2)) result) (error "vmimod:p1:p2:cr"))  		   
		   (if (<> (setq cr (imod p1 c2)) result) (error "vmimod:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (imod c1 v2)) result) (error "vmimod:c1:v2:cr"))  
		   (if (<> (setq cr (imod c1 p2)) result) (error "vmimod:c1:p2:cr"))  		   
		   (if (<> (setq cr (imod c1 c2)) result) (error "vmimod:c1:c2:cr"))  
        )) ; end vmimod case
       ;; Test the vmnadd instruction  
       ((= testId "vmnadd")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(nadd " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (nadd v1 v2)) result) (error "vmnadd:v1:v2:vr"))  		   
		   (if (<> (setq vr (nadd v1 p2)) result) (error "vmnadd:v1:p2:vr"))  
		   (if (<> (setq vr (nadd v1 c2)) result) (error "vmnadd:v1:c2:vr"))  

		   (if (<> (setq vr (nadd p1 v2)) result) (error "vmnadd:p1:v2:vr"))  		   
		   (if (<> (setq vr (nadd p1 p2)) result) (error "vmnadd:p1:p2:vr"))  
		   (if (<> (setq vr (nadd p1 c2)) result) (error "vmnadd:p1:c2:vr"))  
             
		   (if (<> (setq vr (nadd c1 v2)) result) (error "vmnadd:c1:v2:vr"))  		   
		   (if (<> (setq vr (nadd c1 p2)) result) (error "vmnadd:c1:p2:vr"))  		   
		   (if (<> (setq vr (nadd c1 c2)) result) (error "vmnadd:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (nadd v1 v2)) result) (error "vmnadd:v1:v2:pr"))  
		   (if (<> (setq pr (nadd v1 p2)) result) (error "vmnadd:v1:p2:pr"))  
		   (if (<> (setq pr (nadd v1 c2)) result) (error "vmnadd:v1:c2:pr"))  
		   
		   (if (<> (setq pr (nadd p1 v2)) result) (error "vmnadd:p1:v2:pr"))  		   
		   (if (<> (setq pr (nadd p1 p2)) result) (error "vmnadd:p1:p2:pr"))  		   
		   (if (<> (setq pr (nadd p1 c2)) result) (error "vmnadd:p1:c2:pr"))  
             
		   (if (<> (setq pr (nadd c1 v2)) result) (error "vmnadd:c1:v2:pr"))  		   
		   (if (<> (setq pr (nadd c1 p2)) result) (error "vmnadd:c1:p2:pr"))  		   
		   (if (<> (setq pr (nadd c1 c2)) result) (error "vmnadd:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (nadd v1 v2)) result) (error "vmnadd:v1:v2:cr"))  
		   (if (<> (setq cr (nadd v1 p2)) result) (error "vmnadd:v1:p2:cr"))  
		   (if (<> (setq cr (nadd v1 c2)) result) (error "vmnadd:v1:c2:cr"))  
		   
		   (if (<> (setq cr (nadd p1 v2)) result) (error "vmnadd:p1:v2:cr"))  		   
		   (if (<> (setq cr (nadd p1 p2)) result) (error "vmnadd:p1:p2:cr"))  		   
		   (if (<> (setq cr (nadd p1 c2)) result) (error "vmnadd:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (nadd c1 v2)) result) (error "vmnadd:c1:v2:cr"))  
		   (if (<> (setq cr (nadd c1 p2)) result) (error "vmnadd:c1:p2:cr"))  		   
		   (if (<> (setq cr (nadd c1 c2)) result) (error "vmnadd:c1:c2:cr"))  
        )) ; end vmnadd case       
        
        ;; Test the vmisub instruction  
       ((= testId "vmnsub")
        (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(nsub " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (nsub v1 v2)) result) (error "vmnsub:v1:v2:vr"))  		   
		   (if (<> (setq vr (nsub v1 p2)) result) (error "vmnsub:v1:p2:vr"))  
		   (if (<> (setq vr (nsub v1 c2)) result) (error "vmnsub:v1:c2:vr"))  

		   (if (<> (setq vr (nsub p1 v2)) result) (error "vmnsub:p1:v2:vr"))  		   
		   (if (<> (setq vr (nsub p1 p2)) result) (error "vmnsub:p1:p2:vr"))  
		   (if (<> (setq vr (nsub p1 c2)) result) (error "vmnsub:p1:c2:vr"))  
             
		   (if (<> (setq vr (nsub c1 v2)) result) (error "vmnsub:c1:v2:vr"))  		   
		   (if (<> (setq vr (nsub c1 p2)) result) (error "vmnsub:c1:p2:vr"))  		   
		   (if (<> (setq vr (nsub c1 c2)) result) (error "vmnsub:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (nsub v1 v2)) result) (error "vmnsub:v1:v2:pr"))  
		   (if (<> (setq pr (nsub v1 p2)) result) (error "vmnsub:v1:p2:pr"))  
		   (if (<> (setq pr (nsub v1 c2)) result) (error "vmnsub:v1:c2:pr"))  
		   
		   (if (<> (setq pr (nsub p1 v2)) result) (error "vmnsub:p1:v2:pr"))  		   
		   (if (<> (setq pr (nsub p1 p2)) result) (error "vmnsub:p1:p2:pr"))  		   
		   (if (<> (setq pr (nsub p1 c2)) result) (error "vmnsub:p1:c2:pr"))  
             
		   (if (<> (setq pr (nsub c1 v2)) result) (error "vmnsub:c1:v2:pr"))  		   
		   (if (<> (setq pr (nsub c1 p2)) result) (error "vmnsub:c1:p2:pr"))  		   
		   (if (<> (setq pr (nsub c1 c2)) result) (error "vmnsub:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (nsub v1 v2)) result) (error "vmnsub:v1:v2:cr"))  
		   (if (<> (setq cr (nsub v1 p2)) result) (error "vmnsub:v1:p2:cr"))  
		   (if (<> (setq cr (nsub v1 c2)) result) (error "vmnsub:v1:c2:cr"))  
		   
		   (if (<> (setq cr (nsub p1 v2)) result) (error "vmnsub:p1:v2:cr"))  		   
		   (if (<> (setq cr (nsub p1 p2)) result) (error "vmnsub:p1:p2:cr"))  		   
		   (if (<> (setq cr (nsub p1 c2)) result) (error "vmnsub:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (nsub c1 v2)) result) (error "vmnsub:c1:v2:cr"))  
		   (if (<> (setq cr (nsub c1 p2)) result) (error "vmnsub:c1:p2:cr"))  		   
		   (if (<> (setq cr (nsub c1 c2)) result) (error "vmnsub:c1:c2:cr"))  
        )) ; end vmnsub case           

          ;; Test the vmimul instruction  
       ((= testId "vmnmul")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(nmul " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (nmul v1 v2)) result) (error "vmnmul:v1:v2:vr"))  		   
		   (if (<> (setq vr (nmul v1 p2)) result) (error "vmnmul:v1:p2:vr"))  
		   (if (<> (setq vr (nmul v1 c2)) result) (error "vmnmul:v1:c2:vr"))  

		   (if (<> (setq vr (nmul p1 v2)) result) (error "vmnmul:p1:v2:vr"))  		   
		   (if (<> (setq vr (nmul p1 p2)) result) (error "vmnmul:p1:p2:vr"))  
		   (if (<> (setq vr (nmul p1 c2)) result) (error "vmnmul:p1:c2:vr"))  
             
		   (if (<> (setq vr (nmul c1 v2)) result) (error "vmnmul:c1:v2:vr"))  		   
		   (if (<> (setq vr (nmul c1 p2)) result) (error "vmnmul:c1:p2:vr"))  		   
		   (if (<> (setq vr (nmul c1 c2)) result) (error "vmnmul:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (nmul v1 v2)) result) (error "vmnmul:v1:v2:pr"))  
		   (if (<> (setq pr (nmul v1 p2)) result) (error "vmnmul:v1:p2:pr"))  
		   (if (<> (setq pr (nmul v1 c2)) result) (error "vmnmul:v1:c2:pr"))  
		   
		   (if (<> (setq pr (nmul p1 v2)) result) (error "vmnmul:p1:v2:pr"))  		   
		   (if (<> (setq pr (nmul p1 p2)) result) (error "vmnmul:p1:p2:pr"))  		   
		   (if (<> (setq pr (nmul p1 c2)) result) (error "vmnmul:p1:c2:pr"))  
             
		   (if (<> (setq pr (nmul c1 v2)) result) (error "vmnmul:c1:v2:pr"))  		   
		   (if (<> (setq pr (nmul c1 p2)) result) (error "vmnmul:c1:p2:pr"))  		   
		   (if (<> (setq pr (nmul c1 c2)) result) (error "vmnmul:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (nmul v1 v2)) result) (error "vmnmul:v1:v2:cr"))  
		   (if (<> (setq cr (nmul v1 p2)) result) (error "vmnmul:v1:p2:cr"))  
		   (if (<> (setq cr (nmul v1 c2)) result) (error "vmnmul:v1:c2:cr"))  
		   
		   (if (<> (setq cr (nmul p1 v2)) result) (error "vmnmul:p1:v2:cr"))  		   
		   (if (<> (setq cr (nmul p1 p2)) result) (error "vmnmul:p1:p2:cr"))  		   
		   (if (<> (setq cr (nmul p1 c2)) result) (error "vmnmul:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (nmul c1 v2)) result) (error "vmnmul:c1:v2:cr"))  
		   (if (<> (setq cr (nmul c1 p2)) result) (error "vmnmul:c1:p2:cr"))  		   
		   (if (<> (setq cr (nmul c1 c2)) result) (error "vmnmul:c1:c2:cr"))  
        )) ; end vmnmul case           
          ;; Test the vmndiv instruction  
         ((= testId "vmndiv")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(ndiv " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (ndiv v1 v2)) result) (error "vmndiv:v1:v2:vr"))  		   
		   (if (<> (setq vr (ndiv v1 p2)) result) (error "vmndiv:v1:p2:vr"))  
		   (if (<> (setq vr (ndiv v1 c2)) result) (error "vmndiv:v1:c2:vr"))  

		   (if (<> (setq vr (ndiv p1 v2)) result) (error "vmndiv:p1:v2:vr"))  		   
		   (if (<> (setq vr (ndiv p1 p2)) result) (error "vmndiv:p1:p2:vr"))  
		   (if (<> (setq vr (ndiv p1 c2)) result) (error "vmndiv:p1:c2:vr"))  
             
		   (if (<> (setq vr (ndiv c1 v2)) result) (error "vmndiv:c1:v2:vr"))  		   
		   (if (<> (setq vr (ndiv c1 p2)) result) (error "vmndiv:c1:p2:vr"))  		   
		   (if (<> (setq vr (ndiv c1 c2)) result) (error "vmndiv:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (ndiv v1 v2)) result) (error "vmndiv:v1:v2:pr"))  
		   (if (<> (setq pr (ndiv v1 p2)) result) (error "vmndiv:v1:p2:pr"))  
		   (if (<> (setq pr (ndiv v1 c2)) result) (error "vmndiv:v1:c2:pr"))  
		   
		   (if (<> (setq pr (ndiv p1 v2)) result) (error "vmndiv:p1:v2:pr"))  		   
		   (if (<> (setq pr (ndiv p1 p2)) result) (error "vmndiv:p1:p2:pr"))  		   
		   (if (<> (setq pr (ndiv p1 c2)) result) (error "vmndiv:p1:c2:pr"))  
             
		   (if (<> (setq pr (ndiv c1 v2)) result) (error "vmndiv:c1:v2:pr"))  		   
		   (if (<> (setq pr (ndiv c1 p2)) result) (error "vmndiv:c1:p2:pr"))  		   
		   (if (<> (setq pr (ndiv c1 c2)) result) (error "vmndiv:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (ndiv v1 v2)) result) (error "vmndiv:v1:v2:cr"))  
		   (if (<> (setq cr (ndiv v1 p2)) result) (error "vmndiv:v1:p2:cr"))  
		   (if (<> (setq cr (ndiv v1 c2)) result) (error "vmndiv:v1:c2:cr"))  
		   
		   (if (<> (setq cr (ndiv p1 v2)) result) (error "vmndiv:p1:v2:cr"))  		   
		   (if (<> (setq cr (ndiv p1 p2)) result) (error "vmndiv:p1:p2:cr"))  		   
		   (if (<> (setq cr (ndiv p1 c2)) result) (error "vmndiv:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (ndiv c1 v2)) result) (error "vmndiv:c1:v2:cr"))  
		   (if (<> (setq cr (ndiv c1 p2)) result) (error "vmndiv:c1:p2:cr"))  		   
		   (if (<> (setq cr (ndiv c1 c2)) result) (error "vmndiv:c1:c2:cr"))  
        )) ; end vmndiv case           
          ;; Test the vmnmod instruction  
        ((= testId "vmnmod")
         (begin 
           ;; Reference the arguments for this test.
           (setq p1 (setq c1 (setq v1 (argFetch 2))))         
           (setq p2 (setq c2 (setq v2 (argFetch 3))))         
           ;; Use the emulator to compute the correct result.
           (setq result (eval (append "(nmod " v1 " " v2 ")")))         
           ;; Test the compiler and compare with the correct result.
		   (if (<> (setq vr (nmod v1 v2)) result) (error "vmnmod:v1:v2:vr"))  		   
		   (if (<> (setq vr (nmod v1 p2)) result) (error "vmnmod:v1:p2:vr"))  
		   (if (<> (setq vr (nmod v1 c2)) result) (error "vmnmod:v1:c2:vr"))  

		   (if (<> (setq vr (nmod p1 v2)) result) (error "vmnmod:p1:v2:vr"))  		   
		   (if (<> (setq vr (nmod p1 p2)) result) (error "vmnmod:p1:p2:vr"))  
		   (if (<> (setq vr (nmod p1 c2)) result) (error "vmnmod:p1:c2:vr"))  
             
		   (if (<> (setq vr (nmod c1 v2)) result) (error "vmnmod:c1:v2:vr"))  		   
		   (if (<> (setq vr (nmod c1 p2)) result) (error "vmnmod:c1:p2:vr"))  		   
		   (if (<> (setq vr (nmod c1 c2)) result) (error "vmnmod:c1:c2:vr"))  
             		   
		   (if (<> (setq pr (nmod v1 v2)) result) (error "vmnmod:v1:v2:pr"))  
		   (if (<> (setq pr (nmod v1 p2)) result) (error "vmnmod:v1:p2:pr"))  
		   (if (<> (setq pr (nmod v1 c2)) result) (error "vmnmod:v1:c2:pr"))  
		   
		   (if (<> (setq pr (nmod p1 v2)) result) (error "vmnmod:p1:v2:pr"))  		   
		   (if (<> (setq pr (nmod p1 p2)) result) (error "vmnmod:p1:p2:pr"))  		   
		   (if (<> (setq pr (nmod p1 c2)) result) (error "vmnmod:p1:c2:pr"))  
             
		   (if (<> (setq pr (nmod c1 v2)) result) (error "vmnmod:c1:v2:pr"))  		   
		   (if (<> (setq pr (nmod c1 p2)) result) (error "vmnmod:c1:p2:pr"))  		   
		   (if (<> (setq pr (nmod c1 c2)) result) (error "vmnmod:c1:c2:pr"))  
             		   
		   (if (<> (setq cr (nmod v1 v2)) result) (error "vmnmod:v1:v2:cr"))  
		   (if (<> (setq cr (nmod v1 p2)) result) (error "vmnmod:v1:p2:cr"))  
		   (if (<> (setq cr (nmod v1 c2)) result) (error "vmnmod:v1:c2:cr"))  
		   
		   (if (<> (setq cr (nmod p1 v2)) result) (error "vmnmod:p1:v2:cr"))  		   
		   (if (<> (setq cr (nmod p1 p2)) result) (error "vmnmod:p1:p2:cr"))  		   
		   (if (<> (setq cr (nmod p1 c2)) result) (error "vmnmod:p1:c2:cr"))  
             		   
		   (if (<> (setq cr (nmod c1 v2)) result) (error "vmnmod:c1:v2:cr"))  
		   (if (<> (setq cr (nmod c1 p2)) result) (error "vmnmod:c1:p2:cr"))  		   
		   (if (<> (setq cr (nmod c1 c2)) result) (error "vmnmod:c1:c2:cr"))  
        )) ; end vmnmod case  
    ) ; end cond
    (append "result = " result " vr = " vr)
    ) ; end selfTest9




;;**EXPORTKEY**:CompilerLib:%SELFTESTERR
;;*********************************************************************
;; Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: These child Lambdas support the CompilerLib self test process.
;;*********************************************************************             

                                                           
;;*********************************************************************
;; Function selfTest must be compiled as a stand alone C function 
;; and linked into the host interface layer.
;;*********************************************************************
(deforphan CompilerLib:selfTestErr(testId ...) 
   vars:(v1 v2)  
   pvars:(p1 p2)  
   cvars:(c1 c2)  
     
     
  ;; Use the emulator to compute the correct result.
  (defun errHandler(err) (writeln "Foo got the following error: " err))
  (onError errHandler)
  (error "badFoo")  
  ) ; end selfTestErr




;;**EXPORTKEY**:CompilerLib:@%C_EVAL_FUNCTION
;#text#
#if 0
NAME:	F%FILENAME%_Eval%NN%
#endif

TVAL F%FILENAME%_Eval%NN%(LpXCONTEXT gCP,LpTHREAD gTP,TLambda* myLambda,NUM argc, TVAL argv[])
{   
    /* RUNTIME REGISTER POINTERS */
	register LpTVAL		argsPtr;	/* Pointer to Lambda args 	*/
	register LpBIND		varsPtr;	/* Pointer to Lambda vars 	*/
	register LpBIND		pvarsPtr;	/* Pointer to Lambda pvars 	*/
	register LpBIND		cvarsPtr;	/* Pointer to Lambda cvars 	*/
	register TSymbol**	pcodePtr;	/* Pointer to pcode vector 	*/

	StartFrame
	DeclareTVAL(__Ec);		// Error code
	DeclareTVAL(__Ret);		// Return Value 
	
	/* -VARS_TVAL_DECLARATIONS- */
	%VARS_TVAL_DECLARATIONS%
	
	EndFrame

	/* -AUTO_ARG_CHECKING- */ 
	if (argc < %AUTO_ARG_CHECKING%)
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);
		}
	
	/* INITIALIZATION. */
	
	argsPtr = argv;
	varsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->TemporaryVariables);
	pvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PersistantVariables);
	cvarsPtr = (LpBIND)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->ClassVariables); 
	pcodePtr = (TSymbol**)gCP->FSmartbase_ObjectPtr((POINTER)gCP,gTP,&myLambda->PcodeVector); 
	
	/* -INITIALIZE_VARS_DECLARATIONS- */
	%INITIALIZE_VARS_DECLARATIONS%
	
	/* START OF GENERATED CODE. */	
	%CODE%   

 
 IllegalValue:
     Stack(__Ret) = gCP->FVmScript_ERROR_ILLEGAL_VALUE;
     goto Quit;

 IllegalDivide:

    Stack(__Ret) = gCP->FVmScript_ERROR_DIVIDE_BY_ZERO;
    goto Quit;

 OverFlowError: 
 
    Stack(__Ret) = gCP->FVmScript_ERROR_OVERFLOW;
    goto Quit;

Quit:
	FrameExit(Stack(__Ret));
}





;;**EXPORTKEY**:CompilerLib:@%C_HEADER
;#text#
#if 0
%FILENAME%.c

SUMMARY: 			This Lambda implements the %FILENAME% Lambda as a registered
	          		C user defined function. Each compiled instruction is
	          		marked with a boxed comment lines for ease of human understanding.
	         
NOTE: 	   			This code was machine generated by CompilerLib.

AUTHORS:            CompilerLib

#endif

#define _Lambda_COMPILER_ 1
#include "fsmtbase.h"

extern TVAL F%FILENAME%_Init(LpXCONTEXT gCP,LpTHREAD gTP);
extern TVAL F%FILENAME%_MakeNative(LpXCONTEXT gCP,LpTHREAD gTP,NUM argc,TVAL argv[]);

/* Lambda native C evaluator function declarations. */
$$$EXTERNS$$$

/********************************************************************/ 
/* BEGIN MACRO DEFINITIONS
/********************************************************************/

#define RealValue(x, pTval, lbl) \
	switch ((pTval)->Tag) { \
	case TYBOLE: \
	case TYCHAR: \
	case TYNUM:    x = (REAL)((pTval)->u.Int);   break; \
	case TYREAL: \
	case TYDATE: \
	case TYMONEY:  x = (pTval)->u.Real;  break; \
	case TYSHORT:  x = (REAL)((pTval)->u.Short); break; \
	case TYTEXT:   x = gCP->atof((pTval)->u.Text); break; \
	case TYSTRING: x = gCP->atof((char *)(gCP->FSmartbase_ObjectPtr((POINTER)gCP, gTP, (pTval)))); break; \
	case TYVOID: \
	default: goto lbl; }

#define IntValue(i, pTval, lbl) \
	switch ((pTval)->Tag) { \
	case TYBOLE: \
	case TYCHAR: \
	case TYNUM:    i = (pTval)->u.Int;   break; \
	case TYREAL: \
	case TYDATE: \
	case TYMONEY:  i = (NUM)((pTval)->u.Real);  break; \
	case TYSHORT:  i = (NUM)((pTval)->u.Short); break; \
	case TYTEXT:   i = gCP->atol((pTval)->u.Text); break; \
	case TYSTRING: i = gCP->atol((char *)(gCP->FSmartbase_ObjectPtr((POINTER)gCP, gTP, (pTval)))); break; \
	case TYVOID: \
	default: goto lbl; }

#define IsNative(Pred, pTval) \
	switch ((pTval)->Tag) { \
	case TYVOID:  \
	case TYBOLE:  \
	case TYCHAR:  \
	case TYNUM:   \
	case TYREAL:  \
	case TYDATE:  \
	case TYMONEY: \
	case TYSHORT: \
	case TYTEXT:  Pred = 1; break; \
	default: Pred = 0; }

#define IsScalar(Pred, pTval) \
	switch ((pTval)->Tag) { \
	case TYVOID:  \
	case TYBOLE:  \
	case TYCHAR:  \
	case TYNUM:   \
	case TYREAL:  \
	case TYDATE:  \
	case TYMONEY: \
	case TYSHORT: \
	case TYTEXT:  \
	case TYSTRING: Pred = 1; break; \
	default: Pred = 0; }

/*	----------------------------------------------------------------------------
CALC - Macro to perform numeric operation on two TVALs that contain a numeric
Helper MACRO for child Lambdas

t1			[in] TVAL containing a numeric value (NUM,REAL,DATE,MONEY,...)
t2			[in] TVAL containing a numeric value
op			[in] numeric operation (+, -, *, /)
lbl			[in] label for jump must be distinct for each macro call in an Lambda
Returns:	TVAL containing result in result
			result is of type TYREAL unless both Args are of type TYNUM
	------------------------------------------------------------------------- */
#define CALC(t1, t2, op, lbl, R) \
	if (t1.Tag == TYNUM && t2.Tag == TYNUM) \
	{	Result.Tag = TYNUM; \
		Result.u.Int = t1.u.Int op t2.u.Int; \
		__asm{ jno lbl } \
		Result.Tag = TYREAL; \
		Result.u.Real = (REAL)(t1.u.Int) op t2.u.Int; \
lbl:	; \
	} \
	else \
	{	RealValue(R, &t1, BadTypeError) \
		RealValue(Result.u.Real, &t2, BadTypeError) \
		Result.Tag = TYREAL; \
		Result.u.Real op= R; \
	}
  

/*	----------------- Miscellaneous Macros ------------------------  */
  
#define inRange(v,s,e)        (v >= s && v < e)  
#define CharArray(tval)       ((LpCHAR)*((TString*)((tval).u.Object))->itsCString)
#define String(tval)          ((TString*)((tval).u.Object))
#define SymbolArray(tval)     ((LpCHAR)*((TSymbol*)((tval).u.Object))->itsCString)
#define Symbol(tval)          ((TSymbol*)((tval).u.Object)) 
#define Vector(tval)          ((TVector*)((tval).u.Object))
#define NumVector(tval)       ((TNumVector*)((tval).u.Object))
#define IntVector(tval)       (tval.u.IntVector)
#define FltVector(tval)       ((TFltVector*)((tval).u.Object))
#define ByteVector(tval)      ((TByteVector*)((tval).u.Object))
#define BitVector(tval)       ((TBitVector*)((tval).u.Object))
#define ObjVector(tval)       ((TObjVector*)((tval).u.Object))
#define PcodeVector(tval)     ((TPcodeVector*)((tval).u.Object))
#define Structure(tval)		  ((TStructure*)((tval).u.Object))
#define Directory(tval)       ((TDirectory*)((tval).u.Object))
#define Dictionary(tval)      ((TDictionary*)((tval).u.Object))
#define Matrix(tval)          ((TMatrix*)((tval).u.Object))
#define NumMatrix(tval)       ((TNumMatrix*)((tval).u.Object))
#define IntArray(tval)        ((LpNUM)*((TIntVector*)((tval).u.Object))->itsIntArray)
#define TvalArray(tval)       ((LpTVAL)*((TVector*)((tval).u.Object))->itsTvalArray)
#define BitArray(tval)        ((LpCHAR)*((TBitVector*)((tval).u.Object))->itsBitArray)
#define ByteArray(tval)       ((LpCHAR)*((TByteVector*)((tval).u.Object))->itsByteArray)
#define RealArray(tval)       ((LpREAL)*((TNumVector*)((tval).u.Object))->itsRealArray)
#define FloatArray(tval)      ((LpFLOAT)*((TFltVector*)((tval).u.Object))->itsFloatArray)
#define ObjArray(tval)        ((struct TObject**)*((TObjVector*)((tval).u.Object))->itsObjectArray)
#define PcodeArray(tval)      ((LpNUM)*((TPcodeVector*)((tval).u.Object))->itsInstructionArray)
#define TvalMatrix(tval)      ((LpTVAL)*((TMatrix*)((tval).u.Object))->itsTvalMatrix)
#define RealMatrix(tval)      ((LpREAL)*((TNumMatrix*)((tval).u.Object))->itsRealMatrix)
#define BondArray(tval)       ((LpBIND)*((TDictionary*)((tval).u.Object))->itsDictionaryArray)
#define BindArray(tval)       ((LpBIND)*((TStructure*)((tval).u.Object))->itsDictionaryArray)
#define PBindArray(tval)      ((LpPBIND)*((TDirectory*)((tval).u.Object))->itsDirectoryArray) 
#define _TObject_TypeFlag(tt) atHMChar(gCP->TObject_TypeFlag,(tt))

#if 0 
Setup macros for arithmetic overflow conditions  
#endif

#define JumpNoOverflow(label)		_asm { jno label }
#define JumpOnOverflow(label)		_asm { jo label }

/********************************************************************/ 
/* END MACRO DEFINITIONS
/********************************************************************/
 

#if 0
F%FILENAME%_Init

This function initializes the native C Code support for the %FILENAME% Lambda, and
registers all necessary support functions to the Smartbase environment. There are
several steps to this process:

	o	The F%FILENAME%.c & F%FILENAME%.h source files must be compiled and linked with
		the glue layer code. 
	
	o	The F%FILENAME%_Init function must be called during engine initialization.

	o	After the %FILENAME% Lambda has been loaded into memory, the F%FILENAME%_MakeNative 
		function must be called, which links the %FILENAME% Lambda to the F%FILENAME%_Eval
		function, so the %FILENAME% Lambda can be evaluated at native C speed instead of 
		at emulated speed.
	
	Hint: 	After the %FILENAME% Lambda has been loaded into memory, the F%FILENAME%_MakeNative 
			function may be called, from the console, as follows: (%FILENAME%_MakeNative %FILENAME%)

#endif

TVAL F%FILENAME%_Init(LpXCONTEXT gCP,LpTHREAD gTP)
{
	StartFrame
	DeclareTVAL(lEc);
	EndFrame
 
	/* Register the Smartbase functions contained in this package */
	Stack(lEc) = gCP->FSmartbase_RegisterCProcedure((POINTER)gCP,gTP,(LpCHAR)"%FILENAME%_MakeNative",(LpFUNC)&F%FILENAME%_MakeNative);
	ExitOnError(Stack(lEc));
	
	FrameExit(gCP->Tval_TRUE);
}

#if 0
F%FILENAME%_MakeNative


Usage:		(%FILENAME%_MakeNative %FILENAME%)


The %FILENAME%_MakeNative Function receives an instance of the %FILENAME% Lambda 
as an argument. The %FILENAME%_MakeNative Function links the %FILENAME% Lambda to 
the F%FILENAME%_Eval function, so the %FILENAME% Lambda can be evaluated at native 
C speed instead of at emulated speed.

Note:
 1.	After the conversion to native, the %FILENAME% Lambda should perform exactly as prior
	to conversion with the exception that it should evaluate faster.

#endif

TVAL F%FILENAME%_MakeNative(LpXCONTEXT gCP,LpTHREAD gTP,NUM argc, TVAL argv[])
{
	// Initialize the global symbols and protect them from garbage collection.
	StartFrame
	DeclareTVAL(myLambda);
	DeclareTVAL(childLambda);
	DeclareTVAL(lEc);
	EndFrame

	/* Make sure we pass only one argument and that must be our Lambda. */
	
	if ((argc != 1) || (argv[0].Tag != TYLAMBDA))
		{
		FrameExit(gCP->TObject_ERROR_INVALID_ARGLIST);		
		}
		
	/* Link the Lambda (argument) to the F%FILENAME%_Eval function. 		   */
	/* Note: This allows the %FILENAME% Lambda to be evaluated faster. 	   */
	/* Warning: Passing the wrong Lambda or an out of date %FILENAME% Lambda */
	/*			to this function will result in unpredictable behavior.    */
		
$$$EVALUATORS$$$

	FrameExit(gCP->TObject_TRUE);
}




;;**EXPORTKEY**:CompilerLib:@@defaultLexer
(defriend CompilerLib:defaultLexer(inString)
;; ********************************************************************
;; summary:  This Lambda converts an input string into a vector of
;;           recognized lexemes. It is the default lexical analyzer
;;           for the ParseLib compiler generator.
;;           This Lambda may be modified, in any way, by the user.
;; Parms:    inString   The source string to be broken into lexemes.
;; return:   tokenList  The vector of recognized lexemes.
;; ********************************************************************
    pvars:(;; Persistent variables
           CH                  ;; The current input character from the input string
           INLEN               ;; The length of the input string
           IP                  ;; The input pointer for the input string
           INSTRING            ;; The string of the input characters to be parsed
           keepWhitespaceSW    ;; Switch to keep all whitespace strings
           lowerCaseSW         ;; Switch to convert all names into lower case
           oldKB               ;; The old vector of character break parsing routines
           operatorList        ;; The vector of operator symbols
           KB                  ;; The vector of character break parsing routines
           SB                  ;; The vector of string terminator pairs
           tokenDirectory      ;; Lexicon of tokens and their attributes
           tokenList           ;; The vector of lexical tokens
           TP                  ;; The output pointer for the token output vector
           ;; Methods list
           addStringDelimiters ;; Add a pair of string delimiters to the lexical analyzer
           _default            ;; Recognize this one character
           defaultTokenRule    ;; Modified default rule for adding attributes to a parsed token
           _Ignore             ;; Ignore this character parsing routine
           _Initialize         ;; Initialize the vector of character break parsing routines
           _recFraction        ;; Recognize all fractions
           _recInteger         ;; Recognize all integers
           _recName            ;; Recognize all names
           _recNumber          ;; Recognize all numbers
           _recOperators       ;; Recognize all operator symbols
           _recSpecial         ;; Recognize all special symbols
           _recString          ;; Recognize all delimited strings
           _setFeatures        ;; Give features to a recognized token
           _whiteSpace         ;; Ignore all whitespace characters
           turnFractionsOnOff  ;; Turns fraction recognition on/off
           ) ;; end of persistent variables
    vars:(token oldIP)
    ;;************************************************************************
    ;;  Define the child Lambdas for this parent.
    ;;************************************************************************
    ;; Add a named pair of string delimiters to the lexical analyzer.
    (defun addStringDelimiters(name start end)
       vars:(tmpLambda)
       ;;  Initialize the ParseLib once and only once.
       (if (= KB #void) (_Initialize))
       ;;  If this is the first delimiter pair, start a new directory.
       (setq CH start[0])
       (if (= SB[CH] #void) 
           (begin
              (setq SB[CH] (new Structure:))
              (setq KB[CH] _recString)
           )) ;; end if
       ;;  Set the character directory with this new string delimiter pair.
       (setq SB[CH][name] (new Vector: 2 start end))
       ) ;; end addStringDelimiters
    ;;  Ignore this character parsing routine.
    (defun _Ignore() (++ IP))
    ;;  Create the character break vector.
    (defun _Initialize()
        vars:(i)
        (setq KB (new Vector: 256))
        (setq SB (new Vector: 256))
        (setq operatorList #(#\= #\< #\> #\! #\^ #\~ #\+ #\/ #\* #\- #\| #\&))
        ;; Actual mapping of parse routines to break character positions.
        (loop for i from 0 until 256 do (setq KB[i] _recSpecial))
        (loop for i from 0 to 32 do (setq KB[i] _whiteSpace)) 
        (loop for i from 128 until 256 do (setq KB[i] _whiteSpace)) 
        (loop for i from (code #\a) to (code #\z) do (setq KB[i] _recName)) 
        (loop for i from (code #\A) to (code #\Z) do (setq KB[i] _recName)) 
        (loop for i from (code #\0) to (code #\9) do (setq KB[i] _recNumber)) 
        (loop for i from 0 until (length operatorList) do (setq KB[operatorList[i]] _recOperators)) 
        (setq KB[(code #\_)] _recName) 
        (setq KB[(code #\.)] _recFraction) 
        (setq oldKB (copy KB))
        ) ;; end of _Initialize
    ;;  Recognize all fractions.
    (defun _recFraction()
        vars:(oldIP result)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize fraction portion of number (if any)
        (if (isCharNumeric CH)
            then
            (begin
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
               (setq result (number (substring INSTRING oldIP (subi IP 1))))
               ) ; end then
            else
            (setq result (symbol ".")) 
            ) ; end recognize fraction.
        (setq tokenList[TP] result)
        (++ TP)
        ) ;; end _recFraction
    ;;  Recognize all names.
    (defun _recName()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isCharName CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (if lowerCaseSW
            (setq tokenList[TP] (symbol (downcase (substring INSTRING oldIP (subi IP 1)))))
            (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
            ) ; end if
        (++ TP)
        ) ;; end _recName
    ;;  Recognize all numbers.
    (defun _recNumber()
        vars:(oldIP num fraction)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Recognize fraction portion of number (if any)
        (if (and (= CH #\.) (isCharNumeric INSTRING[(add1 IP)]))
            (begin
               (setq fraction true)
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
            )) ; end recognize fraction.
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (if (= fraction true) (setq num (number num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recNumber
    ;;  Recognize all integers.
    (defun _recInteger()
        vars:(oldIP num)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recInteger
    ;;  Recognize all operator symbols.
    (defun _recOperators()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isMember CH operatorList) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
        (++ TP)
        ) ;; end _recOperators
    ;; Recognize all special symbols.
    (defun _recSpecial() (setq tokenList[TP] (symbol (string CH))) (++ IP) (++ TP))
    ;; Recognize all delimited strings.
    (defun _recString()
        vars:(oldIP i delimPairs delimLen result              
              name this start end startLen endLen)
        (setq oldIP IP)
        ;; Check for a starting string delimiter.
        (setq delimPairs SB[CH])
        (setq delimLen (length delimPairs))
        (loop for i from 0 until delimLen do
           (setq name delimPairs[i 0])
           (setq start delimPairs[i 1][0])
           (setq startLen (length start))
           (setq this (mid INSTRING IP startLen))
           (if (= start this)
               (begin
                  (setq end delimPairs[i 1][1])
                  (setq endLen (length end))
                  (+= IP startLen)
                  (while (< IP INLEN) do
                     (if (= INSTRING[IP] end[0])
                         (begin
                            (setq this (mid INSTRING IP endLen))
                            (if (= end this)
                                (begin
                                   (+= IP endLen)
                                   (setq result (substring INSTRING oldIP (subi IP 1)))
                                   ;; Ignore all whitespace delimited strings
                                   (if (<> (left name 10) "Whitespace")
                                       (begin
                                          (setq tokenList[TP] (new Vector: 2 name result))
                                          (++ TP)
                                          )) ; end  if
                                   (return TP)              
                                   )) ; end inner if
                            )) ; end outter if
                     (++ IP)
                     ) ; end while
                  (setq result (substring INSTRING oldIP (subi IP 1)))
                  ;; Ignore all whitespace delimited strings
                  (if (or keepWhitespaceSW (<> (left name 10) "Whitespace"))
                      (begin
                         (setq tokenList[TP] (new Vector: 2 name result))
                         (++ TP)
                         )) ; end  if
                  (return TP)              
                  )) ; end if 
           ) ;; end loop
        ;; If we get here, this is not the start of a delimited string,
        ;; so invoke the old lexeme parser for this character.
        (oldKB[CH])) ;; end _recString
     ;; Give features to a recognized token
     (defun _setFeatures(token oldIP)
        vars:(parseTree treeIndex treeLen tokenAttr)
        ;; This Lambda tests compiled FSM style methods of attributing each parsed token.
        (setq tokenAttr tokenDirectory[token])
        (if (= tokenAttr #void)
            then
            ;; Create an attributed token using default rule
            (setq tokenAttr (defaultTokenRule token))
            else
            ;; Copy the attributes and set the Value from the dictionary
            (begin
               (setq tokenAttr (copy tokenAttr))
               (setq tokenAttr.Value token)
            )) ; end if
        ;; Set the displacement of the token in the source string
        (setq tokenAttr.Charpos (integer oldIP))
        (setq tokenList[(subi TP 1)] tokenAttr)
        true) ;; end of _setFeatures
    ;; Turns fraction recognition on/off.
    (defun turnFractionsOnOff(onOffSW)
        vars:(i)
        ;; Turn fractions on?
        (if onOffSW
            ;; Turn fractions on
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recNumber)) 
                  (setq oldKB[i] _recNumber)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recFraction))
               (setq oldKB[(code #\.)] _recFraction)
               ) ; end turn fractions on
            ;; Turn fractions off
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recInteger)) 
                  (setq oldKB[i] _recInteger)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recSpecial))
               (setq oldKB[(code #\.)] _recSpecial)
               ) ; end turn fractions off
            ) ; end if
        ) ;; end of turnFractionsOnOff
    ;;  Ignore all whitespace characters.
    (defun _whiteSpace()        
        vars:(oldIP i result)
        ;; Save old IP address
        (setq oldIP IP)
        ;; Loop until all whitespace chars are discovered
        (setq CH INSTRING[(++ IP)]) 
        (while (and (> CH 0) (<= CH 32)) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Return whitespace token (iff keepWhitespaceSW is true)
        (if keepWhitespaceSW
            (begin
               (setq result (substring INSTRING oldIP (subi IP 1)))
               (setq tokenList[TP] (new Vector: 2 "Whitespace" result))
               (++ TP)              
               )) ; end if
        ) ;; end _whiteSpace
    ;;************************************************************************
    ;;  Define the main code routines for this parent.
    ;;************************************************************************
    ;;  Initialize the ParseLib once and only once.
    (if (= KB #void) (_Initialize))
    ;;  Initialize the output token vector. 
    (setq tokenList (new Vector: 0))
    (setq TP 0)
    ;;  Recognize each character in the input string.
    (setq INSTRING inString)
    (setq INLEN (length INSTRING))
    (setq IP 0)
    (while (< IP INLEN) do
        (setq oldIP IP)
        ;; Retrieve the next input character
        (setq CH INSTRING[IP])
        ;; Invoke the parse routine for this input character
        (KB[CH])
        ;; If a token was recognized, give it some features
        (if (and (> TP 0) (not (isStructure (setq token tokenList[(subi TP 1)])))) (_setFeatures token oldIP))
        ) ;; end while
    ;;  Return the token list as the output
    tokenList) ;; end defaultLexer














;;**EXPORTKEY**:CompilerLib:@UserDefinedFunctions
;; ************************************************
;; CompilerLib User defined functions
;; ************************************************





;;**EXPORTKEY**:CompilerLib:_LEXRULE_LMAIN
;; ************************************************
;; LMAIN user defined Lexical Rule implementation
;; Summary: This Lambda implements the LMAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_LEXRULE_LMAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  _tkch
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 "")
   (setq _tkn 0)
   (setq _repeatSW true)
   (setq _oldIp _ip)

   (if (= _verboseLexCount.LMAIN #void) 
          (setq _verboseLexCount.LMAIN 1) 
          (setq _verboseLexCount.LMAIN (iadd _verboseLexCount.LMAIN 1)))

   (if (and (<> _verboseLexIn.LMAIN #void) (> _verboseLexIn.LMAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting LMAIN Rule on: " (_showInput 20)))
     (setq _ip0 _ip)
     (setq _tkch (iadd _ip 1))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************












     ;; ====================
     ;; case: "void"
     ;; ====================
     (if (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "void" << ($ASIS $ch #void  Term: true Constant: true Void: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void  Term: true Constant: true Void: true) )
            (if _verbose
                (writeRule
                     {MAIN: "void" << ($ASIS $ch #void  Term: true Constant: true Void: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "void"
     ;; ====================
     ;; case: PoundSign
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_PoundSign[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: "void"
         ;; ====================
         (if (if (= (setq _tk2 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: PoundSign "void" << ($ASIS $ch #void  Term: true Constant: true  Void: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch #void  Term: true Constant: true  Void: true) )
                (if _verbose
                    (writeRule
                         {MAIN: PoundSign "void" << ($ASIS $ch #void  Term: true Constant: true  Void: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "void"
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_LeftParen[_tk2] 1)) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: "obj"
             ;; ====================
             (if (if (= (setq _tk3 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 3)) 3))) "obj") true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Bar
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk4] 1)) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: PoundSign LeftParen "obj" Bar << ($ASIS $ch $3 VecStart: true Constant: true) >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (_tkASIS _tkch _tk3 VecStart: true Constant: true) )
                        (if _verbose
                            (writeRule
                                 {MAIN: PoundSign LeftParen "obj" Bar << ($ASIS $ch $3 VecStart: true Constant: true) >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Bar
               ) ; end begin
             ) ; end case : "obj"
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : PoundSign
     ;; ====================
     ;; case: DQuote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NotDQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotDQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: DQuote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2 String: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : DQuote
           ) ; end begin
         ) ; end case : NotDQuote*
       ) ; end begin
     ) ; end case : DQuote
     ;; ====================
     ;; case: Bar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NotBar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotBar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Bar
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Bar NotBar* Bar << ($ASIS $ch $2  Term: true Name: true LispName: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2  Term: true Name: true LispName: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Bar NotBar* Bar << ($ASIS $ch $2  Term: true Name: true LispName: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Bar
           ) ; end begin
         ) ; end case : NotBar*
         ;; *********************************************************
         ;; RULE: MAIN: Bar << ($OUT $ch $1 Bar: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch _tk1 Bar: true) )
            (if _verbose
                (writeRule
                     {MAIN: Bar << ($OUT $ch $1 Bar: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Bar
     ;; ====================
     ;; case: Quote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NameStart
         ;; ====================
         (if (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk2] 1)) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NameChar*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Quote NameStart NameChar* << ($ASIS $ch (makeQuotedSymbol (append $2 $3)) Symbol: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch (makeQuotedSymbol (append _tk2 _tk3)) Symbol: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Quote NameStart NameChar* << ($ASIS $ch (makeQuotedSymbol (append $2 $3)) Symbol: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : NameChar*
           ) ; end begin
         ) ; end case : NameStart
       ) ; end begin
     ) ; end case : Quote
     ;; ====================
     ;; case: NameStart
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NameChar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true ) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (symbol (append _tk1 _tk2)) Name: true Term: true ) )
                (if _verbose
                    (writeRule
                         {MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true ) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NameChar*
       ) ; end begin
     ) ; end case : NameStart
     ;; ====================
     ;; case: Digit+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch (integer _tk1) Number: true Integer: true Term: true) )
            (if _verbose
                (writeRule
                     {MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Digit+
     ;; ====================
     ;; case: Period
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Digit+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2)) Number: true Term: true) )
                (if _verbose
                    (writeRule
                         {MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Digit+
       ) ; end begin
     ) ; end case : Period
     ;; ====================
     ;; case: /
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: *
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (or (<> _tkIN[_ip] #\*) (<> _tkIN[(iadd _ip 1)] #\/)) ) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: *
                 ;; ====================
                 (if (if (= (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: /
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip4))
                       (begin (setq _ip5 _ip)
                         ;; *********************************************************
                         ;; RULE: MAIN: / * Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}* * / << true >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  true )
                            (if _verbose
                                (writeRule
                                     {MAIN: / * Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}* * / << true >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (goto Skip:))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : /
                   ) ; end begin
                 ) ; end case : *
               ) ; end begin
             ) ; end case : Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}*
           ) ; end begin
         ) ; end case : *
         ;; ====================
         ;; case: /
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NotEol*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotEol[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Eol?
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Eol[_tk4] 1)) true (begin (setq _ip (isub _ip 1)) (setq _tk4 {}) true))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: / / NotEol* Eol? << true >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  true )
                        (if _verbose
                            (writeRule
                                 {MAIN: / / NotEol* Eol? << true >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Eol?
               ) ; end begin
             ) ; end case : NotEol*
           ) ; end begin
         ) ; end case : /
       ) ; end begin
     ) ; end case : /
     ;; ====================
     ;; case: #
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\#) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: <
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NameStart
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: NameChar*
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Whitespace*
                     ;; ====================
                     (if (begin (setq _i 0) (setq _tk5 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk5[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                       (begin (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit*
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                           (begin (setq _ip6 _ip)
                             ;; ====================
                             ;; case: >
                             ;; ====================
                             (if (if (= (setq _tk7 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip6))
                               (begin (setq _ip7 _ip)
                                 ;; *********************************************************
                                 ;; RULE: MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_tkOUT _tkch (inspect (number _tk6)) vtyp: obj: Term: true) )
                                    (if _verbose
                                        (writeRule
                                             {MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (goto Skip:))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : >
                           ) ; end begin
                         ) ; end case : Digit*
                       ) ; end begin
                     ) ; end case : Whitespace*
                   ) ; end begin
                 ) ; end case : NameChar*
               ) ; end begin
             ) ; end case : NameStart
           ) ; end begin
         ) ; end case : <
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: Any
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (symbol (string _tk1)) Default: true) )
            (if _verbose
                (writeRule
                     {MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Any
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: $LIST ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tkLIST )
            (if _verbose
                (writeRule
                     {MAIN: Eof :: $LIST ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize 
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule LMAIN on: " (_showInput 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseLexIn.LMAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseLexCount.LMAIN _verboseLexIn.LMAIN) (error "Count" "in Routine LMAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _LEXRULE_LMAIN
















;;**EXPORTKEY**:CompilerLib:_LEXRULE_MAIN
;; ************************************************
;; MAIN user defined Lexical Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_LEXRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  _tkch
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 "")
   (setq _tkn 0)
   (setq _repeatSW true)
   (setq _oldIp _ip)

   (if (= _verboseLexCount.MAIN #void) 
          (setq _verboseLexCount.MAIN 1) 
          (setq _verboseLexCount.MAIN (iadd _verboseLexCount.MAIN 1)))

   (if (and (<> _verboseLexIn.MAIN #void) (> _verboseLexIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting MAIN Rule on: " (_showInput 20)))
     (setq _ip0 _ip)
     (setq _tkch (iadd _ip 1))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************












     ;; ====================
     ;; case: "void"
     ;; ====================
     (if (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "void" << ($ASIS $ch #void  Term: true Constant: true Void: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void  Term: true Constant: true Void: true) )
            (if _verbose
                (writeRule
                     {MAIN: "void" << ($ASIS $ch #void  Term: true Constant: true Void: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "void"
     ;; ====================
     ;; case: PoundSign
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_PoundSign[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: "void"
         ;; ====================
         (if (if (= (setq _tk2 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: PoundSign "void" << ($ASIS $ch #void  Term: true Constant: true  Void: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch #void  Term: true Constant: true  Void: true) )
                (if _verbose
                    (writeRule
                         {MAIN: PoundSign "void" << ($ASIS $ch #void  Term: true Constant: true  Void: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "void"
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_LeftParen[_tk2] 1)) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: "obj"
             ;; ====================
             (if (if (= (setq _tk3 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 3)) 3))) "obj") true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Bar
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk4] 1)) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: PoundSign LeftParen "obj" Bar << ($ASIS $ch $3 VecStart: true Constant: true) >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (_tkASIS _tkch _tk3 VecStart: true Constant: true) )
                        (if _verbose
                            (writeRule
                                 {MAIN: PoundSign LeftParen "obj" Bar << ($ASIS $ch $3 VecStart: true Constant: true) >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Bar
               ) ; end begin
             ) ; end case : "obj"
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: BackSlash
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_BackSlash[_tk2] 1)) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Any
             ;; ====================
             (if (if (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: PoundSign BackSlash Any << ($ASIS $ch $3 Character: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk3 Character: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: PoundSign BackSlash Any << ($ASIS $ch $3 Character: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Any
           ) ; end begin
         ) ; end case : BackSlash
         ;; ====================
         ;; case: <
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NameStart
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: NameChar*
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Whitespace*
                     ;; ====================
                     (if (begin (setq _i 0) (setq _tk5 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk5[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                       (begin (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit*
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                           (begin (setq _ip6 _ip)
                             ;; ====================
                             ;; case: >
                             ;; ====================
                             (if (if (= (setq _tk7 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip6))
                               (begin (setq _ip7 _ip)
                                 ;; *********************************************************
                                 ;; RULE: MAIN: PoundSign < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) Term: true Object: true Constant: true) >>
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_tkOUT _tkch (inspect (number _tk6)) Term: true Object: true Constant: true) )
                                    (if _verbose
                                        (writeRule
                                             {MAIN: PoundSign < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) Term: true Object: true Constant: true) >>}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (goto Skip:))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : >
                           ) ; end begin
                         ) ; end case : Digit*
                       ) ; end begin
                     ) ; end case : Whitespace*
                   ) ; end begin
                 ) ; end case : NameChar*
               ) ; end begin
             ) ; end case : NameStart
           ) ; end begin
         ) ; end case : <
       ) ; end begin
     ) ; end case : PoundSign
     ;; ====================
     ;; case: DQuote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NotDQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotDQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: DQuote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2 String: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : DQuote
           ) ; end begin
         ) ; end case : NotDQuote*
       ) ; end begin
     ) ; end case : DQuote
     ;; ====================
     ;; case: Bar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NotBar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotBar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Bar
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Bar[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Bar NotBar* Bar << ($ASIS $ch $2 SymbolName: true Term: true Name: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2 SymbolName: true Term: true Name: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Bar NotBar* Bar << ($ASIS $ch $2 SymbolName: true Term: true Name: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Bar
           ) ; end begin
         ) ; end case : NotBar*
         ;; *********************************************************
         ;; RULE: MAIN: Bar << ($OUT $ch $1 Bar: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch _tk1 Bar: true) )
            (if _verbose
                (writeRule
                     {MAIN: Bar << ($OUT $ch $1 Bar: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Bar
     ;; ====================
     ;; case: Quote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NameStart
         ;; ====================
         (if (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk2] 1)) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NameChar*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Quote NameStart NameChar* << ($ASIS $ch (makeQuotedSymbol (append $2 $3)) Symbol: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch (makeQuotedSymbol (append _tk2 _tk3)) Symbol: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Quote NameStart NameChar* << ($ASIS $ch (makeQuotedSymbol (append $2 $3)) Symbol: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : NameChar*
           ) ; end begin
         ) ; end case : NameStart
       ) ; end begin
     ) ; end case : Quote
     ;; ====================
     ;; case: NameStart
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: NameChar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true ) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (symbol (append _tk1 _tk2)) Name: true Term: true ) )
                (if _verbose
                    (writeRule
                         {MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true ) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NameChar*
       ) ; end begin
     ) ; end case : NameStart
     ;; ====================
     ;; case: Digit+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Period
         ;; ====================
         (if (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk2] 1)) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Digit*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2 _tk3)) Number: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Digit*
           ) ; end begin
         ) ; end case : Period
         ;; *********************************************************
         ;; RULE: MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true Constant: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkASIS _tkch (integer _tk1) Number: true Integer: true Term: true Constant: true) )
            (if _verbose
                (writeRule
                     {MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true Constant: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Digit+
     ;; ====================
     ;; case: Period
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Digit+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true Constant: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2)) Number: true Term: true Constant: true) )
                (if _verbose
                    (writeRule
                         {MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true Constant: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Digit+
       ) ; end begin
     ) ; end case : Period
     ;; ====================
     ;; case: /
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: *
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (or (<> _tkIN[_ip] #\*) (<> _tkIN[(iadd _ip 1)] #\/)) ) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: *
                 ;; ====================
                 (if (if (= (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: /
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip4))
                       (begin (setq _ip5 _ip)
                         ;; *********************************************************
                         ;; RULE: MAIN: / * Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}* * / << true >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  true )
                            (if _verbose
                                (writeRule
                                     {MAIN: / * Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}* * / << true >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (goto Skip:))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : /
                   ) ; end begin
                 ) ; end case : *
               ) ; end begin
             ) ; end case : Any{(or (<> $IN[_ip] #\*) (<> $IN[(iadd _ip 1)] #\/))}*
           ) ; end begin
         ) ; end case : *
         ;; ====================
         ;; case: /
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: NotEol*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotEol[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Eol?
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Eol[_tk4] 1)) true (begin (setq _ip (isub _ip 1)) (setq _tk4 {}) true))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: / / NotEol* Eol? << true >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  true )
                        (if _verbose
                            (writeRule
                                 {MAIN: / / NotEol* Eol? << true >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Eol?
               ) ; end begin
             ) ; end case : NotEol*
           ) ; end begin
         ) ; end case : /
       ) ; end begin
     ) ; end case : /
     ;; ====================
     ;; case: Whitespace+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Whitespace+ << true >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  true )
            (if _verbose
                (writeRule
                     {MAIN: Whitespace+ << true >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Whitespace+
     ;; ====================
     ;; case: Any
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (symbol (string _tk1)) Default: true) )
            (if _verbose
                (writeRule
                     {MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Any
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: $LIST ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tkLIST )
            (if _verbose
                (writeRule
                     {MAIN: Eof :: $LIST ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize 
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule MAIN on: " (_showInput 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseLexIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseLexCount.MAIN _verboseLexIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _LEXRULE_MAIN














;;**EXPORTKEY**:CompilerLib:_SYNRULE_AEXPRESSION
;; ************************************************
;; AEXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the AEXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_AEXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: AEXPRESSION: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.AEXPRESSION #void) 
          (setq _verboseSynCount.AEXPRESSION 1) 
          (setq _verboseSynCount.AEXPRESSION (iadd _verboseSynCount.AEXPRESSION 1)))

   (if (and (<> _verboseSynIn.AEXPRESSION #void) (> _verboseSynIn.AEXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting AEXPRESSION Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Storage
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Storage:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Name
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Name:] #void) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Colon
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[Colon:] #void) true (setq _ip _ip4))
                       (begin (setq _ip5 _ip)
                         ;; ====================
                         ;; case: String
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[String:] #void) true (setq _ip _ip5))
                           (begin (setq _ip6 _ip)
                             ;; ====================
                             ;; case: RightParen
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[RightParen:] #void) true (setq _ip _ip6))
                               (begin (setq _ip7 _ip)
                                 ;; *********************************************************
                                 ;; RULE: AEXPRESSION: Storage Colon LeftParen Name Colon String RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (setq (setq (setq _tk0.Value _tk4.Value)[Storage:] _tk1.Value)[Term:] true) )
                                    (if _verbose
                                        (writeRule
                                             {AEXPRESSION: Storage Colon LeftParen Name Colon String RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : RightParen
                           ) ; end begin
                         ) ; end case : String
                       ) ; end begin
                     ) ; end case : Colon
                     ;; ====================
                     ;; case: RightParen
                     ;; ====================
                     (if (begin (setq _ip _ip4)
                      (if (<> (setq _tk5 (_getToken))[RightParen:] #void) true (setq _ip _ip4)))
                       (begin (setq _ip5 _ip)
                         ;; *********************************************************
                         ;; RULE: AEXPRESSION: Storage Colon LeftParen Name RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq (setq (setq _tk0.Value _tk4.Value)[Storage:] _tk1.Value)[Term:] true) )
                            (if _verbose
                                (writeRule
                                     {AEXPRESSION: Storage Colon LeftParen Name RightParen :: (setq (setq (setq $0.Value $4.Value)[Storage:] $1.Value)[Term:] true) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : RightParen
                   ) ; end begin
                 ) ; end case : Name
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : Storage
     ;; ====================
     ;; case: Boolean
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Boolean:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: AEXPRESSION: Boolean :: (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true)::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (setq (setq _tk1.AEXPRESSION true)[Storage:] cons:)[Term:] true))
            (if _verbose
                (writeRule
                     {AEXPRESSION: Boolean :: (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true)::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Boolean
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: AEXPRESSION: Name :: (addToGvars $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToGvars _tk1) )
            (if _verbose
                (writeRule
                     {AEXPRESSION: Name :: (addToGvars $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: SymbolName
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[SymbolName:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: AEXPRESSION: SymbolName :: (addToGvars $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToGvars _tk1) )
            (if _verbose
                (writeRule
                     {AEXPRESSION: SymbolName :: (addToGvars $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SymbolName
     ;; ====================
     ;; case: OperatorName
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[OperatorName:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: AEXPRESSION: OperatorName :: (addToGvars $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToGvars _tk1) )
            (if _verbose
                (writeRule
                     {AEXPRESSION: OperatorName :: (addToGvars $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : OperatorName
     ;; ====================
     ;; case: Term
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Term:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: AEXPRESSION: Term :: (if $1.Name (addToGvars $1) (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true))::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (if _tk1.Name (addToGvars _tk1) (setq (setq (setq _tk1.AEXPRESSION true)[Storage:] cons:)[Term:] true)))
            (if _verbose
                (writeRule
                     {AEXPRESSION: Term :: (if $1.Name (addToGvars $1) (setq (setq (setq $1.AEXPRESSION true)[Storage:] cons:)[Term:] true))::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Term
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule AEXPRESSION on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.AEXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.AEXPRESSION _verboseSynIn.AEXPRESSION) (error "Count" "in Routine AEXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_AEXPRESSION














;;**EXPORTKEY**:CompilerLib:_SYNRULE_ASMSTATEMENT
;; ************************************************
;; ASMSTATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the ASMSTATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_ASMSTATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: ASMSTATEMENT: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.ASMSTATEMENT #void) 
          (setq _verboseSynCount.ASMSTATEMENT 1) 
          (setq _verboseSynCount.ASMSTATEMENT (iadd _verboseSynCount.ASMSTATEMENT 1)))

   (if (and (<> _verboseSynIn.ASMSTATEMENT #void) (> _verboseSynIn.ASMSTATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting ASMSTATEMENT Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Number
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: AsmOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[AsmOperator:] #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: OPERANDS
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_OPERANDS)) morphFail)true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: ASMSTATEMENT: Number Colon AsmOperator OPERANDS ::  (outCInstruction  $1.Value $3 $4.Value)::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret   (outCInstruction  _tk1.Value _tk3 _tk4.Value))
                        (if _verbose
                            (writeRule
                                 {ASMSTATEMENT: Number Colon AsmOperator OPERANDS ::  (outCInstruction  $1.Value $3 $4.Value)::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : OPERANDS
               ) ; end begin
             ) ; end case : AsmOperator
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: Binding
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Binding:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: InitializeOperator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: String
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[String:] #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: ASMSTATEMENT: Binding InitializeOperator String :: (begin (list $1.Value $3.Value) (setq LambdaName (removeSpecChar $3.Value))) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (begin (list _tk1.Value _tk3.Value) (setq LambdaName (removeSpecChar _tk3.Value))) )
                    (if _verbose
                        (writeRule
                             {ASMSTATEMENT: Binding InitializeOperator String :: (begin (list $1.Value $3.Value) (setq LambdaName (removeSpecChar $3.Value))) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : String
           ) ; end begin
         ) ; end case : InitializeOperator
       ) ; end begin
     ) ; end case : Binding
     ;; ====================
     ;; case: Args
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Args:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: INTFACELIST($1.Value)
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_INTFACELIST _tk1.Value)) morphFail)true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: ASMSTATEMENT: Args Colon InitializeOperator INTFACELIST($1.Value) :: (list $1.Value $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list _tk1.Value _tk4.Value) )
                        (if _verbose
                            (writeRule
                                 {ASMSTATEMENT: Args Colon InitializeOperator INTFACELIST($1.Value) :: (list $1.Value $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : INTFACELIST($1.Value)
               ) ; end begin
             ) ; end case : InitializeOperator
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : Args
     ;; ====================
     ;; case: "vm"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] "vm") true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; ====================
                 ;; case: PoundSign
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[PoundSign:] #void) true (setq _ip _ip3))
                   (begin (setq _ip4 _ip)
                     ;; ====================
                     ;; case: "<"
                     ;; ====================
                     (if (if (= (setq _tk5 (_getToken))[Value:] "<") true (setq _ip _ip4))
                       (begin (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Name
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[Name:] #void) true (setq _ip _ip5))
                           (begin (setq _ip6 _ip)
                             ;; ====================
                             ;; case: Name
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Name:] #void) true (setq _ip _ip6))
                               (begin (setq _ip7 _ip)
                                 ;; ====================
                                 ;; case: ">"
                                 ;; ====================
                                 (if (if (= (setq _tk8 (_getToken))[Value:] ">") true (setq _ip _ip7))
                                   (begin (setq _ip8 _ip)
                                     ;; *********************************************************
                                     ;; RULE: ASMSTATEMENT: "vm" Colon InitializeOperator PoundSign "<" Name Name ">" << (if  (= $7.Value "dtrtlVirtualMachine") true (_makeError "AC 140" $7.Value "Invalid Virtual Machine")) >>
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (if  (= _tk7.Value "dtrtlVirtualMachine") true (_makeError "AC 140" _tk7.Value "Invalid Virtual Machine")) )
                                        (if _verbose
                                            (writeRule
                                                 {ASMSTATEMENT: "vm" Colon InitializeOperator PoundSign "<" Name Name ">" << (if  (= $7.Value "dtrtlVirtualMachine") true (_makeError "AC 140" $7.Value "Invalid Virtual Machine")) >>}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (goto Skip:))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : ">"
                               ) ; end begin
                             ) ; end case : Name
                           ) ; end begin
                         ) ; end case : Name
                       ) ; end begin
                     ) ; end case : "<"
                   ) ; end begin
                 ) ; end case : PoundSign
               ) ; end begin
             ) ; end case : InitializeOperator
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : "vm"
     ;; ====================
     ;; case: "Instructions"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] "Instructions") true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: ASMSTATEMENT: "Instructions" Colon :: (outVars) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (outVars) )
                (if _verbose
                    (writeRule
                         {ASMSTATEMENT: "Instructions" Colon :: (outVars) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : "Instructions"
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule ASMSTATEMENT on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.ASMSTATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.ASMSTATEMENT _verboseSynIn.ASMSTATEMENT) (error "Count" "in Routine ASMSTATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_ASMSTATEMENT














;;**EXPORTKEY**:CompilerLib:_SYNRULE_INTFACELIST
;; ************************************************
;; INTFACELIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the INTFACELIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_INTFACELIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: INTFACELIST: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.INTFACELIST #void) 
          (setq _verboseSynCount.INTFACELIST 1) 
          (setq _verboseSynCount.INTFACELIST (iadd _verboseSynCount.INTFACELIST 1)))

   (if (and (<> _verboseSynIn.INTFACELIST #void) (> _verboseSynIn.INTFACELIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting INTFACELIST Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Void
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Void:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: INTFACELIST: Void :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose
                (writeRule
                     {INTFACELIST: Void :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Void
     ;; ====================
     ;; case: VecStart
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[VecStart:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: OBJVECTOR(%0)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_OBJVECTOR _ak0)) morphFail)true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: INTFACELIST: VecStart OBJVECTOR(%0) :: (setq $2.Charpos $1.Charpos) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk2.Charpos _tk1.Charpos) )
                (if _verbose
                    (writeRule
                         {INTFACELIST: VecStart OBJVECTOR(%0) :: (setq $2.Charpos $1.Charpos) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : OBJVECTOR(%0)
       ) ; end begin
     ) ; end case : VecStart
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule INTFACELIST on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.INTFACELIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.INTFACELIST _verboseSynIn.INTFACELIST) (error "Count" "in Routine INTFACELIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_INTFACELIST














;;**EXPORTKEY**:CompilerLib:_SYNRULE_MAIN
;; ************************************************
;; MAIN user defined Syntax Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: MAIN: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.MAIN #void) 
          (setq _verboseSynCount.MAIN 1) 
          (setq _verboseSynCount.MAIN (iadd _verboseSynCount.MAIN 1)))

   (if (and (<> _verboseSynIn.MAIN #void) (> _verboseSynIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting MAIN Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: #
     ;; ====================
     (if (if (= (setq _tk1 (_getToken))[Value:] |#|:) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: "CompilerLib"
         ;; ====================
         (if (if (= (setq _tk2 (_getToken))[Value:] "CompilerLib") true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: #
             ;; ====================
             (if (if (= (setq _tk3 (_getToken))[Value:] |#|:) true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: # "CompilerLib" # || (= $3.Charpos 14) || << true >>
                 ;; *********************************************************
                 (if  (= _tk3.Charpos 14) 
                  (begin
                    (setq _ret  true )
                    (if _verbose
                        (writeRule
                             {MAIN: # "CompilerLib" # || (= $3.Charpos 14) || << true >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : #
           ) ; end begin
         ) ; end case : "CompilerLib"
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: STMTLIST
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Eof
         ;; ====================
         (if (if (_eofToken)true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Eof :: (list $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (list _tk1.Value) )
                (if _verbose
                    (writeRule
                         {MAIN: STMTLIST Eof :: (list $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Eof
         ;; ====================
         ;; case: Value
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Value:] #void) true (setq _ip _ip1)))
           (begin (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Value :: (_makeError "AC 100" $2.Charpos "Invalid expression") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "AC 100" _tk2.Charpos "Invalid expression") )
                (if _verbose
                    (writeRule
                         {MAIN: STMTLIST Value :: (_makeError "AC 100" $2.Charpos "Invalid expression") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Value
       ) ; end begin
     ) ; end case : STMTLIST
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Value :: (_makeError "AC 101" $1.Charpos "Invalid expression") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "AC 101" _tk1.Charpos "Invalid expression") )
            (if _verbose
                (writeRule
                     {MAIN: Value :: (_makeError "AC 101" $1.Charpos "Invalid expression") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (_eofToken)true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: (begin (outGlobal) (list #void) ) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (begin (outGlobal) (list #void) ) )
            (if _verbose
                (writeRule
                     {MAIN: Eof :: (begin (outGlobal) (list #void) ) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule MAIN on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.MAIN _verboseSynIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_MAIN














;;**EXPORTKEY**:CompilerLib:_SYNRULE_OBJVECTOR
;; ************************************************
;; OBJVECTOR user defined Syntax Rule implementation
;; Summary: This Lambda implements the OBJVECTOR
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_OBJVECTOR(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: OBJVECTOR: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.OBJVECTOR #void) 
          (setq _verboseSynCount.OBJVECTOR 1) 
          (setq _verboseSynCount.OBJVECTOR (iadd _verboseSynCount.OBJVECTOR 1)))

   (if (and (<> _verboseSynIn.OBJVECTOR #void) (> _verboseSynIn.OBJVECTOR -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting OBJVECTOR Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Binding
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Binding:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: OBJVECTOR: Binding << (setq $0.Value (addToVarList %0 $1.Value)) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (addToVarList _ak0 _tk1.Value)) )
            (if _verbose
                (writeRule
                     {OBJVECTOR: Binding << (setq $0.Value (addToVarList %0 $1.Value)) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Binding
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: OBJVECTOR: Name << (setq $0.Value (addToVarList %0 $1.Value)) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (addToVarList _ak0 _tk1.Value)) )
            (if _verbose
                (writeRule
                     {OBJVECTOR: Name << (setq $0.Value (addToVarList %0 $1.Value)) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: Term
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Term:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: OBJVECTOR: Term << (setq $0.Value (addToVarList %0 $1.Value)) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (addToVarList _ak0 _tk1.Value)) )
            (if _verbose
                (writeRule
                     {OBJVECTOR: Term << (setq $0.Value (addToVarList %0 $1.Value)) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Term
     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: OBJVECTOR: RightParen :: $0 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose
                (writeRule
                     {OBJVECTOR: RightParen :: $0 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule OBJVECTOR on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.OBJVECTOR -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.OBJVECTOR _verboseSynIn.OBJVECTOR) (error "Count" "in Routine OBJVECTOR"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_OBJVECTOR














;;**EXPORTKEY**:CompilerLib:_SYNRULE_OPERANDS
;; ************************************************
;; OPERANDS user defined Syntax Rule implementation
;; Summary: This Lambda implements the OPERANDS
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_OPERANDS(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: OPERANDS: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.OPERANDS #void) 
          (setq _verboseSynCount.OPERANDS 1) 
          (setq _verboseSynCount.OPERANDS (iadd _verboseSynCount.OPERANDS 1)))

   (if (and (<> _verboseSynIn.OPERANDS #void) (> _verboseSynIn.OPERANDS -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting OPERANDS Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: AEXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_AEXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: OPERANDS
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_OPERANDS)) morphFail)true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: OPERANDS: AEXPRESSION Comma OPERANDS :: (setq $0.Value (insert $3.Value 0 $1)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1)) )
                    (if _verbose
                        (writeRule
                             {OPERANDS: AEXPRESSION Comma OPERANDS :: (setq $0.Value (insert $3.Value 0 $1)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : OPERANDS
           ) ; end begin
         ) ; end case : Comma
         ;; *********************************************************
         ;; RULE: OPERANDS: AEXPRESSION :: (setq $0.Value (new Vector: 1 $1)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1)) )
            (if _verbose
                (writeRule
                     {OPERANDS: AEXPRESSION :: (setq $0.Value (new Vector: 1 $1)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : AEXPRESSION
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: OPERANDS: Value :: (_makeError "AC 137" $1.Charpos "Invalid argument list")::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "AC 137" _tk1.Charpos "Invalid argument list"))
            (if _verbose
                (writeRule
                     {OPERANDS: Value :: (_makeError "AC 137" $1.Charpos "Invalid argument list")::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule OPERANDS on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.OPERANDS -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.OPERANDS _verboseSynIn.OPERANDS) (error "Count" "in Routine OPERANDS"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_OPERANDS














;;**EXPORTKEY**:CompilerLib:_SYNRULE_STMTLIST
;; ************************************************
;; STMTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the STMTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_STMTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STMTLIST: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STMTLIST #void) 
          (setq _verboseSynCount.STMTLIST 1) 
          (setq _verboseSynCount.STMTLIST (iadd _verboseSynCount.STMTLIST 1)))

   (if (and (<> _verboseSynIn.STMTLIST #void) (> _verboseSynIn.STMTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting STMTLIST Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: ASMSTATEMENT
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_ASMSTATEMENT)) morphFail)true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: STMTLIST: ASMSTATEMENT << (addToQuadsList $0 $1) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToQuadsList _tk0 _tk1) )
            (if _verbose
                (writeRule
                     {STMTLIST: ASMSTATEMENT << (addToQuadsList $0 $1) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : ASMSTATEMENT
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (_eofToken)true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: STMTLIST: Eof :: (begin (outGlobal) $0) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (begin (outGlobal) _tk0) )
            (if _verbose
                (writeRule
                     {STMTLIST: Eof :: (begin (outGlobal) $0) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: STMTLIST: Value :: (_makeError "AC 140" $1.Charpos "Invalid Statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "AC 140" _tk1.Charpos "Invalid Statement") )
            (if _verbose
                (writeRule
                     {STMTLIST: Value :: (_makeError "AC 140" $1.Charpos "Invalid Statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule STMTLIST on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STMTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STMTLIST _verboseSynIn.STMTLIST) (error "Count" "in Routine STMTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STMTLIST














;;**EXPORTKEY**:CompilerLib:_SYNRULE_STRUCTURE
;; ************************************************
;; STRUCTURE user defined Syntax Rule implementation
;; Summary: This Lambda implements the STRUCTURE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_STRUCTURE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STRUCTURE: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STRUCTURE #void) 
          (setq _verboseSynCount.STRUCTURE 1) 
          (setq _verboseSynCount.STRUCTURE (iadd _verboseSynCount.STRUCTURE 1)))

   (if (and (<> _verboseSynIn.STRUCTURE #void) (> _verboseSynIn.STRUCTURE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting STRUCTURE Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Name
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; ====================
         ;; case: Colon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Colon:] #void) true (setq _ip _ip1))
           (begin (setq _ip2 _ip)
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: STRUCTURE: Name Colon SEXPRESSION << (addToStructure %0 $1.Value $3.Value) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addToStructure _ak0 _tk1.Value _tk3.Value) )
                    (if _verbose
                        (writeRule
                             {STRUCTURE: Name Colon SEXPRESSION << (addToStructure %0 $1.Value $3.Value) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : Colon
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: RightBrace
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightBrace:] #void) true (setq _ip _ip0)))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: STRUCTURE: RightBrace :: %0 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _ak0 )
            (if _verbose
                (writeRule
                     {STRUCTURE: RightBrace :: %0 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightBrace
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule STRUCTURE on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STRUCTURE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STRUCTURE _verboseSynIn.STRUCTURE) (error "Count" "in Routine STRUCTURE"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STRUCTURE
















;;**EXPORTKEY**:CompilerLib:_SYNRULE_TERM
;; ************************************************
;; TERM user defined Syntax Rule implementation
;; Summary: This Lambda implements the TERM
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild CompilerLib:_SYNRULE_TERM(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: TERM: true))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.TERM #void) 
          (setq _verboseSynCount.TERM 1) 
          (setq _verboseSynCount.TERM (iadd _verboseSynCount.TERM 1)))

   (if (and (<> _verboseSynIn.TERM #void) (> _verboseSynIn.TERM -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (if _verbose (writeln (setq _indent (append _indent " ")) "Attempting TERM Rule on: " (_showSource 20)))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************



     ;; ====================
     ;; case: Term
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Term:] #void) true (setq _ip _ip0))
       (begin (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: TERM: Term :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose
                (writeRule
                     {TERM: Term :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Term
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (writeln _indent "Rejecting Rule TERM on: " (_showSource 20) 
                                     (setq _indent (left _indent (sub1 (length _indent))))))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.TERM -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.TERM _verboseSynIn.TERM) (error "Count" "in Routine TERM"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_TERM
















;;**EXPORTKEY**:CompilerLibSelfTest
(defun CompilerLibSelfTest(x y z) 
;; ********************************************************************
;; summary:  The CompilerLib compiler self testing function.
;;           Function selfTest must be compiled as a stand alone C function 
;;           and linked into the host interface layer.
;;           Compile time self test child Lambdas for the CompilerLib compiler.
;; Note: This Lambda supports the CompilerLib self test process.
;; 
;; Args:     x       Any singleton argument.
;;           y       Any singleton argument.
;;           z       Any singleton argument.
;; return:   result  The result from self testing.
;; ********************************************************************
   vars:(v1 v2 vr result vintvec monthlyBills aLongString aHostObj)  
   pvars:(p1 p2 pr pintvec )  
   cvars:(c1 c2 cr cintvec)  
     
   ;; vmargcount  
   ;; Use the emulator to compute the correct result.
   (setq result ((eval "(lambda(x ...) (argCount))") x y z))
   ;; Test the compiler and compare with a hard-coded result
   (setq vr (setq pr (setq cr (argCount))))         
   (if (<> vr result) (error "vmargCount: error at vr"))
   (if (<> pr result) (error "vmargCount: error at pr"))
   (if (<> cr result) (error "vmargCount: error at cr"))  		   		     		   
        
   ;; vmargfetch  
   ;; Use the emulator to compute the correct result.
   (setq result ((eval "(lambda(x ...) (argFetch 1))") x y z))         
   ;; Test the compiler and compare with a hard-coded result
   (setq vr (setq pr (setq cr (argFetch 1))))         
   (if (<> vr result) (error "vmargFetch: error at vr"))
   (if (<> pr result) (error "vmargFetch: error at pr"))
   (if (<> cr result) (error "vmargFetch: error at cr"))  		   		     		   
                  
   ;; vmSend  
   ;; Test sending a message along with a single argument 
   (addMethod Structure:addValues (lambda(s) (apply + s)))
   (setq monthlyBills #{CarPymt: 400 Mortgage: 2100 }) 
   (setq result (send  addValues:  monthlyBills))
   (if (<> result 2500) (error "vmSend: (1 arg) test error"))
	   
   ;; vmSend 
   ;; Test sending a message along with multiple arguments 
   (addMethod String:appendValues (lambda(s t u v)  (append s t u v))) 
   (setq aLongString (new String: "A Long Message: ")) 
   (setq result (send appendValues: aLongString "hello " "world " "hello." ))
   (if (<> result "A Long Message: hello world hello.") (error "vmSend: (2 args) test error"))
	         
   ;; vmSelf 
   (setq p1 23)
   (setq result (myself))
   (if (<> result.p1 p1) (error "vmSelf: test error"))              

   ;; Test the vmbadd instruction  
   ;; Reference the arguments for this test.
   (setq p1 (setq c1 (setq v1 false)))         
   (setq p2 (setq c2 (setq v2 true)))         
   ;; Use the emulator to compute the correct result.
   (setq result (eval (append "(badd " v1 " " v2 ")")))         
   ;; Test the compiler and compare with the correct result.
   (if (<> (setq vr (badd v1 v2)) result) (error "vmbadd:v1:v2:vr"))  		   
   (if (<> (setq vr (badd v1 p2)) result) (error "vmbadd:v1:p2:vr"))  
   (if (<> (setq vr (badd v1 c2)) result) (error "vmbadd:v1:c2:vr"))  

   (if (<> (setq vr (badd p1 v2)) result) (error "vmbadd:p1:v2:vr"))  		   
   (if (<> (setq vr (badd p1 p2)) result) (error "vmbadd:p1:p2:vr"))  
   (if (<> (setq vr (badd p1 c2)) result) (error "vmbadd:p1:c2:vr"))  
     
   (if (<> (setq vr (badd c1 v2)) result) (error "vmbadd:c1:v2:vr"))  		   
   (if (<> (setq vr (badd c1 p2)) result) (error "vmbadd:c1:p2:vr"))  		   
   (if (<> (setq vr (badd c1 c2)) result) (error "vmbadd:c1:c2:vr"))  
     		   
   (if (<> (setq pr (badd v1 v2)) result) (error "vmbadd:v1:v2:pr"))  
   (if (<> (setq pr (badd v1 p2)) result) (error "vmbadd:v1:p2:pr"))  
   (if (<> (setq pr (badd v1 c2)) result) (error "vmbadd:v1:c2:pr"))  
   
   (if (<> (setq pr (badd p1 v2)) result) (error "vmbadd:p1:v2:pr"))  		   
   (if (<> (setq pr (badd p1 p2)) result) (error "vmbadd:p1:p2:pr"))  		   
   (if (<> (setq pr (badd p1 c2)) result) (error "vmbadd:p1:c2:pr"))  
     
   (if (<> (setq pr (badd c1 v2)) result) (error "vmbadd:c1:v2:pr"))  		   
   (if (<> (setq pr (badd c1 p2)) result) (error "vmbadd:c1:p2:pr"))  		   
   (if (<> (setq pr (badd c1 c2)) result) (error "vmbadd:c1:c2:pr"))  
     		   
   (if (<> (setq cr (badd v1 v2)) result) (error "vmbadd:v1:v2:cr"))  
   (if (<> (setq cr (badd v1 p2)) result) (error "vmbadd:v1:p2:cr"))  
   (if (<> (setq cr (badd v1 c2)) result) (error "vmbadd:v1:c2:cr"))  
   
   (if (<> (setq cr (badd p1 v2)) result) (error "vmbadd:p1:v2:cr"))  		   
   (if (<> (setq cr (badd p1 p2)) result) (error "vmbadd:p1:p2:cr"))  		   
   (if (<> (setq cr (badd p1 c2)) result) (error "vmbadd:p1:c2:cr"))  
     		   
   (if (<> (setq cr (badd c1 v2)) result) (error "vmbadd:c1:v2:cr"))  
   (if (<> (setq cr (badd c1 p2)) result) (error "vmbadd:c1:p2:cr"))  		   
   (if (<> (setq cr (badd c1 c2)) result) (error "vmbadd:c1:c2:cr"))  

   "self Test completed successfully") ; end selfTest


