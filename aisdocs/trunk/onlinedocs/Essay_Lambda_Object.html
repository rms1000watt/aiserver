
<HTML>
<HEAD>
<link rel="stylesheet" type="text/css" href="../CoreContent/help.css">
<TITLE>AIS Essay Template</TITLE></HEAD>
<!--Page Parameters -->
<BODY BGCOLOR="#FFFFF0" TEXT="#000000" LINK="#0000ff">

<A NAME="topage"></A>
<A HREF="TOP"></A>



<P>&nbsp;</P>

<FONT COLOR="#000080"><H1>Lambda Object</H1></FONT>
<P>&nbsp;</P>

<UL>
<li><a href="#SSoftware Lambdas"><FONT SIZE=2>Software Lambdas</font></a></li><li><a href="#SExecutable Objects"><FONT SIZE=2>Executable Objects</font></a></li><li><a href="#SLambda Properties"><FONT SIZE=2>Lambda Properties</font></a></li><li><a href="#SDot Operator"><FONT SIZE=2>Dot Operator</font></a></li><li><a href="#SLambda Event Handling"><FONT SIZE=2>Lambda Event Handling</font></a></li><li><a href="#SReserved Lambda Methods"><FONT SIZE=2>Reserved Lambda Methods</font></a></li><li><a href="#SDoomed Lambdas"><FONT SIZE=2>Doomed Lambdas</font></a></li><li><a href="#SInternet Security"><FONT SIZE=2>Internet Security</font></a></li>
</UL>

<P><H2><A NAME="SSoftware Lambdas"></A>Software Lambdas</H2></P>
		  <div class="h2section" id="Software Lambdas"> 
            <p>Software Lambdas are executable objects which act as small building blocks
               for creating ever larger programs with increasing sophistication.
               Lambdas differ from old style functions in several important ways:</p>
               <ul>
                <li>Lambdas are actual objects which can be passed around the Internet and stored and retrieved from databases</li>
                <li>Lambdas may contain their own persistent memory supporting the accumulation of "knowledge" or "state"</li>
                <li>Lambdas are navigable objects and can even navigate "learn" about each other</li>
                <li>Lambdas can be connected together in many interesting ways to form larger and larger communities</li>
               </ul>
            <p>These differences, from old style functions, allow the rapid development of larger and larger programs with ever increasing functionality.</p>              
		    <p>The next wave of technological innovation must integrate linked
		    organizations and multiple application platforms. Developers must construct
		    unified information management systems that use the world wide web and
		    advanced software technologies. Software Lambdas, one of the most exciting
		    new developments in computer software technology, can be used to quickly and
		    easily build integrated enterprise systems. The idea of having a software
		    Lambda that can perform complex tasks on our behalf is intuitively appealing.
		    The natural next step is to use multiple software Lambdas that communicate
		    and cooperate with each other to solve complex problems and implement
		    complex systems. Software Lambdas provide a powerful new method for
		    implementing these next-generation information systems.</p>
		    <p>Nowhere is this more apparent than with modern <i>Genetic Programming</i>
		    technology which can produce <i>millions</i> of complex analytic software
		    Lambdas. None of these software Lambdas have a human author. They are all
		    authored by machines. There are no human experts to guide in their
		    deployment, to explain how they operate, or to describe the analytic
		    techniques which they employ. Furthermore, just keeping track of the
		    experimental results, of millions of analytic software Lambdas, can be a real
		    housekeeping chore. It becomes rapidly obvious that a database capable of
		    storing and serving analytic software Lambdas is necessary.</p>
		    <p>Analytic Information Server (AIS) is a database system designed to store and
		    serve millions of analytic software Lambdas across the Internet, intranets,
		    WANs, and LANs. Analytic Information Server is also capable of storing and
		    serving vast quantities of XML data upon which these analytic software
		    Lambdas perform their complicated analyses.</p>
		    <p>AIS is a powerful database environment combining Lambda technology and
		    Internet server technology. It comes with a rich set of re-usable Lambda
		    Libraries, a fast Lisp compiler, a built-in Lambda JavaScript compiler, an
		    interactive Lambda debugger, and persistent Lambda repository with a flexible
		    database schema. AIS is designed to store and serve software Lambdas which
		    specialize in large volume data analysis, where microchip-level execution
		    speed is a priority, and multiple gigabyte repositories are commonplace.</p>
		    <p>Any software Lambda served from AIS can be deployed directly over TCP/IP
		    connections to any Internet browser on the World Wide Web, and can be
		    deployed from any software product (MSWord, Excel, Project, etc) or user
		    client application that can open a TCP/IP socket connection (<i>which is to
		    say almost all existing legacy applications</i>).</p>
		  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SExecutable Objects"></A>Executable Objects</H2></P>
		    <div class="h2section" id="Executable Objects">
		    <p class="BodyTextTable">An AIS Lambda is a concrete executable software
		    object <b><u>building block</u></b> that is a fundamental unit of data
		    stored in an AIS repository, and is mobile between copies of Lambda
		    Information Server across the Internet. We make no a priori claims about the
		    eventual capability of these Lambda objects; instead, we let any positive
		    properties emerge naturally as the communities of these interacting Lambdas
		    become more complex. In this manner of thinking, <i>intelligence</i> is not
		    really a property of any one software Lambda object; instead, intelligence is
		    an emerging property of a whole complex community of executable Lambda
		    objects. For instance, it is very difficult to isolate any one human neural
		    cell and make the claim that this particular cell is intelligent. However,
		    one can grow billions of human neural cells in a complex interacting
		    community (<i>the human brain</i>) under such conditions that most
		    interested observers would consider the whole community of neural cells <i>intelligent</i>.</p>
		    <p class="BodyTextTable">AIS Lambdas are concrete executable software objects
		    with the following rudimentary capabilities. Lambdas are designed to work
		    together in communities of other Lambdas forming complex adaptive
		    applications. Lambdas can communicate with other Lambdas in the system,
		    sharing information.<span style="mso-spacerun: yes">&nbsp; </span>An Lambda
		    can <b style="mso-bidi-font-weight:normal"><u>reconfigure</u></b> itself. If
		    a situation arises that requires an Lambda to perform a new action, the Lambda
		    can reproduce another Lambda and direct that Lambda to perform a different set
		    of tasks. An Lambda has the rudimentary capability being <b><u>goal-oriented</u></b>,
		    and may <b><u>collaborate</u></b> with other Lambdas to accomplish its goals.
		    Lambdas have the ability to <b><u>learn</u></b>. Lambdas can be written in
		    multiple computer languages, and can be executed under the control of
		    multiple virtual machines. Lambdas can personalize the presentation of
		    information. Lambdas can be asked to automatically perform small or tedious
		    tasks such as locating a specific piece of information, or filtering through
		    a large database looking for a set of conditions. Lambdas have the ability to
		    execute at microchip-level speeds.</p>
		    <p>The ability of Lambdas to modify themselves as they learn and to interact
		    with communities of other Lambdas, sharing knowledge and goals, presents
		    opportunities for the development of powerful, adaptive data analysis
		    solutions. Lambda data analysis applications may have adaptive user
		    interfaces which learn the needs of different users and which adjust to
		    changing data conditions.</p>
		    <p><font color="navy" size="4">Multiple Computer Languages</font></p>
		    <p>Each AIS Lambda is a concrete executable software object <b><u>building
		    block</u></b> that is a fundamental unit of data stored in an AIS
		    repository. Multiple computer languages can be expressed as executable Lambda
		    objects. Analytic Information Server currently comes with a built-in Lisp
		    compiler, a JavaScript compiler, an XML compiler, a natural language chatbot
		    compiler, various Lambda query language compilers, and there is even an Lambda
		    community which acts as a feature-based compiler compiler. It is certainly
		    possible, and is currently often the practice to have communities of Lambdas
		    which are not all produced by the same compiler. For instance, there are
		    examples of parent Lambdas written in Lisp which have child Lambdas written in
		    JavaScript and vice versa.</p>
		    <p>Analytic Information Server is <i>agnostic</i> in the choice of Lambda
		    programming language. It is often the case that one computer language is
		    preferable for certain data analysis applications while yet another computer
		    language is preferable for other data analysis applications. AIS comes
		    equipped with several Lambda compilers and rule-based tools for the easy
		    creation of additional user-defined Lambda programming languages. The only
		    caveat is that popular computer languages implemented in Analytic Information
		    Server must be tailored to produce our executable Lambda objects, and to
		    operate within the AIS runtime environment. AIS compiler development tools
		    are not designed to create compilers for execution outside Analytic Information
		    Server.</p>
		    <p><font color="navy" size="4">Multiple Virtual Machines</font></p>
		    <p>AIS Lambdas are designed to be write-once-run-anywhere executable objects.
		    This is accomplished via the virtual machine concept of software Lambda
		    execution. Lambda virtual machines are designed to be mapped onto the actual
		    host microchip at the server location, providing faithful Lambda execution
		    wherever the Lambda may travel on the Internet. There are currently several
		    virtual machines operating within Analytic Information Server. The DRM
		    virtual machine uses a <i>Dynamically typed Register Machine</i>
		    model to provide portable Lambda execution from high level dynamically typed
		    instructions all the way to super fast microchip-level register execution.
		    The DRM virtual machine runs in emulation mode during the debug phase of
		    Lambda development; while, during normal operation, the DRM virtual machine's
		    just-in-time (JIT) compiler automatically converts Lambdas to run in the 
			NATIVE code of the host machine. The NATIVE code is
		    a faithful machine language translation of the execution rules in
		    the DRM virtual machine onto the actual host microchip at the server
		    location. DRM NATIVE virtual machine code always runs at microchip-level execution
		    speeds.</p>
		    <p>Analytic Information Server is <i>agnostic</i> in the choice of Lambda
		    virtual machine. It is certainly possible, and is currently often the
		    practice to have communities of Lambdas which are not all running on the same
		    virtual machine. It is often the case that one virtual machine model is
		    preferable for certain data analysis applications while yet another virtual
		    machine model is preferable for other data analysis applications. AIS comes
		    equipped with several Lambda virtual machines and loadable library tools for
		    the easy creation of additional user-defined Lambda virtual machines. The
		    only caveat is that popular virtual machines (<i>such as the Python, Java,
		    or Smalltalk virtual machines</i>) implemented in Analytic Information Server
		    must be tailored to execute our executable Lambda objects, and to operate
		    within the AIS runtime environment. AIS virtual machine development tools
		    are not designed to create virtual machines for execution outside Lambda
		    Information Server.</p>
		    <p><font color="navy" size="4">Microchip-level Execution Speeds</font></p>
		    <p>Analytic Information Server is primarily concerned with software Lambdas
		    which perform high volume data analysis. Super fast execution speed is
		    essential in such application domains. There are several levels of general
		    computer program execution speeds. Disk based operations, such as those
		    performed by <i>SQL</i> and other database system languages, are among the
		    slowest executing animals in the program zoo. The next level of faster
		    execution speed is achieved by programs performing memory to memory
		    operations, such as those performed by <i>COBOL</i> and many other business
		    languages. The fastest possible level of program execution is achieved by
		    programs performing register to register operations on the microchip, such
		    as those performed by <i>assembler</i> language.</p>
		    <p>The AIS DRM virtual machine provides very fast native execution of
		    Lambdas performing disk based operations, memory to memory operations, and
		    microchip-level register to register operations. Regardless of the data
		    analysis domain, AIS allows the development of write-once-run-anywhere
		    Lambdas which execute at the fastest possible speeds.</p>
		    <p><font color="navy" size="4">Multiple Programming Paradigms</font></p>
		    <p>AIS Lambdas are designed to operate in many different programming
		    paradigms. Analytic Information Server is <i>agnostic</i> in the choice of
		    Lambda programming paradigm. It is often the case that one programming
		    paradigm is preferable for certain data analysis applications while yet
		    another programming paradigm is preferable for other data analysis
		    applications. AIS provides basic services and tools for: register to
		    register programming; functional programming; object oriented programming;
		    Lambda oriented programming; rule based programming; evolutionary
		    programming; and natural language programming paradigms.</p>
		    <p>AIS comes equipped with basic services and tools for the easy creation of
		    additional user-defined Lambda programming paradigms. The only caveat is that
		    popular programming paradigms (<i>such as the object oriented, evolutionary,
		    or register to register</i>) implemented in Analytic Information Server must be
		    tailored to execute our executable Lambda objects, and to operate within the
		    AIS runtime environment. AIS programming paradigm development tools are not
		    designed to create programming paradigms for execution outside Lambda
		    Information Server.</p>
		  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SLambda Properties"></A>Lambda Properties</H2></P>
		  <div class="h2section" id="Lambda Properties">	    
		    <p>The Lambda object stores Lambda behavior and knowledge in a standard
		    building block format (regardless of the original source language). The
		    Analytic Information Server Lambda object contains the following properties:</p>
		    <p>&nbsp;</p>
		    <table border="3" cellpadding="2" class="members_table">
		      <colgroup>
		        <col>
		        <col>
		      </colgroup>
		      <tr>
		        <th>Av:</th>
		        <td>The arguments Structure object containing the Lambda's arguments.</td>
		      </tr>
		      <tr>
		        <th>EvalWhenDoomed:</th>
		        <td>The <b>EvalWhenDoomed</b>: property is set true iff the Lambda is to
		          be evaluated, by the garbage collector, when it is doomed.</td>
		      </tr>
		      <tr>
		        <th>In:</th>
		        <td>The <b>faces</b>: Structure object containing the Lambda's published
		          interface styles, current plans, goals, current capabilities, and any
		          other information acquired during the learning stage.</td>
		      </tr>
		      <tr>
		        <th>Pc:</th>
		        <td>The Pcode Vector object containing the Lambda's virtual machine
		          codes.</td>
		      </tr>
		      <tr>
		        <th>Pv:</th>
		        <td>The <b>pvars</b>: Structure object containing the Lambda's persistent
		          variables.</td>
		      </tr>
		      <tr>
		        <th>Sv:</th>
		        <td>The <b>svars</b>: Structure object containing the Lambda's self object
		          variables.</td>
		      </tr>
		      <tr>
		        <th>Cv:</th>
		        <td>The <b>cvars</b>: Structure object containing the Lambda's persistent
		          class variables</td>
		      </tr>
		      <tr>
		        <th>Rv:</th>
		        <td>The <b>regs</b>: Structure object containing the Lambda's register
		          variables</td>
		      </tr>
		      <tr>
		        <th>Nc:</th>
		        <td>The Native Code Vector object containing the Lambda's native machine
		          code.</td>
		      </tr>
		      <tr>
		        <th>Sc:</th>
		        <td>The Source Code Vector containing the original language source for
		          debugger display and recreation of the original Lambda.</td>
		      </tr>
		      <tr>
		        <th>Tv:</th>
		        <td>The <b>vars</b>: Structure object containing the Lambda's temporary
		          frame variables.
		      </tr>
		      <tr>
		        <th>Vm:</th>
		        <td>The Virtual Machine execution function (each Lambda may run on a
		          separate virtual machine).</td>
		      </tr>
		    </table>
		    <p>&nbsp;</p>
		    <p>An Lambda is a <i>First Class Object</i>. A First Class object in Lambda
		    Information Server is any object that is fully exposed, i.e., all of the
		    Structures are visible and modifiable by the other Lambdas in the system. All
		    Lambdas have the following data structure elements: source code (<b>Sc</b>),
		    pseudo code instructions (<b>Pc</b>), argument variables (<b>Av</b>),
		    self object variables (<b>Sv</b>), persistent variables (<b>Pv</b>), 
		    persistent class variables (<b>Cv</b>),
		    register variables (<b>Rv</b>), temporary variables (<b>Tv</b>), interfaces
		    (<b>In</b>), native code (<b>Nc</b>), and the virtual machine emulator (<b>Vm</b>).
		    All Lambda structures can viewed and modified by the programmer:</p>
		  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDot Operator"></A>Dot Operator</H2></P>
		  <div class="h2section" id="Dot Operator">		    
		    <p>Each property is represented internally as a Structure Object. Any of the
		    Lambda object properties can be displayed by referencing the Lambda and the
		    property name using the Lisp or JavaScript dot operator (see the <b>ref</b>
		    function).</p>
		    <p>The Lisp lambda function always returns an Lambda:</p>
		    <p><b>&nbsp;&nbsp;&nbsp;(setq anLambda (lambda(x)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    faces:((english true))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    pvars:(p1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    cvars:(c1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    vars: (t1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    regs: ((r1 Integer))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    (defun child(x) (/ x p1))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    (setq p1 100)))</b></p>
		    <p><i>Any of the Lambda properties may be referenced with the Lisp or
		    JavaScript dot operator:</i></p>
		    <table border="3" cellpadding="2" class="members_table">
		      <colgroup>
		        <col>
		        <col style="font-style:italic">
		        <col>
		      </colgroup>
		      <tr>
		        <th>anLambda.Pv</th>
		        <td>Returns</td>
		        <td>The Structure <b>#{p1: #void&nbsp;&nbsp;&nbsp;child: #&lt;Lambda
		          1234&gt;}</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.Cv</th>
		        <td>Returns</td>
		        <td>The Structure <b>#{c1: #void}</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.Tv</th>
		        <td>Returns</td>
		        <td>The Structure <b>#{t1: #void}</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.Rv</th>
		        <td>Returns</td>
		        <td>The Structure <b>#{r1: Integer}</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.In</th>
		        <td>Returns</td>
		        <td>The Structure <b>#{ english: true }</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.EvalWhenDoomed</th>
		        <td>Returns</td>
		        <td><b>false</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.Cv.c1</th>
		        <td>Returns</td>
		        <td>The value of the variable <b>c1</b></td>
		      </tr>
		    </table>
		    <p>&nbsp;</p>
		    <p><i>Any of the persistent (<b>Pv</b>) attributes may be referenced
		    directly with the dot operator:</i></p>
		    <table border="3" cellpadding="2" class="members_table">
		      <colgroup>
		        <col>
		        <col style="font-style:italic">
		        <col>
		      </colgroup>
		      <tr>
		        <th>anLambda.p1</th>
		        <td>Returns</td>
		        <td>The singleton <b>#void</b></td>
		      </tr>
		      <tr>
		        <th>anLambda.child</th>
		        <td>Returns</td>
		        <td>The Lambda <b>#&lt;Lambda 1234&gt;</b></td>
		      </tr>
		    </table>
		    <p>&nbsp;</p>
		    <p>The special <b>ref1</b> Lambda method may be used to set up an abstract
		    Lambda event handler, which captures all access attempts (<i>somewhat like a
		    cell membrane</i>):</p>
		    <p><b>&nbsp;&nbsp;&nbsp;(setq anLambda (lambda(x)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    faces:((english true))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    pvars:(p1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    cvars:(c1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    vars: (t1)</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    (defun child(x) (/ x p1))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    (defun ref1(s) (writeln &quot;Please do not touch my &quot; s))</b></p>
		    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    (setq p1 100)))</b></p>
		    <p>&nbsp;</p>
		    <p class="notes">Notes &amp; Hints</p>
		    <p>The <b>ref1</b> Lambda method captures all access attempts (<i>somewhat
		    like an abstract cell membrane</i>). When any other Lambda in the system
		    attempts the following access <b>anLambda.child</b>, the access attempt will
		    be intercepted and the String <b><i>&quot;Please do not touch my child&quot;</i></b>
		    will be returned.</p>
		  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SLambda Event Handling"></A>Lambda Event Handling</H2></P>
		  <div class="h2section" id="Lambda Event Handling"> 
	    <p>Analytic Information Server Lambdas are not designed to be run alone. They
	    are designed to be run in small, medium, or large communities of other
	    Lambdas. As the size of an Lambda community increases, its behavior can become
	    increasingly complex, increasingly clever or <i>intelligent</i>. During the
	    course of your contact with AIS, your will hear about many very complex
	    Lambdas (<i>such as the Alice natural language chat robot, or the parseLib
	    compiler compiler Lambda</i>). In actual fact, Alice and parseLib are not
	    single Lambdas. They are large Lambda communities, working together to produce
	    useful and complex results.</p>
	    <p>Any large community of Lambdas must designate some Lambdas to perform
	    interface activities for the community. Lambdas in the community cannot all
	    be equal. Many Lambdas, inside the community, must specialize in specific
	    behavior for the good of entire community. Multiple internal areas of
	    specialization is often the key to increasingly <i>intelligent</i> behavior.</p>
	    <p>In order for the terms <i>inside</i> and <i>outside</i> to make sense,
	    when referring to an Lambda community, the community must designate one or
	    more Lambdas to perform all interface tasks with other <i>&quot;outside&quot;</i>
	    Lambdas. The designated interface Lambdas create an <i>application interface</i>
	    supporting <i>access conventions</i>, for the community as a whole. Among
	    other tasks, these <i>access conventions</i> protect the community's <i>internal</i>
	    Lambdas from undesired access (analogous to the protections provided by a
	    cell membrane or the skin of a biological community).</p>
	    <p>The simplest method for designating one or more Lambdas to perform all
	    interface tasks is by proclamation. The designated interface Lambdas and the
	    suported <i>application interface</i> and <i>access conventions</i> are
	    published. Other external Lambdas are expected to behave honorably and abide
	    by the published conventions. In situations where the trust between Lambdas
	    is not absolute, Analytic Information Server allows Lambdas to inforce published
	    access conventions, by making these <i>reinforced</i> Lambdas aware of any
	    access attempts by other external Lambdas. Access attempts on any AIS Lambda
	    are called <i>events</i>. Any AIS Lambda object may be made event aware.
	    There are a number of designated events (which are described in the next
	    section).</p>
	    <p>The following example shows how Analytic Information Server supports event
	    handling for all Lambdas (see the table of Reserved Lambda Methods). Certain
	    predefined events create conditions to which an Lambda may respond (if the
	    designer so chooses). An interesting example of Analytic Information Server
	    event handling support, is that an Lambda may be made aware of any attempt to
	    access it. For instance, in the following nearly identical Lambdas, one is
	    access aware and the other is not.</p>
	    <p>The <b>parent1</b> Lambda, shown below, is unaware of the access attempts
	    from any other Lambdas.</p>
	    <p><b>&nbsp;&nbsp;&nbsp; (defun parent1(x)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pvars:(p1)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq p1 x))</b></p>
	    <p>The <b>parent2</b> Lambda, shown below, is aware of all access attempts
	    from any other Lambdas and responds to the access attempt as programmed.</p>
	    <p><b>&nbsp;&nbsp;&nbsp; (defun parent2(x)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pvars:(p1)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun
	    ref1(member) (* (myself).Pv[member] (myself).Pv[member]))</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun
	    set1(member) &quot;Ouch! Please do not touch me.&quot;)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq p1 x))</b></p>
	    <p>&nbsp;</p>
	    <p class="notes">Notes &amp; Hints</p>
	    <p>For example, we can set the persistent memory of the <b>parent1</b> and
	    the <b>parent2</b> Lambdas to see how an event unaware Lambda reponds versus
	    how an event aware Lambda responds. The results are quite different depending
	    upon whether the event unaware or the event aware Lambda is accessed.</p>
	    <table border="3" cellpadding="2" class="members_table">
	      <colgroup>
	        <col align="CENTER" width="30%">
	        <col align="CENTER" width="10%">
	        <col>
	      </colgroup>
	      <tr>
	        <td>(parent1 10)</td>
	        <td>Returns</td>
	        <td>10</td>
	      </tr>
	      <tr>
	        <td>parent1.p1</td>
	        <td>Returns</td>
	        <td>10</td>
	      </tr>
	      <tr>
	        <td>(setq parent1.p1 5)</td>
	        <td>Returns</td>
	        <td>true</td>
	      </tr>
	      <tr>
	        <td>parent1.p1</td>
	        <td>Returns</td>
	        <td>5</td>
	      </tr>
	      <tr>
	        <td>(parent2 10)</td>
	        <td>Returns</td>
	        <td>10</td>
	      </tr>
	      <tr>
	        <td>parent2.p1</td>
	        <td>Returns</td>
	        <td>100</td>
	      </tr>
	      <tr>
	        <td>(setq parent2.p1 5)</td>
	        <td>Returns</td>
	        <td>&quot;Ouch! Please do not touch me.&quot;</td>
	      </tr>
	    </table>
	  </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SReserved Lambda Methods"></A>Reserved Lambda Methods</H2></P>   
		 <div class="h2section" id="Reserved Lambda Methods">       
	   <p>An Lambda community's designated interface Lambdas and suported <i>application
	    interface</i> and <i>access conventions</i> are published via proclamation
	    in the Interfaces section of each Lambda, and other external Lambdas are
	    expected to behave honorably and abide by the published conventions. In
	    situations where the trust between Lambdas is not absolute, Analytic Information
	    Server allows Lambdas to inforce published access conventions, by making
	    these <i>reinforced</i> Lambdas aware of any access attempts by other
	    external Lambdas. Access attempts on any AIS Lambda are called <i>events</i>.
	    Any AIS Lambda object may be made event aware.</p>
	    <p>Analytic Information Server supports reserved Lambda methods (child Lambdas)
	    each of which has a special access event which it captures and manages. The
	    reserved Lambda methods (if present) monitor and control actions taken upon
	    the Lambda in response to these special access events, and can enforce the
	    published <i>access conventions</i> of the Lambda community. These reserved
	    methods are:</p>
	    <table border="3" cellpadding="2" class="members_table">
	      <colgroup>
	        <col>
	        <col width="30%">
	        <col>
	      </colgroup>
	      <tr>
	        <th align="CENTER">Method</th>
	        <th align="CENTER">Trigger Event Syntax</th>
	        <th align="CENTER">Description of captured event</th>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>abortTrans</b></td>
	        <td align="CENTER">(abortTransaction anLambda)</td>
	        <td>Called when the <b>abortTransaction</b> built-in function attempts
	          to abort a transaction with the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>beginTrans</b></td>
	        <td align="CENTER">(beginTransaction anLambda)</td>
	        <td>Called when the <b>beginTransaction</b> built-in function attempts
	          to begin a transaction with the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>commitTrans</b></td>
	        <td align="CENTER">(commitTransaction anLambda)</td>
	        <td>Called when the <b>commitTransaction</b> built-in function attempts
	          to close a transaction with the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>doClear</b></td>
	        <td align="CENTER">(clear anLambda)</td>
	        <td>Called when the <b>clear</b> built-in function attempts to clear the
	          contents of the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>length</b></td>
	        <td align="CENTER">(length anLambda)</td>
	        <td>Called when the <b>length</b> built-in function requests the size of
	          the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>new</b></td>
	        <td align="CENTER">(copy anLambda)<br>
	          (new anLambda)</td>
	        <td>Called when the <b>copy</b> or <b>new</b> built-in functions attempt
	          to clone or copy the Lambda.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>ref1</b></td>
	        <td align="CENTER">(ref anLambda x:)<br>
	          anLambda.x<br>
	          anLambda[0]</td>
	        <td>Called when the <b>ref</b> built-in function, the <b>dot operator</b>,
	          or the <b>bracket operator</b> attempt to access the Lambda with a
	          single index argument.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>ref2</b></td>
	        <td align="CENTER">(ref anLambda 0 2)<br>
	          anLambda[0 2]</td>
	        <td>Called when the <b>ref</b> built-in function or the <b>bracket
	          operator</b> attempt to access the Lambda with two index arguments.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>ref3</b></td>
	        <td align="CENTER">(ref anLambda 0 x: 5)<br>
	          anLambda[0 x: 2]</td>
	        <td>Called when the <b>ref</b> built-in function or the <b>bracket
	          operator</b> attempt to access the Lambda with three index arguments.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>set1</b></td>
	        <td align="CENTER">(set anLambda x: newValue)<br>
	          (setq anLambda.x newValue)<br>
	          (setq anLambda[0] newValue)</td>
	        <td>Called when the <b>set</b> built-in function, the <b>dot operator</b>,
	          or the <b>bracket operator</b> attempt to alter the Lambda with a
	          single index argument.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>set2</b></td>
	        <td align="CENTER">(set anLambda 0 2 newValue)<br>
	          (setq anLambda[0 2] newValue)</td>
	        <td>Called when the <b>set</b> built-in function or the <b>bracket
	          operator</b> attempt to alter the Lambda with two index arguments.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>set3</b></td>
	        <td align="CENTER">(set anLambda 0 x: 5 newValue)<br>
	          (setq anLambda[0 x: 2] newValue)</td>
	        <td>Called when the <b>set</b> built-in function or the <b>bracket
	          operator</b> attempt to alter the Lambda with three index arguments.</td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>refImport</b></td>
	        <td align="CENTER">(importTab anLambda fileName)</td>
	        <td>Called when the <b>importTab</b> built-in function attempts to
	          import ascii tab delimited data directly into the Lambda.
	          <p>&nbsp;</p>
	          <p class="notes">Notes &amp; Hints</p>
	          <p>The <b>refImport</b> Lambda method captures all <i>give me your next
	          import record container</i> requests by the built-in <b>importTab</b>
	          function as it imports the contents of an ascii tab delimited file,
	          record by record, directly into the Lambda.</p>
	        </td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>setImport</b></td>
	        <td align="CENTER">(importTab anLambda fileName)</td>
	        <td>Called when the <b>importTab</b> built-in function attempts to
	          import ascii tab delimited data directly into the Lambda.
	          <p>&nbsp;</p>
	          <p class="notes">Notes &amp; Hints</p>
	          <p>The <b>setImport</b> Lambda method captures all <i>please take this <u>filled</u>
	          import record container</i> requests by the built-in <b>importTab</b>
	          function as it imports the contents of an ascii tab delimited file,
	          record by record, directly into the Lambda.</p>
	        </td>
	      </tr>
	      <tr>
	        <td align="CENTER"><b>refExport</b></td>
	        <td align="CENTER">(exportTab anLambda fileName)</td>
	        <td>Called when the <b>exportTab</b> built-in function attempts to
	          export ascii tab delimited data directly from the Lambda.
	          <p>&nbsp;</p>
	          <p class="notes">Notes &amp; Hints</p>
	          <p>The <b>refExport</b> Lambda method captures all <i>give me your next
	          export record</i> requests by the built-in <b>exportTab</b> function
	          as it exports the contents of Lambda directly into an ascii tab
	          delimited file, record by record.</p>
	        </td>
	    </table>
	  </div>
	 <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SDoomed Lambdas"></A>Doomed Lambdas</H2></P>   
		<div class="h2section" id="Doomed Lambdas"> 
	    <p>One of the most important events occurs at the end of an Lambda's life
	    span, just before the Lambda is destroyed. When an Lambda object is not longer
	    referenced, the garbage collector may choose to destroy the Lambda. Before
	    final destruction takes place, the Lambda will be sent a <b>doomed</b>
	    message.</p>
	    <p>Each Lambda's <b>EvalWhenDoomed</b> property is initially set to false.
	    Normally, garbage collecting an Lambda, causes nothing to happen (<i>other
	    than the destruction of the Lambda</i>); however, if the Lambda's <b>EvalWhenDoomed</b>
	    property is set to true, then the doomed Lambda is evaluated by the garbage
	    collector BEFORE final destruction.</p>
	    <p>For instance, the following Lambda community opens a file and performs
	    operations to the open file during the life span of the Lambda. When the
	    Lambda is destroyed, we do not wish the file to be left open. The closeLog
	    child Lambda has the task of responding to the <b>doomed</b> event and
	    closing the file before final destruction.</p>
	    <p>This example shows how several Lambdas in a community can work together
	    to open a file, keep it open during the life of the Lambda, and close the
	    file before the Lambda is destroyed.</p>
	    <p><b>(defun fileLog()</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	    pvars:(logFileHandle)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun closeLog()
	    (setq logFileHandle (fileClose logFileHandle)))</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun
	    openLog(fileName)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	    (setq logFileHandle (fileOpen fileName))</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	    (setq closeLog.EvalWhenDoomed true))</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defun
	    writeLog(record) (fileWrite logFileHandle record))</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;;
	    Initialization
</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq
	    logFileHandle false)
</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (setq
	    closeLog.EvalWhenDoomed false)</b></p>
	    <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true)</b></p>
	    </div>	   
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P><P><H2><A NAME="SInternet Security"></A>Internet Security</H2></P>   
		<div class="h2section" id="Internet Security"> 
      <p>Analytic Information Server enforces strict Internet security as its
      default mode of operation. Obviously, for any Lambda database system,
      Internet security is a fundamental issue. Rather than suffer an
      unfortunate security breach, AIS enforces strict Internet security at all
      times.</p>
      <p>Analytic Information Server supports three Internet (TCP/IP) protocols:
      HTML, XML, and AMP (<i>Lambda Message Protocol</i>) which is an XML
      extension protocol. Unless an Lambda declares itself as public (in the
      Interface section of the Lambda object), the Lambda remains unavailable to
      all Internet clients regardless of which protocol is being used by the
      client.</p>
      <p>The AMP protocol allows individual Lambdas to be accessed by Internet
      clients being served by Analytic Information Server. The AMP protocol
      supports user security levels from 0 (lowest) to 7 (highest). In order to
      be available to an Internet client, using the AMP protocol, an Lambda
      object must publish its availability in its Interfaces section. The
      following example Lambda is accessible by AMP Internet clients with
      security levels of five or higher.</p>
      <p><b>&nbsp;&nbsp;&nbsp; (defun clientHelper(msg)</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; faces:(;;
      This Lambda's interface proclamations</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (public Amp:) ;; Is available to AIS clients using the AMP protocol</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (security 5) ;; A client security level of five or higher is required</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ) ; end of Interfaces proclmations</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pvars:(p1)</b></p>
      <p><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (eval msg))</b></p>
      <p>&nbsp;</p>
      <p class="notes">Notes &amp; Hints</p>
      <p>Further details on the <b>AMP</b> Internet protocol may be found in the
      <i>Lambda Message protocols</i> reference guide.</p>
    </div>
	    <P ALIGN="CENTER"><INPUT TYPE='button' VALUE='Top of Page' onClick='navigate("#TOP");'></P>

 

</BODY>
</HTML>