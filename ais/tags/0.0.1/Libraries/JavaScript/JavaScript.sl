;;/**********************************************************************************
;;    Copyright (C) 2008 Investment Science Corp.
;;
;;    This program is free software: you can redistribute it and/or modify
;;    it under the terms of the GNU General Public License as published by
;;    the Free Software Foundation, either version 3 of the License, or
;;    any later version.
;;
;;    This program is distributed in the hope that it will be useful,
;;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;    GNU General Public License for more details.
;;
;;    You should have received a copy of the GNU General Public License
;;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;
;;***********************************************************************************/
;;
;;*************************************
;;*************************************
;; Exported Lambda File Cabinet Document
;;*************************************
;;*************************************

;;**EXPORTKEY**:javaScript
(defun javaScript(_input)
;; ********************************************************************
;; summary:  The javaScript compiler generated from javaScript:DEFINITION.
;; Summary:  This Lambda implements the javaScript compiler as defined
;;           in the javaScript:DEFINITION compiler definition file.
;;           Much code has been marked with a boxed comment lines for
;;           ease of human understanding.
;; Note:     This code was machine generated by ParseLib.
;; Parms:    _input   The javaScript language source string
;; return:   _result  The Lambda resulting from compiling the _input source.
;; Modification history:
;; TM Jan 15 99 Added Console Error suppression (see _consoleError, _makeError and _lastError)
;; TM Jan 20 99 Added _verboseLexIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSynIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Added _verboseSemIn - a directory of routines to be _verbose in
;; TM Jan 20 99 Changes _verbosexxxIn so that you supply a stop count
;;              example: (setq javaScript._verboseSynIn.MYRULE 2})  ; error after 2nd pass
;;                       (setq javaScript._verboseSynIn.MYRULE 0})  ; verbose on every pass
;;                       (setq javaScript._verboseSynIn.MYRULE: -1}) ; not verbose
;; TM Nov 13 01 Added _verboseLex   - flag forcing _verbose only in Lex
;;                    _verboseSyn   - flag forcing _verbose only in Syntax
;;                    _verboseSem   - flag forcing _verbose only in Semantic
;; TM Nov 19 10 Added new error handling that automatically turns verbose on near the 
;;              parse error. This makes most of the other error handling in the tool 
;;              obsolete except when you want to see a full trace of all rule attempts from
;;              the begining of one of the passes.
;; ********************************************************************
   pvars:(_changeCount             ;; Number of rule based substitutions
          _explainOnOff            ;; Switch for saving semantic explanation steps in the _explanation variable 
          _explanation             ;; Variable for saving semantic explanation steps (see _explainOnOff) 
          _indent                  ;; Indent for displaying each explanation step on the console
          _io                      ;; Current parse tree index object
          _ip                      ;; Current parse tree index pointer
          (_maxPasses 200)         ;; Maximum number of passes before issuing error (singlePass = false)
          (morphFail |*failure*|:) ;; Morph rule failure RHS value
          _name                    ;; Name of the current compiler definition
          _parseLen                ;; Current parse tree length
          _parseTree               ;; Current head of the parse tree during recognition
          _passCount               ;; Current number of passes already executed by apply
          _result                  ;; Final result of parsing the submitted compiler definition rules 
          _semanticRule            ;; Current semantic rule to be applied by _applyRule 
          _semanticStack           ;; Current semantic stack for use by _applyRule 
          _semanticVerbose         ;; Switch for displaying each semantic explanation step on the console 
          _showTokens              ;; Show only the token list resulting from the lexical analyzer
          _syntaxFeatures          ;; Syntax features supplied in the compiler definition
          _tkIN                    ;; Place holder for the input source string (see $IN) 
          _tkLIST                  ;; The output token list from the lexer rules.
          _tkOUT                   ;; Output a feature based token to the token list.
          tokenDirectory           ;; Lexicon of token and their attributes
          _userFunctions           ;; User functions source code supplied in the compiler definition
          _verbose                 ;; Switch for displaying each explanation step on the console
          _verboseHold 
           ;; Switch for displaying each explanation step on the console
          _verboseLex			   ;; Switch for displaying only lexical steps
          _verboseSyn              ;; Switch for displaying only syntax steps
          _verboseSem              ;; Switch for displaying only sematic steps
          _verboseLexIn            ;; Structure of lex parse routines in which we should force _verbose true
          _verboseSynIn            ;; Structure of syntax parse routines in which we should force _verbose true
          _verboseSemIn            ;; Structure of semantic parse routines in which we should force _verbose true
          _verboseLexCount         ;; Structure of Counts used by _verboseLexCount (not set by user!)
          _verboseSynCount         ;; Structure of Counts used by _verboseSynCount (not set by user!)
          _verboseSemCount         ;; Structure of Counts used by _verboseSemCount (not set by user!)
          _lastError               ;; Error encountered during parse 
          
          _ruleCount               ;; Number of rules tried 
          _ruleCountLex
          _ruleCountSyn
          _ruleCountSem
          _failurePass
          _failureIn
          _verboseState
          (_verboseTrigger -1)     ;; If more than zero this indicates at what _ruleCount _verbose should be turned on
     
          _incCount				   ;; increment number of rules tried and test for error condition
          _startLog
           
          (_consoleErrors true)    ;; Error messaging flag is false no messages will be printed to console
          ;; Methods list 
          _findLineNum             ;; find the line the error ocurred in
          _makeError               ;; _error function wrapper that creates pretty errors and sets _lastError values
          _error                   ;; error function wrapper allowing silent or console messaging
          _apply                   ;; Apply the specified semantic rule to the result
          _applyRule               ;; Apply the current semantic rule to a sub list
          appendList               ;; Append multiple arguments into a list
          defaultLexer             ;; Default lexical analyzer for recognizing input symbols
          defaultTokenRule         ;; Modified default rule for adding attributes to a parsed token
          _eofToken                ;; Return true if we are at the end of the parse tree
          _errorHandler            ;; Handle any errors which may occur during compilation
          _getToken                ;; Get the next attributed token in the parse tree
          _Initialize              ;; Initialization routine for setting token dicrectory, etc.
          _initializeSW            ;; Initialization switch (set true after first initialization).
          initRule                 ;; User defined initialization routine for setting token dicrectory, etc.
          _lastIp                  ;; Move the current parse tree index to the previous position
          _lenIp                   ;; Return the length of the current parse tree
          _nextIp                  ;; Move the current parse tree index to the next position
          outputRule               ;; Default rule for returning the final output from the compiler
          _popIp                   ;; Pop the current parse tree index up one level to the next position
          preLexRule               ;; Default rule for any pre-lexical compiler operations.
          _pushIp                  ;; Push the current parse tree index down one level to the next position
          _setLexicalFeature       ;; Assign a set of letters to the specified lexical feature
          _setSyntaxFeature        ;; Set a whole class of syntax tokens with the specified attribute
          _setWordFeatures         ;; Set or enhance a whole word with the specified features and feature values
          _showInput               ;; Show a fragment of the input source string in lexical verbose mode
          _showSource              ;; Show a fragment of the input source string in syntax verbose mode
          startRule                ;; Default rule for starting the compiler
          _writeRule               ;; Display the results of a rule firing in verbose mode
          $IN                      ;; Place holder for the input source string (see _tkIN)
          $LIST                    ;; The output token list from the lexer rules.
          $OUT                     ;; Output a feature based token to the token list.
          $ASIS                    ;; Output a feature based token to the token list (as is).








          ;; Variables to hold lexical feature bit maps
          _LF_Digit
          _LF_Alpha
          _LF_AlphaNum
          _LF_NameChar
          _LF_Letter
          _LF_NameStart
          _LF_Operator
          _LF_DQuote
          _LF_NotDQuote
          _LF_Quote
          _LF_NotQuote
          _LF_Whitespace
          _LF_Eol
          _LF_NotEol
          _LF_Period
          _LF_Exponent
          _LF_Sign
          ;; Functions to implement Lexical Rules
          _LEXRULE_MAIN
          ;; Functions to implement Syntax Rules
          _SYNRULE_ARGLIST
          _SYNRULE_CFCALL
          _SYNRULE_CHILD
          _SYNRULE_CLASS
          _SYNRULE_CUT
          _SYNRULE_EXPRESSION
          _SYNRULE_FIELDLIST
          _SYNRULE_FILTER
          _SYNRULE_FRIEND
          _SYNRULE_FSTATEMENT
          _SYNRULE_FSTMTLIST
          _SYNRULE_FUNCTION
          _SYNRULE_MAIN
          _SYNRULE_METHOD
          _SYNRULE_NAME
          _SYNRULE_NAMELIST
          _SYNRULE_ORPHAN
          _SYNRULE_PARMLIST
          _SYNRULE_PEXPRESSION
          _SYNRULE_PHRASE
          _SYNRULE_QUALIFY
          _SYNRULE_REFLIST
          _SYNRULE_SCORE
          _SYNRULE_SEXPRESSION
          _SYNRULE_SSTATEMENT
          _SYNRULE_STATEMENT
          _SYNRULE_STMTLIST
          _SYNRULE_TERM
          _SYNRULE_VAR
          ;; Functions to implement Semantic Rules
          _SEMRULE_LAMBDA
          _SEMRULE_LET
          _SEMRULE_LETOMIT
          _SEMRULE_LETTRUNCATE
          _SEMRULE_MAIN
          _SEMRULE_OMIT
          _SEMRULE_REFOMIT
          _SEMRULE_REFTRUNCATE
          _SEMRULE_TRUNCATE
         ) ;; end of persistent variables
   vars:(i verboseHold outString outExplain)
   ;; ***************************************************
   ;; Define the child Lambdas which belong to this parent
   ;; ***************************************************

   ;;*********************************************************************
   ;; 
   ;;*********************************************************************
   (defun _incCount()
   	(setq _ruleCount (+ _ruleCount 1)) 
   	(if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog))
   	
   	true)

   ;;*********************************************************************
   ;; 
   ;;*********************************************************************
   (defun _startLog()
   		vars:(i len)
		(setq _verbose true)
		(writeln "*********Lexed Tokens with Features Near Failure*********")
		(setq len (min (+ _ip 50) (length _parseTree)))
		(loop for i from _ip until len do
			(writeln "[" i "] " _parseTree[i])
		) ; end loop
		(writeln "*********Source near Failure***********")
		(writeln "Charpos=" _parseTree[_ip].Charpos)
		(writeln (substring $IN _parseTree[_ip].Charpos (+ _parseTree[_ip].Charpos 1000)))
		(writeln "*********Rules starting near Failure*****")
   			
   true)


   ;;*********************************************************************
   ;; Centralized print routine for logging errors to console. 
   ;;*********************************************************************
   (defun _logLine(lineArg show)
   		vars:(lineText)
   		(setq lineText (new Vector: byte: 30000))
   		(cond
   			((= show source:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg (_showSource 20))))
   			((= show input:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg (_showInput 20))))
   			((= show none:) (setq lineText (appendWriteln lineText (rept " " _indent) lineArg)))
		);cond   			
 		(writeln lineText)  
   true)

   ;;*********************************************************************
   ;; Finds the line number given a character position
   ;;*********************************************************************
   (defun _findLineNum(pos)
      vars: (i j l)
      (setq j 0)
      (setq l (length $IN))
      (if (< pos l) (setq l pos))
      (loop for i from 0 until l do
         (if (= $IN[i] 10) (setq j (iadd j 1)))
         ); end loop
      j; return number of linefeeds found
      ); end findLineNum

   ;;*********************************************************************
   ;; Construct Error
   ;;*********************************************************************
   (defun _makeError(errorKey pos desc)
      vars: (i j line1 line2 line3 line4 eof nontabs tabs temp result)

      (setq eof (length $IN))
      (setq nontabs 0)
      (setq tabs 0)


      ;find start of error line - line2
      (setq i pos)
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line2 (iadd i 1)) (setq line2 0))

      ;Count number of tabs and non-tabs up to error in error line
      (setq j line2)
      (while (< j pos) (if (= $IN[j] 9) (setq tabs (iadd tabs 1)) (setq nontabs (iadd nontabs 1))) (setq j (iadd j 1)))

      ;find start of line1
      (while (and (>= i 0) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (isub i 1))) 
      (while (and (>= i 0) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (isub i 1)))
      (if (> i 0) (setq line1 (iadd i 1)) (setq line1 0))

      ;find start of line 3
      (setq i pos) ; reset to error position
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
       (setq line3 i)

      ;find start of line 4
      (while (and (< i eof) (<> $IN[i] 10) (<> $IN[i] 13)) (setq i (iadd i 1)))
      (while (and (< i eof) (or (= $IN[i] 10) (= $IN[i] 13))) (setq i (iadd i 1)))
      (setq line4 i)

      ;Create error window
      (setq temp (append 
           (if (> (- line2 line1) 0) (substring $IN line1 (isub line2 1)) "") ;line 1
           (if (> (- line3 line2) 0) (substring $IN line2 (isub line3 1)) "") ;line 2 
           (if (= line3 eof) _eol ""); add an _eol if line2 is the only line!
           (rept " " nontabs) (rept (string (char 9)) tabs) "^error" _eol 
           (if (> line4 line3) (substring $IN line3 (isub line4 1)) "")
           ))

      ; Normalize tabs to 4 chars each
      (setq j (length temp))
      (setq result "")
      (loop for i from 0 until j do
         (setq result (append result (if (= temp[i] 9) "    " (string temp[i]))))
         ); end loop

      ;insert values into the _lastError structure
      (setq _lastError.errorKey errorKey)
      (setq _lastError.line (_findLineNum pos))
      (setq _lastError.desc desc)
      (setq _lastError.charpos pos)
      (setq _lastError.message result)

      ;(_error errorKey (append " " desc " Line:" _lastError.line " Charpos:" pos _eol _lastError.message))
      (_error (append " " desc " Line:" _lastError.line " Char:" pos _eol _lastError.message))

      ); end _makeError

   ;; _error wraps the builtin error function so that it 
   ;; is possible to disable console errors for silent
   ;; operation. The _consoleErrors variable determines
   ;; the function of _error.
   (defun _error ( ... )
      vars:(argc i e)

      (setq argc (argCount))
      (setq e (new Vector: argc))
      (loop for i from 0 until argc do
         (setq e[i] (argFetch i))
         ); end loop

       (if _consoleErrors (apply error e) (error e[0]))

      false ; we will never actually get here but put in a return anyway
      ); of defun _error

   ;; Append multiple arguments into a list.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun appendList(one two ...)
       vars:(result argc i)
       (cond 
           ((and (isPair one) (isPair two)) (setq result (append one two)))
           ((= one #void) (setq result two))
           ((and (isPair one) (= two #void)) (setq result one))
           ((isPair one) (setq result (append one (list two))))
           ((= two #void) (setq result (list one)))
           (else (setq result (list one two)))
           ) ; end cond
       (setq argc (argCount))
       (loop for i from 2 until argc do
           (setq result (appendList result (argFetch i)))
           ) ;; end loop
       result) ;; end appendList
   ;; Apply the specified semantic rule to the result.
   ;; Note: This Lambda is here as a builtin function for
   ;;       use in the output section of any rule definition. 
   (defun _apply(theRule multiplePass)
       vars:(outList outString outExplain)
       ;(if _semanticVerbose (setq outString (append "Replacing: " (string _result true) " ==> ")))
       ;(if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string _result true) " ==> "))))
       (setq outList _result)
       (setq _passCount 0)
       (setq _semanticRule theRule)
       Retry::
       (if (> _passCount _maxPasses) (_error "ParseLib_Pass" "Exceeded maximum number of apply rules."))
       (setq _changeCount 0)
       (setq outList (morph (list outList) _applyRule morphFail))
       (if (isPair outList) (setq outList (car outList)))
       (if (and (> _changeCount 0) (= multiplePass true) (isPair outList)) (goto Retry:))
       ;(if (= _semanticVerbose true) (writeln outString  (string outList true)))
       ;(if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
       (setq _result outList)
       _result) ;; end of _apply
   ;; Apply the current semantic rule to a sub list
   ;; Note: This Lambda is called by morph for every sub list
   ;;       in the larger result list. 
   (defun _applyRule(sexp)
      vars:(ret outString outExplain)
      (setq _ip -1)
      (setq _io sexp)
      (if _semanticVerbose (setq outString (append "Replacing: " (string sexp true) " ==> ")))
      (if _explainOnOff (setq outExplain (setq outExplain (append "Replacing: " (string sexp true) " ==> "))))
      (setq _semanticStack (new Structure: _io _ip))
      (if (<> (setq ret (_semanticRule)) morphFail)
          (begin
             (++ _changeCount)
             (if (= _semanticVerbose true) (writeln outString  (string ret true)))
             (if _explainOnOff (setq _explanation (append _explanation outExplain (string ret true) _eol)))
             (return ret)
          )) ;; end if
      morphFail) ;; end of _applyRule
   ;; Modified default rule for adding attributes to a parsed token.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun defaultTokenRule(token)
       vars:(result tokenLen tokenEnd)
       ;; Is this token a delimited constant?
       (if (isVector token) 
           (begin
              (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
              (return result)
              )) ;; end if delimited constant
       ;; Is this token an integer constant?
       (if (isInteger token) 
           (begin
              (setq result (new Structure: Value: token  Integer: true  Number: true  Constant: true))
              (return result)
              )) ;; end if integer constant
       ;; Is this token an numeric constant?
       (if (isNumber token) 
           (begin
              (setq result (new Structure: Value: token  Number: true  Constant: true))
              (return result)
              )) ;; end if numeric constant
       ;; Is this token a name token?
       (if (isCharName token) 
           (begin
              (setq result (new Structure: Value: token  Name: true  Default: true))
              ;; Add the token to the directory so we don't have to do this again.
              (setq tokenDirectory[token] result) 
              (return result)
              )) ;; end if numeric constant
       ;; Create a default attributed structure for this token
       (setq result (new Structure: Value: token Default: true))
       ;; Add the token to the directory so we don't have to do this again.
       (setq tokenDirectory[token] result) 
       result) ;; end defaultTokenRule
   ;; Return true if the we are at the end of the parse tree.
   (defun _eofToken()
       (if (>= (_nextIp) (_lenIp)) true (_lastIp))) ;; end _eofToken
   ;; Manages any errors which may occur during compilation.
   (defun _errorHandler(errMsg)
      vars:(stemp n)
      (setq stemp (string errMsg true))
      (setq n (length stemp))
      (setq stemp (right (left stemp (- n 2)) (- n 4)))
      (error stemp)) ;; end of _errorHandler
   ;; Get the next token in the current parse tree.
   (defun _getToken()
       vars:(result i io n)
       ;; Load the next token in the parse tree.
       ;(if (>= (_nextIp) (_lenIp)) (begin (setq result morphFail) (_lastIp) (return result)))
       (if (>= (_nextIp) (_lenIp)) (return morphFail))
       (if (isNumber _ip) (return _io[_ip]))
       (setq n (subi (length _ip) 1))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (setq result io[_ip[n]]) 
       result) ;; end of _getToken
   ;; Initialization routine for setting token dicrectory, etc.
   ;; Note: This Lambda is run once during the lifetime of the
   ;;       parent Lambda.
   (defun _Initialize()
       (setq _initializeSW true)
       ;; Reset the verbose mode indent.
       (setq _indent 0)
       ;; Create the token directory for the compiler definition language.
       (setq tokenDirectory (new Directory:))
       ;; Adjust the lexical analyzer for the compiler definition language.
       (defaultLexer._Initialize)








       ;; Initialization of Delimited Strings
       (defaultLexer.addStringDelimiters   String: {"} {"})
       (defaultLexer.addStringDelimiters   Symbol: {'} {'})
       (defaultLexer.addStringDelimiters   Whitespace: {/*} {*/})
       (defaultLexer.addStringDelimiters   Whitespace2: {//} _eol
)
         ;; Initialization of Lexical Features
       (setq _LF_Digit (_setLexicalFeature _LF_Digit #( 1 48 57)))
       (setq _LF_Alpha (_setLexicalFeature _LF_Alpha #( 1 97 122 1 65 90)))
       (setq _LF_AlphaNum (_setLexicalFeature _LF_AlphaNum #( 1 97 122 1 65 90 1 48 57)))
       (setq _LF_NameChar (_setLexicalFeature _LF_NameChar #( 1 97 122 1 65 90 1 48 57 1 95 95)))
       (setq _LF_Letter (_setLexicalFeature _LF_Letter #( 1 97 122 1 65 90)))
       (setq _LF_NameStart (_setLexicalFeature _LF_NameStart #( 1 97 122 1 65 90 1 95 95)))
       (setq _LF_Operator (_setLexicalFeature _LF_Operator #( 1 60 60 1 62 62 1 61 61 1 38 38 1 37 37 1 33 33 1 94 94 1 126 126 1 43 43 1 47 47 1 42 42 1 45 45 1 124 124 1 35 35)))
       (setq _LF_DQuote (_setLexicalFeature _LF_DQuote #( 1 34 34)))
       (setq _LF_NotDQuote (_setLexicalFeature _LF_NotDQuote #( 1 0 255 0 34 34)))
       (setq _LF_Quote (_setLexicalFeature _LF_Quote #( 1 39 39)))
       (setq _LF_NotQuote (_setLexicalFeature _LF_NotQuote #( 1 0 255 0 39 39)))
       (setq _LF_Whitespace (_setLexicalFeature _LF_Whitespace #( 1 0 32)))
       (setq _LF_Eol (_setLexicalFeature _LF_Eol #( 1 10 10 1 13 13)))
       (setq _LF_NotEol (_setLexicalFeature _LF_NotEol #( 1 0 255 0 10 10 0 13 13)))
       (setq _LF_Period (_setLexicalFeature _LF_Period #( 1 46 46)))
       (setq _LF_Exponent (_setLexicalFeature _LF_Exponent #( 1 101 101 1 69 69)))
       (setq _LF_Sign (_setLexicalFeature _LF_Sign #( 1 43 43 1 45 45)))
         ;; Initialization of Syntax Features
       (_setSyntaxFeature Operator: #( |+| |-| |*| |/| |%| "&&" "||" "#") #void)
       (_setSyntaxFeature Lisp: #( |+| |-| |*| |/| |%| "&&" "||" "#") #(+ - * / mod and or pdiv ))
       (_setSyntaxFeature Charop: #( |+| |-| |*| |/| |%| "&&" "||") #(cadd csub cmul cdiv cmod and or ))
       (_setSyntaxFeature Chartyp: #( |+| |-| |*| |/| |%| "&&" "||") #(char char char char char bool bool ))
       (_setSyntaxFeature Boolop: #( |+| |-| |*| |/| |%| "&&" "||") #(badd bsub bmul bdiv bmod and or ))
       (_setSyntaxFeature Booltyp: #( |+| |-| |*| |/| |%| "&&" "||") #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |+| |-| |*| |/| |%| "&&" "||") #(iadd isub imul idiv imod and or ))
       (_setSyntaxFeature Inttyp: #( |+| |-| |*| |/| |%| "&&" "||") #(int int int int int bool bool ))
       (_setSyntaxFeature Floatop: #( |+| |-| |*| |/| |%| "&&" "||") #(nadd nsub nmul ndiv nmod and or ))
       (_setSyntaxFeature Floattyp: #( |+| |-| |*| |/| |%| "&&" "||") #(float float float float float bool bool ))
       (_setSyntaxFeature Operator: #( |==| |<| |<=| |>| |>=| |!=|) #void)
       (_setSyntaxFeature Lisp: #( |==| |<| |<=| |>| |>=| |!=|) #(= < <= > >= <> ))
       (_setSyntaxFeature Boolop: #( |==| |<| |<=| |>| |>=| |!=|) #(bcompareEQ bcompareLT bcompareLE bcompareGT bcompareGE bcompareNE ))
       (_setSyntaxFeature Booltyp: #( |==| |<| |<=| |>| |>=| |!=|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Charop: #( |==| |<| |<=| |>| |>=| |!=|) #(ccompareEQ ccompareLT ccompareLE ccompareGT ccompareGE ccompareNE ))
       (_setSyntaxFeature Chartyp: #( |==| |<| |<=| |>| |>=| |!=|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |==| |<| |<=| |>| |>=| |!=|) #(icompareEQ icompareLT icompareLE icompareGT icompareGE icompareNE ))
       (_setSyntaxFeature Inttyp: #( |==| |<| |<=| |>| |>=| |!=|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature Floatop: #( |==| |<| |<=| |>| |>=| |!=|) #(ncompareEQ ncompareLT ncompareLE ncompareGT ncompareGE ncompareNE ))
       (_setSyntaxFeature Floattyp: #( |==| |<| |<=| |>| |>=| |!=|) #(bool bool bool bool bool bool bool ))
       (_setSyntaxFeature MathAssignmentOperator: #( |+=| |-=| |/=| |*=| "%=") #void)
       (_setSyntaxFeature Lisp: #( |+=| |-=| |/=| |*=| |%| |=|) #(+ - / * mod ))
       (_setSyntaxFeature Charop: #( |+=| |-=| |/=| |*=| |%| |=|) #(cadd csub cmul cdiv cmod ))
       (_setSyntaxFeature Chartyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(char char char char char ))
       (_setSyntaxFeature Boolop: #( |+=| |-=| |/=| |*=| |%| |=|) #(badd bsub bmul bdiv bmod ))
       (_setSyntaxFeature Booltyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(bool bool bool bool bool ))
       (_setSyntaxFeature Intop: #( |+=| |-=| |/=| |*=| |%| |=|) #(iadd isub imul idiv imod ))
       (_setSyntaxFeature Inttyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(int int int int int int ))
       (_setSyntaxFeature Floatop: #( |+=| |-=| |/=| |*=| |%| |=|) #(nadd nsub nmul ndiv nmod ))
       (_setSyntaxFeature Floattyp: #( |+=| |-=| |/=| |*=| |%| |=|) #(float float float float float ))
       (_setSyntaxFeature AssignmentOperator: #( |=|) #void)
       (_setSyntaxFeature Lisp: #( |=|) #(setq ))
       (_setSyntaxFeature InitializeOperator: #( |=|) #void)
       (_setSyntaxFeature RelationOperator: #( |==| |<| |<=| |>| |>=| |!=|) #void)
       (_setSyntaxFeature Boolean: #( |true| |false|) #(true false ))
       (_setSyntaxFeature Term: #( |true| |false|) #void)
       (_setSyntaxFeature Increment: #( |++| |--|) #void)
       (_setSyntaxFeature Lisp: #( |++| |--|) #(+ - ))
       (_setSyntaxFeature Boolop: #( |++| |--|) #(badd bsub ))
       (_setSyntaxFeature Booltyp: #( |++| |--|) #(bool bool ))
       (_setSyntaxFeature Charop: #( |++| |--|) #(cadd csub ))
       (_setSyntaxFeature Chartyp: #( |++| |--|) #(char char ))
       (_setSyntaxFeature Intop: #( |++| |--|) #(iadd isub ))
       (_setSyntaxFeature Inttyp: #( |++| |--|) #(int int ))
       (_setSyntaxFeature Floatop: #( |++| |--|) #(nadd nsub ))
       (_setSyntaxFeature Floattyp: #( |++| |--|) #(float float ))
       (_setSyntaxFeature Logical: #( |!|) #void)
       (_setSyntaxFeature Lisp: #( |!|) #(not ))
       (_setSyntaxFeature Precedence: #( |*| |/| |%| |+| |-| |<| |<=| |>| |>=| |==| |!=| "&&" "||") #(2 1 1 3 4 5 5 5 5 6 6 7 8 ))
       (_setSyntaxFeature For: #( |for|) #void)
       (_setSyntaxFeature Function: #( |function|) #void)
       (_setSyntaxFeature Friend: #( |friend|) #void)
       (_setSyntaxFeature Class: #( |class|) #void)
       (_setSyntaxFeature Extends: #( |extends|) #void)
       (_setSyntaxFeature Child: #( |child|) #void)
       (_setSyntaxFeature Orphan: #( |orphan|) #void)
       (_setSyntaxFeature Method: #( |method|) #void)
       (_setSyntaxFeature If: #( |if|) #void)
       (_setSyntaxFeature Name: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #void)
       (_setSyntaxFeature Of: #( |of|) #void)
       (_setSyntaxFeature Type: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #void)
       (_setSyntaxFeature Reftyp: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(int float char bool obj char char char obj obj obj obj int char float int float obj int obj float ))
       (_setSyntaxFeature Refop: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(ref ref ref ref ref reftext refSymbol refString ref ref ref refVector refBitVector refBytVector refNumVector refIntVector refFltVector refObjVector refPcdVector ref ref ))
       (_setSyntaxFeature Setop: #( |int| |float| |char| |bool| |obj| |text| |symbol| |string| |stc| |dir| |dic| |vec| |bitvec| |bytvec| |numvec| |intvec| |fltvec| |objvec| |pcdvec| |matrix| |nummat|) #(setq setq setq setq setq setq setq setString setq setq setq setVector setBitVector setBytVector setNumVector setIntVector setFltVector setObjVector setPcdVector setq setq ))
       (_setSyntaxFeature While: #( |while|) #void)
       (_setSyntaxFeature Else: #( |else|) #void)
       (_setSyntaxFeature Var: #( |var|) #void)
       (_setSyntaxFeature Pvar: #( |pvar|) #void)
       (_setSyntaxFeature Cvar: #( |cvar|) #void)
       (_setSyntaxFeature Semicolon: #( ";") #void)
       (_setSyntaxFeature Colon: #( ":") #void)
       (_setSyntaxFeature Question: #( "?") #void)
       (_setSyntaxFeature LeftParen: #( "(") #void)
       (_setSyntaxFeature RightParen: #( ")") #void)
       (_setSyntaxFeature LeftBrace: #( "{") #void)
       (_setSyntaxFeature RightBrace: #( "}") #void)
       (_setSyntaxFeature LeftBracket: #( "[") #void)
       (_setSyntaxFeature RightBracket: #( "]") #void)
       (_setSyntaxFeature Comma: #( ",") #void)
       (_setSyntaxFeature DotOperator: #( ".") #void)
       (_setSyntaxFeature Reserved: #( |if| |then| |else| |while| |do| |var| |pvar| |cvar| |for| |function| |orphan| |friend| |child| |class| |method| |extends|) #void)
       (_setSyntaxFeature Filter: #( |filter|) #void)
       (_setSyntaxFeature Percent: #( |%|) #void)
       (_setSyntaxFeature Sort: #( |sort|) #void)
       (_setSyntaxFeature Backup: #( |backup|) #void)
       (_setSyntaxFeature Direction: #( |up| |down|) #void)
       (_setSyntaxFeature All: #( |all|) #void)
       (_setSyntaxFeature Omit: #( |omit|) #void)
       (_setSyntaxFeature Check: #( |check|) #void)
       (_setSyntaxFeature Checkoff: #( |checkoff| |nocheck|) #void)
       (_setSyntaxFeature Checkon: #( |checkon|) #void)
       (_setSyntaxFeature Cut: #( |bottom| |top|) #void)
       (_setSyntaxFeature Slice: #( |slice|) #void)
       (_setSyntaxFeature Lisp: #( |slice| |bottom| |up| |top| |down| |all|) #(<= <= <= >= >= true ))
       (_setSyntaxFeature Score: #( |score|) #void)
       (_setSyntaxFeature ScoreCommand: #( |average| |averageForAll| |total| |totalForAll| |maximum| |minimum| |deviation| |sharpe|) #void)
       (_setSyntaxFeature Set: #( |Set| |set|) #void)
       (_setSyntaxFeature Setnr: #( |Setnr| |setnr|) #void)
       (_setSyntaxFeature Run: #( |run|) #void)
       (_setSyntaxFeature Restore: #( |restore|) #void)
       (_setSyntaxFeature Reserved: #( |all| |average| |averageForAll| |backup| |bottom| |check| |checkoff| |checkon| |down| |filter|) #void)
       (_setSyntaxFeature Reserved: #( |nocheck| |omit| |restore| |run| |score| |set| |sort| |up| |top| |total| |totalForAll|) #void)
       ;; Call the user defined initialization routine
       (initRule)
       true) ;; end _Initialize
   ;; Default rule for user defined compiler initialization tasks.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun initRule()
       true) ;; end initRule
   ;; Move the current parse tree index to the previous position.
   (defun _lastIp()
       (if (isNumber _ip) (return (setq _ip (subi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (subi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _lastIp
   ;; Return the length of the current parse.
   (defun _lenIp()
       vars:(i io n)
       (if (isNumber _ip) (return (length _io)))
       (setq n (sub1 (length _ip)))
       (setq io _io)
       (loop for i from 0 until n do
           (setq io io[_ip[i]])          
           ) ; end loop
       (length io)) ;; end _lenIp
   ;; Default main Lexical Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _LEXRULE_MAIN()
       (defaultLexer $IN)) ;; end _LEXRULE_MAIN
   ;; Move the current parse tree index to the next position.
   (defun _nextIp()
       (if (isNumber _ip) (return (setq _ip (addi _ip 1))))
       (setq _ip[(subi (length _ip) 1)] (addi _ip[(sub1 (length _ip))] 1))
       _ip[(subi (length _ip) 1)]) ;; end _nextIp
   ;; Default rule for returning the final output from the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun outputRule(result)
       result) ;; end outputRule
   ;; Pop the current parse tree index up one level to the next position.
   (defun _popIp()
       (if (isNumber _ip) (return true))
       (if (<= (length _ip) 1) (begin (setq _ip _ip[0]) (return true)))
       (resize _ip (subi (length _ip) 1))
       true) ;; end _popIp
   ;; Default rule for any pre-lexical compiler operations.
   (defun preLexRule(input) input)
   ;; Push the current parse tree index down one level to the next position.
   (defun _pushIp()
       (if (isNumber _ip) (setq _ip (new Vector: 1 _ip)))
       (setq _ip[(length _ip)] -1)
       true) ;; end _pushIp
   ;; Assign a set of letters to the specified lexical feature
   (defun _setLexicalFeature(letterBitMap values)
       vars:(i j valueLen start end bit)
       (setq valueLen (length values))
       (if (= letterBitMap #void) (setq letterBitMap (new Vector: bit: 255)))
       (loop for i from 0 until valueLen by 3 do
          (setq bit values[i])
          (setq start (integer (min values[(+ i 1)] values[(+ i 2)])))
          (setq end (integer (max values[(+ i 1)] values[(+ i 2)])))
          (loop for j from start to end do
              (setq letterBitMap[j] bit)
              ) ; end j loop
           ) ; end i loop
       letterBitMap) ; end _setLexicalFeature
   ;; Set a whole class of syntax tokens with the specified attribute and values
   (defun _setSyntaxFeature(name words values)
       vars:(i wordLen token)
       (setq wordLen (length words))
       (loop for i from 0 until wordLen do
           (setq token tokenDirectory[words[i]])
           (if (= token #void) (setq token (new Structure:)))
           (if (= values[i] #void)
               (setq token[name] true)
               (setq token[name] values[i])
               ) ; end if
           (setq token.Value words[i])
           (setq tokenDirectory[words[i]] token)
           ) ; end loop
       true) ; end _setSyntaxFeature 
   ;; Set or enhance a whole word with the specified features and feature values
   ;; Note1: The word may be a single word or a vector starting with the word
   ;;        and proceeding with all of its gramatical synonyms. 
   ;;        For instance:   #(give gives gave given giving) 
   ;;        Each synonym may be a single word or a vector starting with the word
   ;;        and proceeding with all of its special features. 
   ;;        For instance:   #(give gives gave given #(giving Noun))
   ;; Note2: Each feature may be a single word or a vector starting with the feature
   ;;        and proceeding with the value of the feature. A singleton feature is
   ;;        assumed to have a value of true. 
   ;;        For instance:   Noun: Name: #(Color blue) 
   (defun _setWordFeatures(words commonFeatures)
       vars:(k K m M n N token feature featureName word extraFeatures)
       ;; If there are more than one grammatical synonym, then define each one.
       (if (not (isVector words)) (setq words (new Vector: 1 words)))
       (setq M (length words)) 
	   (setq N (length commonFeatures))
       ;; Extract the common feature name from the first word.
       ;; Note: Words with extra features are entered as Vectors
       (if (isVector words[0])
           then
           ;; The common word has extra features
           (setq featureName (downcase (makeString words[0][0])))
           else
           ;; The common word has no extra features
           (setq featureName (downcase (makeString words[0])))
           ) ; end if
       (setq featureName[0] (upcase featureName[0]))
       (setq featureName (symbol featureName))
       ;; Set all words to upper case.
       (loop for m from 0 until M do
           ;; Each word is stored upper case.
           ;; Note: Words with extra features are entered as Vectors
           (if (isVector words[m])
               then
               ;; This word has extra features
               (begin
                  (setq extraFeatures words[m])
                  (setq K (length extraFeatures))
                  (setq word (makeString extraFeatures[0]))
               ) ; end then
               else
               ;; This word has no extra features
               (begin
                  (setq extraFeatures #void)
                  (setq K 0)
                  (setq word (makeString words[m]))
               )) ; end if
	       (setq token tokenDirectory[word])
	       (if (= token #void) (setq token (new Structure:)))
	       (setq token.Value word)
           ;; Each word has its main word as a feature.
	       (setq token[featureName] true)
           ;; Each word has itself as a feature.
	       (setq feature (downcase (makeString word)))
	       (setq feature[0] (upcase word[0]))
	       (setq feature (symbol feature))
	       (setq token[feature] true)
	       ;; Add common features to this word.
	       (loop for n from 0 until N do
	           (setq feature commonFeatures[n])
	           (if (isVector feature) 
	               (setq token[feature[0]] feature[1])
	               (setq token[feature] true)
	               ) ; end if
	           ) ; end feature loop
	       ;; Add extra features to this word.
	       (loop for k from 1 until K do
	           (setq feature extraFeatures[k])
	           (if (isVector feature) 
	               (setq token[feature[0]] feature[1])
	               (setq token[feature] true)
	               ) ; end if
	           ) ; end feature loop
           (setq tokenDirectory[word] token)
	       ) ; end word loop
       true) ; end _setWordFeatures
   ;; Show a fragment of the input source string in lexical verbose mode
   (defun _showInput(size)
       vars:(sourceIndex sourceLen result)
       (setq sourceLen (length $IN))
       (setq sourceIndex (addi _ip 1))
       (if (< sourceIndex sourceLen)
           (setq result (mid $IN sourceIndex size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showInput
   ;; Show a fragment of the input source string in syntax verbose mode
   (defun _showSource(size)
       vars:(treeIndex treeLen result)
       (setq treeLen (length _parseTree))
       (setq treeIndex (addi _ip 1))
       (if (< treeIndex treeLen)
           (setq result (mid $IN _parseTree[treeIndex].Charpos size))
           (setq result "...End Of File...")
           ) ; end if
       result) ; end _showSource
   ;; Default rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun startRule()
       true) ;; end startRule
   ;; Default main Syntax Rule for starting the compiler.
   ;; Note: This Lambda is here in case the user does not 
   ;;       define one of his/her own.
   (defun _SYNRULE_MAIN()
       _parseTree) ;; end _SYNRULE_MAIN
   ;; Display the results of a rule firing in verbose mode.
   (defun writeRule(ruleID _ret t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10)
   	   vars:(ruleText)
   	   (setq ruleText (new Vector: byte: 5000))
   	   (appendWriteln ruleText 
   	   		"Firing " 
   	   		ruleID
	       	(if (<> t1 #void)  (append "  " (rept " " _indent) "t1 = " (string t1 true) _eol) "")
	       	(if (<> t2 #void)  (append "  " (rept " " _indent) "t2 = " (string t2 true) _eol) "")
	       	(if (<> t3 #void)  (append "  " (rept " " _indent) "t3 = " (string t3 true) _eol) "")
	       	(if (<> t4 #void)  (append "  " (rept " " _indent) "t4 = " (string t4 true) _eol) "")
	       	(if (<> t5 #void)  (append "  " (rept " " _indent) "t5 = " (string t5 true) _eol) "")
	       	(if (<> t6 #void)  (append "  " (rept " " _indent) "t6 = " (string t6 true) _eol) "")
	       	(if (<> t7 #void)  (append "  " (rept " " _indent) "t7 = " (string t7 true) _eol) "")
	       	(if (<> t8 #void)  (append "  " (rept " " _indent) "t8 = " (string t8 true) _eol) "")
	       	(if (<> t9 #void)  (append "  " (rept " " _indent) "t9 = " (string t9 true) _eol) "")
	       	(if (<> t10 #void)  (append "  " (rept " " _indent) "t10 = "(string t10 true) _eol) "")
       		(append "  " (rept " " _indent) " ==> " (string _ret true)))
       (_logLine ruleText none:)
       true) ;; end writeRule
    ;; Output a feature based token to the token list (output as is).
    (defun _tkASIS(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (error "$ASIS must have at least two arguments"))
       (if (isOdd (argCount)) (error "$ASIS must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Use these value as is. Do not use the syntax feature directory.
       ;; Note: Create an attributed token using the user supplied features.
       (setq tokenAttr (new Structure:))
       (setq tokenAttr.Value value)
       (setq tokenAttr.Charpos charpos)
       (loop for argIndex from 2 until (argCount) by 2 do
          (setq featureName (argFetch argIndex))
          (setq featureValue (argFetch (iadd argIndex 1)))
          (setq tokenAttr[(symbol featureName)] featureValue)
          ) ; end feature loop
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkASIS
    ;; Output a feature based token to the token list.
    (defun _tkOUT(charpos value ...)
       vars:(parseTree treeIndex treeLen tokenAttr argc featureName featureValue argIndex)
       ;; Check the number of arguments for validity.
       (if (< (argCount) 2) (_error "$OUT must have at least two arguments"))
       (if (isOdd (argCount)) (_error "$OUT must have an even number of arguments"))
       ;; Make sure the token list is a vector.
       (if (= _tkLIST #void) (setq _tkLIST (new Vector: 0)))
       (setq $LIST _tkLIST)
       ;; Load any syntax features for this value.
       (setq tokenAttr tokenDirectory[value])
       (if (= tokenAttr #void)
           then
           ;; This value is not found in the syntax feature directory.
           ;; Note: Create an attributed token using the user supplied features.
           (begin
              (setq tokenAttr (new Structure:))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              (loop for argIndex from 2 until (argCount) by 2 do
                 (setq featureName (argFetch argIndex))
                 (setq featureValue (argFetch (iadd argIndex 1)))
                 (setq tokenAttr[(symbol featureName)] featureValue)
                 ) ; end feature loop
              ) ; end then
           else
           ;; This value is found in the syntax feature directory.
           ;; Note: Copy the features from the dictionary and set the value.
           (begin
              (setq tokenAttr (copy tokenAttr))
              (setq tokenAttr.Value value)
              (setq tokenAttr.Charpos charpos)
              ) ; end else
           ) ; end if
       ;; Set the displacement of the token in the source string
       (setq _tkLIST[(length _tkLIST)] tokenAttr)
       tokenAttr) ;; end of _tkOUT

	(defun _substitute(begIp endIp newItem)
		vars:(n N)
		(setq _ip (- begIp 1))
		(setq N (+ (- endIp begIp) 1))
		(setq _parseTree[begIp] newItem)
		(++ begIp)
		(loop for n from 1 until N do
			(delete _parseTree begIp)
		);n
		true)

   ;; ************************************************
   ;; Define the main entry code for this parent Lambda
   ;; ************************************************
   ;; ************************************************
   ;; Define the main entry code for this parent Lambda
   ;; ************************************************
   ;; Perform any pre-lexical work required before compilation
   (setq _verboseState _verbose)
   (setq _verboseTrigger -1)
   (setq _ruleCount 0)
   (setq _failurePass false)
   RESTART::	; come here if we have an error so we can turn _verbose on close to the failure
   (if (> _ruleCount 0) ; this means we are restarting after a failure
    	(begin
    	(setq _failurePass true)
   	    (cond
   	    ((= _failureIn lex:) ; error found in Lexical Pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) 15))) ; show at least 15 rules before failure
	   	((= _failureIn syn:) ; error found in syntax pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) _ruleCountSyn))) ; make sure we don't start _verbose in lexical analysis
	   	((= _failureIn sem:) ; error found in semantic pass
	   		(setq _verboseTrigger (max (- _ruleCount 15) _ruleCountSem))) ; make sure we dont start _verbose in syntax analysis
   		)));if

   (setq _ruleCount 0)
   (setq _verbose _verboseState)
   (setq _lastError (new Structure:)) ;; Clear _lastError 
   (onError _errorHandler)
   (setq _verboseLexCount (new Structure:)) ;Clear routine pass counts
   (setq _verboseSynCount (new Structure:))
   (setq _verboseSemCount (new Structure:))

   (setq _input (preLexRule _input))
   ;; Initialize the parent Lambda once and only once.
   (setq _indent 0)
   (setq _tkIN _input)
   (setq $IN _input)
   (setq $OUT _tkOUT)
   (setq $ASIS _tkASIS)
   (if (= _initializeSW #void) (_Initialize))
   (setq defaultLexer.defaultTokenRule defaultTokenRule)
   (setq defaultLexer.tokenDirectory tokenDirectory)
   
   ;; In verbose mode, display the source string contents
   (if _verbose (writeln _eol "************Input Source************" _eol $IN))
   ;; Run the user defined start rule.
   (startRule)


   ;; Run the Lexical Rules
   ;; Note: Create the attributed token stream parse tree.
   (setq _verboseHold _verbose)
   (setq _verbose (or _verboseHold _verboseLex))
   (if _verbose (writeln "*********Lexical Rule Firings*********"))
   (setq _tkLIST #void)
   (setq $LIST _tkLIST)
   (setq _ip -1)
   (setq _indent 0)
   (setq _parseTree (_LEXRULE_MAIN)) 
   (if (and (not _failurePass) (not _verbose)(= _parseTree |*failure*|:)) (begin (setq _failureIn lex:) (goto RESTART:)))
   ;; In verbose mode, display the parse tree contents
   (if _showTokens
      (begin
         (writeln "*********Lexed Tokens with Features*********")
         (loop for i from 0 until (length _parseTree) do
             (writeln "[" i "] " _parseTree[i])
             ) ; end loop
         )) ; end if
   (if (= _parseTree |*failure*|:) (goto END:))
   
    ;; Run the Syntax Rules
   (setq _verbose (or _verboseHold _verboseSyn))
   (if _verbose (writeln "*********Syntax Rule Firings*********"))
   (setq _ruleCountSyn _ruleCount)
   (setq _ip -1)
   (setq _io _parseTree)
   (setq _parseLen (length _parseTree))
   (setq _indent 0)
   (setq _result (_SYNRULE_MAIN))
   (if (and (not _failurePass) (not _verbose) (= _result |*failure*|:)) (begin (setq _failureIn syn:) (goto RESTART:)))
   (if (= _result |*failure*|:) (goto END:))
   
   ;; Run the Semantic Rules
   (if _verbose (writeln "*********Semantic Rule Firings*********"))
   (setq _ruleCountSem _ruleCount)
   (setq _verbose (or _verboseHold _verboseSem))
   (setq _explanation #void)
   
   (if _verbose (setq outString (append "Reducing:= " (string _result true) " ==> " )))
   (if _explainOnOff (setq outExplain (append "Reducing:= " (string _result true) " ==> " )))
   (setq _indent 0)
   ;; Perform semantic passes (if any)
   (_apply _SEMRULE_MAIN true)
   ;; Return the final output by invoking the user defined output rule.
   (if _semanticVerbose (writeln outString (string _result true)))
   (if _explainOnOff (setq _explanation (append _explanation outExplain (string _result true) _eol)))
   (setq _verbose verboseHold)
   
   (setq _result (outputRule _result))
   (setq _verbose _verboseState)   
   (if (and (not _failurePass) (not _verbose) (= _result |*failure*|:)) (begin (setq _failureIn sem:) (goto RESTART:)))
   (if _verbose (writeln "*********Final Output*********" _eol _result)) 
   
   END::
   
   _result) ;; end of compiler










;;**EXPORTKEY**:javaScript:%%Document_JavaScript_Language_Guide
;#text#
<?xml version="1.0" encoding="UTF-8"?>

<Document>

	<KnowledgeBase>

	    <Title>JavaScript Language Guide</Title>

		<Topic>JavaScript</Topic>

		<SubTopic>Language Guide</SubTopic>

		<HumanKeywords>JavaScript Lambdas Runtime</HumanKeywords>

	</KnowledgeBase>

	<Essay>Essay_JavaScript_Introduction</Essay>
	<Essay>Essay_Runtime_Environment</Essay>
	<Essay>Essay_JavaScript_Statements</Essay>
 
</Document>





;;**EXPORTKEY**:javaScript:%%Essay_JavaScript_Introduction
;#text#
<?xml version="1.0" encoding="UTF-8"?>
<Essay>
	<KnowledgeBase>
	    <Title>JavaScript Introduction</Title>
		<Topic>JavaScript</Topic>
		<SubTopic>Overview</SubTopic>
		<HumanKeywords>JavaScript Programming Artificial-Intelligence</HumanKeywords>
	</KnowledgeBase>
	<Section>
	    <Heading>Introduction</Heading>
		<Description><![CDATA[
	
             <div class="h2section" id="Introduction">	
		    <p>JavaScript was developed by Netscape as a means to bring the simplicity
		    of scripting languages to a wider audience. The main difference between Java
		    and JavaScript, is that Java code is compiled into &quot;applets&quot; that
		    are distinct from the HTML page and whose code cannot be viewed directly,
		    whereas JavaScript code is included directly in the HTML document and can be
		    easily modified.</p>
		    <p>JavaScript is a scripting language designed to extend the functionality
		    of web pages. Typically written as part of an HTML document, a JavaScript
		    controls the elements of the page and reacts to user actions.</p>
		    <p>The generic JavaScript language is distinguished from the <b>javaScript</b>
		    language by an uppercase letter &quot;J&quot;. The<b> javaScript </b>language<b>
		    </b>is<b> </b>a proprietary javaScript compiler generated by <b>ParseLib</b>.
		    The <b>javaScript</b> compiler Lambda converts javaScript source code into an
		    Analytic Information Server parse tree which is the input to the <b>morph</b>
		    and <b>compile</b> functions. The <b>compile</b> function finally produces
		    an Lambda ready execute.</p>
		    <p>Thus, the <b>javaScript </b>language<b> </b>is an easy to use alternative
		    tool that web programmers may find more easy to use than Lisp. The
		    javaScript language extends the power of Lambda Oriented programming to a
		    wider audience.</p>
		    <p>javaScript includes a number of language commands for creating datamine
		    tables, filtering tables, and scoring tables. It was developed, for the
		    dataMineLib, as a means to bring the full power and simplicity of
		    scripting languages to the data mining process.</p>
		    <p>Thus, the <b>Filter Extensions</b> is an easy to use alternative tool
		    that dataMineLib programmers may find more easy to use than the data mine
		    Lambda?s API. These language extensions bring the power of scripting
		    languages to the data mining process.</p>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Invoking javaScript from Lisp</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Invoking javaScript from Lisp">
		    <p>The <b>javaScript</b> compiler Lambda can be called from the Lisp parser, <b>lisp</b>,
		    by using the <b>#javaScript#</b> compiler directive, or it can be called
		    directly. If called directly, it should be followed by morph and compile
		    (see the lisp parser - javaScript is a replacement for the lisp parser). The
		    <b>javaScript</b> Lambda was generated by the ParseLib Lambda.</p>
		    <b>Note</b>: The javaScript Lambda must be loaded into the workspace prior to
		    using the javaScript language. (see the javaScript library and the Dynamic
		    HTML example).
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Invoking javaScript from the Console</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Invoking javaScript from the Console">
			<p>The LambdaClient IDE contains a Console tab. Clicking the right mouse
		    button, and selecting the &quot;Set Prefix&quot; option displays a modal
		    dialog containing an edit box for the user to enter a Console prefix. The
		    Console prefix controls which parser is invoked when the console receives
		    any text to be evaluated. The valid prefixes are: &quot;&quot; (a null
		    string), &quot;<b>#lisp#&quot;,</b> and <b>&quot;#javaScript#&quot;</b>. If
		    the Console prefix is a null string or <b>#lisp#,</b> then any expressions
		    submitted for evaluation will be parsed with the Lisp parser. If the Console
		    prefix is <b>&quot;#javaScript#&quot;</b>, the JavaScript parser will be
		    invoked.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Lambda Objects</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Lambda Objects;">
			<p>The LambdaClient development uses an Lambda-oriented metaphor. <b>javaScript</b>
		    &quot;Lambdas&quot; are a unique class of objects designed to act as the <b><u>building
		    blocks</u></b><u></u> for intelligent, adaptive, systems. Lambdas contain
		    more than just binary machine code (Analytic Information Server supports many
		    built-in functions, which are primarily binary machine code, but these are
		    not Lambdas). Lambdas are something more than just functions. Lambdas are
		    building block objects, which contain the necessary structure to provide
		    some rudimentary autonomy. Lambdas can contain other child Lambdas and can
		    give birth to other child Lambdas. Lambdas can publish their preferred style
		    of interface. Lambdas have an abstract threshold (like a cell membrane) which
		    makes the Lambda aware of any mutative or referential access attempt from the
		    outside. Lambdas may run on native machine code or they may be emulated by a
		    virtual machine. There may be a different virtual machine for each Lambda.
		    Lambdas contain their persistent and temporary knowledge variables. Lambdas
		    contain the original source code used to compile them. Lambdas can be
		    generated from multiple languages. Analytic Information Server comes with a
		    built-in Lisp compiler, which produces Lambdas.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Lambda Properties</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Lambda Properties">
			<p>The Lambda object stores Lambda behavior and knowledge in a standard
		    building block format (regardless of the original source language). The
		    Analytic Information Server Lambda object contains the following eight
		    properties:</p>
			
		    <table class=members_table border="3" cellpadding="2" >
			<colgroup><col class="member"><col class="description"></colgroup>
		      <tr>
		        <td>Av:</td>
		        <td>
		          <p>The arguments Structure object containing the Lambda's arguments.<br><br></p>
		        </td>
		      </tr>
		      <tr">
		        <td>In:</td>
		        <td>
		          <p>The <b>faces</b>: Structure object containing the Lambda's published
		          interface styles.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Pc:</td>
		        <td>
		          <p>The Pcode Vector object containing the Lambda's virtual machine
		          codes.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Pv:</td>
		        <td>
		          <p>The <b>pvars</b>: Structure object containing the Lambda's
		          persistent variables.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Cv:</td>
		        <td>
		          <p>The <b>cvars</b>: Structure object containing the Lambda's
		          persistent class variables</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Nc:</td>
		        <td>
		          <p>The Native Code Vector object containing the Lambda's native machine
		          code.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Sc:</td>
		        <td>
		          <p>The Source Code Vector containing the original language source for
		          debugger display.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Tv:</td>
		        <td>
		          <p>The <b>vars</b>: Structure object containing the Lambda's temporary
		          frame variables.</p>
		        </td>
		      </tr>
		      <tr>
		        <td>Vm:</td>
		        <td>
		          <p>The Virtual Machine emulator function (each Lambda may run on a
		          separate virtual machine).</p>
		        </td>
		      </tr>
		    </table>
		    <p>&nbsp;</p>
		    <p>An Lambda is <i>First Class Object</i>. A First Class object in Lambda
		    Information Server is any object that is fully exposed, i.e., all of the
		    Structures are visible and modifiable by the programmer. All Lambdas have the
		    following data structures: source code tokens (<b>Sc</b>), pcode tokens (<b>Pc</b>),
		    argument variables (<b>Av</b>), persistent variables (<b>Pv</b>)<b>, </b>persistent
		    class variables (<b>Cv</b>)<b>, </b>temporary variables (<b>Tv</b>),
		    interfaces (<b>In</b>), native code (<b>Nc</b>), and the virtual machine
		    emulator (<b>Vm</b>). All Lambda structures can viewed and modified by the
		    programmer:</p>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>javaScript Filter Lambdas</Heading>
		<Description><![CDATA[
            <div class="h2section" id="JavaScript Filter Lambdas">
			<p>The principal activity of the datamine is to reduce tables to smaller
		    tables which have a higher <i>score</i> than the original table. This
		    process is called filtering. For instance, in the stock market, we start
		    with a table of all possible stocks and we wish to select a few stocks to
		    purchase. If the few stocks we purchase have a higher <i>score</i> (percent
		    profit) than the average of all stocks, then we are happy. The act of
		    selecting a few stocks to purchase reduces the original table of all stocks
		    down to the table of those we wish to purchase. This process is called
		    filtering.</p>
		    <p>Other examples of filtering include reviewing a table of all United
		    States households to select only those households which are to receive this
		    month's promotional mailing. Reviewing a table of possible oil deposit sites
		    to select only those sites where we wish to drill. There are many other
		    examples of filtering.</p>
		    <p>The <i>score</i> of a table is determined by the Score Lambda (see the <b>Score
		    Lambdas</b> section next).</p>
		    <p>All datamine table filtering is performed by Filter Lambdas, which are
		    entered by the user in the simple, easy to learn datamine javaFilter
		    language. An example might be:</p>
		    <blockquote>
		      <pre>filter top LastMonthProfit 10%;</pre>
		    </blockquote>
		    <p>or</p>
		    <blockquote>
		      <pre>filter all Timeliness = 1;</pre>
		    </blockquote>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>javaScript Score Lambdas</Heading>
		<Description><![CDATA[
             <div class="h2section" id="javaScript Score Lambdas">
			<p>If the principal activity of the datamine is to reduce tables to smaller
		    tables which have a higher <i>score</i> than the original table, then there
		    must be some means of determining a table?s score. All datamine table
		    scoring is performed by Score Lambdas, which are entered by the user in the
		    simple, easy to learn datamine javaFilter language. An example might be:</p>
		    <blockquote>
		      <pre>score avg NextMonthProfit;</pre>
		    </blockquote>
		    <p>or</p>
		    <blockquote>
		      <pre>score sum ItemPrice * TotalItems;</pre>
		    </blockquote>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>JavaScript Data Types</Heading>
		<Description><![CDATA[
            <div class="h2section" id="JavaScript Data Types">
		   <p>The <b>javaScript</b> Programmer has access to all of the types in the
		    Analytic Information Server environment. These are the same as the Lisp data
		    types. The Lisp data types are divided into three categories: Native Data
		    Types (also known as Immediate types), Objects (heap objects) and
		    Repositories. The Native (immediate) types can be entirely contained within
		    the immediate data of a single Virtual Machine Container. The Objects (heap
		    objects) types are too large to be contained within a single Virtual Machine
		    Container and require extra memory must be managed by the heap manager.
		    Without exception, all of the Object types are identified by an object id.
		    The object id identifies a block of memory, managed by the Analytic Information
		    Server memory manager, in which the Object's data is stored. (see Object
		    Identifier Notation).</p>
		    <p>Virtual Machine Containers are of fixed length and come in different
		    sizes. Small data items are stored in immediate mode, and may be moved to
		    the heap if the data becomes too large to store immediately.</p>
		    <p>The Heap contains memory resident data, which is of variable length or is
		    too large to fit in small fixed containers. The Analytic Information Server
		    object Heap manager supports automated object resizing, garbage collection,
		    and anti-fragmentation algorithms so that the user may concentrate on the
		    analysis and modeling of data rather than on memory management.</p>
		    <p>Repositories (databases) contain persistent data of all sorts. Lambda
		    Information Server supports repositories with multiple database volumes and
		    multiple database schema's including General Object Repositories, Text
		    Repositories, and Lambda Repositories.</p>
		    <p>The generic Analytic Information Server data type is known to javaScript as <b>obj</b>.
		    No type identification, such as <i>var n;</i>, will cause javaScript to
		    treat the variable, <i>n</i>, as being of type <b>obj</b>, that is to say
		    any possible Analytic Information Server data type.</p>
		    <p>The javaScript compiler also supports strong typing of declared variables
		    <b>obj</b>. Providing a type identification, such as <i>var int n;</i>, will
		    cause javaScript to treat the variable, <i>n</i>, as being of type <b>int</b>,
		    that is to say it will be managed as an Analytic Information Server type <b>Integer</b>.</p>
		    <p>The following is a list of javaScript strong data types together with the
		    Analytic Information Server types which they represent.</p>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
			<colgroup><col><col class="italic"><col><col class="italic"></colgroup>
		      <tr align="top">
		        <th>obj</th>
		        <td>Object</td>
		        <th>bool</th>
		        <td>Boolean</td>
		        <th>char</th>
		        <td>Character</td>
		        <th>int</th>
		        <td>Integer</td>
		        <th>float</th>
		        <td>Number</td>
		      </tr>
		      <tr align="top">
		        <th>text</th>
		        <td>Text</td>
		        <th>string</th>
		        <td>String</td>
		        <th>symbol</th>
		        <td>Symbol</td>
		        <th>bytvec</th>
		        <td>ByteVector</td>
		        <th>fltvec</th>
		        <td>FloatVector</td>
		      </tr>
		      <tr align="top">
		        <th>stc</th>
		        <td>Structure</td>
		        <th>dir</th>
		        <td>Directory</td>
		        <th>dic</th>
		        <td>Dictionary</td>
		        <th>matrix</th>
		        <td>Matrix</td>
		        <th>nummat</th>
		        <td>NumMatrix</td>
		      </tr>
		      <tr align="top">
		        <th>vec</th>
		        <td>Vector</td>
		        <th>bitvec</th>
		        <td>BitVector</td>
		        <th>numvec</th>
		        <td>NumVector</td>
		        <th>intvec</th>
		        <td>IntVector</td>
		        <th>objvec</th>
		        <td>ObjVector</td>
		      </tr>
		    </table>
         </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Strong Typing</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Strong Typing">
			<p>The <b>javaScript</b> Programmer has access to compile time strong typing
		    variable declarations. Strongly typed variables are compiled with Lambda
		    Information Server's strong typed virtual machine instructions. Strongly
		    typed variables operate faster, at run time; but, are more prone to
		    programmer error as there is little or no run time type checking performed.</p>
		    <p>The programmer can even cast an arbitrary javaScript expression to a
		    valid type. The casting will alert the javaScript compiler to treat the
		    result of the cast expression as specified. This will direct the javaScript
		    compiler to use Analytic Information Server's strong typed virtual machine
		    instructions with the cast expression. Warning: casting does not introduce
		    any run time type checking.</p>
		    <p>The following javaScript code sample illustrates the actions of the
		    javaScript compiler when strong typing variable declarations and type casts
		    are encounteres.</p>
		    <p><b>The javaScript source code for foo</b></p>
		    <blockquote>
			  <pre>
		      // A test of strong typing, including expression type casting, in javaScript.
		      function foo(int i) {
		      var char c1, string name=new('String',&quot;Hello There&quot;);
		      c1 +=name[((int)length(name))-i];
		      }</pre>
		    </blockquote>
		    <p><b>The compiled code for foo</b></p>
		    <table border="3" cellpadding="2">
		      <tr>
		        <td><u>Virtual Machine Instructions for</u>: <b>foo</b></td>
		      </tr>
		      <tr>
		        <td>0000: push &quot;String,&quot;Hello There&quot;</td>
		      </tr>
		      <tr>
		        <td>0007: call 2,new,vars:(name)</td>
		      </tr>
		      <tr>
		        <td>0011: push vars:(name)</td>
		      </tr>
		      <tr>
		        <td>0013: call 1,length,vars:(__T4)</td>
		      </tr>
		      <tr>
		        <td>0017: isub args:(i),vars:(__T4),vars:(__T3)</td>
		      </tr>
		      <tr>
		        <td>0021: refstring vars:(__T3),vars:(name),vars:(__T2)</td>
		      </tr>
		      <tr>
		        <td>0025: cadd vars:(__T2),vars:(c1),vars:(c1)</td>
		      </tr>
		      <tr>
		        <td>0029: return vars:(c1)</td>
		      </tr>
		    </table>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>White Space</Heading>
		<Description><![CDATA[
             <div class="h2section" id="White Space">
			<p>The javaScript compiler uses white space to separate each of its symbols
		    and operators. The javaScript white space characters include all the
		    standard 8-bit ASCII control characters (less than 32 decimal), and the
		    blank character (32 decimal).</p>
		    <b>LF, CR, TAB</b> ..control chars..
		    <p>space</p>
		    <p>The javaScript compiler ignores whitespace</p>
		    <blockquote>
		      <pre>a = 1 + 2;  // This is a valid statement
		       b=1+2;  // This is also a valid statement</pre>
		    </blockquote>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Special Characters</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Special Characters">
			<p>javaScript uses the standard 8-bit ASCII character set. Some of the
		    javaScript special characters serve to group a set of characters as a single
		    unit (e.g. double quotes group characters to form a string constant). The
		    remainder of the special characters serve to separate tokens (e.g. comma or
		    blank) or prefix a constant (e.g. $ # ).</p>
		    <p>The following are the javaScript special characters.</p>
		    <table border="3" cellpadding="2" width="50%" style="font-weight: bold" >
		      <tr align="top">
		        <td>\</td>
		        <td>|</td>
		        <td>(</td>
		        <td>)</td>
		        <td>[</td>
		        <td>]</td>
		        <td>{</td>
		        <td>}</td>
		        <td>#</td>
		        <td>@</td>
		      </tr>
		      <tr align="top">
		        <td>'</td>
		        <td>'</td>
		        <td>,</td>
		        <td>&quot;</td>
		        <td>:</td>
		        <td>;</td>
		        <td>$</td>
		        <td>%</td>
		        <td>.</td>
		        <td>&nbsp;</td>
		      </tr>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Naming Conventions for Variables</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Naming Conventions for Variables">
			<p>javaScript variable names are composed of case-sensitive alphanumeric
		    characters. No spaces are allowed in a variable name but the underscore (_)
		    character may be embedded to separate multi-word names . Another convention
		    to make multiple word names more readable its to use start the first word
		    with a lowercase letter and begin the first letter of each succeeding word
		    with an uppercase letter.</p>
		    <p>For example</p>
		    <blockquote>
		      <pre>myVariable
		
		sum
		
		namesOfStudents</pre>
		     </blockquote>
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Constants</Heading>
		<Description><![CDATA[
		     <div class="h2section" id="Constants">
			<p>javaScript is a dynamically typed language. The type of a variable is
		    unknown until runtime when data is stored into it. The follow table contains
		    the constant forms recognized by the javaScript compiler. For more detail on
		    the data types listed below, see <b>Analytic Information Server Programmer's
		    Guide.</b></p>
		    <table border="3" cellpadding="2" width="50%">
		      <tr align="top">
		        <td><b>Type</b></td>
		        <td><b>Constant Form</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Void</b></td>
		        <td><b>void</b> or <b>nil</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Boolean</b></td>
		        <td><b>true</b> or <b>false</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Date</b></td>
		        <td><b>#Mar,2,1987</b> or <b>#Jun,1,200BC</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Integer</b></td>
		        <td><b>12 </b>or<b> -2345</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Number</b></td>
		        <td><b>12.9 </b>or<b> 0.123456</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Object</b></td>
		        <td><b>#&lt;Vector 1273&gt;</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>String</b></td>
		        <td><b>&quot;Hello World&quot;</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>Symbol</b></td>
		        <td><b>'Hello'</b></td>
		      </tr>
		    </table>
		  </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Comments</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Comments">
			<p>Because the javaScript compiler tries to evaluate all of the words in a
		    script, it is useful to have text, which is to be ignored by the compiler.
		    This ignored text, called a comment, allows you to include information,
		    which may be useful to understanding the javaScript statements. There are
		    two types of comments: single line and multi-line.</p>
		    <p>A single line comment tells the compiler to ignore all the characters up
		    to the end-of-line (eol). A single line comment must begin with the
		    characters: //</p>
		    <p>For Example:</p>
		    <blockquote>
		      <pre>// This is a comment</pre>
		    </blockquote>
		    <p>A multi-line comment tells the compiler to ignore all the characters
		    embedded in between the delimiters: <b>/*</b> and */</p>
		    <p>For Example:</p>
		    <blockquote>
		      <pre>/*  Humpty Dumpty 
		
		            sat on a wall  */</pre>
		    </blockquote>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Global Variables</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Global Variables">
			<p>javaScript variables have automatic global declaration. Referencing a
		    symbol, which has not already been declared, automatically causes it to be
		    declared as a global variable. This feature has been added to make
		    javaScript user-friendlier and to make javaScript consistent with other
		    Analytic Information Server languages.</p>
		    <p>The following javaScript expressions are equivalent (The assumption is
		    made that X has not already been referenced).</p>
		    <blockquote>
		      <pre>X = 23</pre>
		    </blockquote>
		    <p>is equivalent to:</p>
		    <blockquote>
		      <pre>var X = 23</pre>
		    </blockquote>
		    <p>javaScript global variables are valid during the whole life of the
		    current workspace (see the <b>_globals</b> global symbol table variable).
		    javaScript global variables are referenced by specifying the symbol. In
		    addition to user defined globals, javaScript global variables include all of
		    the built-in functions such as <b>+ - * upperCase, sin, cos, date, etc.</b></p>
		    <p>The Analytic Information Server javaScript dialect is specified as
		    case-sensitive (most dialects of javaScript are case-insensitive). Therefore</p>
		    <blockquote>
		      <pre>Var</pre>
		    </blockquote>
		    <p>is NOT equivalent to:</p>
		    <blockquote>
		      <pre>var</pre>
		    </blockquote>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Function Calls</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Function Calls">
			<p>Any user-defined javaScript Lambda, and Lisp Lambda, and any Lambda
		    Information Server function may be called from javaScript. The syntax is
		    simple the function name followed by parenthesis, (). If the function
		    requires arguments, they must be supplied in between the parenthesis and
		    multiple arguments should be separated by a comma. The parenthesis are
		    mandatory even if no arguments are supplied. All javaScript functions
		    receive arguments by value. After function invocation, one and only one
		    result value is returned.</p>
		    <p>For example</p>
		    <blockquote>
		      <pre>mod(10, 2); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Returns 0
		
		            today();            //Returns 729855</pre>
		    </blockquote>
            </div>
	    ]]></Description>
	</Section>
</Essay>




;;**EXPORTKEY**:javaScript:%%Essay_JavaScript_Statements
;#text#
<?xml version="1.0" encoding="UTF-8"?>
<Essay>
	<KnowledgeBase>
	    <Title>JavaScript Statements</Title>
		<Topic>JavaScript</Topic>
		<SubTopic>Overview</SubTopic>
		<HumanKeywords>JavaScript Programming Artificial-Intelligence</HumanKeywords>
	</KnowledgeBase>
	<Section>
	    <Heading>Statements Overview</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Statements Overview">
			<p>This chapter is a reference guide to the JavaScript statements. These
		    statements contain the basic control flow operators for the javaScript
		    language. All of the basic building blocks of JavaScript are contained in
		    its statements.</p>
		    <p>All JavaScript statements are lexical structures, which are understood
		    only by the javaScript parser. They are not understood by the system outside
		    of the javaScript parser, and they are not available nor are they understood
		    by Lisp. All JavaScript statements have meaning only at parse time.</p>
		    <p>All JavaScript special forms are structures, which are understood only by
		    the JavaScript compiler. Unlike Function objects, the JavaScript special
		    forms are invalid outside of compilation, at run time.</p>
		    <p>JavaScript supports user defined global symbols, allowing the user to
		    assign any valid JavaScript object to the newly created global symbol. User
		    defined global symbols behave just like their built-in cousins; however,
		    JavaScript even allows the user to redefine any of the built-in JavaScript
		    special form symbols.</p>
		    <p>The Analytic Information Server dialect of javaScript is case sensitive.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Binary Arithmetic Operators</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Binary Arithmetic Operators">
			<h3>Overview</h3>
		    <p>javaScript supports the basic binary and unary arithmetic operations:
		    addition (+), subtraction (-), multiplication (*), division (/), protected division (#), and modulus
		    (%).</p>
		    <h3>Type</h3>
		    <p><b>Statement</b></p>
		    <h3>Syntax</h3>
		    <p><b>operand1 binaryOperator operand2</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">Operand1</b><b style="mso-bidi-font-weight: normal"><o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes"> </span>first
		          operand.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b>binaryOperator</b><b style="mso-bidi-font-weight: normal"><o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes"> binary
		          operator. </span>Must be one of: &nbsp; <b>+, -, *, /, #, %.</b></td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">Operand2</b><b style="mso-bidi-font-weight: normal"><o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes"> second
		          operand</span>.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The result of the binary operation.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">binary operator</b>
		    statement to perform basic arithmetic operations on two numeric values, or
		    to concatenate two string values.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">These simple examples demonstrates the effect of the
		    various binary operators.</p>
		    <p class="MsoBodyText"><b>a = 1 + 20;
		    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns
		    21<br>
		    <br>
		    b = 30 - 5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    //Returns 25<br>
		    <br>
		    c = 2 * 2.1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    //Returns 4.2<br>
		    <br>
		    d = 100 / 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    //Returns 10<br>
		    <br>
		    e = 10 % 4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    //Returns 2&nbsp; (the remainder)</b><b style="mso-bidi-font-weight: normal"><u><o:p>
		    </o:p>
		    </u></b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">binary operator</b> statement
		    performs basic arithmetic operations on two numeric values, or concatenates
		    two string values.</p>
			<p>On a divsion by zero, the protected divide operator returns the highest possible number in the system if 
			the sign of the numerator is negative or the lowest possible number in the system if the sign of the numerator is positive.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Unary Arithmetic Operators</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Unary Arithmetic Operators">
			<h3>Overview</h3>
		    <p>javaScript supports the basic unary arithmetic operations: increment
		    (++), decrement (--), and negation (-).<br>
		    Syntax: unaryOperator operand1</p>
		    <h3>Type</h3>
		    <p><b>Statement</b></p>
		    <h3>Syntax</h3>
		    <p><b>unaryOperator operand1</b></p>
		    <p><b>operand1</b> <b>incrementOperator</b></p>
		    <p><b>operand1</b> <b>decrementOperator</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b>unaryOperator</b><b style="mso-bidi-font-weight: normal"><o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes"> unary
		          operator. </span>Must be one of: &nbsp; <b>++, --, -.</b></td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">Operand<o:p>1
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes"> first
		          operand</span>.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The result of the unary operation.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">unary operator</b>
		    statement to perform basic arithmetic operations on a single numeric value.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">These simple examples demonstrates the effect of the
		    various unary operators.</p>
		    <p class="MsoBodyText"><b>var a = 100;<br>
		    <br>
		    var b&nbsp; = 100;<br>
		    <br>
		    var c = 10;<br>
		    <br>
		    var d = 10;<br>
		    <br>
		    ++a; &nbsp;&nbsp;&nbsp; //Returns 101<br>
		    <br>
		    --b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 99<br>
		    <br>
		    c++;&nbsp;&nbsp;&nbsp; //Returns 11<br>
		    <br>
		    d--;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 9<br>
		    <br>
		    -a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns -101</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">unary operator</b> statement
		    performs basic arithmetic operations on a single numeric value.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Assigment Operators</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Assigment Operators">
			<h3>Overview</h3>
		    <p>javaScript assigns a value to a variable with the <b>=</b> (equal)
		    operator. Another class of assignment operators perform math operations on
		    the variable and saves the result in the same variable. They are <b>+=, -=,
		    *=, /=and %=</b>. The <b>+=</b> operator is shorthand for a=a + exp.</p>
		    <h3>Type</h3>
		    <p><b>Statement</b></p>
		    <h3>Syntax</h3>
		    <p><b>variable assignmentOperator expression</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">variable <b style="mso-bidi-font-weight: normal"></o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">
		          variable to be assigned a new value.</span></td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b>assignmentOperator</b><b style="mso-bidi-font-weight: normal">
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The assignment Operator. Must be one of:&nbsp;
		          <b>=, +=, -=, *=, /=, %=.</b></td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">expression</b><b style="mso-bidi-font-weight: normal">
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">If the <b>assignmentOperator</b> is (=),
		          the expression may return any value. If the <b>assignmentOperator</b>
		          is (+=, -=, *=, /=, or %=), then the expression must return a numeric
		          value.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">If the <b>assignmentOperator</b> is (=),
		          the variable is set to the value of expression. If the <b>assignmentOperator</b>
		          is (+=, -=, *=, /=, or %=), then the arithmetic operation is performed
		          on the original variable and the expression.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">assignment</b><b style="mso-bidi-font-weight: normal">
		    operator</b> statement to assign a new value to a javaScript variable.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">This simple example demonstrates the effect of the
		    simple assignment operator.</p>
		    <p class="MsoBodyText"><b>a = 3.14;
		    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 3.14</b></p>
		    <h3><u>Example2</u></h3>
		    <p class="MsoBodyText">This examples demonstrate the effects of the
		    arithmetic assignment operators.</p>
		    <p class="MsoBodyText"><b>var a = 100;<br>
		    <br>
		    var b&nbsp; = 100;<br>
		    <br>
		    var c = 10;<br>
		    <br>
		    var d = 10;<br>
		    <br>
		    a += 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 110<br>
		    <br>
		    b -= 10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 90<br>
		    <br>
		    c *= 10;&nbsp;&nbsp;&nbsp;&nbsp; //Returns 100</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">assignment</b><b style="mso-bidi-font-weight: normal">
		    operator</b> statement assigns a new value to a javaScript variable.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>child</Heading>
		<Description><![CDATA[
            <div class="h2section" id="child">
			<h3>Overview</h3>
		    <p>The <b>child</b> function declaration creates a new Lambda object and
		    assigns it to the specified persistent variable name <b>childName</b> of the
		    parent Lambda <b>parent</b>. The <b>child</b> function declaration always
		    returns the newly created object identifier of the new Lambda. The child
		    Lambda is invoked using the <b>parent.childName()</b> syntax form.</p>
		    <h3>Type</h3>
		    <p><b>Statement</b></p>
		    <h3>Syntax</h3>
		    <p><b>child parent childName ([type] arg..) { cvardec pvardec vardec exp }</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <td align="center"><b>child</b></td>
		        <td>
		          <p>Mandatory keyword.</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>parent</b></td>
		        <td>
		          <p>Name of the parent class</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>childName</b></td>
		        <td>
		          <p>The name of the child Lambda (function)</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>([type] arg...)</b></td>
		        <td>
		          <p>A list of type hints (optional) and arguments separated by commas.
		          If there are no arguments the parenthesis are still required. <b>Note</b>:
		          The optional type hints can be one of the following: <b>char</b>,<b>
		          bool</b>,<b> int</b>,<b> float</b>,<b> </b>or<b> obj</b></p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>cvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          class variable declaration. See <b>cvar</b>.</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>pvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          variable declaration. See <b>pvar</b>.</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>vardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a local
		          variable declaration. See <b>var</b>.</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>exp</b></td>
		        <td>
		          <p>The javaScript statements that form the Lambda</p>
		        </td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">An Lambda object.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">child</b> statement to
		    create a new javaScript Lambda with a child relationship to a parent Lambda.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">This simple example demonstrates the effect of the
		    simple assignment operator.</p>
		    <blockquote>
		      <pre><b>function  foo(x)  {
		
		               pvar y;
		
		               y = x
		
		               return (y);
		
		               }
		
		
		
		               child foo sum (x)  {
		
		               var temp ;
		
		               temp = x +  y;
		
		               return ( temp );
		
		    }</b></pre>
		    </blockquote>
		    <p>We can invoke the parent and the child Lambda as follows:</p>
		    <blockquote>
		      <pre><b>foo(10);                          //Returns 10
		
		              foo.sum(3);                       //Returns 13
		
		              compareEQ(foo.Cv, foo.sum.Cv); &nbsp;&nbsp; //Returns true
		
		              compareEQ(foo.Pv, foo.sum.Pv); &nbsp;&nbsp;&nbsp;//Returns true</b></pre>
		    </blockquote>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">child</b> statement creates a
		    new javaScript Lambda with a child relationship to a parent Lambda. A Child
		    Lambda inherits <b>pvar</b> and <b>cvar</b> structures from its parent Lambda.</p>
          </div> 
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>class</Heading>
		<Description><![CDATA[
            <div class="h2section" id="class">
			<h3>Overview</h3>
		    <p>The <b>class</b> statement declares a class and names all of its members.
		    The <b>class</b> statement can also use to sub-class, i.e., create a class
		    that inherits from another class and extend it.</p>
		    <h3>Type</h3>
		    <p><b>Statement</b></p>
		    <h3>Syntax</h3>
		    <p><b>class className {member1 ; member2 ... }</b></p>
		    <p><b>class className extends parentClass {member1 ; member2 ... }</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <td align="center"><b>class</b></td>
		        <td>
		          <p>Mandatory Keyword</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>className</b></td>
		        <td>
		          <p>The name of this class</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>extends</b></td>
		        <td>
		          <p>Optional Keyword. If present, it must be followed by an existing
		          parent class.</p>
		        </td>
		      </tr>
		      <tr>
		        <td align="center"><b>{member1; member2; ...}</b></td>
		        <td>
		          <p>The names of the class members, where each name is separated by a
		          semicolon</p>
		        </td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">An class name.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">class</b> statement to
		    create a new class or to extend and existing class through in heritance.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">This simple example demonstrates the effect of the
		    simple assignment operator.</p>
		    <blockquote>
		      <pre><b>class employee {Name; Address; Salary }
		
		              emp = new ('employee' , 'Name' ,&quot;Tom Jones&quot; , 'Address',  &quot;200 Main Street, Small Town,  USA&quot; )
		
		              display(emp.Name)</b></pre>
		    </blockquote>
		    <h3><u>Example2</u></h3>
		    <p class="MsoBodyText">This simple example demonstrates the effect of the
		    simple assignment operator.</p>
		    <blockquote>
		      <pre><b>class employee {Name; Address; Salary }
		
		              class manager extends 'employee' {Perks }
		
		              emp = new ('employee' , 'Name' ,&quot;Tom Jones&quot; , 'Address',  &quot;200 Main Street, Small Town,  USA&quot; )
		
		              mgr = new('manager', 'Name', &quot;John Smith&quot;, 'Perks', &quot;Special Parking Space&quot;)</b></pre>
		    </blockquote>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">class</b> statement creates a
		    new class or to extend and existing class through in heritance.</p>
            </div> 
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Comparison Operators</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Comparison Operators">
			<p>The comparison operators are <b>==(equal) , !=(not equal) ,&lt; (less
		    than) , &lt;=(less than or equal) , &gt; (greater than), &gt;=(greater than
		    or equal)</b> . The resulting value is a Boolean value of <b>true</b> if the
		    relational operator results in a true comparison otherwise the resulting
		    value is <b>false. </b>javaScript performs type checking and type
		    conversions, therefore the operands need not be the same type.<b><br>
		    </b>Syntax: (obj1 operator obj2)</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>obj1</b></td>
		        <td>
		          <p>First object to be compared</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>operator</b></td>
		        <td>
		          <p>Must be <b>==(equal), !=(not equal) ,&lt; (less than) , &lt;=(less
		          than or equal) , &gt; (greater than), &gt;=(greater than or equal)</b>
		          .</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>obj2</b></td>
		        <td>
		          <p>Second object to be compared</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>Returns true if the comparison is true, false if the comparison is
		          false</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <pre>var a = true; //Returns True
		
		         (a == true ); //Returns  True  
		
	             ( 2 &lt; 3)	; //Returns  True
		
		         ( 2 &gt; 3)	; //Returns  False</pre>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Conditional Expression</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Conditional Expression">
			<p>A conditional expression is a shorthand version of the if-else statement.
		    Besides having a shorter syntax, conditional expression always return a
		    value, unlike the if statement.<b><br>
		    </b>Syntax: condition ? val1 : val2</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>condition</b></td>
		        <td>
		          <p>A Boolean expression</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>?</b></td>
		        <td>
		          <p>Mandatory operator</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>val1</b></td>
		        <td>
		          <p>The value to be returned if condition is true.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>:</b></td>
		        <td>
		          <p>Mandatory operator</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>val2</b></td>
		        <td>
		          <p>The value to be returned if condition is false.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>If the condition is true, val1 is returned, otherwise val2 is
		          returned</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <pre>a = 1;
		
		         X = (a &gt;= 1) ? 1 : -1  ); // X will be set to 1</pre>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>cvar</Heading>
		<Description><![CDATA[
             <div class="h2section" id="cvar">
			<p>The <b>cvar</b> statement declares a persistent class variable within an
		    Lambda. This means that the persistent class variable will have a scope for
		    the life of the Lambda object. The class variable is created and initialized
		    when the Lambda is instantiated and re-initialized each time the Lambda is
		    invoked. Although javaScript is a dynamically typed language, the cvar
		    allows the programmer to optionally provide hints to the compiler by
		    specifying a type for variable declarations. The supported types are: char,
		    bool, int, float, and obj. Specifying a type of obj is equivalent to
		    specifying no type information.<br>
		    Syntax: cvar varName<br>
		    Syntax: cvar varName=init<br>
		    Syntax: cvar type varName<br>
		    Syntax: cvar type varName=init</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>cvar</b></td>
		        <td>
		          <p>Mandatory keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>type</b></td>
		        <td>obj char bool int float obj text string symbol bitvec fltvec pcdvec
		          stc dir dic matrix nummat vec bitvec numvec intvec objvec</td>
		      </tr>
		      <tr align="top">
		        <td><b>cvarName</b></td>
		        <td>
		          <p>The name of the persistent class variable</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>=init</b></td>
		        <td>
		          <p>Optional argument. If present, the compiler will assign the <b>cvarName</b>
		          to the value in <b>init</b>.</p>
		        </td>
		      </tr>
		    </table>
		    <b>Note</b>: If type hints are supplied, the programmer must assure that no
		    other types are saved in the variable. <b>Note</b>: Multiple variable
		    declarations may be separated by commas as in: <b>cvar x, int y, z;</b>.
		    <p>When To Use</p>
		    <p>Unlike a temporary variable <b>(var)</b> that is declared inside a
		    function and which is only &quot;alive&quot; while the function is currently
		    active, a <b>cvar </b>(persistent variable) is accessible, as long the Lambda
		    object instance is active. The contents of the entire <b>cvar</b> structure
		    is in <b>LambdaName.Cv</b>, where <b>LambdaName</b> is the name of the
		    instance of the Lambda. The contents of a single <b>cvar </b>variable is <b>LambdaName.Cv.memberName;</b></p>
		    <p>A persistent class variable <b>(cvar)</b> is analogous to a static
		    variable in a C or C++ programming environment. It is created and
		    initialized when the Lambda is instantiated and it is persistent, meaning the
		    memory is not released as long as the Lambda is in memory. However, the <b>cvar</b>
		    differs from the <b>pvar</b> in that it is always re-initialized on entry to
		    the Lambda that encapsulates it.</p>
		    <p>Example1</p>
		    <pre>function squareIt(x)  {
		
		    cvar float xx;
		
		    var y;
		
		    xx = x * x;
		
		    y = xx;
		
		    return (xx);
		
		    }
		
		
		
		    var result, int;
		
		    result = squareIt(10);
		
		    writeln(result); //displays &quot;100&quot;
		
		    writeln(squareIt.Cv.xx); //displays &quot;100&quot;		
		
		    writeln(squareIt.y); //error !Cannot find name: y in the PV structure of Lambda squareIt!</pre>
		    <p>Example2</p>
		    <pre>function foo  (x)  {
		
		         cvar z;
		
		         z = x;
		
		         return(z);
		
		         }
		
		
		
		         var z;
		
		         result = foo(7);
		
		         display(result);  //displays &quot;7&quot;
		
		         display(z);  //displays #void  (accesses the contents of the global variable)
		
		         display(foo.Cv.z);  //displays &quot;7&quot;</pre>
		    <p>Notes and Hints</p>
		    <p>The scope of variables in nested Lambdas depends upon the following
		    compilation rules: Nested Lambdas do not share either their arguments or
		    their temporary variables. The argument and the temporary variables are
		    always limited in scope to the immediate Lambda object. A nested Lambda shares
		    the persistent variables <b>(pvar)</b> and the persistent class variables <b>(cvar)</b>
		    of its parents. When a variable reference is encountered, the javaScript
		    compiler first searches the local Lambda's temporary variables<b> (var)</b>,
		    then the persistent variable structure <b>(pvar)</b>, then the persistent
		    class structure <b>(cvar)</b>, and finally the global variables.</p>
		    <p>Also note: Any variable that is used without explicit declaration is
		    automatically declared as a global variable. (This is true even if it is
		    used inside a function definition).</p>
           </div> 
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>filter</Heading>
		<Description><![CDATA[
            <div class="h2section" id="filter">
			<p>The <b>filter</b> statement performs a set of filter operations on the <b>dataMineLib.currentTable</b>
		    cursor. The filter statement may be followed by a single command or by
		    multiple commands. The filter statement supports commands for sorting and
		    deleting rows from the current view index. The filter command only alters
		    the current table view. The backup table index is not altered by the filter
		    command.<br>
		    Syntax: filter command1; ?? commandN;</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>filter</b></td>
		        <td valign="top" width="69%">Keyword (optional)</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>Command1;</b></td>
		        <td valign="top" width="69%">filter statement command (mandatory).</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>CommandN;</b></td>
		        <td valign="top" width="69%">filter statement command (optional).</td>
		      </tr>
		    </table>
		    <h3>Notes and Hints</h3>
		    <p><b>Note1</b>: All the commands of a single <b>filter</b> statement are
		    grouped together into a single block. This is true regardless of whether or
		    not the <u>filter</u> keyword is present, and regardless of whether or not
		    the multiple filter commands are enclosed in braces.</p>
		    <p><b>Note2</b>: The <b>filter</b> statement generates code which assumes
		    that the variable named, <b>cursor</b>, contains the dataMineLib cursor
		    which is to be filtered.</p>
		    <p><b>Note3</b>: The <b>filter</b> statement may be used as a stand alone
		    statement in a global declaration or inside an existing function. A stand
		    alone filter statement is automatically enclosed in the following universal
		    parse tree lambda:<br>
		    (lambda (cursor)<br>
		    (begin ??filter statement block??)<br>
		    cursor)</p>
		    <p><b>Note4</b>: The <b>filter</b> statement always automatically converts
		    any name symbol into a row field reference.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: all</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Filter Command: all">
			<p>The <b>all</b> command performs a deletion operation on the current table
		    cursor. The backup table view is not effected.<br>
		    Syntax: all filterexpression<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>all</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>filterexpression</b></td>
		        <td valign="top" width="69%">Filter expression.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter all Sales &gt; 10000;</p>
		    <p>This will delete all rows from the current table view where Sales are not
		    greater than 10000. Any rows, where Sales are #void, will be eliminated from
		    the current table view. The backup table view will not be altered.</p>
		    Syntax: all old portfolio<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>all</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>old</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>portfolio</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		    </table>
		    <h3>Example2</h3>
		    <p>filter all old portfolio;</p>
		    <p>This form of the all command, will delete all rows from the current 
		    table view except those stocks contained in the previous portfolio. 
		    If the current table view is not empty, all remaining rows will have a 
		    Notes.Ownership element equal to the percent of the previous portfolio 
		    allocated to the specified stock. 
		    A positive ownership percent indicates a long position. A negative ownership percent is invalid as shorting is not allowed.
		    </p>
		    <P>Note: This form of the all command can only be invoked within a Stock Weekly Summary
		    Training window and then only during a fundWizard blind-forward-testing run. 
		    </P>
		    Syntax: all portfolio<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>all</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>portfolio</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		    </table>
		    <h3>Example2</h3>
		    <p>filter all portfolio;</p>
		    <p>This form of the all command, will delete all rows from the current 
		    table view except those stocks contained in the current portfolio. 
		    If the current table view is not empty, all remaining rows will have a 
		    Notes.Ownership element equal to the percent of the previous portfolio 
		    allocated to the specified stock. 
		    A positive ownership percent indicates a long position. A negative ownership percent is invalid as shorting is not allowed.
		    </p>
		    <P>Note: This form of the all command can only be invoked within a Stock Weekly Summary
		    Training window and then only during a fundWizard blind-forward-testing run. 
		    </P>
		    Syntax: all buy percent<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>all</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>buy</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>percent</b></td>
		        <td valign="top" width="69%">fractional ownership desired</td>
		      </tr>
		    </table>
		    <h3>Example3</h3>
		    <p>filter all buy 10%;</p>
		    <p>This form of the all command, will set the Notes.Ownership element, of all existing rows,
		    to the specified ownership percentage divided by the number of stocks. 
		    The current table view will not be otherwise altered. 
		    If the current table view is not empty, all existing rows will have a 
		    Notes.Ownership element equal to the specified ownership percent for the specified stock.
		    A positive ownership percent indicates a long position. A negative ownership percent is invalid as shorting is not allowed.
		    </p>
		    <P>Note: This form of the all command can only be invoked within a Stock Weekly Summary
		    Training window and then only during a fundWizard blind-forward-testing run. 
		    </P>
		    Syntax: all sell percent<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>all</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>sell</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>percent</b></td>
		        <td valign="top" width="69%">fraction of current ownership desired sold</td>
		      </tr>
		    </table>
		    <h3>Example4</h3>
		    <p>filter all sell 100%;</p>
		    <p>This form of the all command, will sell the specified percent of current ownership,
		    of all stocks in the current view.
		    This command, will subtract from the Notes.Ownership element, 
		    of all current rows, the current ownership times the specified sales percentage. 
		    The current table view will not be otherwise altered. 
		    A positive ownership percent indicates a long position. A negative ownership percent is invalid as shorting is not allowed.
		    </p>
		    <P>Note: This form of the all command can only be invoked within a Stock Weekly Summary
		    Training window and then only during a fundWizard blind-forward-testing run. 
		    </P>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references 
		       UNLESS previously defined in var, reg, pvar, cvar, or argument list declarations.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: bottom</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Filter Command: bottom">
			<p>The <b>bottom</b> command performs a sort on the current table cursor,
		    followed by a deletion operation on the current table cursor.<br>
		    Syntax: bottom sortexpression cutoff<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>bottom</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>sortexpression</b></td>
		        <td valign="top" width="69%">Sort expression.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>cutoff</b></td>
		        <td valign="top" width="69%">Cut off absolute number or percent.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter bottom Sales * Price 100;</p>
		    <p>This will delete all rows from the current table view which are not in
		    the top 100 rows of all (Sales * Price). Any rows, where Sales or Price are
		    #void, will be eliminated from the current table view. The backup table view
		    will not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
           </div>	
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: check</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Filter Command: check">
		   <p>The <b>check</b> command performs a deletion operation on the current
		    table cursor.<br>
		    Syntax: check name1 ? nameN<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>check</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>name1</b></td>
		        <td valign="top" width="69%">Field name (mandatory).</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>nameN</b></td>
		        <td valign="top" width="69%">Field name (optional).</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter check Sales Price;</p>
		    <p>This will delete all rows from the current table view where either Sales
		    or Price are #void. The backup table view will not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: checkoff</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Filter Command: checkoff">
			<p>The <b>checkoff</b> command turns off automatic field checking for the
		    whole filter statement, including any commands which came before the
		    checkoff command. (also the command <b>nocheck</b> can be used as a synonym
		    for <b>checkoff</b>).<br>
		    Syntax: checkoff<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>checkoff</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter checkoff; sort Sales;</p>
		    <p>This will sort all rows from the current table in ascending order by
		    Sales. Even rows where Sales are #void will be included in the sort. The
		    backup table view will not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: omit</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Filter Command: omit">
			<p>The <b>omit</b> command performs a deletion operation on the current
		    table cursor. The current view of the table is permanently altered, and the
		    back up view of the table is permanently altered. The omit command includes
		    an implied <b>checkoff</b> command.<br>
		    Syntax: omit filterexpression<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>omit</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>filterexpression</b></td>
		        <td valign="top" width="69%">Filter expression.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p><b>filter omit Sales &gt; 10000;</b></p>
		    <p>&nbsp;</p>
		    <p>This will delete all rows from the current table view where Sales are
		    greater than 10000. The current table view will be altered. The backup table
		    view will be permanently altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: restore</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Filter Command: restore">
			<p>The <b>restore</b> command restores the backup view of the current table
		    cursor.<br>
		    Syntax: restore<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>restore</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter restore;</p>
		    <p>This will restore the backup view of the current table cursor. The backup
		    table view will not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: run</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Filter Command: run">
			<p>The <b>run</b> command performs a filter on the current table cursor.<br>
		    Syntax: run nameString<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>run</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>nameString</b></td>
		        <td valign="top" width="69%">The name of the filter, in the current
		          project, to run on the table cursor.</td>
		      </tr>
		    </table>
		    <p>Syntax: run functionCall</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>run</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>functionCall</b></td>
		        <td valign="top" width="69%">A javaScript function call expression to a
		          specified filter Lambda.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <pre>filter run &quot;myFilter&quot;;</pre>
		    <p>This will run the &quot;myFilter&quot; FilterLambda, in the current
		    project, on the current table view. The backup table view will not be
		    altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be <b>NOT</b> treated as table row field references.</p>
		    <h3>Example2</h3>
		    <pre>filter run stockWizard.filterMe(cursor); </pre>
		    <p>This will call the stockWizard.filterMe FilterLambda, passing the current
		    table view as an argument.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will <b>NOT</b> be treated as table row field references.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: set</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Filter Command: set">
			<p>The <b>set</b> command performs a update on the current table cursor.<br>
		    Syntax: set fieldName=expression<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>set</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>fieldName</b></td>
		        <td valign="top" width="69%">Name of the field, in each row of the
		          current view, which is to be set with a new value.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>=</b></td>
		        <td valign="top" width="69%">Optional assignment symbol</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>expression</b></td>
		        <td valign="top" width="69%">The new value which is to be set into each
		          row of the current view.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <pre>filter set Score 1; </pre>
		    <pre>filter set Score = 1; </pre>
		    <p>This will set the Score field to 1, in all rows in the current table
		    view. The current table view will be replaced with the new backup view. The
		    backup table view will be permanently altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: setnr</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Filter Command: setnr">
			<p>The <b>setnr</b> command performs a update on the current table cursor
		    without reseting the current view.<br>
		    Syntax: setnr fieldName=expression<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>setnr</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>fieldName</b></td>
		        <td valign="top" width="69%">Name of the field, in each row of the
		          current view, which is to be set with a new value.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>=</b></td>
		        <td valign="top" width="69%">Optional assignment symbol</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>expression</b></td>
		        <td valign="top" width="69%">The new value which is to be set into each
		          row of the current view.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <pre>filter setnr Score 1; </pre>
		    <pre>filter setnr Score = 1; </pre>
		    <p>This will set the Score field to 1, in all rows in the current table
		    view. The current table view will not be reset. The backup table view will
		    be permanently altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: slice</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Filter Command: slice">
			<p>The <b>slice</b> command performs an ascending sort on the current table
		    cursor, followed by a tile operation on the current table cursor.<br>
		    Syntax: slice sortexpression tileIndex of tileCount<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>slice</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>sortexpression</b></td>
		        <td valign="top" width="69%">Sort expression.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>tileIndex</b></td>
		        <td valign="top" width="69%">The index of the tile to show.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>of</b></td>
		        <td valign="top" width="69%">Mandatory keyword.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>tileCount</b></td>
		        <td valign="top" width="69%">The number of tiles.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter slice Sales * Price 42 of 100;</p>
		    <p>This will retain all rows from the current table view which are in the 42
		    percentile of (Sales * Price). Any rows, where Sales or Price are #void,
		    will be eliminated from the current table view. The backup table view will
		    not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: sort</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Filter Command: sort">
			<p>The <b>sort</b> command performs a sort on the current table cursor.<br>
		    Syntax: sort [backup] [direction] sortexpression</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>sort</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>backup</b></td>
		        <td valign="top" width="69%">Optional keyword to specify that the backup
		          view of the table is to be sorted as well as the current view.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>direction</b></td>
		        <td valign="top" width="69%">Optional Sort direction: <b>up</b> or <b>down</b>
		          (optional). If sort direction is omitted, the direction is assumed to
		          be up.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>sortexpression</b></td>
		        <td valign="top" width="69%">Mandatory Sort expression.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>filter sort down Name;</p>
		    <p>This will sort all rows in the current table view in descending order by
		    Name. Any rows, where Name is #void, will be eliminated from the current
		    table view. The backup table view will not be altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>	
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Filter Command: top</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Filter Command: top">
			<p>The <b>top</b> command performs a sort on the current table cursor,
		    followed by a deletion operation on the current table cursor.<br>
		    Syntax: top sortexpression cutoff<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>top</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>sortexpression</b></td>
		        <td valign="top" width="69%">Sort expression.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>cutoff</b></td>
		        <td valign="top" width="69%">Cut off absolute number or percent.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <pre>filter top Salary 10%;</pre>
		    <p>This will delete all rows from the current table view which are not in
		    the top 10% of all Salaries. Any rows, where Salary is #void, will be
		    eliminated from the current table view. The backup table view will not be
		    altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
		    <p>&nbsp;</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>for</Heading>
		<Description><![CDATA[
            <div class="h2section" id="for">
			<p>The <b>for</b> statement repeats a set of javaScript statements until the
		    specified condition is false.<br>
		    Syntax: for ( initexp; cond; increxp ) { exp ... }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>for</b></td>
		        <td>
		          <p>Mandatory keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Initexp;</b></td>
		        <td>
		          <p>Initializer expression. Usually resets an index to be used to
		          determine loop control</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>cond;</b></td>
		        <td>
		          <p>An expression that returns a Boolean value. Usually tests the loop
		          index to see if has reached a max number.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Increxp</b></td>
		        <td>
		          <p>Increment expression. Usually increments (or decrements) the loop
		          index.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>{expr...}</b></td>
		        <td>
		          <p>A set of javaScript statements</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <pre>var int a;
		
		         for (a = 1; a &lt; 10; ++a ) { display(&quot; &quot;, a)}</pre>
		    <p>This will display the following line in the console screen:</p>
		    <pre>1  2  3  4  5  6  7  8  9  </pre>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>friend</Heading>
		<Description><![CDATA[
            <div class="h2section" id="friend">
			<p>The <b>friend </b>statement creates a new Lambda object and assigns it to
		    the specified persistent variable name <b>friendName</b> of the parent Lambda
		    <b>parent</b>. The <b>friend </b>function<b> </b>declaration always returns
		    the newly created Lambda object. The new friend Lambda is invoked by using the
		    <b>parent.friendName ()</b> syntax.<br>
		    Syntax: friend parent friendName ([type] arg..) { cvardec pvardec vardec exp
		    }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>friend</b></td>
		        <td>
		          <p>Mandatory keyword.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>parent</b></td>
		        <td>
		          <p>Name of the parent class</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>friendName</b></td>
		        <td>
		          <p>The name of the friend Lambda (function)</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>([type] arg...)</b></td>
		        <td>
		          <p>A list of type hints (optional) and arguments separated by commas.
		          If there are no arguments the parenthesis are still required. <b>Note</b>:
		          The optional type hints can be one of the following: <b>char</b>,<b>
		          bool</b>,<b> int</b>,<b> float</b>,<b> </b>or<b> obj</b></p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>cvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          class variable declaration. See <b>cvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>pvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          variable declaration. See <b>pvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>vardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a local
		          variable declaration. See <b>var</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>exp</b></td>
		        <td>
		          <p>The javaScript statements that form the Lambda</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>Lambda object identifier</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <b>function foo(x) {<br>
		    pvar y=5, d;<br>
		    d=x<br>
		    return (d);<br>
		    }<br>
		    <br>
		    friend foo sum (x) {<br>
		    pvar d=20 ;<br>
		    var temp ;<br>
		    temp=x + d + y;<br>
		    return ( temp );<br>
		    }</b>
		    <p>We can invoke the parent and friend Lambdas as follows:</p>
		    <pre>foo(10); //Returns 10
		
	           	 foo.sum(3); //Returns 28
		
		         compareEQ(foo.Pv,  foo.sum.Cv); //Returns true
		
		         compareEQ(foo.Pv,  foo.sum.Pv); //Returns false</pre>
		    <p>Notes and Hints</p>
		    <p>A friend Lambda has a different <b>pvar</b> structure than its parent
		    Lambda, but the <b>cvar</b> structure of a friend Lambda is the <b>pvar</b>
		    structure of its parent Lambda.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>function</Heading>
		<Description><![CDATA[
            <div class="h2section" id="function">
			<p>A javaScript function compiles into a first class Lambda object. It has
		    the same footprint and is treated like any Lambda Object created by any
		    compiler in the LambdaClient development environment.<br>
		    Syntax: function name ([type] arg..) { cvardec pvardec vardec exp }<br>
		    Syntax: function ([type] arg..) { cvardec pvardec vardec exp }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>function</b></td>
		        <td>
		          <p>Mandatory keyword.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>name</b></td>
		        <td>
		          <p>(Optional) The name of the Lambda (function)</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>([type] arg...)</b></td>
		        <td>
		          <p>A list of type hints (optional) and arguments separated by commas.
		          If there are no arguments the parenthesis are still required. <b>Note</b>:
		          The optional type hints can be one of the following: <b>char</b>,<b>
		          bool</b>,<b> int</b>,<b> float</b>,<b> </b>or<b> obj</b></p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>cvardec</b></td>
		        <td>
		          <p>Optional Argument. If present, must be followed by a persistent
		          variable declaration. See <b>cvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>pvardec</b></td>
		        <td>
		          <p>Optional Argument. If present, must be followed by a persistent
		          variable declaration. See <b>pvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>vardec</b></td>
		        <td>
		          <p>Optional Argument. If present, must be followed by a local variable
		          declaration. See <b>var</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>exp</b></td>
		        <td>
		          <p>The javaScript statements that form the Lambda</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>Lambda object identifier</p>
		        </td>
		      </tr>
		    </table>
		    <p>Note: A function with no name will generate an unnamed function.</p>
		    <p>When To Use</p>
		    <p>The <b>function </b>statement defines the name of an Lambda, its
		    arguments, and the statements that comprise the Lambda.</p>
		    <p>Example1</p>
		    <pre>function foo (x) {
		
		         writeln( &quot;The value of x is &quot; , x);
		
		         }</pre>
		    <p>To invoke:</p>
		    <pre>foo(29);</pre>
		    <p>Example2</p>
		    <pre>function sayHello  ( ) {
		
		         writeln( &quot;Hello World&quot;);
		
		          }</pre>
		    <p>To invoke:</p>
		    <pre>sayHello();</pre>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Function Invocation</Heading>
		<Description><![CDATA[
                 <div class="h2section" id="Function Invocation">
				<p>javaScript functions may be called by name or by Object Identifier. The
			    function to be invoked must always have a set of parenthesis following the
			    function name. If the function requires arguments, the arguments are passed
			    as a comma separated list inside the parenthesis.<br>
			    Syntax: name ()<br>
			    Syntax: name (arg ...)<br>
			    Syntax: Lambda.child ()<br>
			    Syntax: Lambda.friend ( arg ...)<br>
			    Syntax: class.method ()<br>
			    Syntax: class.method ( arg ...)</p>
			    <table cellspacing="0" border="0" cellpadding="2">
			      <tr align="top">
			        <td><b>name</b></td>
			        <td>
			          <p>The name of the function to be invoked.</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>class.method</b></td>
			        <td>
			          <p>Alternate form of function name. Must be a method of a specified
			          class</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>(arg...)</b></td>
			        <td>
			          <p>A list of arguments separated by commas. If there are no arguments
			          the parenthesis are still required.</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>Returns</b></td>
			        <td>
			          <p>Lambda object identifier</p>
			        </td>
			      </tr>
			    </table>
			    <p>Example1</p>
			    <pre>foo (x) {
			
			         display( &quot;The value of x is &quot; , x);
			
			          }</pre>
			    <p>To invoke:</p>
			    <pre>foo (1998);</pre>
			    <p>Example2</p>
			    <pre>function  foo(x) {
			
			         pvar y;
			
			         y = x;
			
			         return (y);
			
			         }
			
			
			
		           	child foo sum (x) {
			
			        var temp;
			
			        temp = x +  y;
			
			        return ( temp );
			
			        }</pre>
			    <p>We can invoke the parent and the child Lambda as follows:</p>
			    <pre>foo(10);  //Returns 10
			
			         foo.sum(3);  //Returns 13</pre>
                 </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>if</Heading>
		<Description><![CDATA[
            <div class="h2section" id="if">
			<p>The <b>if </b>statement selects one of two expressions to evaluate based
		    upon the value of a <b>{test}</b> expression. If the <b>{cond}</b> evaluates
		    to True, then the expressions in the <b>{thenClause}</b> is evaluated.</p>
		    <p>If the <b>else</b> keyword is present and the <b>{test} </b>evaluates to <b>false</b>,
		    then the expressions in the <b>{elseClause}</b> is evaluated.</p>
		    <p>The <b>{test}</b> and <b>{thenClause}</b> expressions are mandatory. The <b>{else}</b>
		    expression is optional. The braces <b>{} </b>are also mandatory.</p>
		    <p>The <b>{elseClause} </b>may also be an <b>if </b>statement therefore
		    creating a limitless number of conditions and conditional paths.<br>
		    Syntax: if (test) { trueClause... }<br>
		    Syntax: if (test) { trueClause... } else { elseClause... }<br>
		    Syntax: if (test) { trueClause... } else if (test2) { exp ... }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>test</b></td>
		        <td>
		          <p>An expression that returns a Boolean value. Must be enclosed in
		          parenthesis.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>thenClause</b></td>
		        <td>
		          <p>The expression to be executed if the cond clause returned True</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>else</b></td>
		        <td>
		          <p>Optional Keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>elseClause</b></td>
		        <td>
		          <p>Optional expression. If the else keyword is present the elseClause
		          must be present. The expression to be executed if the cond clause
		          returned False</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>else if</b></td>
		        <td>
		          <p>If present, must be a valid if statement.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>Returns the value of the expression evaluated. If no else clause is
		          specified, the returned value is the result of the condition
		          expression.</p>
		        </td>
		      </tr>
		    </table>
		    <p>When To Use</p>
		    <p>The <b>if </b>statement is used whenever it is necessary to perform
		    actions based on a condition</p>
		    <p>Example1</p>
		    <b>j=1</b>
		    <pre>if ( j &lt; 10 ) { k = 100;} else { k = -100;} //sets k to 100</pre>
		    <p>Example2</p>
		    <pre>	j = 2;
		
	  				if ( j &lt; 10 )  { k = 100;} 
		
					else if ( j == 0)  {k = 10;}
		
					else if ( j == 1 ) {k = 100;} 
		
					else if ( j == 2 ) {k = 1000;} //sets k to 1000</pre>
           </div> 
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Logical Operators</Heading>
		<Description><![CDATA[
                <div class="h2section" id="Logical Operators">
				<p>The logical operators are <b>&amp;&amp; (and) , || (or) , </b>and<b> !
			    (not) </b>. The resulting value from a logical operation is a Boolean value.
			    The <b>&amp;&amp;</b> operator returns <b>true</b> if <i><u>both</u></i><u></u>
			    operands are <b>true</b>, the <b>|| </b>operator<b> </b>returns <b>true</b>
			    if <i><u>one</u></i><u></u> or <i><u>both</u></i><u></u> operands are <b>true</b>,
			    and the <b>!</b> operator returns <b>true</b> if the operand is <b>false</b>,
			    otherwise the <b>!</b> operator returns <b>false</b>. javaScript performs
			    type checking and type conversions, therefore if the operands are not
			    Boolean, the operands are converted to Boolean.<b><br>
			    </b>Syntax: (obj1 &amp;&amp; obj2 )<br>
			    Syntax: (obj1 || obj2 )</p>
			    <table cellspacing="0" border="0" cellpadding="2">
			      <tr align="top">
			        <td><b>obj1</b></td>
			        <td>
			          <p>First object to be compared</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>operator</b></td>
			        <td>
			          <p>Must be <b>&amp;&amp; (and) , || (or)</b></p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>obj2</b></td>
			        <td>
			          <p>Second object to be compared</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>Returns</b></td>
			        <td>
			          <p>The <b>&amp;&amp;</b> operator returns <b>true</b> if <i><u>both</u></i><u></u>
			          operands are <b>true</b>, otherwise it returns <b>false</b>. The <b>||
			          </b>operator<b> </b>returns <b>true</b> if <i><u>one</u></i><u></u> or
			          <i><u>both</u></i><u></u> operands are <b>true</b> otherwise it
			          returns <b>false</b>.</p>
			        </td>
			      </tr>
			    </table>
			    <p><br>
			    Syntax: (!obj1)</p>
			    <table cellspacing="0" border="0" cellpadding="2">
			      <tr align="top">
			        <td><b>!</b></td>
			        <td>
			          <p>Logical not operator<b></b></p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>obj1</b></td>
			        <td>
			          <p>Object to be negated</p>
			        </td>
			      </tr>
			      <tr align="top">
			        <td><b>Returns</b></td>
			        <td>
			          <p>Returns <b>true</b> if the operand is <b>false</b>, otherwise the <b>!</b>
			          operator returns <b>false</b>.</p>
			        </td>
			      </tr>
			    </table>
			    <p>Example1</p>
			    <pre>	var a = true, k;
			
						if ( 2 &lt; 3) &amp;&amp; (a == true) {k = 1;} else {k = 2;} // sets k to 1   
			
						if ( 2 &gt; 3) || (a == true) {k = 1;} else {k = 2;} // sets k to 1   
			
						if ( 2 &gt; 3) &amp;&amp; (!a) {k = 1;} else {k = 2;}// sets k to 2</pre>
              </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>method</Heading>
		<Description><![CDATA[
           <div class="h2section" id="method">
			<p>The <b>method</b> statement defines a method to javaScript class.<br>
		    Syntax: method className methodName([type] arg...) { expr }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>method</b></td>
		        <td>
		          <p>Mandatory keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>className</b></td>
		        <td>
		          <p>Name of the parent class of the method</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>methodName</b></td>
		        <td>
		          <p>Name of this method.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>([type] arg...)</b></td>
		        <td>
		          <p>A list of type hints (optional) and arguments separated by commas.
		          If there are no arguments the parenthesis are still required. <b>Note</b>:
		          The optional type hints can be one of the following: <b>char</b>,<b>
		          bool</b>,<b> int</b>,<b> float</b>,<b> </b>or<b> obj</b></p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>{expr}</b></td>
		        <td>
		          <p>A set of javaScript statements</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <pre>	class employee {Name; Address; Salary }
		
					method employee updateSalary( this, newSalary) {
		
					this.Salary = newSalary;
		
					}
		
					emp = new ('employee', 'Name', &quot;Tom Jones&quot;,  'Address',  &quot;200 Main Street, Small Town,  USA&quot; )
		
					emp.updateSalary(45000);
		
					writeln (emp.Name, &quot;'s new salary is &quot;, emp.Salary);</pre>
		    <b>Note: </b>In a method declaration the receiving object (this) is
		    declared, but is not passed in the function invocation.
		    <pre>emp.updateSalary(45000); // This is correct
		
				emp.updateSalary(emp,45000); // This is incorrect</pre>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>new</Heading>
		<Description><![CDATA[
             <div class="h2section" id="new">
					<p>The <b>new</b> function creates an instance of an object. The Lambda
		    Information Server definition of an object is very specific. It is a memory
		    resident container to store data, which is of variable length or is too
		    large to fit in small fixed containers. The Analytic Information Server object
		    Heap manager supports automated object resizing, garbage collection, and
		    anti-fragmentation algorithms so that the user may concentrate on the
		    analysis and modeling of data rather than on memory management.</p>
		    <p>The javaScript compiler supports all of the Analytic Information Server
		    objects. Each object is covered in detail in its own chapter in the <b>Lambda
		    Information Server Programmer's Guide.</b></p>
		    <pre>	Syntax: new ('objectType' )
		
					Syntax: new ('String' , value)
		
					Syntax: new ('Symbol' , value)
		
					Syntax: new  ('Vector' , vecSubType,  size)
		
					Syntax: new  ('Vector',  vecSubType,  size,  value)
		
					Syntax: new  ('Structure',  key,  value)
		
					Syntax: new  ('Structure',  key,  value ... . cdr )
		
					Syntax: new  ('Dictionary',  key,  value)
		
					Syntax: new  ('Directory',  key,  value)
		
					Syntax: new  ('ObjectRepository',  filename,  'key',  code, 'buffer', count)</pre>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>new</b></td>
		        <td>
		          <p>Mandatory keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>objectType</b></td>
		        <td>
		          <p>Must be 'String', 'Symbol', 'Vector', 'Structure' , 'Dictionary',
		          'Directory', 'ObjectRepository'</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>value</b></td>
		        <td>
		          <p>Optional Argument. If present, must be a constant of type
		          objectType.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>vecSubType</b></td>
		        <td>
		          <p>Optional argument, but if present must only be used with objectType,
		          Vector. Valid vecSubtypes are</p>
		          <p>'normal'</p>
		          <p>'bit'</p>
		          <p>'integer'</p>
		          <p>'float'</p>
		          <p>'number'</p>
		          <p>'small'</p>
		          <p>'object'</p>
		          <p>'pcode'.</p>
		          <p>If omitted, the default is normal vector.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>size</b></td>
		        <td>
		          <p>Optional argument, but if present must only be used with objectType,
		          Vector. It must be an integer representing the number of items the
		          Vector will store.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>key, value</b></td>
		        <td>
		          <p>Optional arguments to Structure, Dictionary, and Directory, but
		          must appear in pairs. There may be an arbitrary number of key, value
		          pairs.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>. cdr</b></td>
		        <td>
		          <p>Optional Argument to Structure only. If present, it must be a
		          constant that will be assigned to the cdr (tail) of a structure.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>filename</b></td>
		        <td>
		          <p>If objectType is ObjectRepository, filename is a mandatory field
		          which names the database archive file to be associated with the
		          ObjectRepository. If no such file exists, a new database archive file
		          will be created.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>'clear'</b></td>
		        <td>
		          <p>If objectType is ObjectRepository, 'clear' is an optional keyword.
		          If present, the database archive file will be cleared immediately
		          before any further processing. If no such file exists, a new database
		          archive file will be created.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>'key', code</b></td>
		        <td>
		          <p>If objectType is ObjectRepository, 'key' is an optional keyword. If
		          present and it must followed by a number. See ObjectRepository in the
		          Programmer's Guide for more detail.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>'buffer',count</b></td>
		        <td>
		          <p>If objectType is ObjectRepository, 'buffer' is an optional keyword.
		          If the key word 'buffer' is present, the numeric buffered object count
		          must follow. See ObjectRepository in the Programmer's Guide for more
		          detail.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>The <b>new</b> function will return an object identifier for the
		          type specified in objectType .</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>javaScript Syntax</b></td>
		        <td><b>Lisp Syntax</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('String', &quot;John&quot;)</b></td>
		        <td><b>(new String: &quot;John&quot;)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Symbol' , &quot;Donald&quot;)</b></td>
		        <td><b>(new Symbol: &quot;Donald&quot;)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Vector', 3, 11, 12, 99)</b></td>
		        <td><b>(new Vector: 3 11 12 99)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Vector' , 'bit', 5, 1 )</b></td>
		        <td><b>(new Vector: bit: 5 1)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Structure', 'X', 22, 'Y', 34, ' .', 3)</b></td>
		        <td><b>(new Structure: X: 22 Y: 34 . 3)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Dictionary' , 'Name', &quot;John Doe&quot;, 'Age', 30)</b></td>
		        <td><b>(new Dictionary: Name: &quot;John Doe&quot; Age: 30)</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ('Directory' , 1, &quot;New Year's Day&quot;, 2,
		          &quot;Valentine's Day&quot; )</b></td>
		        <td><b>(new Directory: 1 &quot;New Year's Day&quot; 2 &quot;Valentine's
		          Day&quot; )</b></td>
		      </tr>
		      <tr align="top">
		        <td><b>new ( 'ObjectRepository', &quot;myarchive.odb&quot;)</b></td>
		        <td><b>(new ObjectRepository: &quot;myarchive.odb&quot;)</b></td>
		      </tr>
		    </table>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>orphan</Heading>
		<Description><![CDATA[
              <div class="h2section" id="orphan">
			<p>The <b>orphan </b>statement creates a new Lambda object and assigns it to
		    the specified persistent variable name <b>orphanName</b> of the parent Lambda
		    <b>parent</b>. The <b>orphan </b>function<b> </b>declaration always returns
		    the newly created Lambda object. The new orphan Lambda is invoked by using the
		    <b>parent.orphanName ()</b> syntax form.<br>
		    Syntax: orphan parent orphanName ([type] arg..) { cvardec pvardec vardec exp
		    }</p>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>orphan</b></td>
		        <td>
		          <p>Mandatory keyword.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>parent</b></td>
		        <td>
		          <p>Name of the parent class</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>orphanName</b></td>
		        <td>
		          <p>The name of the orphan Lambda (function)</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>([type] arg...)</b></td>
		        <td>
		          <p>A list of type hints (optional) and arguments separated by commas.
		          If there are no arguments the parenthesis are still required. <b>Note</b>:
		          The optional type hints can be one of the following: <b>char</b>,<b>
		          bool</b>,<b> int</b>,<b> float</b>,<b> </b>or<b> obj</b></p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>cvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          class variable declaration. See <b>cvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>pvardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a persistent
		          variable declaration. See <b>pvar</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>vardec</b></td>
		        <td>
		          <p>Optional declaration. If present, must be followed by a local
		          variable declaration. See <b>var</b>.</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>exp</b></td>
		        <td>
		          <p>The javaScript statements that form the Lambda</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>Returns</b></td>
		        <td>
		          <p>Lambda object identifier</p>
		        </td>
		      </tr>
		    </table>
		    <p>Example1</p>
		    <pre>  	 function  foo(x) {
		
		   			 pvar y = 5; pvar d =30;
		
		   			 var temp ;
		
		   			 temp = x + d + y;
		
		   			 return ( temp );
		
		   			 }
		
		
		
					orphan foo  sum (x) {
		
		   		    pvar d = 20 ; 
		
		  		    cvar e = 100 ; 
		
		   			var temp ;
		
		   		    temp = x + d + y;
		
		   		   return ( temp );
		
		    		}</pre>
		    <p>We can invoke the parent and orphan Lambdas as follows:</p>
		    <pre> 	y = 10; //declare a global variable
		
				 	foo(10); //Returns 45
		
					foo.sum(10); //Returns 40 (uses the value of global  y)
		
					compareEQ(foo.Cv,  foo.sum.Cv); //Returns false
		
					compareEQ(foo.Pv,  foo.sum.Pv); //Returns false</pre>
		    <p>Notes and Hints</p>
		    <p>An orphan<b> </b>Lambda is a member of its parent's <b>pvar</b> structure.
		    Therefore, the parent knows about the orphan. However, the orphan Lambda has
		    a different <b>pvar</b> structure than its parent Lambda, and a different <b>cvar</b>
		    structure than its parent Lambda. Therefore, an orphan Lambda knows nothing of
		    its parent Lambda.</p>
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>pvar</Heading>
		<Description><![CDATA[
             <div class="h2section" id="pvar">
		  <p>The <b>pvar</b> statement declares a persistent variable within an Lambda.
		    This means that the persistent class variable will have a scope for the life
		    of the Lambda object. The persistent variable is created and initialized when
		    the Lambda is instantiated and <u>not</u> re-initialized each time the Lambda
		    is invoked. Although javaScript is a dynamically typed language, the pvar
		    allows the programmer to optionally provide hints to the compiler by
		    specifying a type for variable declarations. The supported types are: char,
		    bool, int, float, and obj. Specifying a type of obj is equivalent to
		    specifying no type information.</p>
		    <b>Note</b>: If type hints are supplied, the programmer must assure that no
		    other types are saved in the variable.
		    <pre>	Syntax: pvar varName 
		
					Syntax: pvar varName = init
		
					Syntax: pvar type varName 
		
					Syntax: pvar type varName = init</pre>
		    <table cellspacing="0" border="0" cellpadding="2">
		      <tr align="top">
		        <td><b>pvar</b></td>
		        <td>
		          <p>Mandatory keyword</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>type</b></td>
		        <td>obj char bool int float obj text string symbol bitvec fltvec pcdvec
		          stc dir dic matrix nummat vec bitvec numvec intvec objvec</td>
		      </tr>
		      <tr align="top">
		        <td><b>pvarName</b></td>
		        <td>
		          <p>The name of the persistent variable</p>
		        </td>
		      </tr>
		      <tr align="top">
		        <td><b>=init</b></td>
		        <td>
		          <p>Optional argument. If present, the compiler will assign the <b>pvarName</b>
		          to the value in <b>init</b>.</p>
		        </td>
		      </tr>
		    </table>
		    <p>When To Use</p>
		    <p>Unlike a <b>var </b>statement that is declared inside a function, the
		    variables are only &quot;alive&quot; while the function is currently active.
		    A <b>pvar </b>(persistent variable) is accessible, as long the Lambda object
		    instance is active. The contents of the <b>pvar</b> structure is in <b>LambdaName.Pv</b>,
		    where <b>LambdaName</b> is the name of the instance of the Lambda.</p>
		    <p>A persistent variable <b>(pvar)</b> is analogous to a static variable in
		    a C or C++ programming environment. . It created and initialized when the
		    Lambda is instantiated.</p>
		    <p>Unlike temporary variables <b>(var),</b> which are always allocated and
		    initialized upon entry to a function and released upon exit, a <b>pvar</b>
		    is initialized once and the memory allocated is fixed until the application
		    ends.</p>
		    <p>Example1</p>
		    <pre>	function squareIt  (x)  {
		
		    		pvar xx;
		
		    		var y;
		
		   			xx = x * x;
		
		    		y = xx;
		
		    		return (xx);
		
		    		}
		
		
		
					var result;
		
					result = squareIt (10);
		
					writeln(result);  //displays &quot;100&quot;
		
					writeln(squareIt.xx);  //displays &quot;100&quot;
		
					writeln(squareIt.y); //error !Cannot find name: y in the PV structure of Lambda squareIt!</pre>
		    <p>Notes and Hints</p>
		    <p>The scope of variables in nested Lambdas depends upon the following
		    compilation rules: Nested Lambdas do not share either their arguments or
		    their temporary variables. The argument and the temporary variables are
		    always limited in scope to the immediate Lambda object. A nested Lambda shares
		    the persistent variables <b>(pvar)</b> and the persistent class variables <b>(cvar)</b>
		    of its parents. When a variable reference is encountered, the javaScript
		    compiler first searches the local Lambda's temporary variables<b> (var)</b>,
		    then the persistent variable structure <b>(pvar)</b>, then the persistent
		    class structure <b>(cvar)</b>, and finally the global variables.</p>
		    <p>Also note: Any variable that is used without explicit declaration is
		    automatically declared as a global variable. (This is true even if it is
		    used inside a function definition).</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>reg</Heading>
		<Description><![CDATA[
               <div class="h2section" id="reg">
			   <p>The <b>reg</b> statement declares a register variable inside a
		        javaScript program. If a <b>reg</b> statement appears outside a
		        function definition, the variable declaration generates an error
		        message.</p>
		        <p>The <b>reg</b> statement declares a register variable within an
		        Lambda. This means that the register variable will have a scope for this
		        invocation of the Lambda object. The register variable is created and
		        initialized each time the Lambda is invoked. Although javaScript is a
		        dynamically typed language, the reg allows the programmer to optionally
		        provide hints to the compiler by specifying a type for register
		        declarations. The supported types are: int and float.
		        Specifying a type of int is equivalent to specifying no type
		        information.</p>
		        <b>Note</b>: If type hints are supplied, the programmer must assure that
		        no other types are saved in the variable.<b><u><br>
		        </u></b><u></u>Syntax: reg varName<br>
		        Syntax: reg varName=init|<br>
		        Syntax: reg type varName<br>
		        Syntax: reg type varName=init
		        <table cellspacing="0" border="0" cellpadding="2">
		          <tr align="top">
		            <td><b>reg</b></td>
		            <td>
		              <p>Mandatory keyword</p>
		            </td>
		          </tr>
		          <tr align="top">
		            <td><b>type</b></td>
		            <td>int float</td>
		          </tr>
		          <tr align="top">
		            <td><b>varName</b></td>
		            <td>
		              <p>The name of the register variable</p>
		            </td>
		          </tr>
		          <tr align="top">
		            <td><b>=init</b></td>
		            <td>
		              <p>Optional argument. If present, the compiler will assign the <b>varName</b>
		              to the value in <b>init</b>.</p>
		            </td>
		          </tr>
		        </table>
		        <p>When To Use</p>
		        <p>It is necessary to explicitly declare register variables inside a function
		        using the <b>reg</b> statement. The register variable structure, <b>LambdaName.Rv,
		        </b>(where <b>LambdaName</b> is the name of the instance of the Lambda) is
		        accessible.</p>
		        <p>Register variables are always allocated and initialized upon entry
		        to a function and released upon exit.</p>
		        <p>Example1</p>
		        <pre>	function zoo  (x)  {
		
		    			reg int m;
		
		    			m = x;
		
		    			writeln(m);
		
		    			return (m);
		
		    			}
		
		
		
						var m = 99;
		
						result = zoo(7); //displays &quot;7&quot;  (accesses the contents of the local variable)
		
						writeln(m);  //displays &quot;99&quot;  (accesses the contents of the global variable)
		
						writeln(zoo.m); //error--!Cannot find name: m in the PV structure of Lambda zoo!</pre>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>score</Heading>
		<Description><![CDATA[
            <div class="h2section" id="score">
			<p>The <b>score</b> statement performs a set of scoring operations on the <b>dataMineLib.currentTable</b>
		    cursor. The score statement must be followed by a single command. The score
		    statement supports commands for averaging and totalling rows from the
		    current view index. The score statement does not alter the current table
		    view. The backup table index is not altered by the score statement.<br>
		    Syntax: score command;</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>score</b></td>
		        <td valign="top" width="69%">Keyword (optional)</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>command</b></td>
		        <td valign="top" width="69%">score statement command (mandatory).</td>
		      </tr>
		    </table>
		    <p>Syntax: score expression;</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>score</b></td>
		        <td valign="top" width="69%">Keyword (mandatory)</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>expression</b></td>
		        <td valign="top" width="69%">Any valid javaFilter expression including
		          imbedded score statement commands (mandatory).</td>
		      </tr>
		    </table>
		    <p>Syntax: score variable=command;</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>score</b></td>
		        <td valign="top" width="69%">Keyword (optional)</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>variable</b></td>
		        <td valign="top" width="69%">A variable name to receive the finished
		          score.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>=</b></td>
		        <td valign="top" width="69%">The javaFilter assignment operator.</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>command</b></td>
		        <td valign="top" width="69%">score statement command (mandatory).</td>
		      </tr>
		    </table>
		    <h3>Notes and Hints</h3>
		    <p><b>Note1</b>: The <b>score</b> statement generates code which assumes
		    that the variable named, <b>cursor</b>, contains the dataMineLib cursor
		    which is to be filtered.</p>
		    <p><b>Note2</b>: The <b>score</b> statement may be used as a stand alone
		    statement in a global declaration or inside an existing function. A stand
		    alone filter statement is automatically enclosed in the following universal
		    parse tree lambda:</p>
		    <p>(lambda (cursor)<br>
		    (begin ?score statement block?)<br>
		    )</p>
		    <p><b>Note3</b>: The <b>score</b> statement always automatically converts
		    any name symbol into a row field reference.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Score Command: average</Heading>
		<Description><![CDATA[
            <div class="h2section" id="Score Command: average">
			<p>The <b>average</b> command averages a numeric expression over each row in
		    the current table cursor.<br>
		    Syntax: average expression<b></b></p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>average</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>expression</b></td>
		        <td valign="top" width="69%">Numeric expression.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>score average Sales;</p>
		    <p>This will return the average of Sales for the current table. Any rows,
		    where Sales are #void, will be treated a zero values in the average. The
		    current table view will not be altered. The backup table view will not be
		    altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Score Command: averageForAll</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Score Command: averageForAll">
			<p>The <b>averageForAll</b> command averages a numeric expression over ALL
		    rows in the current table cursor.<br>
		    Syntax: averageForAll expression</p>
		    <table border="0" cellpadding="2" cellspacing="0" width="638">
		      <tr>
		        <td valign="top" width="31%"><b>averageForAll</b></td>
		        <td valign="top" width="69%">Mandatory keyword</td>
		      </tr>
		      <tr>
		        <td valign="top" width="31%"><b>expression</b></td>
		        <td valign="top" width="69%">Numeric expression.</td>
		      </tr>
		    </table>
		    <h3>Example1</h3>
		    <p>score averageForAll Sales;</p>
		    <p>This will return the average of Sales for the backup table. Any rows,
		    where Sales are #void, will be treated a zero values in the average. The
		    current table view will not be altered. The backup table view will not be
		    altered.</p>
		    <h3>Notes and Hints</h3>
		    <p>Any names will be treated as table row field references.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Score Command: total</Heading>
		<Description><![CDATA[
              <div class="h2section" id="Score Command: total">
			  <p>The <b>total</b> command totals a numeric expression over each row in
		      the current table cursor.</p>
		      <p>Syntax: total expression<b></b></p>
		      <table border="0" cellpadding="2" cellspacing="0" width="638">
		        <tr>
		          <td valign="top" width="31%"><b>total</b></td>
		          <td valign="top" width="69%">Mandatory keyword</td>
		        </tr>
		        <tr>
		          <td valign="top" width="31%"><b>expression</b></td>
		          <td valign="top" width="69%">Numeric expression.</td>
		        </tr>
		      </table>
		      <h3>Example1</h3>
		      <p>score total Sales;</p>
		      <p>This will return the total of Sales for the current table. Any rows,
		      where Sales are #void, will be treated a zero values in the total. The
		      current table view will not be altered. The backup table view will not be
		      altered.</p>
		      <h3>Notes and Hints</h3>
		      <p>Any names will be treated as table row field references.</p>
              </div>
	    ]]></Description>
	</Section>

	<Section>
	    <Heading>Score Command: totalForAll</Heading>
		<Description><![CDATA[
          <div class="h2section" id="Score Command: totalForAll">
	    <p>The <b>totalForAll</b> command totals a numeric expression over ALL
        rows in the current table cursor.<br>
        Syntax: totalForAll expression<b></b></p>
        <table border="0" cellpadding="2" cellspacing="0" width="638">
          <tr>
            <td valign="top" width="31%"><b>totalForAll</b></td>
            <td valign="top" width="69%">Mandatory keyword</td>
          </tr>
          <tr>
            <td valign="top" width="31%"><b>expression</b></td>
            <td valign="top" width="69%">Numeric expression.</td>
          </tr>
        </table>
        <h3>Example1</h3>
        <p>score totalForAll Sales;</p>
        <p>This will return the total of Sales for the backup table. Any rows,
        where Sales are #void, will be treated a zero values in the total. The
        current table view will not be altered. The backup table view will not
        be altered.</p>
        <h3>Notes and Hints</h3>
        <p>Any names will be treated as table row field references.</p>
         </div>
	    ]]></Description>
	</Section>

	<Section>
	    <Heading>Statement Blocks</Heading>
		<Description><![CDATA[
          <div class="h2section" id="Statement Blocks">
			<p>An arbitrary number of javaScript statements may be grouped logically
        by embedding the statements in braces <b>{ exp</b> ...<b>}</b>. A
        statement block such as this may be placed in any position where a
        single statement is required. Multiple statements in javaScript may be
        written on a single line as long as a semicolon terminates each
        statement.<br>
        Syntax: {exp ...}</p>
        <table cellspacing="0" border="0" cellpadding="2">
          <tr align="top">
            <td><b>exp ...</b></td>
            <td>
              <p>Any number of expressions to be evaluated</p>
            </td>
          </tr>
        </table>
        <p>When To Use</p>
        <p>A statement block may be placed in any position where a single
        statement is required.</p>
        <p>Example1</p>
        <pre>	j = 1;

				if ( j &lt; 10 ) { k = 100; writeln(k);} else { k = -100; writeln(k);} </pre>
         </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>var</Heading>
		<Description><![CDATA[
        <div class="h2section" id="var">
		<p>The <b>var</b> statement declares a temporary variable inside a
        javaScript program. The location of the <b>var</b> statement determines
        the scope the variable. If a <b>var</b> statement appears inside a
        function definition, the variable is considered local to that function
        only. If a <b>var</b> statement appears outside a function definition,
        the variable has global scope.</p>
        <p>The <b>var</b> statement declares a temporary variable within an
        Lambda. This means that the temporary variable will have a scope for this
        invocation of the Lambda object. The temporary variable is created and
        initialized each time the Lambda is invoked. Although javaScript is a
        dynamically typed language, the var allows the programmer to optionally
        provide hints to the compiler by specifying a type for variable
        declarations. The supported types are: char, bool, int, float, and obj.
        Specifying a type of obj is equivalent to specifying no type
        information.</p>
        <b>Note</b>: If type hints are supplied, the programmer must assure that
        no other types are saved in the variable.<b><u><br>
        </u></b><u></u>Syntax: var varName<br>
        Syntax: var varName=init|<br>
        Syntax: var type varName<br>
        Syntax: var type varName=init
        <table cellspacing="0" border="0" cellpadding="2">
          <tr align="top">
            <td><b>var</b></td>
            <td>
              <p>Mandatory keyword</p>
            </td>
          </tr>
          <tr align="top">
            <td><b>type</b></td>
            <td>obj char bool int float obj text string symbol bitvec fltvec
              pcdvec stc dir dic matrix nummat vec bitvec numvec intvec objvec</td>
          </tr>
          <tr align="top">
            <td><b>varName</b></td>
            <td>
              <p>The name of the temporary variable</p>
            </td>
          </tr>
          <tr align="top">
            <td><b>=init</b></td>
            <td>
              <p>Optional argument. If present, the compiler will assign the <b>varName</b>
              to the value in <b>init</b>.</p>
            </td>
          </tr>
        </table>
        <p>When To Use</p>
        <p>Since global variables are automatically declared in the LambdaClient
        environment, it is unnecessary declare global variables. However, it is
        necessary to explicitly declare temporary variables inside a function
        using the <b>var</b> statement. The temporary variable structure, <b>LambdaName.Tv,
        </b>(where <b>LambdaName</b> is the name of the instance of the Lambda) is
        accessible, as long the Lambda object instance is active.</p>
        <p>Temporary variables are always allocated and initialized upon entry
        to a function and released upon exit.</p>
        <p>Example1</p>
        <pre>	function zoo  (x)  {

    			var m;

    			m = x;

    			writeln(m);

    			return (m);

    			}



				var m = 99;

				result = zoo(7); //displays &quot;7&quot;  (accesses the contents of the local variable)

				writeln(m);  //displays &quot;99&quot;  (accesses the contents of the global variable)

				writeln(zoo.m); //error--!Cannot find name: m in the PV structure of Lambda zoo!</pre>
        <p>Notes and Hints</p>
        <p>The scope of variables in nested Lambdas depends upon the following
        compilation rules: Nested Lambdas do not share either their arguments or
        their temporary variables. The argument and the temporary variables are
        always limited in scope to the immediate Lambda object. A nested Lambda
        shares the persistent variables <b>(pvar)</b> and the persistent class
        variables <b>(cvar)</b> of its parents. When a variable reference is
        encountered, the javaScript compiler first searches the local Lambda's
        temporary variables<b> (var)</b>, then the persistent variable structure
        <b>(pvar)</b>, then the persistent class structure <b>(cvar)</b>, and
        finally the global variables.</p>
        <p>Also note: Any variable that is used without explicit declaration is
        automatically declared as a global variable. (This is true even if it is
        used inside a function definition).</p>
        </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>while</Heading>
		<Description><![CDATA[
          <div class="h2section" id="while">
		<p>The <b>while</b> statement repeats a set of javaScript statements
        until its condition is false.<b><u><br>
        </u></b><u></u>Syntax: while (test) { expr }</p>
        <table cellspacing="0" border="0" cellpadding="2">
          <tr align="top">
            <td><b>while</b></td>
            <td>
              <p>Mandatory keyword</p>
            </td>
          </tr>
          <tr align="top">
            <td><b>(test)</b></td>
            <td>
              <p>An expression that returns a Boolean value</p>
            </td>
          </tr>
          <tr align="top">
            <td><b>{expr}</b></td>
            <td>
              <p>A set of javaScript statements</p>
            </td>
          </tr>
        </table>
        <p>Example1</p>
        <pre>	var int a = 1;

				while (a &lt; 10)   { display (&quot; &quot;, a)  ++a }		</pre>
        <p>This will display the following line in the console screen:</p>
        <pre>1  2  3  4  5  6  7  8  9  </pre>
        </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>return</Heading>
		<Description><![CDATA[
         <div class="h2section" id="return">
		<p>The <b>return</b> statement exits the current function passes a
        single value to the caller.<b><u><br>
        </u></b><u></u>Syntax: return ( value )</p>
        <table cellspacing="0" border="0" cellpadding="2">
          <tr align="top">
            <td><b>value</b></td>
            <td>
              <p>Any expression that returns a value. May be embedded in
              parenthesis</p>
            </td>
          </tr>
          <tr align="top">
            <td><b>Returns</b></td>
            <td>
              <p>Immediately evaluates the expression, returns the value, and
              resume execution of the caller function</p>
            </td>
          </tr>
        </table>
        <p>When To Use</p>
        <p>The <b>return</b> statement is used to leave the current function and
        return to the caller with a return value.</p>
        <p>Example1</p>
        <pre>	function foo  (x)  {

    			var m;

    			m = x * 2;

    			return (m); // the value of m is returned to the caller

    			}



				result = foo(7); //result will receive the value of 14</pre>
         </div>
	    ]]></Description>
	</Section>

</Essay>




;;**EXPORTKEY**:javaScript:%%Essay_Runtime_Environment
;#text#
<?xml version="1.0" encoding="UTF-8"?>
<Essay>
	<KnowledgeBase>
	    <Title>Runtime Environment</Title>
		<Topic>JavaScript</Topic>
		<SubTopic>Overview</SubTopic>
		<HumanKeywords>JavaScript Programming Artificial-Intelligence</HumanKeywords>
	</KnowledgeBase>
	<Section>
	    <Heading>Environment Overview</Heading>
		<Description><![CDATA[	
           <div class="h2section" id="Environment Overview">
		    <p>Compiling the javaScript Lambda automatically creates the javaScript
		    runtime environment. The javaScript runtime environment consists of a number
		    of global Lambdas, functions, string and text class methods.</p>
		    <p>The JavaScript runtime environment contains a number of string and text <b>Class
		    Methods</b> which are useful in JavaScript programming. Compiling the
		    javaScript compiler automatically creates these string and text class
		    methods.</p>
		    <p>The <b>Math</b> Lambda is a global Lambda containing a number of
		    mathematical constants and functions useful in JavaScript programming.
		    Compiling the javaScript compiler automatically creates the Math Lambda. The
		    Math Lambda is an important element of the JavaScript runtime environment.</p>
		    <p>The <b>rulesLib</b> is a global Lambda providing a tiny rule-based
		    forward production engine useful in JavaScript programming. Compiling the
		    javaScript compiler automatically creates the rulesLib. The rulesLib is
		    an important element of the JavaScript runtime environment.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Class Methods</Heading>
		<Description><![CDATA[
           <div class="h2section" id="Class Methods">
		    <p>The JavaScript runtime environment contains a number of string and text <b>Class
		    Methods</b> which are useful in JavaScript programming. Compiling the
		    javaScript compiler automatically creates these string and text class
		    methods.</p>
		    <table border="3" cellpadding="2" width="100%">
			<colgroup><col><col style="font-style:italic"><col></colgroup>
		      <tr>
		        <th><i></i>String</i>:charAt(self n)</th>
		        <td>Function</td>
		        <td>Returns the character at index n.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:indexOf(self text)</th>
		        <td>Function</td>
		        <td>Returns the index of the first occurrence of text in self.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:lastIndexOf(self text)</th>
		        <td>Function</td>
		        <td>Returns the index of the last occurrence of text in self.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:length(self)</th>
		        <td>Function</td>
		        <td>Return the number of characters in the string.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:split(self text)</th>
		        <td>Function</td>
		        <td>Returns an array of substrings all split at text.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:substring(self n m)</th>
		        <td>Function</td>
		        <td>Returns substring from character n to one before character m.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:toLowerCase(self)</th>
		        <td>Function</td>
		        <td>Returns string in lower case.</td>
		      </tr>
		      <tr>
		        <th><i>String</i>:toUpperCase(self)</th>
		        <td>Function</td>
		        <td>Returns string in upper case.</td>
		      </tr>
		    </table>
          </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>Math Lambda</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Math Lambda">
			<p>The <b>Math</b> Lambda is a global Lambda containing a number of
		    mathematical constants and functions useful in JavaScript programming.
		    Compiling the javaScript compiler automatically creates the Math Lambda. The
		    Math Lambda is an important element of the JavaScript runtime environment.</p>
		    <table border="3" cellpadding="2" class=members_table>
			<colgroup><col><col style="font-style:italic"><col></colgroup>
		      <tr>
		        <th>Math</th>
		        <td>Lambda</td>
		        <td>JavaScript runtime Math constants and functions</td>
		      </tr>
		      <tr>
		        <th>Math.E</th>
		        <td>Constant</td>
		        <td>Base of natural logarithms (2.718...)</td>
		      </tr>
		      <tr>
		        <th>Math.LN2</th>
		        <td>Constant</td>
		        <td>Natural logarithm of 2 (0.693...)</td>
		      </tr>
		      <tr>
		        <th>Math.LN10</th>
		        <td>Constant</td>
		        <td>Natural logarithm of 10 (2.302...)</td>
		      </tr>
		      <tr>
		        <th>Math.LOG2E</th>
		        <td>Constant</td>
		        <td>Base 2 logarithm of e (1.442...)</td>
		      </tr>
		      <tr>
		        <th>Math.LOG10E</th>
		        <td>Constant</td>
		        <td>Base 10 logarithm of e (0.434...)</td>
		      </tr>
		      <tr>
		        <th>Math.PI</th>
		        <td>Constant</td>
		        <td>Ratio of circumference to diameter (3.141...)</td>
		      </tr>
		      <tr>
		        <th>Math.SQRT1_2</th>
		        <td>Constant</td>
		        <td>Square root of one half (0.707...)</td>
		      </tr>
		      <tr>
		        <th>Math.SQRT2</th>
		        <td>Constant</td>
		        <td>Square root of two (1.414...)</td>
		      </tr>
		      <tr>
		        <th>Math.exp(x)</th>
		        <td>Function</td>
		        <td>Returns E raised to the power of a single argument.</td>
		      </tr>
		      <tr>
		        <th>Math.floor(x)</th>
		        <td>Function</td>
		        <td>Rounds down to next integer for one argument.</td>
		      </tr>
		      <tr>
		        <th>Math.log(x)</th>
		        <td>Function</td>
		        <td>Returns the natural logarithm for one argument.</td>
		      </tr>
		      <tr>
		        <th>Math.max(x,y)</th>
		        <td>Function</td>
		        <td>Returns the maximum of two arguments.</td>
		      </tr>
		      <tr>
		        <th>Math.min(x,y)</th>
		        <td>Function</td>
		        <td>Returns the minimum of two arguments.</td>
		      </tr>
		      <tr>
		        <th>Math.pow(x,p)</th>
		        <td>Function</td>
		        <td>Returns x raised to the power of p.</td>
		      </tr>
		      <tr>
		        <th>Math.random(x)</th>
		        <td>Function</td>
		        <td>Returns a random number between zero and one.</td>
		      </tr>
		      <tr>
		        <th>Math.round(x)</th>
		        <td>Function</td>
		        <td>Rounds to the closest integer.</td>
		      </tr>
		      <tr>
		        <th>Math.sin(x)</th>
		        <td>Function</td>
		        <td>Returns sine of a single argument.</td>
		      </tr>
		      <tr>
		        <th>Math.sqrt(x)</th>
		        <td>Function</td>
		        <td>Returns square root of a single argument.</td>
		      </tr>
		      <tr>
		        <th>Math.tan(x)</th>
		        <td>Function</td>
		        <td>Returns tangent of a single argument.</td>
		      </tr>
		    </table>
          </div>
	]]></Description>
	</Section>
	 
	<Section>
	    <Heading>Rules Lambda Overview</Heading>
		<Description><![CDATA[
             <div class="h2section" id="Rules Lambda Overview">
			<p>The <b>rulesLib</b> is a global Lambda providing a tiny rule-based
		    forward production engine useful in JavaScript programming. Compiling the
		    javaScript compiler automatically creates the rulesLib. The rulesLib is
		    an important element of the JavaScript runtime environment.</p>
		    <p>The <b>rulesLib</b> is needed by the JavaScript compiler to identify
		    patterns during the code optimization phase of compilation. The JavaScript
		    programmer may also use the rulesLib in applications where a small set of
		    complex list modifying rules are required. The rulesLib is not meant to be
		    applied in applications with a large rule base.</p>
		    <p>The <b>rulesLib</b> creates, maintains, and applies a Dictionary of <b>IF
		    -&gt; THEN</b> list substitution rules for transforming a list and all its
		    sub lists into a new list. Anywhere a sub list matches one of the IF rules,
		    the THEN rule is substituted in place of the original sub list. The Lambda
		    supports wild card substitution rules, indefinite arity pattern matching,
		    forward chaining, user defined recognition functions, user defined
		    substitution functions, and single or multiple pass substitution rule
		    application.</p>
		    <p>The rulesLib can be used for semantic analysis, algebraic reduction,
		    parse tree optimization, theorem proving, and a host of other applications.
		    The Lambda operates with its rule base stored in RAM memory; and, is
		    therefore, not useful for problems requiring huge rule bases.</p>
		    <p>The rulesLib supports a simple rule Language of <b>IF -&gt; THEN</b>
		    list substitution rules for transforming a list and all its sub lists into a
		    new list. The IF - &gt; THEN rules are all entered via the assert function.
		    This Lambda accepts and saves a set of transformation rules in its internal
		    rules dictionary. Each rule is entered, by the programmer, in two parts --
		    an IF form followed by a THEN form.
		    <p>&nbsp;
		    <p>An example might be:</p>
			<blockquote>
		    <pre>(rulesLib.assert '(x + y)  '(addi x y))</pre>
			</blockquote>
		    <p>We may then apply the above rules against an input list as follows:</p>
			<blockquote>
		    <pre>(rulesLib.apply  '(x + y)) <i>...Returns...</i>  '(addi x y)</pre>
			</blockquote>
		    <h3>Constant Rules</h3>
		    <p>The simplest rule form is the constant pattern. Both the IF and the THEN
		    forms are constant patterns, containing no wild cards, or other special
		    characters.<br>
		    An example might be:</p>
		    <pre><b>(rulesLib.assert '(x + y)  '(Add x to y))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '(x + y))</b> <i>...Returns...</i>  <b>'(Add x to y)</b></pre>
		    <p>Whenever an exact match occurs with the IF pattern, the THEN pattern is
		    substituted in the output list.</p>
		    <h3>Wild Cards</h3>
		    <p>This Lambda supports wild card variables to make rule definitions more
		    flexible for the programmer. An example of wild card rule variables is as
		    follows:</p>
		    <pre><b>(rulesLib.assert '($X + $Y)  '(addi $X $Y))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '(m + 10))</b> <i>...Returns...</i>  <b>'(addi m 10)</b></pre>
		    <p>The rules and wild card variables operate on sub lists as well as the
		    whole list as follows:</p>
		    <pre><b>(rulesLib.apply '((m + 10) + 20))</b> <i>...Returns...</i>  <b>'(addi (addi m 10) 20)</b></pre>
		    <h3>Lambda Rules</h3>
		    <p>This Lambda supports named lambda rule definitions which allow more
		    flexible actions to be taken by the programmer during the recognition phase
		    and also during the production phase. Some examples of named lambda rule
		    definitions is as follows:</p>
		    <pre><b>(rulesLib.assert $FOLD:(lambda(op x y) vars:(f) (setq f (getGlobalValue (symbol op))) (f x y)))</b></pre>
		    <pre><b>(rulesLib.assert $NUM:(lambda(x) (if (isNumber x) x)))</b></pre>
		    <pre><b>(rulesLib.assert $OP:(lambda(x) vars:((d #{+ addi - subi * muli / divi})) (if (isMember x d) d[x])))</b></pre>
		    <pre><b>(rulesLib.assert '(&lt;$X=$NUM&gt; &lt;$Y=$OP&gt; &lt;$Z=$NUM&gt;) '(&lt;$FOLD&gt; $Y $X $Z))</b></pre>
		    <pre><b>(rulesLib.assert '($X &lt;$Y=$OP&gt; $Z) '($Y $X $Z))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '(m + 10))</b> <i>...Returns...</i> <b>'(addi m 10)</b></pre>
		    <pre><b>(rulesLib.apply '(5 + 10))</b> <i>...Returns...</i> <b>15</b></pre>
		    <h3>Append Output Rules</h3>
		    <p>Using the built in &lt;$&gt; function in a THEN rule causes the
		    appendList function to be applied to the result as follows:</p>
		    <pre><b>(rulesLib.assert '($X + $Y) '(&lt;$&gt; + $X $Y))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '((5 6 7) + (10 20)))</b> <i>...Returns...</i> <b>'(+ 5 6 7 10 20)</b></pre>
		    <h3>Rule Precedence</h3>
		    <p>This Lambda supports multiple rule definitions up to the limits of
		    available memory. Rules asserted first have precedence over rules asserted
		    later as follows:</p>
		    <pre><b>(rulesLib.assert $OP:(lambda(x)
		
		&nbsp;&nbsp;&nbsp; vars:((d #{+ addi - subi * muli / divi}))
		
		&nbsp;&nbsp;&nbsp; (if (isMember x d) d[x])))</b></pre>
		    <pre><b>(rulesLib.assert '($X &lt;$Y=$OP&gt; $Z) '($Y $X $Z))</b></pre>
		    <pre><b>(rulesLib.assert '(addi $X $X) '(muli $X 2))</b></pre>
		    <pre><b>(rulesLib.assert '(addi $X 0) '$X)</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '(m + m))</b> <i>...Returns...</i> <b>'(addi m m)</b></pre>
		    <h3>Single Pass Mode</h3>
		    <p>This Lambda supports single pass mode, during rule application, as
		    follows:</p>
		    <pre><b>(setq rulesLib.singlePass true)</b></pre>
		    <pre><b>(rulesLib.assert '($X + $Y) '(+ $X  $Y))</b></pre>
		    <pre><b>(rulesLib.assert '(+ $X $X) '(* $X  2))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply '(m + m))</b> <i>...Returns...</i> <b>'(+ m m)</b></pre>
		    <p>The second rule, converting (+ m m) into (* 2 m), was never fired,
		    because the rulesLib was set to single pass mode.</p>
		    <h3>Asterisk Wild Card Rules</h3>
		    <p>This Lambda supports asterisk wild card rules anywhere within lists, as
		    follows:</p>
		    <pre><b>(rulesLib.assert '(min ($X*)) '(&lt;$FN&gt; min $X))</b></pre>
		    <pre><b>(rulesLib.assert '($X* min)   '(&lt;$FN&gt; min $X))</b></pre>
		    <pre><b>(rulesLib.assert $FN:(lambda(fn x) (append (list fn) x)))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply  '(min (2 3)))</b> <i>...Returns...</i> <b>'(min 2 3)</b></pre>
		    <pre><b>(rulesLib.apply  '((2 3 4) min))</b> <i>...Returns...</i> <b>'(min 2 3 4)</b></pre>
		    <h3>Append List Function</h3>
		    <p>The builtin appendList function allows multiple arguments to be append
		    together to form a list. The appendList function is builtin and may be used
		    in any IF-&gt;THEN rule by double quoting the THEN form as follows:</p>
		    <pre><b>(rulesLib.assert '(min ($X $Y)) ''(min $X $Y))</b></pre>
		    <p>We may then apply the above rules against a list as follows:</p>
		    <pre><b>(rulesLib.apply  '(min (2 3) (4 5 6)))</b> <i>...Returns...</i> <b>'(min 2 3 4 5 6)</b></pre>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.apply</Heading>
		<Description><![CDATA[
            <div class="h2section" id="rulesLib.apply">
		    <p class=description>The <b>apply</b> function applies the IF -&gt; THEN rules in the Lambda's
		    rule base to the specified input list. The result of apply is a new list
		    with all of the IF patterns substituted with THEN patterns.</p>
		    <p class=type>Type: Function</p>
		    <p class=syntax>Syntax</p>
		    <pre>(rulesLib.apply  aList)</pre>
		    <p class=arguments>Arguments</p>
		    <hr>
		    <table border="3" cellpadding="2" class=arguments>
			<colgroup><col class=arguments><col class=explanation></colgroup>
		      <tr>
		        <th>Arguments</th>
		        <th>Explanation</th>
		      </tr>
		      <tr>
		        <th>aList</th>
		        <td>An input list to be modified according to
		          the IF -&gt; THEN rules asserted in the rulesLib's rule base.</td>
		      </tr>
		      <tr>
		        <th>RETURN</th>
		        <td>The output list after modification by the
		          IF -&gt; THEN rules asserted in the rulesLib's rule base.</td>
		      </tr>
		    </table>
		    <hr>
		    <p class=whentouse>When To Use</p>
		    <p>The <b>apply</b> function performs the actual forward chaining pattern
		    substitution provided by the rulesLib. Use the apply function when all
		    rules have been asserted, and an input list is ready for pattern
		    substitution.</p>
		    <p class=example>Example</p>
		    <p>An input list will contain algebraic expressions. By asserting a few
		    simple rules, the rulesLib can perform symbolic algebra, reducing the
		    input list to its simplest algebraic form as follows:</p>
		    <table width="100%">
			<colgroup><col width="70%"><col width="30%"></colgroup>
		      <tr>
		        <td>
		          <pre>(setq x (new rulesLib))</pre>
		        </td>
		        <td></td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X + 0) '$X)</pre>
		        </td>
		        <td>;; [0] Adding zero does nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '(0 + $X) '$X)</pre>
		        </td>
		        <td>;; [1] Adding zero does nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X - 0) '$X)</pre>
		        </td>
		        <td>;; [2] Subtracting zero does nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '(0 - $X) '$X)</pre>
		        </td>
		        <td>;; [3] Subtracting zero does nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X * 0) 0)</pre>
		        </td>
		        <td>;; [4] Multiplying by zero destroys.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '(0 * $X) 0)</pre>
		        </td>
		        <td>;; [5] Multiplying by zero destroys.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X / 1) '$X)</pre>
		        </td>
		        <td>;; [6] Dividing by one does nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X / $X) 1)</pre>
		        </td>
		        <td>;; [7] Dividing by itself leaves one.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.assert '($X - $X) 0)</pre>
		        </td>
		        <td>;; [8] Subtracting itself leaves nothing.</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.apply '(x - (x + 0)))</pre>
		        </td>
		        <td>;; Returns&nbsp;&nbsp;&nbsp;&nbsp; 0</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.apply '((x + y) / (x + y)))</pre>
		        </td>
		        <td>;; Returns&nbsp;&nbsp;&nbsp;&nbsp; 1</td>
		      </tr>
		      <tr>
		        <td>
		          <pre>(x.apply '(x - (y + 0)))</pre>
		        </td>
		        <td>;; Returns&nbsp;&nbsp;&nbsp;&nbsp; '(x - y)</td>
		      </tr>
		    </table>
		    <p class=notes>Notes &amp; Hints</p>
		    <p>The <b>apply</b> function performs its substitutions using forward rule
		    chaining:</p>
		    <pre>(x.apply '(x - (x + 0)))</pre>
		    <p><b>First</b>, fires rule [0], the Adding Zero rule, to produce:&nbsp;&nbsp;&nbsp;<b>'(x
		    - x)</b></p>
		    <p><b>Next</b>, fires rule [8], the Subtracting Itself rule, to produce:&nbsp;&nbsp;&nbsp;<b>0</b></p>
		    <p><b>Hint:</b> Setting the rulesLib to verbose mode, will cause a print
		    out of each rule firing as it happens (see the set function for verbose).</p>
          </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.assert</Heading>
		<Description><![CDATA[
                 <div class="h2section" id="rulesLib.assert">
				<h3>Overview</h3>
			    <p>The <b style="mso-bidi-font-weight: normal">assert</b> function enters IF
			    -&gt; THEN rules into the Lambda's rule base. Rules defined first have
			    precedence over rules defined later. The result of <b style="mso-bidi-font-weight: normal">assert</b>
			    is a new IF -&gt; THEN rule has been added to the Lambda's rule base.</p>
			    <h3>Type</h3>
			    <p><b>Function</b></p>
			    <h3>Syntax</h3>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(rulesLib.assert<span style="mso-spacerun: yes">&nbsp;
			    </span>IFform<span style="mso-spacerun: yes">&nbsp; </span>THENform)<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(rulesLib.assert<span style="mso-spacerun: yes">&nbsp;
			    </span>$FUNCName:LAMBDAform)<o:p>
			    </o:p>
			    </b></p>
			    <h3>Arguments</h3>
			    <hr>
			    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
			      <tr>
			        <th align="CENTER" width="20%">Arguments</th>
			        <th align="LEFT" width="80%">Explanation</th>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">IFform<o:p>
			          </o:p>
			          </b></th>
			        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">&nbsp; </span>IF
			          pattern of the rule being defined. A more detailed description of<span style="mso-spacerun: yes">&nbsp;
			          </span>IF rule formats is described in the <b style="mso-bidi-font-weight: normal">Overview</b><b style="mso-bidi-font-weight: normal">
			          </b>section.</td>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">THENform<o:p>
			          </o:p>
			          </b></th>
			        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">&nbsp; </span>THEN
			          pattern of the rule being defined. A more detailed description of<span style="mso-spacerun: yes">&nbsp;
			          </span>THEN rule formats is described in the <b style="mso-bidi-font-weight: normal">Overview</b><b style="mso-bidi-font-weight: normal">
			          </b>section.</td>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%">RETURN</th>
			        <td align="LEFT" width="80%">true or an error message</td>
			      </tr>
			    </table>
			    <hr>
			    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
			      <tr>
			        <th align="CENTER" width="20%">Arguments</th>
			        <th align="LEFT" width="80%">Explanation</th>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">$FUNCName<o:p>
			          </o:p>
			          </b></th>
			        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">&nbsp; </span>$
			          function name of the user function being defined. A more detailed
			          description of<span style="mso-spacerun: yes">&nbsp; </span>$ function
			          name formats is described in the <b style="mso-bidi-font-weight: normal">Overview</b><b style="mso-bidi-font-weight: normal">
			          </b>section.</td>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">LAMBDAform<o:p>
			          </o:p>
			          </b></th>
			        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">&nbsp; </span>Lambda
			          value of the user function being defined. A more detailed description
			          of<span style="mso-spacerun: yes">&nbsp; </span>lambda value formats
			          is described in the <b style="mso-bidi-font-weight: normal">Overview</b><b style="mso-bidi-font-weight: normal">
			          </b>section.</td>
			      </tr>
			      <tr>
			        <th align="CENTER" width="20%">RETURN</th>
			        <td align="LEFT" width="80%">true or an error message</td>
			      </tr>
			    </table>
			    <hr>
			    <h3><u>When To Use</u></h3>
			    <p>The <b style="mso-bidi-font-weight: normal">assert</b> function performs
			    the actual rule definition to the rulesLib. Use the <b style="mso-bidi-font-weight: normal">assert</b>
			    function to define all rules before using the apply function to perform
			    pattern substitution.</p>
			    <h3><u>Example1</u></h3>
			    <p class="MsoBodyText">A simple English-like database query language is
			    developed. By asserting a number of simple rules, the rulesLib can perform
			    natural language database update and query as follows:</p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
			    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Define
			    simple database structures.<span style="mso-tab-count: 1">&nbsp; </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(define Child
			    (new Dictionary:))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Create Child database<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(define
			    Parent (new Dictionary:))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Create Parent database<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(define
			    Gender (new Dictionary:))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Create Gender database<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Define
			    database update and query functions.<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $ADDMOM:(lambda(mom
			    child) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(if
			    (isVoid Child[mom]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Child[mom] (new Vector: 1 child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Child[mom][(length Child[mom])] child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(if
			    (isVoid Parent[mom]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Parent[mom] (new Vector: 1 child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Parent[mom][(length Parent[mom])] child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Gender[mom] 'female)<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">'ok))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $ADDDAD:(lambda(dad
			    child) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(if
			    (isVoid Child[dad]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Child[dad] (new Vector: 1 child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Child[dad][(length Child[dad])] child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(if
			    (isVoid Parent[dad]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Parent[dad] (new Vector: 1 child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 2in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Parent[dad][(length Parent[dad])] child))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(setq
			    Gender[dad] 'male)<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">'ok))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $ASKMOM:(lambda(mom
			    child) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(and
			    (isMember child Child[mom]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>(= Gender[mom] 'female))))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $ASKDAD:(lambda(dad
			    child) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">(and
			    (isMember child Child[dad]) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 1.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>(= Gender[dad] 'male))))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $GETPARENTS:(lambda(child)
			    Parent[child]))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $GETCHILDREN:(lambda(parent)
			    Child[parent]))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $ASKGENDER:(lambda(person
			    gender) (= Gender[person] gender)))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert $IN:lambda(x
			    y) (isMember x y))) <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Define
			    database Boolean logic rules.<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(true and true)<span style="mso-spacerun: yes">&nbsp; </span>true)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical and rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '($X and false)<span style="mso-spacerun: yes">&nbsp; </span>false)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical and rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(false and $X)<span style="mso-spacerun: yes">&nbsp; </span>false)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical and rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(false or false)<span style="mso-spacerun: yes">&nbsp; </span>false)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical or rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '($X or true)<span style="mso-spacerun: yes">&nbsp; </span>true)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical or rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(true or $X)<span style="mso-spacerun: yes">&nbsp; </span>true)<span style="mso-spacerun: yes">&nbsp;
			    </span><span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>;; Logical or rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Is $X one of $Y ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$IN&gt;
			    $X $Y))<span style="mso-spacerun: yes">&nbsp; </span>;; Logical meber of a
			    set rule<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Define
			    database natural language rules.<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '($M is the mother of $C)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$ADDMOM&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$M<span style="mso-spacerun: yes">&nbsp; </span>$C))<span style="mso-spacerun: yes">&nbsp;
			    </span>;; Add mothers to database<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '($D is the father of $C)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$ADDDAD&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$D<span style="mso-spacerun: yes">&nbsp; </span>$C))<span style="mso-spacerun: yes">&nbsp;
			    </span>;; Add fathers to database<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Is $D the father of $C ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$ASKDAD&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$D<span style="mso-spacerun: yes">&nbsp; </span>$C))<span style="mso-spacerun: yes">&nbsp;
			    </span>;; Query Parents database<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Is $M the mother of $C ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$ASKMOM&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$M<span style="mso-spacerun: yes">&nbsp; </span>$C))<span style="mso-spacerun: yes">&nbsp;
			    </span>;; Query Parents database<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Who are the parents of $C ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$GETPARENTS&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$C))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Who are the children of $P ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$GETCHILDREN&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$P))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Is $P $X ?)<span style="mso-spacerun: yes">&nbsp; </span>'(&lt;$ASKGENDER&gt;<span style="mso-spacerun: yes">&nbsp;
			    </span>$P<span style="mso-spacerun: yes">&nbsp; </span>$X))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Use
			    forward rule chaining to define complex logical relationships<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
			    '(Is $G the grandmother of $C ?)<span style="mso-spacerun: yes">&nbsp; </span><o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText" style="MARGIN-LEFT: 0.5in; TEXT-INDENT: 0.5in"><b style="mso-bidi-font-weight: normal">'(($G
			    is one of (Who are the parents of $C)) and (Is $G female ?)))<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Start
			    updating and questioning the database.<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply
			    '(Mary is the mother of John))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>ok <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply
			    '(Sally is the mother of Bill))<span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>ok <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply
			    '(John is the father of Jane))<span style="mso-tab-count: 1">&nbsp; </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>ok <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply
			    '(Jack is the father of John))<span style="mso-tab-count: 1">&nbsp; </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>ok <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(Is
			    Sally female ?))<span style="mso-tab-count: 4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>true<o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(Is
			    Mary the grandmother of Jane ?))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>true <o:p>
			    </o:p>
			    </b></p>
			    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply
			    '(Who are the parents of John ?))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
			    </span>#(Jack<span style="mso-spacerun: yes">&nbsp; </span>Mary) <o:p>
			    </o:p>
			    </b></p>
			    <h3><u>Notes &amp; Hints</u></h3>
			    <p>The English-like imperatives update the database, and the interrogatives
			    query the database. The <b style="mso-bidi-font-weight: normal">assert</b>
			    function for the Grandmother rule assumes the use of forward rule chaining.
			    The <b style="mso-bidi-font-weight: normal">THEN</b> side of the rule is
			    substituted into the list, and forward rule chaining will reduce the
			    resulting complex expression to <b style="mso-bidi-font-weight: normal">true</b>
			    if and only if the original query is true.
                </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.clear</Heading>
		<Description><![CDATA[
           <div class="h2section" id="rulesLib.clear">
			<h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">clear</b> function resets the
		    Lambda. The previously asserted rules are cleared, and the Lambda is made
		    ready for new rule assertions.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b>(clear&nbsp; rulesLib)</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">rulesLib</th>
		        <td align="LEFT" width="80%">The rulesLib which is to be cleared.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">true</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">clear</b> function when
		    the Lambda is to be reset, and a new set of rules are to be asserted.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">Clearing the Lambda resets all of the rules. The Lambda
		    is then ready for new rules to be asserted. In this example, the second
		    apply returns the original input list because all the rules have been erased
		    with the clear function.</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [0] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert '(0
		    + $X) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [1] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X) 0)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [2] Subtracting itself leaves nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(x
		    - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>0 <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(clear x)<span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><span style="mso-tab-count: 3"><b style="mso-bidi-font-weight: normal; mso-tab-count: 3"></b></span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 1">
		    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>true
		    <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(x
		    - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>'(x - (x + 0))</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">clear</b> function resets the
		    current rule base, and allows a new set of rules are to be asserted.</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.length</Heading>
		<Description><![CDATA[
             <div class="h2section" id="rulesLib.length">
			<h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">length</b> function returns
		    the number of rules currently asserted to the Lambda.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b>(length rulesLib)</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The rulesLib whose length is to be
		          determined.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The number of rules currently in the
		          Lambda's rule base.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">length</b> function to
		    determine the number of rules currently asserted to the Lambda.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">The <b style="mso-bidi-font-weight: normal">length</b>
		    function, shown here, returns the number of rules currently in the Lambda's
		    rule base (see the <b style="mso-bidi-font-weight: normal">assert</b>
		    function).</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [0] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert '(0
		    + $X) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [1] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X) 0)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [2] Subtracting itself leaves nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(length x)<span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>3</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">length</b> function returns
		    the number of rules currently asserted to the Lambda.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.new</Heading>
		<Description><![CDATA[
            <div class="h2section" id="rulesLib.new">
			<h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">new</b> function creates a
		    new rulesLib from an existing rulesLib. The newly created rulesLib
		    inherits all of the properties of the original Lambda, is a new individual,
		    and is completely separate from the original Lambda. Rules asserted to the
		    new Lambda do not effect the original Lambda and vice versa.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b>(new<span style="mso-spacerun: yes">&nbsp; </span>rulesLib)</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The original rulesLib to be copied.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">A new individual rulesLib with its own
		          identity.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">new</b> function when a
		    rulesLib is to be created. New creates a genetic copy of the original
		    Lambda, with its own separate existence and its own separate identity. New is
		    usually the first function used in employing a rulesLib.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">Creating a new individual rulesLib is usually the
		    first step in employing a rulesLib to solve a problem. Once created, the
		    new rulesLib may have its own rules asserted, and may be applied to
		    solving pattern matching problems.</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [0] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert '(0
		    + $X) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [1] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X) 0)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [2] Subtracting itself leaves nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(x
		    - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>0</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">new</b> function creates a
		    new rulesLib. New creates a genetic copy of the original Lambda, with its
		    own separate existence and its own separate identity. New is usually the
		    first function used in employing a rulesLib. Each new rulesLib can hold
		    a distinct rule base. Multiple ruleLambdas can be used to manage separate
		    rule bases, such as one rulesLib for precedence rules and a second
		    rulesLib for normal arithmetic rules.</p>
            </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.ref</Heading>
		<Description><![CDATA[
            <div class="h2section" id="rulesLib.ref">
			<h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">ref</b> function allows
		    access to the Lambda's internal structures and memory. The internal
		    structures, which can be accessed, include all of the member functions
		    listed in this chapter, plus a number of important option switches such as: <b style="mso-bidi-font-weight: normal">failureValue</b>;
		    <b style="mso-bidi-font-weight: normal">maxPasses</b>; <b style="mso-bidi-font-weight: normal">singlePass</b>;
		    and <b style="mso-bidi-font-weight: normal">verbose</b>. Any IF -&gt; THEN
		    rule in the Lambda's memory can be accessed with an integer key. The rule is
		    returned as a List containing the IFform followed by the THENform. Finally,
		    any rule in the Lambda's memory can be accessed using its IFform as a key.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b style="mso-bidi-font-weight: normal">(ref<span style="mso-spacerun: yes">&nbsp;
		    </span>rulesLib<span style="mso-spacerun: yes">&nbsp; </span>memberName)<span style="mso-spacerun: yes">&nbsp;
		    </span></b><i style="mso-bidi-font-style: normal">also</i><b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span></b><b style="mso-bidi-font-weight: normal; mso-spacerun: yes">&nbsp;
		    </b><b style="mso-bidi-font-weight: normal">rulesLib.memberName<o:p>
		    </o:p>
		    </b></p>
		    <p><b style="mso-bidi-font-weight: normal">(ref<span style="mso-spacerun: yes">&nbsp;
		    </span>rulesLib<span style="mso-spacerun: yes">&nbsp; </span>integer)<span style="mso-spacerun: yes">&nbsp;
		    </span></b><span style="mso-spacerun: yes"><b style="mso-bidi-font-weight: normal; mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </b></span><i style="mso-bidi-font-style: normal">also</i><b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span></b><b style="mso-bidi-font-weight: normal; mso-spacerun: yes">&nbsp;
		    </b><b style="mso-bidi-font-weight: normal">rulesLib[integer]<o:p>
		    </o:p>
		    </b></p>
		    <p><b style="mso-bidi-font-weight: normal">(ref<span style="mso-spacerun: yes">&nbsp;
		    </span>rulesLib<span style="mso-spacerun: yes">&nbsp; </span>IFform) <span style="mso-spacerun: yes">&nbsp;</span></b><i style="mso-bidi-font-style: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    also</i><b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span></b><b style="mso-bidi-font-weight: normal; mso-spacerun: yes">&nbsp;
		    </b><b style="mso-bidi-font-weight: normal">rulesLib[IFform]<o:p>
		    </o:p>
		    </b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The rulesLib whose internals are to be
		          accessed.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">memberName<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The name of a member in the Lambda's
		          internal structure. These include the member functions listed in this
		          chapter including: <b style="mso-bidi-font-weight: normal">apply</b>, <b style="mso-bidi-font-weight: normal">assert</b>;
		          and the Lambda's internal option switches including: <b style="mso-bidi-font-weight: normal">failureValue</b>,
		          <b style="mso-bidi-font-weight: normal">maxPasses</b>, <b style="mso-bidi-font-weight: normal">singlePass</b>,
		          and <b style="mso-bidi-font-weight: normal">verbose</b>.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The value of the specified internal
		          structure. For member functions, such as <b style="mso-bidi-font-weight: normal">apply</b>
		          and <b style="mso-bidi-font-weight: normal">assert</b>, the internal
		          member function is returned for invocation. For <b style="mso-bidi-font-weight: normal">failureValue</b>,
		          the essoteric symbol used to indicate rule failure is returned. For <b style="mso-bidi-font-weight: normal">maxPasses</b>,
		          the integer value of the maximum allowed number of passes in multiple
		          pass mode is returned.<span style="mso-spacerun: yes">&nbsp; </span>For
		          <b style="mso-bidi-font-weight: normal">singlePass</b>, true indicates
		          single pass mode is on and false otherwise.<span style="mso-spacerun: yes">&nbsp;
		          </span>For <b style="mso-bidi-font-weight: normal">verbose</b>, true
		          indicates verbose mode is on and false otherwise.</td>
		      </tr>
		    </table>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The rulesLib whose internals are to be
		          accessed.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">integer<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The nth rule, in the Lambda's memory, is
		          accessed. The integer must be zero or greater and less then the length
		          of the Lambda (see the <b style="mso-bidi-font-weight: normal">length</b>
		          function).</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The previously asserted rule is returned as
		          a List containing first the IFform followed by the THENform.</td>
		      </tr>
		    </table>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The rulesLib whose internals are to be
		          accessed.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">IFform</th>
		        <td align="LEFT" width="80%">The IFform of a previously asserted rule in
		          the Lambda's memory.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The THENform of a previously asserted rule,
		          in the Lambda's memory, is returned.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">ref</b> function to
		    access the Lambda's internal structures and memory.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">The dot syntactical form of the <b style="mso-bidi-font-weight: normal">ref</b>
		    function is used here to assert and apply rules to the Lambda. Since the
		    member function references are at the head of a List, as soon as they are
		    returned Lisp invokes them. Next the 2<sup>nd</sup> rule is returned, using
		    the indexed access feature of the <b style="mso-bidi-font-weight: normal">ref</b>
		    function. Finally, the THENform of the 1<sup>st</sup> rule is returned using
		    its IFform as a key.</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [0] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert '(0
		    + $X) '$X)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [1] Adding zero does nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X) 0)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>;; [2] Subtracting itself leaves nothing.<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(x
		    - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>0 <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">x[2]<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>'(($X - $X) 0) <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">x['(0 + $X)]<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>'$X <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><i style="mso-bidi-font-style: normal">also</i><b style="mso-bidi-font-weight: normal"><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">((ref x
		    'apply) '(x - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp; </span></b>Returns<span style="mso-tab-count: 2"><b style="mso-bidi-font-weight: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </b><b style="mso-bidi-font-weight: normal; mso-tab-count: 2"></b></span><b style="mso-bidi-font-weight: normal">0
		    <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(ref x 2)<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>'(($X - $X) 0) <o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(ref x '(0 +
		    $X))<span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>'$X</b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p class="MsoBodyText">An often used syntactical shorthand <b style="mso-bidi-font-weight: normal">ref</b>
		    function are the . (dot) operator and the [] operator.<span style="mso-spacerun: yes">&nbsp;</span></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(x
		    - (x + 0)))<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><i style="mso-bidi-font-style: normal">is the same as</i><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>((ref x 'apply) '(x - (x + 0)))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">x[2]<span style="mso-tab-count: 4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><span style="mso-tab-count: 4"><b style="mso-bidi-font-weight: normal; mso-tab-count: 4">&nbsp;
		    </b></span><i style="mso-bidi-font-style: normal">is the same as</i><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>(ref x 2)<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">x['(0 + $X)]<span style="mso-tab-count: 3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><i style="mso-bidi-font-style: normal">is the same as</i><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>(ref x '(0 + $X))</b></p>
		    <p>&nbsp;</p>
           </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.set</Heading>
		<Description><![CDATA[
            <div class="h2section" id="rulesLib.set">
		    <h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">set</b> function allows
		    updates to the Lambda's internal structures and memory. The internal
		    structures, which can be updated, include a number of important option
		    switches such as: <b style="mso-bidi-font-weight: normal">failureValue</b>; <b style="mso-bidi-font-weight: normal">maxPasses</b>;
		    <b style="mso-bidi-font-weight: normal">singlePass</b>; and <b style="mso-bidi-font-weight: normal">verbose</b>.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b>(set<span style="mso-spacerun: yes">&nbsp; </span>rulesLib<span style="mso-spacerun: yes">&nbsp;
		    </span>memberName<span style="mso-spacerun: yes">&nbsp; </span>newValue)</b></p>
		    <p><b style="mso-bidi-font-weight: normal">(setq<span style="mso-spacerun: yes">&nbsp;
		    </span>rulesLib.memberName<span style="mso-spacerun: yes">&nbsp; </span>newValue)<o:p>
		    </o:p>
		    </b></p>
		    <p><b style="mso-bidi-font-weight: normal">(setq<span style="mso-spacerun: yes">&nbsp;
		    </span>rulesLib[memberName:] newValue)<o:p>
		    </o:p>
		    </b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">rulesLib</b></th>
		        <td align="LEFT" width="80%">The Lambda whose internal memory is to be
		          updated.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">memberName</th>
		        <td align="LEFT" width="80%">The name of a member in the Lambda's
		          internal structure. These include the Lambda's internal option
		          switches: <b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;</span>failureValue</b>,
		          <b style="mso-bidi-font-weight: normal">maxPasses</b>, <b style="mso-bidi-font-weight: normal">singlePass</b>,
		          and <b style="mso-bidi-font-weight: normal">verbose</b>.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">newValue<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The new setting for the Lambda's internal
		          structure.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">The new value of the specified internal
		          structure.</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">set</b> function to
		    update the Lambda's internal option switches.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">The dot syntactical form of the <b style="mso-bidi-font-weight: normal">set</b>
		    function is used here to assert and apply rules to the Lambda. Since the
		    member function references are at the head of a List, as soon as they are
		    returned Lisp invokes them.</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0)<span style="mso-spacerun: yes">&nbsp; </span>0)<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X)<span style="mso-spacerun: yes">&nbsp; </span>0)<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Multiple
		    pass mode forward chains until no further substitution is possible<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(m
		    - (m + 0)))</b><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span>0<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">;; Single
		    pass mode halts after the first substitution<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq
		    x.singlePass true)</b><o:p>
		    </o:p>
		    </p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(m
		    - (m + 0)))</b><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span>'(m - m)<o:p>
		    </o:p>
		    </b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p class="MsoBodyText">An often used syntactical shorthand <b style="mso-bidi-font-weight: normal">set</b>
		    function are the . (dot) operator and the [] operator.<span style="mso-spacerun: yes">&nbsp;</span></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq
		    x.verbose true)<span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><span style="mso-tab-count: 2"><b style="mso-bidi-font-weight: normal; mso-tab-count: 2"></b></span><i style="mso-bidi-font-style: normal">is
		    the same as</i><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>(set (ref x 'verbose) true)<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq
		    x[verbose:] false)<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span></b><span style="mso-tab-count: 1"><b style="mso-bidi-font-weight: normal; mso-tab-count: 1"></b></span><i style="mso-bidi-font-style: normal">is
		    the same as</i><b style="mso-bidi-font-weight: normal"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>(set (ref x 'verbose) false)<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal"><span style="COLOR: blue">Note:</span><span style="mso-tab-count: 1">&nbsp;&nbsp;
		    </span></b>See the section on the Lambda Communication Language (ACL) for
		    this Lambda to understand the meaning of the internal option switches: <b style="mso-bidi-font-weight: normal">failureValue</b>,
		    <b style="mso-bidi-font-weight: normal">maxPasses</b>, <b style="mso-bidi-font-weight: normal">singlePass</b>,
		    and <b style="mso-bidi-font-weight: normal">verbose</b>.
             </div>
	    ]]></Description>
	</Section>
	<Section>
	    <Heading>rulesLib.unassert</Heading>
		<Description><![CDATA[
            <div class="h2section" id="rulesLib.unassert">
			<h3>Overview</h3>
		    <p>The <b style="mso-bidi-font-weight: normal">unassert</b> function deletes
		    IF -&gt; THEN rules from the Lambda's rule base. The result of <b style="mso-bidi-font-weight: normal">unassert</b>
		    is a previously asserted IF -&gt; THEN rule is deleted from the Lambda's
		    memory.</p>
		    <h3>Type</h3>
		    <p><b>Function</b></p>
		    <h3>Syntax</h3>
		    <p><b>(rulesLib.unassert<span style="mso-spacerun: yes">&nbsp; </span>IFform)</b></p>
		    <h3>Arguments</h3>
		    <hr>
		    <table border="3" cellpadding="2" width="100%" bgcolor="#99CCCC">
		      <tr>
		        <th align="CENTER" width="20%">Arguments</th>
		        <th align="LEFT" width="80%">Explanation</th>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%"><b style="mso-bidi-font-weight: normal">IFform<o:p>
		          </o:p>
		          </b></th>
		        <td align="LEFT" width="80%">The<span style="mso-spacerun: yes">&nbsp; </span>IF
		          pattern of the rule being deleted. A more detailed description of<span style="mso-spacerun: yes">&nbsp;
		          </span>IF rule formats is described in the <b style="mso-bidi-font-weight: normal">Overview</b><b style="mso-bidi-font-weight: normal">
		          </b>section.</td>
		      </tr>
		      <tr>
		        <th align="CENTER" width="20%">RETURN</th>
		        <td align="LEFT" width="80%">true or an error message</td>
		      </tr>
		    </table>
		    <hr>
		    <h3><u>When To Use</u></h3>
		    <p>Use the <b style="mso-bidi-font-weight: normal">unassert</b> function to
		    delete a previously defined rule from the ruleLambda's rule base.</p>
		    <h3><u>Example1</u></h3>
		    <p class="MsoBodyText">This simple example demonstrates the effect of
		    deleting a rule from the Lambda's memory.</p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(setq x (new
		    rulesLib))<span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span><o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X + 0)<span style="mso-spacerun: yes">&nbsp; </span>0)<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(m
		    - (m + 0)))</b><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span>'(m - m)<u><o:p>
		    </o:p>
		    </u></b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.assert
		    '($X - $X)<span style="mso-spacerun: yes">&nbsp; </span>0)<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(m
		    - (m + 0)))</b><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span>0<o:p>
		    </o:p>
		    </b></p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.unassert<span style="mso-spacerun: yes">&nbsp;
		    </span>'($X - $X))</b><o:p>
		    </o:p>
		    </p>
		    <p class="MsoBodyText"><b style="mso-bidi-font-weight: normal">(x.apply '(m
		    - (m + 0)))</b><span style="mso-spacerun: yes">&nbsp;&nbsp; </span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		    </span>Returns<b style="mso-bidi-font-weight: normal"><span style="mso-spacerun: yes">&nbsp;
		    </span>'(m - m)<u><o:p>
		    </o:p>
		    </u></b></p>
		    <h3><u>Notes &amp; Hints</u></h3>
		    <p>The <b style="mso-bidi-font-weight: normal">unassert</b> function
		    performs rule deletion from the rulesLib. Use the <b style="mso-bidi-font-weight: normal">unassert</b>
		    function to delete a previously defined rule from the Lambda's memory.</p>
            </div>
	    ]]></Description>
	</Section>
	 
</Essay>




;;**EXPORTKEY**:javaScript:%COMPILER_USERFUNCTIONS
;; ********************************************************************
;; summary:  javaScript User defined functions
;;
;; 			 Compile time child Lambdas for the javaScript compiler.
;; 			 These child Lambdas support the javaScript compilation process.
;;
;; Notes:    Requires the browseLib, the ParseLib, and the compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |javaScript:DEFINITION|.
;;
;; ********************************************************************

;;*********************************************************************
;; Function start pushes a new variable dictionary on the stack
;; Note: These persistant variables will extend the java environment
;;*********************************************************************
(defchild javaScript:startRule()
    pvars:(pvarVector           ;; Vector of declared persistant variables.
           cvarVector           ;; Vector of declared class variables. 
           gvarVector           ;; Vector of declared global variables.
           varVector            ;; Vector of declared temporary variables.
           avarVector           ;; Vector of declared argument variables.
           startRuleFilterStmt  ;; Filter statement extended start rule.
           ) ; end of persistant variables
    ;; Initialize the variable vectors.
    (setq gvarVector (new Vector: 1 (new Dictionary:)))
    (setq pvarVector (new Vector: 0))
    (setq cvarVector (new Vector: 0))
    (setq varVector (new Vector: 0))
    (setq avarVector (new Vector: 0))
    ;; Extent this start rule for the Filter statement.
    (startRuleFilterStmt)
    true) ; end startRule

;;*********************************************************************
;; Function start pushes a new variable dictionary on the stack
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:pushVars(struct)
    ;; Create a new variable dictionary for this function.
    (setq pvarVector[(length pvarVector)] (new Dictionary:))
    (setq cvarVector[(length cvarVector)] (new Dictionary:))
    (setq varVector[(length varVector)] (new Dictionary:))
    (setq avarVector[(length avarVector)] (new Dictionary:))
    struct) ; end pushVars

;;*********************************************************************
;; Function end pops the variable dictionary from the stack
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:popVars()
    vars:(result pvarDic cvarDic varDic vecLast varLen i varList)
    ;; Pop the variable dictionaries from the stack.
    (setq vecLast (subi (length pvarVector) 1))
    (setq pvarDic pvarVector[vecLast])
    (setq cvarDic cvarVector[vecLast])
    (setq varDic varVector[vecLast])
    (resize pvarVector vecLast)
    (resize cvarVector vecLast)
    (resize varVector vecLast)
    (resize avarVector vecLast)
    ;; If there are any pvars, append them to the result.
    (if (> (length pvarDic) 0)
        (begin
           (setq result (list (makeQuotedSymbol "pvars")))
           (setq varLen (length pvarDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList pvarDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if pvars
    ;; If there are any cvars, append them to the result.
    (if (> (length cvarDic) 0)
        (begin
           (setq result (list (makeQuotedSymbol "cvars")))
           (setq varLen (length cvarDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList cvarDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if cvars
    ;; If there are any vars, append them to the result.
    (if (> (length varDic) 0)
        (begin
           (setq result (appendList result (list (makeQuotedSymbol "vars"))))
           (setq varLen (length varDic))
           (setq varList #void)
           (loop for i from 0 until varLen do
               (setq varList (appendList varList varDic[i 0]))
               ) ; end loop
           (if (not (isPair varList)) (setq varList (list varList)))
           (setq result (appendList result (list varList)))
           )) ; end if vars
    result) ; end popVars

;;*********************************************************************
;; Add a new variable to the pvars or the vars variable list
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:addVar(var vtype name struct struct2)
    pvars:(addToBeginList)
    vars:(vecLast)
    ;; Add a new variable to the variable dictionary for this function.
    (setq vecLast (subi (length var) 1))
    ;; Manage variable declarations at the global level.
    (if (< vecLast 0)
        (begin
           ;; At the global level, we always substitute the global 
           ;; variable vector (gvarVector) as the variable vector.
           (setq var gvarVector)
           (setq vecLast (subi (length var) 1))
        )) ; end if
    (setq var[vecLast][(symbol name)] vtype)
    (addToBeginList struct struct2.Value)
    struct) ; end addVar

;;*********************************************************************
;; The the variable type of the Name token just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:setVType(token)
    vars:(vecLast)
    ;; Locate a new variable in the variable dictionary for this level.
    (setq vecLast (subi (length varVector) 1))
    ;; If this is a constant, then set its type accordingly.
    (cond
       ;; If the token is an Integer constant, set the type to int.
       ((= token.Integer true)
        (setq token.VType int:))
       ;; If the token is a Number constant, set the type to float.
       ((= token.Number true)
        (setq token.VType float:))
       ;; If the token is a Boolean constant, set the type to bool.
       ((= token.Boolean true)
        (setq token.VType bool:))
       ;; If the token is a Character constant, set the type to char.
       ((= token.Character true)
        (setq token.VType char:))
       ;; If the token is a Name, set the type to char.
       ((= token.Name true)
        (begin
           ;; Set all Name tokens to type obj as a default.
           (setq token.VType obj:)
           ;; If the Name is a registered global, set its type as registered.
           (if (<> gvarVector[0][token.Value] #void) 
               (setq token.VType gvarVector[0][token.Value]))
           ;; If the Name is a registered cvar, set its type as registered.
           (if (<> cvarVector[vecLast][token.Value] #void) 
               (setq token.VType cvarVector[vecLast][token.Value]))
           ;; If the Name is a registered pvar, set its type as registered.
           (if (<> pvarVector[vecLast][token.Value] #void) 
               (setq token.VType pvarVector[vecLast][token.Value]))
           ;; If the Name is a registered var, set its type as registered.
           (if (<> varVector[vecLast][token.Value] #void) 
               (setq token.VType varVector[vecLast][token.Value]))
           ;; If the Name is a registered arg, set its type as registered.
           (if (<> avarVector[vecLast][token.Value] #void) 
               (setq token.VType avarVector[vecLast][token.Value]))
           )) ; end begin
       ;; Otherwise, set the type to obj.
       (else 
        (setq token.VType obj:))
       ) ; end cond
    token) ; end setVType

;;*********************************************************************
;; The the variable type of the binary expression just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:setExpVType(struct token1 optok token2)
    vars:(op resultTyp typ1 typ2)
    ;; Determine the type of both token and the operator.
    (setq typ1 token1.VType)
    (setq typ2 token2.VType)
    (cond
       ;; Is this an Boolean expression?
       ((and (= typ1 bool:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Boolop)
           (setq resultTyp optok.Booltyp)
        )) ; end Boolean expression
       ;; Is this an Character expression?
       ((and (= typ1 char:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Charop)
           (setq resultTyp optok.Chartyp)
        )) ; end Character expression
       ;; Is this an Integer expression?
       ((and (= typ1 int:) (or (= typ2 int:) (= typ2 char:) (= typ2 bool:)))
        (begin
           (setq op optok.Intop)
           (setq resultTyp optok.Inttyp)
        )) ; end Integer expression
       ;; Is this an Number expression?
       ((and (= typ1 float:) (= typ2 float:))
        (begin
           (setq op optok.Floatop)
           (setq resultTyp optok.Floattyp)
        )) ; end Number expression
       ;; Is this any other expression?
       (else
        (begin
           (setq op optok.Lisp)
           (setq resultTyp obj:)
        )) ; end any other expression
       ) ; end cond
    (setq struct.Value (list op token1.Value token2.Value))
    (setq struct.VType resultTyp)
    struct) ; end setExpVType

;;*********************************************************************
;; The the variable type of the precedence expression list just recognized.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:setVTypePrecedence(struct plist)
    regs:(n N)
    vars:(op fop precedence)
    vars:(leftExp rightExp headExp tailExp)
    ;; Manage the different lengths of precedence expressions.
    (setq N (length plist))
    ;; Manage a singleton precedence expression.
    (if (= N 1) (return plist[0]))
    ;; Manage a triple precedence expression.
    (if (= N 3) (return (setExpVType struct plist[0] plist[1] plist[2])))
    ;; Manage a compound precedence expression.
    (setq headExp (list plist[0]))
    (setq tailExp (cdr plist))
    (loop for n from 1 until N by 2 do
      (setq fop tailExp[0])
      (if (> fop.Precedence precedence) 
          (begin
            (setq precedence fop.Precedence)  
            (setq op fop) 
            (setq leftExp headExp) 
            (setq rightExp (cdr tailExp))
          )) ; end if
      (setq headExp (append headExp (list tailExp[0] tailExp[1])))
      (setq tailExp (cddr tailExp))
      ) ; end precedence loop
    (setq leftExp (setVTypePrecedence (new Structure:) leftExp))
    (setq rightExp (setVTypePrecedence (new Structure:) rightExp))
    (setq struct (setExpVType struct leftExp op rightExp))
    struct) ; end setVTypePrecedence

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild javaScript:addToList(struct x) 
    (setq struct.Value (appendList struct.Value x))) ; end addToList

;;*********************************************************************
;; Constructs a function call argument list from an argument vector.
;;*********************************************************************
(defchild javaScript:argList(struct name args)
    ;; Create a function call with or without arguments.
    (if (= args #void) 
        (setq struct.Value (list name))
        (setq struct.Value (append (list name) (objectToList args)))
        ) ; end if
    (setq struct.Term true)
    struct) ; end argList

;;*********************************************************************
;; Constructs a defstruct statement from an argument vector.
;;*********************************************************************
(defchild javaScript:fieldList(struct newType parent args)
    ;; Create a defstruct with or without fields.
    (cond
       ;; Build a defstruct with no parent and no field list.
       ((and (= args #void) (= parent #void)) 
        (setq struct.Value (list defstruct: (makeQuotedSymbol newType))))
       ;; Build a defstruct with no parent and a field list.
       ((and (<> args #void) (= parent #void)) 
        (setq struct.Value (append (list defstruct: (makeQuotedSymbol newType)) (objectToList args))))
       ;; Build a defstruct with a parent and no field list.
       ((and (= args #void) (<> parent #void)) 
        (setq struct.Value (list defstruct: (makeQuotedSymbol newType) ''include parent)))
       ;; Build a defstruct with a parent and a field list.
       ((and (<> args #void) (<> parent #void)) 
        (setq struct.Value (append (list defstruct: (makeQuotedSymbol newType) ''include parent) (objectToList args))))
        ) ; end cond
    struct) ; end fieldList

;;*********************************************************************
;; Constructs a message send argument list from an argument vector.
;;*********************************************************************
(defchild javaScript:sendList(struct method receiver args)
    ;; Return if there are no arguments.
    (if (= args #void) 
        (setq struct.Value (list send: (makeQuotedSymbol method) receiver))
        (setq struct.Value (append (list send: (makeQuotedSymbol method) receiver) (objectToList args)))
        ) ; end if
    (setq struct.Term true)
    struct) ; end sendList

;;*********************************************************************
;; AddToBeginList
;; Note: Avoid using append for repeatedly linking long lists together.
;;       Use the setCdr function, it is much faster. Append was never
;;       meant to be used for long lists repeatedly.
;;*********************************************************************
(defchild javaScript:addToBeginList(struct x)
    ;; Return if there is nothing to append.
    (if (= x #void) (return struct))
    (cond
        ;; Set up begin list header the first time.
        ((= struct.Value #void)
         (begin 
            (setq struct.Value x)
            (setq struct._noBeginList true)
            ))
        ;; Set up begin list header the second time.
        ((= struct._noBeginList true)
         (begin
            ;; Singletons can be ignored because they have no side effects.
            (if (= (isPair struct.Value) false)
                then
                (setq struct.Value x)
                else
                (begin 
                   (setq struct._noBeginList false)
                   (setq struct.Value (list |begin|: struct.Value))
                   (setCdr struct (last struct.Value))
                   (setCdr (cdr struct) (list x))
                   (setCdr struct (last (cdr struct)))
                   ) ; end else
                ) ; end if
            ))
        ;; Append to the begin list the remaining times.
        (else 
         (begin
            (setCdr (cdr struct) (list x))
            (setCdr struct (last (cdr struct)))
            ))
        ) ; end conf
    struct) ; end addToBeginList

;;*********************************************************************
;; Constructs a java child definition from an argument list.
;;*********************************************************************
(defchild javaScript:childList(defname struct parent name args body)
    vars:(varList)
    ;; Retrieve all the declare variables
    (setq varList (popVars))
    ;; Set up |()| if there are no arguments.
    (if (= args.Value #void)
        (setq args (symbol "()"))
        (setq args (objectToList args.Value))
        ) ; end if
    ;; Create the function declaration up to the variables
    (setq struct.Value (list defname (makeQuotedSymbol parent.Value) name.Value args))
    ;; Append the variable declarations (if any)
    (if (<> varList #void)
        (setq struct.Value (appendList struct.Value varList (list body.Value)))
        (setq struct.Value (appendList struct.Value (list body.Value)))
        ) ; end if
    (setq struct.Func true)
    struct) ; end childList

;;*********************************************************************
;; Modified default rule for adding Term attributes to all name tokens.
;;*********************************************************************
(defchild javaScript:defaultTokenRule(token)
    vars:(result tokenLen tokenEnd)
    ;; Is this token a delimited constant?
    (if (isVector token) 
        (begin
           (setq result (new Structure: Value: token[1] token[0] true  Constant: true))
           ;; If this is a String constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] String:) 
               (begin
                  (setq result.Value (mid result.Value 1 (subi (length result.Value) 2)))
                  (setq result.Term true)
                  )) ; end if
           ;; If this is a Symbol constant, make it a Term also and remove the enclosing quotes
           (if (= token[0] Symbol:) 
               (begin
                  (setq result.Value (makeQuotedSymbol (mid result.Value 1 (subi (length result.Value) 2))))
                  (setq result.Term true)
                  )) ; end if
           (return result)
           )) ;; end if delimited constant
    ;; Is this token an integer constant?
    (if (isInteger token) 
        (begin
           (setq result (new Structure: Value: token  Integer: true  Number: true  Term: true))
           (return result)
           )) ;; end if integer constant
    ;; Is this token a numeric constant?
    (if (isNumber token) 
        (begin
           (setq result (new Structure: Value: token  Number: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Is this token a name token?
    (if (isCharName token) 
        (begin
           (setq result (new Structure: Value: token  Name: true  Term: true))
           (return result)
           )) ;; end if numeric constant
    ;; Create a default attributed structure for this token
    (setq result (new Structure: Value: token Default: true))
    result) ;; end defaultTokenRule

;;*********************************************************************
;; Constant Folding Function 
;;*********************************************************************
(defchild javaScript:foldConstants(struct op x y) 
    vars:(f n)
    (setq f (getGlobalValue (symbol op))) 
    (setq n (f x y))
    (if (<> struct #void)
        (begin
           (cond
              ((isInteger n) (setq struct.Integer true))
              ((isBoolean n) (setq struct.Boolean true))
              ((isChar n) (setq struct.Character true))
              ((isNumber n) (setq struct.Number true))
              ) ; end cond
           (setq struct.Value (appendList struct.Value n))
           (setVType struct))
        else
        n)) ; end foldConstants

;;*********************************************************************
;; Constructs a java function definition from an argument list.
;;*********************************************************************
(defchild javaScript:funList(struct name args body)
    vars:(varList)
    ;; Retrieve all the declare variables
    (setq varList (popVars))
    ;; Set up |()| if there are no arguments.
    (if (= args.Value #void)
        (setq args (symbol "()"))
        (setq args (objectToList args.Value))
        ) ; end if
    ;; Create the function declaration up to the variables
    ;; Note: A function name of #void indicates an unnamed lambda
    (if (= name #void)
        (setq struct.Value (list |lambda|: args))
        (setq struct.Value (list |defun|: name.Value args))
        ) ; end if
    ;; Append the variable declarations (if any)
    (if (<> varList #void)
        (setq struct.Value (appendList struct.Value varList (list body.Value)))
        (setq struct.Value (appendList struct.Value (list body.Value)))
        ) ; end if
    (setq struct.Func true)
    struct) ; end funList

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild javaScript:postfix(struct token optok style)
    vars:(op resultTyp inc)
    ;; Determine the type of this operation.
    (cond
       ;; Manage a Boolean operation.
       ((= token.VType bool:)
        (begin
           (setq op optok.Boolop)
           (setq inc 1)
           (setq resultTyp optok.Booltyp)
        )) ; end Boolean operation
       ;; Manage a Character operation.
       ((= token.VType char:)
        (begin
           (setq op optok.Charop)
           (setq inc 1)
           (setq resultTyp optok.Chartyp)
        )) ; end Character operation
       ;; Manage an Integer operation.
       ((= token.VType int:)
        (begin
           (setq op optok.Intop)
           (setq inc 1)
           (setq resultTyp optok.Inttyp)
        )) ; end Integer operation
       ;; Manage a Number operation.
       ((= token.VType float:)
        (begin
           (setq op optok.Floatop)
           (setq inc 1.0)
           (setq resultTyp optok.Floattyp)
        )) ; end Number operation
       ;; Manage all other types.
       (else
        (begin
           (setq op optok.Lisp)
           (setq inc 1)
           (setq resultTyp obj:)
        )) ; end all other types
       ) ; end cond
    (setq struct.VType resultTyp)
    (if (= style false)
        (setq struct.Value (list |setq|: token.Value (list op token.Value inc)))
        else
        (setq struct.Value 
               (list |begin|: 
                   (list |setq|: |_currentResult|: token.Value) 
                   (list |setq|: token.Value (list op token.Value inc))
               _currentResult:))
        ) ; end if
    struct) ; end postfix

;;*********************************************************************
;; Appends iterative results into a single structure 
;;*********************************************************************
(defchild javaScript:qualifyName(struct target index indexExp)
    vars:(refOp setOp)
    (if (= target.VType #void) (setVType target))
    (setq struct.VType tokenDirectory[target.VType].Reftyp)
    ;; Determine the reference operator for this name qualifier.
    (cond
        ;; Manage a single strongly typped index expression.
        ((and (or (= index.VType int:) (= index.VType char:) (= index.VType bool:)) (<> target.VType #void) (<= (length indexExp) 1))
         (begin
	         (setq refOp tokenDirectory[target.VType].Refop)
		     (if (isVector indexExp) 
			     (setq struct.Value (append (list refOp target.Value) (objectToList indexExp)))
			     (setq struct.Value (list refOp target.Value indexExp))
		         ) ; end if
	          (setq struct.Setop tokenDirectory[target.VType].Setop)
         )) ; end strong typped case 
        ;; Any other type of reference uses a generic ref qualfier.
        (else
         (begin
		     (if (isVector indexExp) 
	             (setq struct.Value (append (list |ref|: target.Value) (objectToList indexExp)))
	             (setq struct.Value (list |ref|: target.Value indexExp))
		         ) ; end if
	         (setq struct.Setop |setq|:)
		 )) ; end else case
        ) ; end cond
    (setq struct.Name true)
    (setq struct.Term true)
    (setq struct.NAME true)) ; end qualifyName 
    
;;*********************************************************************
;; Sets up an assignment into a singleton or collection target 
;;*********************************************************************
(defchild javaScript:assignMe(struct op target newValue)
    ;; Compute assignment operator.
    (cond
        ((and (<> target.Setop #void) (<> target.Setop |setq|:) (isPair target.Value)) 
         (begin
            (setq struct.Value (appendList target.Value (list newValue.Value)))
            (setCar struct.Value target.Setop) 
         )) ; end strong typped case
        (else  
         (setq struct.Value (appendList |setq|: target.Value (list newValue.Value)))
         ) ; end else case
       ) ; end cond
    struct) ; end assignMe 
    
;;*********************************************************************
;; Sets up an math assignment into a singleton or collection target 
;;*********************************************************************
(defchild javaScript:assignMath(struct optok target newValue)
    vars:(temp)
    (setq temp (copy struct))
    (setq temp (setExpVType temp target optok newValue))
    (setq struct (assignMe struct optok target temp))
    struct) ; end assignMath 
    
;;*********************************************************************
;; Finds the line number given a character position
;;*********************************************************************
(defchild javaScript:findLineNum(pos)
   vars: (i j l)
   (setq l (length $IN))
   (if (< pos l) (setq l pos))
   (loop for i from 0 until l do
      (if (= $IN[i] 10) (setq j (iadd j 1)))
      ); end loop
   j; return number of linefeeds found
   ); end findLineNum

;; --------------------------------------------------------------------
;; User functions for Filter extensions
;; --------------------------------------------------------------------

;;*********************************************************************
;; Extend the normal javaScript startRule with these initialization
;; functions required for the Filter extensions.
;; Note: This function will run right after the normal startRule.
;;*********************************************************************
(defchild javaScript:startRuleFilterStmt()
    pvars:(autoCheck           ;; The function for generating auto check truncation.
           autoCheckSW         ;; The switch for auto checking on/off.
           autoXReferentSW     ;; The switch for automatic field names to x referents on/off.
           haveSeenDataCmdsSW  ;; The we have seen dataMineLib filter/score commands switch.
           fieldRefs           ;; The dictionary of field name references seen.
           KB                  ;; The rule base for x to y referent conversion.
           OKB                 ;; The rule base for optimizing the final filter Lambda.
           tableCursor         ;; The table cursor for which the filter is to be compiled.
          ) ; end of persistent variables
    ;; Initialize the automatic field names to x referents switch.
    (setq autoXReferentSW false)
    (setq haveSeenDataCmdsSW false)
    ;; Initialize the table cursor.
    (setq tableCursor dataMineLib.currentTable)
    ;; Initialize the variable vectors.
    (setq pvarVector (new Vector: 0))
    (setq varVector (new Vector: 0))
    (setq avarVector (new Vector: 0))
    ;; Initialize the field references Dictionary.
    (setq autoCheckSW true)
    (setq fieldRefs (new Dictionary:))
    ;; Initialize the rulesLib for swapping x and y referents.
    (setq KB (new rulesLib))
    (KB.assert '(ref _x $X) '(ref _y $X))
    (setq KB.singlePass false)
    ;; Initialize the rulesLib for optimizing the final filter Lambda.
    (setq OKB (new rulesLib))
    (OKB.assert '(($X*)) '$X)
    (OKB.assert '(begin $X) '$X)
    ;; ---------------------------------------------------------------
    ;; merge filter statement All commands to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref cursor truncate:) (lambda (_x) $E $P1)) 
                      ((ref cursor truncate:) (lambda (_x) $E $P2)) $B*)                  
                  '(<$> $A (((ref cursor truncate:) (lambda (_x) $E (and $P1 $P2)))) $B))

    (OKB.assert '($A* ((ref cursor truncate:) (let $V (lambda (_x) $E $P1))) 
                      ((ref cursor truncate:) (let $V (lambda (_x) $E $P2))) $B*)                  
                  '(<$> $A (((ref cursor truncate:) (let $V (lambda (_x) $E (and $P1 $P2))))) $B))
    ;; ---------------------------------------------------------------
    ;; merge filter statement All commands with field check at beginning
    ;;                        of sort command to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref cursor truncate:) (lambda (_x) $E1 $P1)) 
                      (begin ((ref cursor truncate:) (lambda (_x) $E $P2)) $B*) $C*)                  
                  '(<$> $A (((ref cursor truncate:) (lambda (_x) $E (and $P1 $P2)))) $B $C))

    (OKB.assert '($A* ((ref cursor truncate:) (let $V (lambda (_x) $E1 $P1))) 
                      (begin ((ref cursor truncate:) (let $V (lambda (_x) $E $P2))) $B*) $C*)                  
                  '(<$> $A (((ref cursor truncate:) (let $V (lambda (_x) $E (and $P1 $P2))))) $B $C))
    ;; ---------------------------------------------------------------
    ;; merge filter statement Omit commands to reduce table passes.
    ;; ---------------------------------------------------------------
    (OKB.assert '($A* ((ref cursor omit:) (lambda (_x) $E $P1)) 
                      ((ref cursor omit:) (lambda (_x) $E $P2)) $B*)                  
                  '(<$> $A (((ref cursor omit:) (lambda (_x) $E (or $P1 $P2)))) $B))

    (OKB.assert '($A* ((ref cursor omit:) (let $V (lambda (_x) $E $P1))) 
                      ((ref cursor omit:) (let $V (lambda (_x) $E $P2))) $B*)                  
                  '(<$> $A (((ref cursor omit:) (let $V (lambda (_x) $E (or $P1 $P2))))) $B))

    ;; ---------------------------------------------------------------
    ;; Turn off all rulesLib assertions so we can use the new compiled semantic rules.
    ;; ---------------------------------------------------------------
    (setq OKB (new rulesLib))

    ;; Initialize the rulesLib for single pass.
    (setq OKB.singlePass false)
    true) ; end startRule

;;*********************************************************************
;; Create a lambda list enclosed in a let expression, which contains
;; definitions of all the locally defined variables.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:letLambda(...)
    vars:(letList lambdaList result i argc varCount vecLast)
    ;; Set up the letList expression with the locally defined variables.
    (setq letList #void)
    (setq vecLast (subi (length varVector) 1))
    ;; If the Name is a registered cvar, then add it to the let lambda list.
    (setq varCount (length cvarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list cvarVector[vecLast][i 0] cvarVector[vecLast][i 0]))))
       ) ; end cvar loop
    ;; If the Name is a registered pvar, then add it to the let lambda list.
    (setq varCount (length pvarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list pvarVector[vecLast][i 0] pvarVector[vecLast][i 0]))))
       ) ; end pvar loop
    ;; If the Name is a registered var, then add it to the let lambda list.
    (setq varCount (length varVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list varVector[vecLast][i 0] varVector[vecLast][i 0]))))
       ) ; end var loop
    ;; If the Name is a registered arg, then add it to the let lambda list.
    (setq varCount (length avarVector[vecLast]))
    (loop for i from 0 until varCount do
       (if (= letList #void) (setq letList (list (list _hdr: 1))))
       (setq letList (append letList (list (list avarVector[vecLast][i 0] avarVector[vecLast][i 0]))))
       ) ; end avar loop
    ;; Add all the arguments to the let lambda list.
    (setq argc (argCount))
    (setq lambdaList (list lambda:))
    (loop for i from 0 until argc do
       (setq lambdaList (append lambdaList (list (argFetch i)))) 
       ) ; end arg loop
    ;; Add the let list and the let lambda list together.
    (if (= letList #void)
        (setq result lambdaList)
        (setq result (list let: letList lambdaList))    
        ) ; end if
    result) ; end letLambda

;;*********************************************************************
;; Run the named current project filter on the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:runFilter(struct filterName)
    vars:(cutLambda errLambda)
    ;; If filter name is void, then return true.
    (if (= filterName #void) (return (setq struct.Value true)))
    ;; Create a call to the specified function.
    (if (isPair filterName) (return (setq struct.Value filterName)))
    ;; Create a call to the runProjectFilter function from the arguments.
    (setq struct.Value (list (list |ref|: (list |ref|: dataMineLib: ''miner) ''runProjectFilter) filterName cursor:))
    (setq autoXReferentSW false)
    struct) ; end runFilter

;;*********************************************************************
;; Create an updateView lambda of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:filterUpdate(struct name setExp resetSW)
    vars:(setLambda errLambda)
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a set lambda from the arguments.
    ;(setq setLambda (letLambda (list _x:) errLambda (list setq: (list |ref|: _x: (makeQuotedSymbol name)) setExp)))
    (setq setLambda (letLambda (list _x:) errLambda (list setq: name setExp)))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= resetSW true)
        then
        (setq struct.Value (list (list |ref|: cursor: ''updateView) setLambda))
        else
        (setq struct.Value (list (list |ref|: cursor: ''updateView) setLambda ''noreset))
        ) ; end if
    (setq autoXReferentSW false)
    (setq fieldRefs (new Dictionary:))
    struct) ; end filterUpdate

;;*********************************************************************
;; Create a find cut of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:fieldCut(struct cutExp command)
    vars:(cutLambda errLambda)
    ;; If cut expression is void, then return true.
    (if (= cutExp #void) (return (setq struct.Value true)))
    ;; If the command is to omit, then turn auto checking off.
    (if (= command "omit") (setq autoCheckSW false))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a cut lambda from the arguments.
    (setq cutLambda (letLambda (list _x:) errLambda cutExp))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= command "omit")
        (setq struct.Value (list (list |ref|: cursor: ''omit) cutLambda))
        (setq struct.Value (list (list |ref|: cursor: ''truncate) cutLambda))
        ) ; end if
    (setq autoXReferentSW false)
    struct) ; end fieldCut

;;*********************************************************************
;; Create a find cut of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:filterCut(struct cutExp command)
    vars:(cutLambda errLambda)
    ;; If cut expression is void, then return true.
    (if (= cutExp #void) (return (setq struct.Value true)))
    ;; If the command is to omit, then turn auto checking off.
    (if (= command "omit") (setq autoCheckSW false))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a cut lambda from the arguments.
    (setq cutLambda (letLambda (list _x:) errLambda cutExp))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Use the command to create the proper truncate call for the cut lambda.
    (if (= command "omit")
        (addToBeginList struct (list (list |ref|: cursor: ''omit) cutLambda))
        (addToBeginList struct (list (list |ref|: cursor: ''truncate) cutLambda))
        ) ; end if
    (setq autoXReferentSW false)
    struct) ; end filterCut

;;*********************************************************************
;; Create a sort followed by a tile of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:sliceCut(struct relOp fieldExp tileIndexExp tileCountExp)
    vars:(yReferent sortLambda errLambda)
    ;; Create a y referent version of the field expression.
    (setq yReferent (KB.apply (copy fieldExp)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a sort lambda from the arguments.
    (setq sortLambda (letLambda (list _x: _y:) errLambda (list relOp fieldExp yReferent)))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create sort and tile commands from the various lambdas.
    (addToBeginList struct (list (list |ref|: cursor: ''sort) sortLambda))
    (addToBeginList struct (list (list |ref|: cursor: ''tile) tileCountExp tileIndexExp))
    (setq autoXReferentSW false)
    struct) ; end sortCut

;;*********************************************************************
;; Create a sort followed by a cut of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:sortCut(struct relOp fieldExp cutExp)
    vars:(yReferent sortLambda errLambda)
    ;; Create a y referent version of the field expression.
    (setq yReferent (KB.apply (copy fieldExp)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a sort lambda from the arguments.
    (setq sortLambda (letLambda (list _x: _y:) errLambda (list relOp fieldExp yReferent)))
    ;; Create a truncate lambda to eliminate any void fields.
    (addToBeginList struct (autoCheck))
    ;; Create sort and cut commands from the various lambdas.
    (if (< cutExp -1)
        (addToBeginList struct (list (list |ref|: cursor: ''sort) sortLambda ''backup))
        (addToBeginList struct (list (list |ref|: cursor: ''sort) sortLambda))
        ) ; end if
    (cond
        ;; Create cut command for integer cuts
        ((>= cutExp 1) (addToBeginList struct (list (list |ref|: cursor: ''truncate) cutExp)))
        ;; Create cut command for percent cuts
        ((>= cutExp 0) (addToBeginList struct 
                           (list (list |ref|: cursor: ''truncate) 
                                 (list integer: 
                                       (list *: (list |ref|: cursor: ''recordCount) cutExp)))))
        ;; Do not create a cut command for negative cuts
        ) ; end cond
    (setq autoXReferentSW false)
    struct) ; end sortCut

;;*********************************************************************
;; Set automatic field name to x referent conversion on. 
;;*********************************************************************
(defchild javaScript:xReferentOn() (setq haveSeenDataCmdsSW (setq autoXReferentSW true)))

;;*********************************************************************
;; Set automatic field name to x referent conversion off. 
;;*********************************************************************
(defchild javaScript:xReferentOff() (setq autoXReferentSW false) (setq haveSeenDataCmdsSW true))

;;*********************************************************************
;; Create an x referent expression from a record field name. 
;;*********************************************************************
(defchild javaScript:xReferent(struct nameStruct)
    vars:(vname fieldNameSW vecLast)
    ;; Determine whether or not the variable is 
    ;; a field name, or a registered variable name.
    (setq vname nameStruct.Value) 
    (setq fieldNameSW true)
    (setq vecLast (subi (length varVector) 1))
    (if (<> gvarVector[0][vname] #void) (setq fieldNameSW false))
    ;; If the Name is a registered cvar, then this is not a field name.
    (if (<> cvarVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered pvar, then this is not a field name.
    (if (<> pvarVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered var, then this is not a field name.
    (if (<> varVector[vecLast][vname] #void) (setq fieldNameSW false)) 
    ;; If the Name is a registered arg, then this is not a field name.
    (if (<> avarVector[vecLast][vname] #void) (setq fieldNameSW false))
    ;; Check to see if the name is a column name of the table being filtered.
    ;; Note: If no tableCursor is present, then any Name (inside a filter statement)
    ;;       is considered to be a field name.
    (if (and (and autoXReferentSW fieldNameSW (<> vname void:) (<> vname nil:))
             (or (= tableCursor #void) (isMember vname tableCursor.colVector)))
        then
        (begin
           ;; If a column name, then record the field in the field references dictionary.
           (setq fieldRefs[vname] true)
           ;; If a column name, then return an x reference to the record.
           (setq struct.Value (list ref: _x: (makeQuotedSymbol vname))))
        else
        (begin
           ;; If not column name, then delete the name from the field references dictionary.
           (setq fieldRefs[vname] #void)
           ;; If not a column name, then return the name as entered.
           (setq struct.Value vname))
        ) ; end if
    (setq struct[Charpos:] nameStruct.Charpos)) ; end xReferent

;;*********************************************************************
;; Test to see if the expression is a record field name. 
;;*********************************************************************
(defchild javaScript:isFieldName(struct nameStruct)
    vars:(xRef)
    ;; Check to see if the name is a column name of the table being filtered.
    ;; Note: If no tableCursor is present, then any Name (inside a filter statement)
    ;;       is considered to be a field name.
    (if (and autoXReferentSW 
             (or (= tableCursor #void) (isMember nameStruct.Value tableCursor.colVector)))
        then
        (begin
           ;; If a column name, then record the field in the field references dictionary.
           (setq fieldRefs[nameStruct.Value] true)
           ;; If a column name, then return an x reference to the record.
           (setq xRef (list |<>|: (list ref: _x: (makeQuotedSymbol nameStruct.Value)) #void))
           ;; Are there previous field references recorded?
           (if (<> struct.Value #void)
               then
               (setq struct.Value (list and: struct.Value xRef))
               else
               (setq struct.Value xRef)
               ) ; end if
           ;; Return true so the recognition step will continue
           (return true))
        ) ; end if
    false) ; end isFieldName

;;*********************************************************************
;; Add an automatic Check command for all record field names seen. 
;;*********************************************************************
(defchild javaScript:autoCheck()
    vars:(i checkExp xRef result)
    ;; Set automatic field name to x referent conversion off.
    (setq autoXReferentSW false)
    ;; If auto checking is off, then just return true.
    (if (= autoCheckSW false) (return true))
    ;; Build the auto check command for all referenced fields.
    (loop for i from 0 until (length fieldRefs) do
        ;; Return an x reference to the record field name.
        (setq xRef (list |<>|: (list ref: _x: (makeQuotedSymbol fieldRefs[i 0])) #void))
        ;; Are there previous field references recorded?
        (if (= checkExp #void)
            then
            (setq checkExp xRef)
            else
            (setq checkExp (list and: checkExp xRef))
            ) ; end if
        ) ; end loop
    ;; Create a truncate expression.
    (setq result (fieldCut (new Structure:) checkExp "all"))
    (setq fieldRefs (new Dictionary:))
    result.Value) ; end autoCheck

;;*********************************************************************
;; Turn off automatic Checking for all record field names seen. 
;;*********************************************************************
(defchild javaScript:autoCheckOff(struct)
    ;; Turn off auto checking.
    (setq autoCheckSW false)
    (setq fieldRefs (new Dictionary:))
    (setq struct.Value true)) ; end autoCheckOff

;;*********************************************************************
;; Turn on automatic Checking for all record field names seen. 
;;*********************************************************************
(defchild javaScript:autoCheckOn(struct)
    ;; Turn on auto checking.
    (setq autoCheckSW true)
    (setq fieldRefs (new Dictionary:))
    (setq struct.Value true)) ; end autoCheckOn

;;*********************************************************************
;; Create a final filter expression on the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:filterFinal(filterExp)
    vars:(result)
    ;; Do nothing, if we've never seen a dataMineLib filter command.
    (if (<> haveSeenDataCmdsSW true) (return filterExp))
    ;; We must add a lambda wrapper if we are stand alone or global.
    (if (<= (length pvarVector) 0)
        then
        ;; If we are stand alone or global, add a lambda wrapper.
        (setq result (list lambda: (list cursor:) filterExp cursor:))
        else
        ;; If we are inside an existing function, add a begin wrapper.
        (setq result (list (symbol "begin") filterExp))
        ) ;; end if
    (setq fieldRefs (new Dictionary:))
    (setq result (OKB.apply (copy result)))
    (setq autoXReferentSW false)
    (if (= result '(begin true #void)) (setq result (list )))
    (if (= result '(lambda (cursor) true #void cursor)) (setq result (list )))
    result) ; end filterFinal

;;*********************************************************************
;; Create a score cut of the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:scoreCut(struct scoreExp command)
    vars:(scoreLambda errLambda)
    ;; If score expression is void, then return zero.
    (if (= scoreExp #void) (return (setq struct.Value 0)))
    ;; Create an on error lambda from the arguments.
    (setq errLambda (list onError: (list lambda: (list s:) false)))
    ;; Create a score lambda from the arguments.
    (setq scoreLambda (letLambda (list _x:) errLambda scoreExp))
    ;; Create a score command from the various lambda.
    (setq struct.Value (list (list |ref|: cursor: (makeQuotedSymbol command)) scoreLambda))
    (setq autoXReferentSW false)
    struct) ; end scoreCut

;;*********************************************************************
;; Create a final score expression on the current result cursor.
;; Note: We use the persistant variables from startRule
;;*********************************************************************
(defchild javaScript:scoreFinal(scoreExp)
    vars:(result)
    ;; Do nothing, if we've never seen a dataMineLib score command.
    (if (<> haveSeenDataCmdsSW true) (return scoreExp))
    ;; We must add a lambda wrapper if we are stand alone or global.
    (if (<= (length pvarVector) 0)
        then
        ;; If we are stand alone or global, add a lambda wrapper.
        (setq result (list lambda: (list cursor:) scoreExp))
        else
        ;; If we are inside an existing function, add a begin wrapper.
        (setq result (list (symbol "begin") scoreExp))
        ) ;; end if
    (setq fieldRefs (new Dictionary:))
    (setq result (OKB.apply (copy result)))
    result) ; end scoreFinal






;;**EXPORTKEY**:javaScript:%DEFINITION
;#text#
;; ********************************************************************
;; summary:  This JavaScript compiler definition includes all the features
;;           of a full JavaScript compiler for the LambdaBase engine.
;;           See the following references:
;;
;;           [1]  "SmartBase/LambdaServer JavaScript compiler", Korns Associates
;;           [2]  "JavaScript For The World Wide Web", Postscript Press
;;           [3]  "JavaScript Developer's Resource", Prentice Hall
;;
;; Notes:    Requires the browseLib, the ParseLib, and this compiler
;;           definition source must be checked into the file cabinet 
;;           under the key: |javaScript:DEFINITION|.
;; Parms:    none
;; return:   java   The ParseLib checks in a newly updated copy of the
;;                  java compiler source and compiles the "javaScript" compiler.
;; ********************************************************************
   
#LexicalRules#

 MAIN: user ordering :: true ::    
 MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>    
 MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>    
 MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>    
 MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>    
 MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>    
 MAIN: Digit+ Period Digit* Exponent Sign Digit+ 
                                  << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>    
 MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>    
 MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>    
 MAIN: Period Digit+    << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>    
 MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*  * / << true >>    
 MAIN: / / NotEol* Eol? << true >>    
 MAIN: "=" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "+" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "-" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "/" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "*" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "%" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "!" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "&" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "|" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "<" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: ">" "="   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "&" "&"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "|" "|"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "-" "-"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "+" "+"   << ($OUT $ch (string (append $1 $2)) Operator: true) >>    
 MAIN: "="       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "+"       << ($OUT $ch (string $1) Operator: true Sign: true) >>    
 MAIN: "-"       << ($OUT $ch (string $1) Operator: true Sign: true) >>    
 MAIN: "/"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "*"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "%"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "!"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "&"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "|"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "<"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: ">"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: "~"       << ($OUT $ch (string $1) Operator: true) >>    
 MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>    
 MAIN: # < NameStart NameChar* Whitespace*  Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>    
 MAIN: Whitespace+      << true >>    
 MAIN: Any              << ($OUT $ch (symbol (string $1)) Default: true) >>    
 MAIN: Eof :: $LIST ::

#End#

#LexicalFeatures#

Digit: [|"0"-"9"|]
Alpha: [|a-z| |A-Z|]
AlphaNum: [|a-z| |A-Z| |"0"-"9"|]
NameChar: [|a-z| |A-Z| |"0"-"9"| "_"]
Letter: [|a-z| |A-Z|]  
NameStart: [|a-z| |A-Z| "_"]  
Operator: [< > = & % ! ^ "~" + / * - "|" "#"]
DQuote: [34]
NotDQuote: [|0-255| ~ 34]
Quote: [39]
NotQuote: [|0-255| ~ 39]
Whitespace: [|0-32|]
Eol: [10 13]
NotEol: [|0-255| ~ 10 13]
Period: ["."]
Exponent: [e E]
Sign: [+ -]

#End#

#SyntaxRules#

  MAIN: user ordering :: true ::
  MAIN: # "javaScript" # || (= $3.Charpos 11) || << true >>
  MAIN: # "dataMineLib" # || (= $3.Charpos 14) || << true >>
  MAIN: STMTLIST Eof :: (list $1.Value) ::
  MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::
  MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::
  MAIN: Eof :: (list #void) ::

  ;; ********************************************************************
  ;; Start rules for compiling javaFilter extensions.
  ;; ********************************************************************
  FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>
  FSTMTLIST: Semicolon << $0 >>

  FSTATEMENT: user ordering :: true ::
  FSTATEMENT: Sort{(xReferentOn)} Backup Direction SEXPRESSION :: (sortCut $0 $3.Lisp $4.Value -2) ::
  FSTATEMENT: Sort{(xReferentOn)} Backup SEXPRESSION :: (sortCut $0 |<=|: $3.Value -2) ::
  FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::
  FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::
  FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::
  FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::
  FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::
  FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
  FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::
  FSTATEMENT: Setnr{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value false) ::
  FSTATEMENT: Setnr{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value false) ::
  FSTATEMENT: Set{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value true) ::
  FSTATEMENT: Set{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value true) ::
  FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::
  FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: cursor: ''restore))) ::
  FSTATEMENT: Omit{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
  FSTATEMENT: Check{(begin (xReferentOn) (autoCheckOn $0) true)} NAMELIST :: (setq $0.Value (autoCheck)) ::
  FSTATEMENT: Checkoff{(xReferentOn)} :: (autoCheckOff $0) ::
  FSTATEMENT: Checkon{(xReferentOn)} :: (autoCheckOn $0) ::

  CUT: user ordering :: true ::
  CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::
  CUT: Number :: $1 ::
  CUT: SEXPRESSION :: $1 ::

  NAMELIST: Name{(isFieldName $0 $1)} << $0 >>
  NAMELIST: Nop :: $0 ::

  FILTER: Filter FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::
  FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::
 
  STATEMENT: FILTER :: $1 ::

  SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::
  SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::

  SCORE: user ordering :: true ::
  SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::
  SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::
  SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::
  SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::

  STATEMENT: SCORE :: $1 ::
  ;; ********************************************************************
  ;; End rules for compiling javaFilter extensions.
  ;; ********************************************************************

  STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>
  STMTLIST: Semicolon << $0 >>

  SEXPRESSION: user ordering :: true ::
  SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION 
               :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::
  SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::
  SEXPRESSION: EXPRESSION :: $1 ::

  PEXPRESSION: user ordering :: true ::
  PEXPRESSION: TERM Operator PEXPRESSION :: (setq $0.Value (append (list $1 $2) $3.Value)) ::
  PEXPRESSION: TERM  :: (setq $0.Value (list $1)) ::

  EXPRESSION: user ordering :: true ::

  EXPRESSION: PHRASE Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::
  EXPRESSION: PHRASE Operator 
               :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::
  EXPRESSION: PHRASE  :: $1 ::

  EXPRESSION: TERM Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::
  EXPRESSION: TERM Operator 
               :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::
  EXPRESSION: TERM :: $1 ::

  EXPRESSION: STATEMENT :: $1 ::
  EXPRESSION: STATEMENT Operator SEXPRESSION :: (setExpVType $0 $1 $2 $3) ::

  STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::
  STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::
  STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::
  STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::
  STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::
  STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::
  STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::
  STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::
  STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::
  STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::
  STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace 
                    :: (childList |deforphan|: $0 $2 $3 $5 $7) ::
  STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::
  STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::
  STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace 
                    :: (childList |defmethod|: $0 $2 $3 $5 $7) ::
  STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value 
                    :: (_makeError "JS 112" $7.Charpos "Invalid statement")::
  STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::
  STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::
  STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::
  STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::

  FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  FRIEND:   Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  ORPHAN:   Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  METHOD:   Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  CHILD:    Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
  CLASS:    Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::


  QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
  QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
  QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::
  QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::
  QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::
  QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::

  CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
  CFCALL: DotOperator Reserved LeftParen 
               :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
  CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
  CFCALL: DotOperator Name LeftParen 
               :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
  CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
  
    ;; ********************************************************************
  ;; Start rules for compiling javaFilter extensions.
  ;; ********************************************************************
  NAME: user ordering :: true ::
  NAME: Name{(isFieldName $0 $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::
  NAME: Name{(isFieldName $0 $1)} :: (xReferent $0 $1) ::
  ;; ********************************************************************
  ;; End rules for compiling javaFilter extensions.
  ;; ********************************************************************

  NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::
  NAME: Name :: (setVType $1) ::

  PHRASE: user ordering :: true ::
  PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
  PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::
  PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::
  PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::
  PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::
  PHRASE: If SEXPRESSION SEXPRESSION Else 
          :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::
  PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::
  PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::
  PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::
  PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::
  PHRASE: While  
          :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::
  PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION
             :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::
  PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::
  PHRASE: Var VAR(varVector setq:) :: $2 ::
  PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::
  PHRASE: Pvar VAR(pvarVector define:) :: $2 ::
  PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::
  PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::
  PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::
  PHRASE: Name CFCALL($1) :: $2 ::
  PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::
  PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) :: 
  PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) :: 
  PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::
  PHRASE: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::

  TERM: user ordering :: true ::
  TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::
  TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
  TERM: + Term :: (setVType $2) ::
  TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::
  TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
  TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::
  TERM: LeftParen SEXPRESSION RightParen :: $2 ::
  TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::
  TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
  TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::
  TERM: Increment NAME :: (postfix $0 $2 $1 false) ::
  TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::
  TERM: Name CFCALL($1) :: $2 ::
  TERM: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
  TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::
  TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::
  TERM: NAME Increment :: (postfix $0 $1 $2 true) ::
  TERM: NAME :: $1 ::
  TERM: Term :: (setVType $1) ::

  VAR: user ordering :: true ::
  VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1)
         :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::
  VAR: Type Name InitializeOperator SEXPRESSION Comma
         :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::
  VAR: Type Name InitializeOperator SEXPRESSION 
         :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::
  VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::
  VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::
  VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::
  VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1)
         :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::
  VAR: Name InitializeOperator SEXPRESSION Comma
         :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::
  VAR: Name InitializeOperator SEXPRESSION 
         :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::
  VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::
  VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::
  VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::
  VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::

  ARGLIST: RightParen :: (setq $0.Value #void) ::
  ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::

  PARMLIST: RightParen :: (setq $0.Value #void) ::
  PARMLIST: Type Name RightParen 
               :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::
  PARMLIST: Type Name Comma PARMLIST 
               :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::
  PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::
  PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::
  PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::

  REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::
  REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::

  FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::
  FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
  FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
  FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::

#End# 

#SemanticPasses#

  MAIN true

#End#

#SemanticRules#

  MAIN| user ordering :: true ::
  MAIN| [ Any ] ] :: $2 ::  
  MAIN| [ Any* ] ] :: (objectToList $2) ::  
  MAIN| "begin" Any ] :: $2 ::
  
  ;; ---------------------------------------------------------------
  ;; merge filter statement All commands with field check at beginning
  ;;                        of sort command to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" TRUNCATE [ "begin" TRUNCATE $SORT $TRUNCATE ] ] 
                                    :: (list (symbol "begin")
                                          (list 
                                             '(ref cursor truncate:) 
                                             (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $5)))
                                          $6 $7) 
                                    ::  
  MAIN| "begin" LETTRUNCATE [ "begin" LETTRUNCATE $SORT $TRUNCATE ] ] 
                                    :: (list (symbol "begin")
                                          (list 
                                             '(ref cursor truncate:) 
                                             (list (symbol "let") (ref $2 0)
                                                (list lambda: '(_x) '(onError (lambda(s) false)) 
                                                                     (list and: (ref $2 1) (ref $5 1))))) 
                                          $6 $7) 
                                    ::  

  ;; ---------------------------------------------------------------
  ;; merge filter statement All commands to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" TRUNCATE TRUNCATE ] :: (list 
                                          '(ref cursor truncate:) 
                                          (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $3))) 
                                    ::  
  MAIN| "begin" LETTRUNCATE LETTRUNCATE ] 
                                    :: (list 
                                          '(ref cursor truncate:)
                                          (list (symbol "let") (ref $2 0)
                                             (list lambda: '(_x) '(onError (lambda(s) false)) 
                                                                  (list and: (ref $2 1) (ref $3 1))))) 
                                    ::  
  ;; ---------------------------------------------------------------
  ;; merge filter statement Omit commands to reduce table passes.
  ;; ---------------------------------------------------------------
  MAIN| "begin" OMIT OMIT ]         :: (list 
                                          '(ref cursor omit) 
                                          (list lambda: '(_x) '(onError (lambda(s) false)) (list or: $2 $3))) 
                                    ::  
  MAIN| "begin" LETOMIT LETOMIT ] 
                                    :: (list 
                                          '(ref cursor omit)
                                          (list (symbol "let") (ref $2 0)
                                             (list lambda: '(_x) '(onError (lambda(s) false)) 
                                                                  (list or: (ref $2 1) (ref $3 1))))) 
                                    ::  

  TRUNCATE| [ REFTRUNCATE LAMBDA ] :: $3 ::  

  LETTRUNCATE| [ REFTRUNCATE LET ] :: $3 ::  

  LETOMIT| [ REFOMIT LET ] :: $3 ::  

  REFTRUNCATE| [ "ref" "cursor" "truncate" ] :: (list $2 $3 $4) ::  

  OMIT| [ REFOMIT LAMBDA ] :: $3 ::  

  REFOMIT| [ "ref" "cursor" "omit" ] :: (list $2 $3 $4) ::  

  LAMBDA| [ "lambda" [ "_x" ] $E $P ]:: $7 ::  

  LET| [ "let" $V LAMBDA ] :: (new Vector: 2 $3 $4) ::  

#End#


#DelimitedStrings#
  String: {"} {"}
  Symbol: {'} {'}
  Whitespace: {/*} {*/}
  Whitespace2: {//} _eol
#End#


#SyntaxFeatures#

  Operator: [+ - * / % "&&" "||" "#"]
  Lisp:     [+ - * / % "&&" "||" "#"] [+ - * / mod and or pdiv]
  Charop:   [+ - * / % "&&" "||" ] [cadd csub cmul cdiv cmod and or]
  Chartyp:  [+ - * / % "&&" "||" ] [char char char char char bool bool]
  Boolop:   [+ - * / % "&&" "||" ] [badd bsub bmul bdiv bmod and or]
  Booltyp:  [+ - * / % "&&" "||" ] [bool bool bool bool bool bool bool]
  Intop:    [+ - * / % "&&" "||" ] [iadd isub imul idiv imod and or]
  Inttyp:   [+ - * / % "&&" "||" ] [int int int int int bool bool]
  Floatop:  [+ - * / % "&&" "||" ] [nadd nsub nmul ndiv nmod and or]
  Floattyp: [+ - * / % "&&" "||" ] [float float float float float bool bool]
  Operator: [== < <= > >= !=]
  Lisp:     [== < <= > >= !=] [= < <= > >= <>]
  Boolop:   [== < <= > >= !=] [bcompareEQ bcompareLT bcompareLE bcompareGT bcompareGE bcompareNE]
  Booltyp:  [== < <= > >= !=] [bool bool bool bool bool bool bool]
  Charop:   [== < <= > >= !=] [ccompareEQ ccompareLT ccompareLE ccompareGT ccompareGE ccompareNE]
  Chartyp:  [== < <= > >= !=] [bool bool bool bool bool bool bool]
  Intop:    [== < <= > >= !=] [icompareEQ icompareLT icompareLE icompareGT icompareGE icompareNE]
  Inttyp:   [== < <= > >= !=] [bool bool bool bool bool bool bool]
  Floatop:  [== < <= > >= !=] [ncompareEQ ncompareLT ncompareLE ncompareGT ncompareGE ncompareNE]
  Floattyp: [== < <= > >= !=] [bool bool bool bool bool bool bool]
  MathAssignmentOperator: [+= -= /= *= "%="]
  Lisp:     [+= -= /= *= %=] [+ - / * mod]
  Charop:   [+= -= /= *= %=] [cadd csub cmul cdiv cmod]
  Chartyp:  [+= -= /= *= %=] [char char char char char]
  Boolop:   [+= -= /= *= %=] [badd bsub bmul bdiv bmod]
  Booltyp:  [+= -= /= *= %=] [bool bool bool bool bool]
  Intop:    [+= -= /= *= %=] [iadd isub imul idiv imod]
  Inttyp:   [+= -= /= *= %=] [int int int int int int]
  Floatop:  [+= -= /= *= %=] [nadd nsub nmul ndiv nmod]
  Floattyp: [+= -= /= *= %=] [float float float float float]
  AssignmentOperator: [=]
  Lisp:               [=] [setq]
  InitializeOperator: [=]
  RelationOperator: [== < <= > >= !=]
  Boolean: [true false] [true false]
  Term: [true false]
  Increment: [++ --]
  Lisp:     [++ --] [+ -]
  Boolop:   [++ --] [badd bsub]
  Booltyp:  [++ --] [bool bool]
  Charop:   [++ --] [cadd csub]
  Chartyp:  [++ --] [char char]
  Intop:    [++ --] [iadd isub]
  Inttyp:   [++ --] [int int]
  Floatop:  [++ --] [nadd nsub]
  Floattyp: [++ --] [float float]
  Logical: [!]
  Lisp: [!] [not]

  ; Operator precedence
  Precedence:		[ *  /  %  +  -  <   <=  >   >=  == !=  "&&"  "||" ]
					[ 2  1  1  3  4  5   5   5   5   6  6   7     8    ]

  For: [for]
  Function: [function]
  Friend: [friend]
  Class: [class]
  Extends: [extends]
  Child: [child]
  Orphan: [orphan]
  Method: [method]
  If: [if]
  Name: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat]
  Of: [of]
  Type: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat]
  Reftyp: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [int float char bool obj char char char obj obj obj obj int char float int float obj int obj float]
  Refop: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [ref ref ref ref ref reftext refSymbol refString ref ref ref refVector refBitVector refBytVector refNumVector refIntVector refFltVector refObjVector refPcdVector ref ref]
  Setop: [int float char bool obj text symbol string stc dir dic vec bitvec bytvec numvec intvec fltvec objvec pcdvec matrix nummat] [setq setq setq setq setq setq setq setString setq setq setq setVector setBitVector setBytVector setNumVector setIntVector setFltVector setObjVector setPcdVector setq setq]
  While: [while]
  Else: [else]
  Var: [var]
  Pvar: [pvar]
  Cvar: [cvar]
  Semicolon: [";"]
  Colon: [":"]
  Question: ["?"]
  LeftParen: ["("]
  RightParen: [")"]
  LeftBrace: ["{"]
  RightBrace: ["}"]
  LeftBracket: ["["]
  RightBracket: ["]"]
  Comma: [","]
  DotOperator: ["."]

  Reserved: [if then else while do var pvar cvar for function orphan friend child class method extends ]

  ;; ********************************************************************
  ;; Start tokens for compiling javaFilter extensions.
  ;; ********************************************************************

  Filter: [filter]
  Percent: [%]
  Sort: [sort]
  Backup: [backup]
  Direction: [up down]
  All: [all]
  Omit: [omit]
  Check: [check]
  Checkoff: [checkoff nocheck]
  Checkon: [checkon]
  Cut: [bottom top]
  Slice: [slice]
  Lisp: [slice bottom up top down all] [<= <= <= >= >= true]

  Score: [score]
  ScoreCommand: [average averageForAll total totalForAll maximum minimum deviation sharpe]

  Set: [Set set]
  Setnr: [Setnr setnr]

  Run: [run]
  Restore: [restore]
  
  Reserved: [all average averageForAll backup bottom check checkoff checkon down filter]
  Reserved: [nocheck omit restore run score set sort up top total totalForAll]

  ;; ********************************************************************
  ;; End tokens for compiling javaFilter extensions.
  ;; ********************************************************************


#End#





;;**EXPORTKEY**:javaScript:%MATH
;;*********************************************************************
;; summary:  This JavaScript language runtime environment includes 
;;           all the features of a full JavaScript environment for 
;;           the Smartbase engine.
;;           See the following references:
;;
;;           [1]  "Analytic Information Server JavaScript compiler", Korns Associates
;;           [2]  "JavaScript For The World Wide Web", Postscript Press
;;           [3]  "JavaScript Developer's Resource", Prentice Hall
;;
;; Note1:    The runtime environment is defined when the javaScript
;;           compiler is compiled.
;; Note2:    Requires the browseLib, and ParseLib.
;;*********************************************************************

;;*********************************************************************
;; Run time class definitions for the javaScript environment.
;; Note: These classes and global variables create the javaScript 
;;       run time execution environment.
;;*********************************************************************

;;*********************************************************************
;; Create the Math object for the javaScript runtime environment 
;;*********************************************************************
(defun Math()
    ;;***********************
    ;; Math object properties
    ;;***********************
    (define E (exp 1))             ;; Base of natural logarithms (2.718...)
    (define LN2 (log 2))           ;; Natural logarithm of 2 (0.693...)
    (define LN10 (log 10))         ;; Natural logarithm of 10 (2.302...)
    (define LOG2E (log2 E))        ;; Base 2 logarithm of e (1.442...)          
    (define LOG10E (log10 E))      ;; Base 10 logarithm of e (0.434...)      
    (define PI (pi))               ;; Ratio of circumference to diameter (3.141...)
    (define SQRT1_2 (sqrt .5))     ;; Square root of one half (0.707...)       
    (define SQRT2 (sqrt 2))        ;; Square root of two (1.414...)         
    ;;***********************
    ;; Math object methods
    ;;***********************
    (define abs ^abs)              ;; Returns absolute value of a single argument.
    (define acos ^acos)            ;; Returns arc cosine of a single argument.
    (define asin ^asin)            ;; Returns arc sine of a single argument.
    (define atan ^atan)            ;; Returns arc tangent of a single argument.
    (defun atan2(n m)              ;; Returns angle of polar coordinate for two arguments.
        (error "atan2 not implemented yet"))
    (defun ceil(n)                 ;; Rounds up to next integer for one argument.
        (round (+ n .5)))
    (define cos ^cos)              ;; Returns cosine of a single argument.
    (define exp ^exp)              ;; Returns e raised to the power of a single argument.
    (define floor ^round)          ;; Rounds down to next integer for one argument.
    (define log ^log)              ;; Returns the natural logarithm for one argument.
    (define max ^max)              ;; Returns the maximum of two arguments.
    (define min ^min)              ;; Returns the minimum of two arguments.
    (define pow ^expt)             ;; Returns the power of two arguments.
    (defun random() (random 1))    ;; Returns a random number between zero and one.
    (define round ^round)          ;; Rounds to the closest integer.
    (define sin ^sin)              ;; Returns sine of a single argument.
    (define sqrt ^sqrt)            ;; Returns square root of a single argument.
    (define tan ^tan)              ;; Returns the tangent of a single argument.
    ) ; end Math
;; Create the global pdiv (protected divide) function
(define pdiv (lambda (x y) (if (or (= y 0) (= y #void)) (cond  ((< x 0) (return BIGNEGNUM))(true (return BIGPOSNUM)))  (return (/ x y)))))

;;*********************************************************************
;; Create the String object for the javaScript runtime environment 
;;*********************************************************************
(defmethod String:charAt(self n)         ;; Returns the character at index n.
    self[n])
(defmethod String:indexOf(self text)     ;; Returns the index of the first occurrence of text in self.
    (find text self))
(defmethod String:lastIndexOf(self text) ;; Returns the index of the last occurrence of text in self.
    (error "lastIndexOf not implemented yet"))
(defmethod String:length(self)           ;; Return the number of characters in the string.
    (length self))
(defmethod String:split(self text)       ;; Returns an array of substrings all split at text.
    (stringToVector self text))
(defmethod String:substring(self n m)    ;; Returns substring from character n to one before character m.
    (substring self n m))
(defmethod String:toLowerCase(self)      ;; Returns string in lower case.
    (downcase self))
(defmethod String:toUpperCase(self)      ;; Returns string in upper case.
    (upcase self))

;;*********************************************************************
;; Create the Text object for the javaScript runtime environment 
;;*********************************************************************
(defmethod Text:charAt(self n)           ;; Returns the character at index n.
    self[n])
(defmethod Text:indexOf(self text)       ;; Returns the index of the first occurrence of text in self.
    (find text self))
(defmethod Text:lastIndexOf(self text)   ;; Returns the index of the last occurrence of text in self.
    (error "lastIndexOf not implemented yet"))
(defmethod Text:length(self)             ;; Return the number of characters in the string.
    (length self))
(defmethod Text:split(self text)         ;; Returns an array of substrings all split at text.
    (stringToVector self text))
(defmethod Text:substring(self n m)      ;; Returns substring from character n to one before character m.
    (substring self n m))
(defmethod Text:toLowerCase(self)        ;; Returns string in lower case.
    (downcase self))
(defmethod Text:toUpperCase(self)        ;; Returns string in upper case.
    (upcase self))





;;**EXPORTKEY**:javaScript:%RULESLambda
;;*********************************************************************
;; summary:  This JavaScript language runtime environment includes 
;;           all the features of a full JavaScript environment for 
;;           the Smartbase engine.
;;           See the following references:
;;
;;           [1]  "Analytic Information Server JavaScript compiler", Korns Associates
;;           [2]  "JavaScript For The World Wide Web", Postscript Press
;;           [3]  "JavaScript Developer's Resource", Prentice Hall
;;
;; Note1:    The runtime environment is defined when the javaScript
;;           compiler is compiled.
;; Note2:    Requires the browseLib, and ParseLib.
;;*********************************************************************

;;*********************************************************************
;; Run time class definitions for the javaScript environment.
;; Note: These classes and global variables create the javaScript 
;;       run time execution environment.
;;*********************************************************************

(defun rulesLib()
;; ********************************************************************
;; summary:  Create, maintain, and apply a Dictionary of IF -> THEN list
;;           substitution rules for transforming a list and all its sub
;;           lists. Anywhere a sub list matches one of the IF rules, the
;;           THEN rule is substituted in place of the original sub list.
;;           This Lambda also supports single or multiple pass substitution
;;           rule application.
;; Parms:    none
;; return:   true
;; ********************************************************************
   pvars:(rulesDic                 ;; Dictionary of morph substitution rules
          singlePass               ;; Switch for single pass morph substitution
          explanation              ;; Contains the explanation after apply
          verbose                  ;; Switch for displaying each explanation step on the console.
          changeCount              ;; Number of rule based substitutions
          (morphFail |*failure*|:) ;; Morph rule failure RHS value
          (maxPasses 200)          ;; Maximum number of passes before issuing error (singlePass = false)
          passCount                ;; Current number of passes already executed by apply
          ;; Methods list 
          appendList               ;; Child to append to items together to always make a list.
          apply                    ;; Child to apply all rules in the rules dictionary to morph a list
          assert                   ;; Child to add a single new rule to the rules dictionary 
          bind                     ;; Child to bind dummy variables to values in a sub list 
          doClear                  ;; Child to clear the rules dictionary 
          isMatch                  ;; Child to match a regular expression with a candidate expression 
          len                      ;; Child to return the number of rules in the rules Dictionary 
          listRules                ;; Child for morph to call during rule application
          new                      ;; Child for initializing the newly created list rules Lambda
          ref1                     ;; Child to return the THEN form corresponding to an IF form 
          rulesDictionary          ;; Friend to manage a dictionary of rules
          set1                     ;; Child to add a single new rule to the rules dictionary 
          setFailure               ;; Child to set the rule failure RHS value
          setMaxPasses             ;; Child to set the maximum apply passes limit 
          setSinglePass            ;; Child to set the single pass switch 
          setVerbose               ;; Child to set the verbose switch 
          unassert                 ;; Child to delete a single rule from the rules dictionary 
          ) ;; end of persistent variables
   ;; Never initialize this Lambda more than once, because the
   ;; inline child Lambdas will overlay the cloned child Lambdas
   ;; in any clone copies of the Lambda and this causes serious
   ;; confusion when the reinitialized clone begins to affect
   ;; the persistant storage of the original Lambda.
   (if (<> new #void) (return true))
   ;; Initialize the inline child Lambdas.
   ;; Append the two arguments into a list.
   (defun appendList(one two ...)
       vars:(result argc i)
       (cond 
           ((and (isPair one) (isPair two)) (setq result (append one two)))
           ((= one #void) (setq result two))
           ((= two #void) (setq result one))
           ((isPair one) (setq result (append one (list two))))
           (else (setq result (list one two)))
           ) ; end cond
       (setq argc (argCount))
       (loop for i from 2 until argc do
           (setq result (appendList result (argFetch i)))
           ) ;; end loop
       result) ;; end appendList
   (defun apply(theList)
       vars:(x)
       (setq x theList)
       (setq passCount 0)
       (setq explanation "")
       Retry::
       (if (> passCount maxPasses) (error "listRule_Pass" "Exceeded maximum number of apply rules."))
       (setq changeCount 0)
       (setq x (morph (list x) listRules morphFail))
       (if (isPair x) (setq x (car x)))
       (if (and (> changeCount 0) (= singlePass false)(isPair x)) (goto Retry:))
       (setq explanation (append explanation "Final result: " (string theList true) " ==> "  (string x true)))
       (if (= verbose true)
           (writeln "Final result: " (string theList true) " ==> "  (string x true)))
       x) ;; end of apply
   (defun assert(ifForm thenForm) (setq rulesDic[ifForm] thenForm))
   (defun bind(mask dic)
   ;; ********************************************************************
   ;; summary:  Bind the specified mask expression (mask) with a Dictionary
   ;;           (dic) containing wild card variables ($Xn) which are bound 
   ;;           to values.
   ;; Parms:    mask:    The mask expression with dummy variables.
   ;;           dic:     The Dictionary of bound variables.
   ;; return:   mask:    The new expression with bound dummy variables replaced.
   ;; ********************************************************************
      vars:(f i n s result tail)
      ;; If the mask is a quoted pair, then remove the extra quotes with eval.
      (if (= (type mask) QuotedPair:) (setq mask (eval mask)))
      ;; Bind the mask with the Dictionary values.
      (cond ;; If the mask is a List whose first element is an appendList
            ;; token value (ie <$>), then recursively bind each 
            ;; remaining element of the List, and return the result of 
            ;; applying appendList to the final bound List.
            ((and (isPair mask) (= mask[0] "<$>"))
             (begin
                (setq n (length mask))
                (loop for i from 1 until n do (setq mask[i] (bind mask[i] dic)))
                (setq tail (cdr mask))
                (if (<= (length tail) 1)
                    (setq result tail) 
                    (setq result (^apply appendList (cdr mask))))))                 
            ;; If the mask is a List whose first element is a lambda wild
            ;; card variable (ie <$x>), then recursively bind each 
            ;; remaining element of the List, and return the result of 
            ;; applying the wild card lambda value to the final bound List.
            ((and (isPair mask) 
                  (isSymbol mask[0]) 
                  (= (left mask[0] 2) "<$")
                  (= (right mask[0] 1) ">"))
             (begin
                (setq n (length mask))
                (loop for i from 1 until n do (setq mask[i] (bind mask[i] dic)))
                (setq n (length mask[0]))
                (setq s (symbol (mid mask[0] 1 (subi n 2))))
                (setq f rulesDic[s])
                (setq result (^apply f (cdr mask))))) 
            ;; If the mask is a List, then recursively bind each 
            ;; element of the List, and return the final bound List.
            ((isPair mask)
             (setq n (length mask))
             (loop for i from 0 until n do (setq mask[i] (bind mask[i] dic)))
             (setq result mask)) 
            ;; If the mask is a wild card symbol, then return the
            ;; value of the wildcard symbol in the bindings Dictionary.
            ((and (isSymbol mask) (= mask[0] #\$)) 
             (setq result dic[mask]))
            ;; If the mask is anything else, then return the mask as is.
            (else (setq result mask))
            ) ;; end cond
      result) ;; end of bind
   (defun doClear() (new))
   (defun isMatch(reg exp dic)
   ;; ********************************************************************
   ;; summary:  Match the specified regular expression (reg) with a candidate
   ;;           expression (exp). The regular expression contains dummy
   ;;           variables ($Xn) which are bound to values in the candidate
   ;;           expression using the Dictionary (dic). The act of matching
   ;;           an expression produces a Dictionary with the correct bindings.
   ;; Parms:    reg:     The regular expression with unbound variables ($Xn).
   ;;           exp:     The natural expression to match with the regular.
   ;;           dic:     The Dictionary of bound variables.
   ;; return:   bool:    True if match, or false if no match.
   ;; ********************************************************************
      vars:(i n s pos leftName rightName
            regLeftHand regRightHand wildcd
            expLeftHand expRightHand tmpDic
            recognizeProc recognizeResult nreg 
            ) ;; end of temporary variables
      ;; Any error results in a no match!
      ;(onError (lambda(err) false))
      ;; Attempt to match the regular expression with the input expression.
      (cond ;; If both expressions are Pairs and the first term in the regular
            ;; expression is a named wild card ending with an asterisk $name*,
            ;; then the wild card is matched to the left hand remainder of the
            ;; input expression, and we try to match the right hand portions of the
            ;; regular expression with any right hand portion of the input expression. 
            ((and (isPair reg) (isPair exp) 
                  (isSymbol reg[0]) 
                  (= (left reg[0] 1) "$") 
                  (= (right reg[0] 1) "*")) 
             (begin
                ;; Isolate the wild card name.
                (setq wildcd (mid reg[0] 0 (sub1 (length reg[0]))))
                (setq regRightHand (cdr reg))
                (setq expRightHand exp)
                (setq expLeftHand #void)
                ;; Match immediately, if the wild card terminates the regular expression.
                (if (= regRightHand #void)
                    (begin
                       (setq dic[wildcd] exp)  
                       (return true)
                       )) ;; end if
                ;; Try to match with any right hand portion of the input expression.
                (while (isPair expRightHand)
                    (setq tmpDic (copy dic))
                    (if (isMatch regRightHand expRightHand tmpDic)
                        (if (and (<> tmpDic[wildcd] #void) (compareNE tmpDic[wildcd] expLeftHand))
                            (return false)
                            (begin (setq tmpDic[wildcd] expLeftHand) (objectToDictionary dic tmpDic) (return true))
                            ) ;; end then
                        (begin
                           (setq nreg (car expRightHand))
                           (setq expRightHand (cdr expRightHand))
                           (if (isPair expLeftHand) 
                               (setq expLeftHand (append expLeftHand (list nreg)))
                               (if (= expLeftHand #void) 
                                   (setq expLeftHand (list nreg))
                                   (setq expLeftHand (append expLeftHand (list nreg))))
                               )) ;; end if
                        ) ;; end if
                    ) ;; end while
                false))
            ;; If both expressions are Pairs and the second term in the regular
            ;; expression is a named wild card ending with an asterisk $name*,
            ;; And the input expression has length one, 
            ;; then the wild card is matched to the left hand remainder of the
            ;; input expression, and we try to match the right hand portions of the
            ;; regular expression with any right hand portion of the input expression. 
            ((and (isPair reg) (isPair exp) 
                  (= (length reg) 2) 
                  (isSymbol reg[1]) 
                  (= (left reg[1] 1) "$") 
                  (= (right reg[1] 1) "*") 
                  (= (length exp) 1)) 
             (begin
                (setq tmpDic (copy dic))
                (setq wildcd (mid reg[1] 0 (sub1 (length reg[1]))))
                (if (<> tmpDic[wildcd] #void) (return false))
                (if (isMatch (car reg) (car exp) tmpDic)
                    (begin
                       (objectToDictionary dic tmpDic)
                       (return true))
                    (return false))
                    )) ;; end empty wild card case
            ;; If both expressions are Pairs, try to match their cars and cdrs.
            ((and (isPair reg) (isPair exp))
             (begin
                (setq tmpDic (copy dic))
                (if (and (isMatch (car reg) (car exp) tmpDic) (isMatch (cdr reg) (cdr exp) tmpDic))
                    (begin
                       (objectToDictionary dic tmpDic)
                       (return true))
                    (return false))
                    )) ;; end both pairs case
            ;; If the regular expression is a wild card rule <$name=$rule>,
            ;; and the rule (retrieved from the rules dictionary) returns true,
            ;; then match and bind the wild card except in the case of a
            ;; previous binding with the same wild card which is not equal 
            ;; to this attempted binding.
            ((and (isSymbol reg) (= (left reg 2) "<$"))
             (begin
                (setq nreg (mid reg 1 (subi (length reg) 2)))  
                (cond
                   ((isBoolean (setq pos (find "=$" (string nreg)))) false)
                   ((not (isLambda (setq recognizeProc rulesDic[(setq rightName (mid nreg (addi pos 1) 10000))]))) false)
                   ((= (setq recognizeResult (recognizeProc exp)) false) false)
                   ((= dic[(setq leftName (left nreg pos))] #void) (setq dic[leftName] recognizeResult) true)
                   ((isEqual dic[leftName] recognizeResult) true)
                   (else false))))
            ;; If the regular expression is a wild card symbol (begins with $),
            ;; then match and bind the wild card except in the case of a
            ;; previous binding with the same wild card which is not equal 
            ;; to this attempted binding.
            ((and (isSymbol reg) (= (left reg 1) "$"))
             (cond ((= dic[reg] #void) (setq dic[reg] exp) true)
                   ((isEqual dic[reg] exp) true)
                   (else false)))
            ;; If both expressions are equal, then this is a match!
            ((= reg exp) 
             true)
            ;; Everything else is a no match!
            (else false)
            ) ;; end cond
      ) ;; end of isMatch
   (defun len() (length rulesDic))
   (defun listRules(sexp)
   ;; ********************************************************************
   ;; summary:  If the head of the specified sub list (sexp) matches a rule
   ;;           (ifForm) in the rules Dictionary, then apply the substitution 
   ;;           rule (thenForm) to the sub list passed by the morph procedure.
   ;; ********************************************************************
      vars:(i n dic cpy ret)
      ;(onError (lambda(err) err))      
      (setq n (length rulesDic))
      (loop for i from 0 until n do
          (setq dic (makeDictionary))
          (if (isMatch rulesDic[i 0] sexp dic)
              (begin
                 (++ changeCount)
                 (setq cpy (copy rulesDic[i 1]))
                 (setq ret (bind cpy dic))
                 (setq explanation (append explanation 
                                           "Rule [" i "] replacing: " 
                                           (string sexp true) " ==> "  
                                           (string ret true) _eol))
                 (if (= verbose true) 
                     (writeln "Rule [" i "] replacing: " (string sexp true) " ==> "  (string ret true)))
                 (return ret)
              )) ;; end if
          ) ;; end of loop
      morphFail) ;; end of listRules
   (defun new()
      (setq rulesDic (^new rulesDictionary))
      (setq singlePass true)
      (setq verbose false)) ;; end of new
   (defun ref1(ifForm) 
        (if (isSymbol ifForm) (return (myself)[Pv:][ifForm])) ;; Supports Lambda polymorphism.
        (if (isNumber ifForm)
            (return (spair rulesDic[ifForm 0] rulesDic[ifForm 1]))
            rulesDic[ifForm])) ;; end of ref1
   (defun set1(ifForm thenForm) 
        (if (= ifForm singlePass:) (return (setq singlePass thenForm))) ;; Supports Lambda polymorphism.
        (if (= ifForm verbose:) (return (setq verbose thenForm))) ;; Supports Lambda polymorphism.
        (assert ifForm thenForm)) ;; end of set1
   (defun setFailure(RHSvalue) (setq morphFail RHSvalue))
   (defun setMaxPasses(limit) (setq maxPasses limit))
   (defun setSinglePass(swt) (setq singlePass swt))
   (defun setVerbose(swt) (setq verbose swt))
   (defun unassert(ifForm) (setq rulesDic[ifForm] #void))
   ;; Initialize the Lambda and assign a new rules Dictionary.
   (new)) ;; end of rulesLib


;;  ***NOTES***:
;; 
;; This Lambda provides a rule based capability for transforming
;; an old list into a new list.
;;
;; This Lambda accepts and saves a set of transformation rules in
;; its internal rules dictionary. Each rule is entered, by the
;; programmer, in two parts -- an IF form followed by a THEN form.
;; An example might be:
;; 
;;     (rulesLib.assert '(x + y) '(addi x y))
;;
;; We may then apply the above rules against a list as follows: 
;;
;;     (rulesLib.apply '(x + y))   ==>  '(addi x y)
;;
;; This Lambda supports wild card variables to make rule definitions
;; more flexible for the programmer. An example of wild card rule
;; variables is as follows:
;;
;;     (rulesLib.assert '($X + $Y) '(addi $X $Y))
;;
;; We may then apply the above rules against a list as follows: 
;;
;;     (rulesLib.apply '(m + 10))   ==>  '(addi m 10)
;;
;; The rules and wild card variables operate on sub lists as well
;; as the whole list as follows: 
;;
;;     (rulesLib.apply '((m + 10) + 20))   ==>  '(addi (addi m 10) 20)
;;
;; This Lambda supports named lambda rule definitions which allow
;; more flexible actions to be taken by the programmer during the
;; recognition phase and also during the production phase. Some 
;; examples of named lambda rule definitions is as follows:
;;
;;     (rulesLib.assert $FOLD:(lambda(op x y) vars:(f) (setq f (getGlobalValue (symbol op))) (f x y)))
;;     (rulesLib.assert $NUM:(lambda(x) (if (isNumber x) x)))
;;     (rulesLib.assert $OP:(lambda(x) vars:((d #{+ addi - subi * muli / divi})) (if (isMember x d) d[x])))
;;     (rulesLib.assert '(<$X=$NUM> <$Y=$OP> <$Z=$NUM>) '(<$FOLD> $Y $X $Z))
;;     (rulesLib.assert '($X <$Y=$OP> $Z) '($Y $X $Z))
;;
;; We may then apply the above rules against a list as follows: 
;;
;;     (rulesLib.apply '(m + 10))   ==>  '(addi m 10)
;;     (rulesLib.apply '(5 + 10))   ==>  15
;;
;; Double quoting a right hand production rule causes the append
;; function to be applied to the result as follows:
;;
;;     (rulesLib.assert '($X + $Y) ''(+ $X $Y))
;;     (rulesLib.apply '((5 6 7) + (10 20)))   ==>  '(+ 5 6 7 10 20)
;;
;; This Lambda supports multiple rule definitions up to the limits
;; of available memory. Rules asserted first have precedence over 
;; rules asserted later as follows:
;;
;;     (rulesLib.assert $OP:(lambda(x) vars:((d #{+ addi - subi * muli / divi})) (if (isMemEqv x d) d[x])))
;;     (rulesLib.assert '($X <$Y=$OP> $Z) '($Y $X $Z))
;;     (rulesLib.assert '(addi $X $X) '(muli $X 2))
;;     (rulesLib.assert '(addi $X 0) '$X)
;;
;; We may then apply the multiple rules against a list as follows: 
;;
;;     (rulesLib.apply '(m + m))   ==>  '(addi m m)
;;
;; This Lambda supports multiple passes, during rule application,
;; as follows:
;;
;;     (setq rulesLib.singlePass false)
;;     (rulesLib.apply '(m + m))   ==>  '(muli m 2)
;;     (rulesLib.apply '(m + 0))   ==>  m
;;
;; This Lambda supports asterisk wild card rules anywhere within lists,
;; as follows:
;;
;;     (rulesLib.assert '(min ($X*)) '(<$FN> min $X))
;;     (rulesLib.assert '($X* min)   '(<$FN> min $X))
;;     (rulesLib.assert $FN:(lambda(fn x) (append (list fn) x)))
;;     (rulesLib.apply  '(min (2 3)))  ==>  '(min 2 3)
;;     (rulesLib.apply  '((2 3) min))  ==>  '(min 2 3)
;;
;;






;;**EXPORTKEY**:javaScript:%RULESLambda_DICTIONARY
;;*********************************************************************
;; summary:  This JavaScript language runtime environment includes 
;;           all the features of a full JavaScript environment for 
;;           the Smartbase engine.
;;           See the following references:
;;
;;           [1]  "Analytic Information Server JavaScript compiler", Korns Associates
;;           [2]  "JavaScript For The World Wide Web", Postscript Press
;;           [3]  "JavaScript Developer's Resource", Prentice Hall
;;
;; Note1:    The runtime environment is defined when the javaScript
;;           compiler is compiled.
;; Note2:    Requires the browseLib, and ParseLib.
;;*********************************************************************

;;*********************************************************************
;; Run time class definitions for the javaScript environment.
;; Note: These classes and global variables create the javaScript 
;;       run time execution environment.
;;*********************************************************************

(deforphan rulesLib:rulesDictionary()
;; ********************************************************************
;; summary:  Create, maintain, and apply a Dictionary of IF -> THEN
;;           substitution rules and wild card lambda rules. The wild
;;           card lambda rules are kept separate from the production
;;           rules. The Lambda is designed to behave similar to a 
;;           Dictionary.
;; Parms:    none  
;; return:   true
;; ********************************************************************
   pvars:(leftRULES                ;; Vector of left hand production rules
          rightRULES               ;; Vector of right hand production rules
          lambdaRULES              ;; Dictionary of lambda rules
          ;; Methods list 
          len                      ;; Method to return the number of rules in the rules Dictionary 
          new                      ;; Method to create a new rules Dictionary 
          ref1                     ;; Method to return the THEN form corresponding to an IF form 
          ref2                     ;; Method to return the rules contained in the rules dictionary 
          refCount                 ;; Method to return the number of production rules 
          set1                     ;; Method to add a single new rule to the rules dictionary 
         ) ;; end of persistent variables
   ;; Never initialize this Lambda more than once, because the
   ;; inline child Lambdas will overlay the cloned child Lambdas
   ;; in any clone copies of the Lambda and this causes serious
   ;; confusion when the reinitialized clone begins to affect
   ;; the persistant storage of the original Lambda.
   (if (<> new #void) (return true))
   ;; Initialize the inline child Lambdas.
   (defun len() (length leftRULES))
   (defun new()
      (setq leftRULES (^new Vector: 0))
      (setq rightRULES (^new Vector: 0))
      (setq lambdaRULES (^new Directory:))
      true) ;; end of new
   (defun ref1(key)
      vars:(i n)
      ;; Are we retrieving wild card lambda rule?
      (if (and (or (isString key) (isSymbol key)) (= key[0] #\$))
          (return lambdaRULES[key]))
      ;; We retrieving right hand production rules.
      (setq n (length leftRULES))
      (loop for i from 0 until n do
          (if (isEqual key leftRULES[i])
              (return rightRULES[i]))
          ) ;; end loop
      #void) ;; end of ref1
   (defun ref2(index1 index2)
      vars:(n)
      (setq n (length leftRULES))
      ;; Are we retrieving a wild card lambda rule?
      (if (>= index1 n)
          (return lambdaRULES[(subi index1 n) index2]))
      ;; Are we retrieving left hand production rules.
      (if (= index2 0)
          (return leftRULES[index1]))
      ;; Are we retrieving right hand production rules.
      (if (= index2 1)
          (return rightRULES[index1]))
      (error "arglist")) ;; end of ref2
   (defun refCount() (length leftRULES))
   (defun set1(key newValue)
      vars:(i n)
      ;; Are we asserting a wild card lambda rule?
      (if (and (isSymbol key) (= key[0] #\$) (<> key $ALL$:))
          (begin
             (if (<> newValue #void)  
                 (return (setq lambdaRULES[key] newValue))) 
             ;; We are deleting a wild card lambda rule.
             (setq i (member key lambdaRULES))
             (if (isNumber i)
                 (vectorDelete lambdaRULES i))
             (return #void))) ;; end deleting lambda rule
      ;; We are asserting a production rule.
      (setq n (length leftRULES))
      (setq i (member key leftRULES))
      (if (isNumber i)
          (if (= newValue #void)
              (begin
                 (vectorDelete leftRULES i)
                 (vectorDelete rightRULES i)
                 (return #void)) ;; end delete production rule
              (begin
                 (setq rightRULES[i] newValue)
                 (return newValue))) ;; end replace production rule
          ) ;; end if
      ;; Do not assert new rules with #void right hand productions.
      (if (= newValue #void) (error "rightHand" (append "rulesDictionary found right hand #void: " key " ==> " newValue)))
      ;; Assert new production rule
      (setq leftRULES[n] key)
      (setq rightRULES[n] newValue)
      newValue) ;; end of set1
   ;; Initialize the Lambda and clear the rules Dictionary.
   (new)) ;; end of rulesDictionary
;;
;; *NOTES*:
;;
;; Rules must be in one of the following forms:
;;
;;      IFFORM                 THENFORM                  DESCRIPTION
;;
;;      $symbol                ..an Lambda..              Lambda wild card rule
;;      $ALL$                  ..anything..              Final production rule
;;      ..other..              ..anything..              Production rule






;;**EXPORTKEY**:javaScript:@@defaultLexer
(defriend javaScript:defaultLexer(inString)
;; ********************************************************************
;; summary:  This Lambda converts an input string into a vector of
;;           recognized lexemes. It is the default lexical analyzer
;;           for the ParseLib compiler generator.
;;           This Lambda may be modified, in any way, by the user.
;; Parms:    inString   The source string to be broken into lexemes.
;; return:   tokenList  The vector of recognized lexemes.
;; ********************************************************************
    pvars:(;; Persistent variables
           CH                  ;; The current input character from the input string
           INLEN               ;; The length of the input string
           IP                  ;; The input pointer for the input string
           INSTRING            ;; The string of the input characters to be parsed
           keepWhitespaceSW    ;; Switch to keep all whitespace strings
           lowerCaseSW         ;; Switch to convert all names into lower case
           oldKB               ;; The old vector of character break parsing routines
           operatorList        ;; The vector of operator symbols
           KB                  ;; The vector of character break parsing routines
           SB                  ;; The vector of string terminator pairs
           tokenDirectory      ;; Lexicon of tokens and their attributes
           tokenList           ;; The vector of lexical tokens
           TP                  ;; The output pointer for the token output vector
           ;; Methods list
           addStringDelimiters ;; Add a pair of string delimiters to the lexical analyzer
           _default            ;; Recognize this one character
           defaultTokenRule    ;; Modified default rule for adding attributes to a parsed token
           _Ignore             ;; Ignore this character parsing routine
           _Initialize         ;; Initialize the vector of character break parsing routines
           _recFraction        ;; Recognize all fractions
           _recInteger         ;; Recognize all integers
           _recName            ;; Recognize all names
           _recNumber          ;; Recognize all numbers
           _recOperators       ;; Recognize all operator symbols
           _recSpecial         ;; Recognize all special symbols
           _recString          ;; Recognize all delimited strings
           _setFeatures        ;; Give features to a recognized token
           _whiteSpace         ;; Ignore all whitespace characters
           turnFractionsOnOff  ;; Turns fraction recognition on/off
           ) ;; end of persistent variables
    vars:(token oldIP)
    ;;************************************************************************
    ;;  Define the child Lambdas for this parent.
    ;;************************************************************************
    ;; Add a named pair of string delimiters to the lexical analyzer.
    (defun addStringDelimiters(name start end)
       vars:(tmpLambda)
       ;;  Initialize the ParseLib once and only once.
       (if (= KB #void) (_Initialize))
       ;;  If this is the first delimiter pair, start a new directory.
       (setq CH start[0])
       (if (= SB[CH] #void) 
           (begin
              (setq SB[CH] (new Structure:))
              (setq KB[CH] _recString)
           )) ;; end if
       ;;  Set the character directory with this new string delimiter pair.
       (setq SB[CH][name] (new Vector: 2 start end))
       ) ;; end addStringDelimiters
    ;;  Ignore this character parsing routine.
    (defun _Ignore() (++ IP))
    ;;  Create the character break vector.
    (defun _Initialize()
        vars:(i)
        (setq KB (new Vector: 256))
        (setq SB (new Vector: 256))
        (setq operatorList #(#\= #\< #\> #\! #\^ #\~ #\+ #\/ #\* #\- #\| #\&))
        ;; Actual mapping of parse routines to break character positions.
        (loop for i from 0 until 256 do (setq KB[i] _recSpecial))
        (loop for i from 0 to 32 do (setq KB[i] _whiteSpace)) 
        (loop for i from 128 until 256 do (setq KB[i] _whiteSpace)) 
        (loop for i from (code #\a) to (code #\z) do (setq KB[i] _recName)) 
        (loop for i from (code #\A) to (code #\Z) do (setq KB[i] _recName)) 
        (loop for i from (code #\0) to (code #\9) do (setq KB[i] _recNumber)) 
        (loop for i from 0 until (length operatorList) do (setq KB[operatorList[i]] _recOperators)) 
        (setq KB[(code #\_)] _recName) 
        (setq KB[(code #\.)] _recFraction) 
        (setq oldKB (copy KB))
        ) ;; end of _Initialize
    ;;  Recognize all fractions.
    (defun _recFraction()
        vars:(oldIP result)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize fraction portion of number (if any)
        (if (isCharNumeric CH)
            then
            (begin
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
               (setq result (number (substring INSTRING oldIP (subi IP 1))))
               ) ; end then
            else
            (setq result (symbol ".")) 
            ) ; end recognize fraction.
        (setq tokenList[TP] result)
        (++ TP)
        ) ;; end _recFraction
    ;;  Recognize all names.
    (defun _recName()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isCharName CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (if lowerCaseSW
            (setq tokenList[TP] (symbol (downcase (substring INSTRING oldIP (subi IP 1)))))
            (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
            ) ; end if
        (++ TP)
        ) ;; end _recName
    ;;  Recognize all numbers.
    (defun _recNumber()
        vars:(oldIP num fraction)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Recognize fraction portion of number (if any)
        (if (and (= CH #\.) (isCharNumeric INSTRING[(add1 IP)]))
            (begin
               (setq fraction true)
               (setq CH INSTRING[(++ IP)])
               ;; Recognize fraction portion of number
               (while (isCharNumeric CH) do
                  (setq CH INSTRING[(++ IP)]) 
                  ) ;; end while
            )) ; end recognize fraction.
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (if (= fraction true) (setq num (number num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recNumber
    ;;  Recognize all integers.
    (defun _recInteger()
        vars:(oldIP num)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)])
        ;; Recognize integer portion of number
        (while (isCharNumeric CH) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq num (number (substring INSTRING oldIP (subi IP 1))))
        (if (= (integer num) num) (setq num (integer num)))
        (setq tokenList[TP] num)
        (++ TP)
        ) ;; end _recInteger
    ;;  Recognize all operator symbols.
    (defun _recOperators()
        vars:(oldIP)
        (setq oldIP IP)
        (setq CH INSTRING[(++ IP)]) 
        (while (isMember CH operatorList) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        (setq tokenList[TP] (symbol (substring INSTRING oldIP (subi IP 1))))
        (++ TP)
        ) ;; end _recOperators
    ;; Recognize all special symbols.
    (defun _recSpecial() (setq tokenList[TP] (symbol (string CH))) (++ IP) (++ TP))
    ;; Recognize all delimited strings.
    (defun _recString()
        vars:(oldIP i delimPairs delimLen result              
              name this start end startLen endLen)
        (setq oldIP IP)
        ;; Check for a starting string delimiter.
        (setq delimPairs SB[CH])
        (setq delimLen (length delimPairs))
        (loop for i from 0 until delimLen do
           (setq name delimPairs[i 0])
           (setq start delimPairs[i 1][0])
           (setq startLen (length start))
           (setq this (mid INSTRING IP startLen))
           (if (= start this)
               (begin
                  (setq end delimPairs[i 1][1])
                  (setq endLen (length end))
                  (+= IP startLen)
                  (while (< IP INLEN) do
                     (if (= INSTRING[IP] end[0])
                         (begin
                            (setq this (mid INSTRING IP endLen))
                            (if (= end this)
                                (begin
                                   (+= IP endLen)
                                   (setq result (substring INSTRING oldIP (subi IP 1)))
                                   ;; Ignore all whitespace delimited strings
                                   (if (<> (left name 10) "Whitespace")
                                       (begin
                                          (setq tokenList[TP] (new Vector: 2 name result))
                                          (++ TP)
                                          )) ; end  if
                                   (return TP)              
                                   )) ; end inner if
                            )) ; end outter if
                     (++ IP)
                     ) ; end while
                  (setq result (substring INSTRING oldIP (subi IP 1)))
                  ;; Ignore all whitespace delimited strings
                  (if (or keepWhitespaceSW (<> (left name 10) "Whitespace"))
                      (begin
                         (setq tokenList[TP] (new Vector: 2 name result))
                         (++ TP)
                         )) ; end  if
                  (return TP)              
                  )) ; end if 
           ) ;; end loop
        ;; If we get here, this is not the start of a delimited string,
        ;; so invoke the old lexeme parser for this character.
        (oldKB[CH])) ;; end _recString
     ;; Give features to a recognized token
     (defun _setFeatures(token oldIP)
        vars:(parseTree treeIndex treeLen tokenAttr)
        ;; This Lambda tests compiled FSM style methods of attributing each parsed token.
        (setq tokenAttr tokenDirectory[token])
        (if (= tokenAttr #void)
            then
            ;; Create an attributed token using default rule
            (setq tokenAttr (defaultTokenRule token))
            else
            ;; Copy the attributes and set the Value from the dictionary
            (begin
               (setq tokenAttr (copy tokenAttr))
               (setq tokenAttr.Value token)
            )) ; end if
        ;; Set the displacement of the token in the source string
        (setq tokenAttr.Charpos (integer oldIP))
        (setq tokenList[(subi TP 1)] tokenAttr)
        true) ;; end of _setFeatures
    ;; Turns fraction recognition on/off.
    (defun turnFractionsOnOff(onOffSW)
        vars:(i)
        ;; Turn fractions on?
        (if onOffSW
            ;; Turn fractions on
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recNumber)) 
                  (setq oldKB[i] _recNumber)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recFraction))
               (setq oldKB[(code #\.)] _recFraction)
               ) ; end turn fractions on
            ;; Turn fractions off
            (begin
               (loop for i from (code #\0) to (code #\9) do
                  (if (= KB[i] oldKB[i]) (setq KB[i] _recInteger)) 
                  (setq oldKB[i] _recInteger)
                  ) ; end loop
               (if (= KB[(code #\.)] oldKB[(code #\.)]) (setq KB[(code #\.)] _recSpecial))
               (setq oldKB[(code #\.)] _recSpecial)
               ) ; end turn fractions off
            ) ; end if
        ) ;; end of turnFractionsOnOff
    ;;  Ignore all whitespace characters.
    (defun _whiteSpace()        
        vars:(oldIP i result)
        ;; Save old IP address
        (setq oldIP IP)
        ;; Loop until all whitespace chars are discovered
        (setq CH INSTRING[(++ IP)]) 
        (while (and (> CH 0) (<= CH 32)) do
           (setq CH INSTRING[(++ IP)]) 
           ) ;; end while
        ;; Return whitespace token (iff keepWhitespaceSW is true)
        (if keepWhitespaceSW
            (begin
               (setq result (substring INSTRING oldIP (subi IP 1)))
               (setq tokenList[TP] (new Vector: 2 "Whitespace" result))
               (++ TP)              
               )) ; end if
        ) ;; end _whiteSpace
    ;;************************************************************************
    ;;  Define the main code routines for this parent.
    ;;************************************************************************
    ;;  Initialize the ParseLib once and only once.
    (if (= KB #void) (_Initialize))
    ;;  Initialize the output token vector. 
    (setq tokenList (new Vector: 0))
    (setq TP 0)
    ;;  Recognize each character in the input string.
    (setq INSTRING inString)
    (setq INLEN (length INSTRING))
    (setq IP 0)
    (while (< IP INLEN) do
        (setq oldIP IP)
        ;; Retrieve the next input character
        (setq CH INSTRING[IP])
        ;; Invoke the parse routine for this input character
        (KB[CH])
        ;; If a token was recognized, give it some features
        (if (and (> TP 0) (not (isStructure (setq token tokenList[(subi TP 1)])))) (_setFeatures token oldIP))
        ) ;; end while
    ;;  Return the token list as the output
    tokenList) ;; end defaultLexer



















;;**EXPORTKEY**:javaScript:@UserDefinedFunctions
;; ************************************************
;; javaScript User defined functions
;; ************************************************










;;**EXPORTKEY**:javaScript:_LEXRULE_MAIN
;; ************************************************
;; MAIN user defined Lexical Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_LEXRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  _tkch
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 "")
   (setq _tkn 0)
   (setq _repeatSW true)
   (setq _oldIp _ip)

   (if (= _verboseLexCount.MAIN #void) 
          (setq _verboseLexCount.MAIN 1) 
          (setq _verboseLexCount.MAIN (iadd _verboseLexCount.MAIN 1)))

   (if (and (<> _verboseLexIn.MAIN #void) (> _verboseLexIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " input:))
     (setq _ip0 _ip)
     (setq _tkch (iadd _ip 1))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************

















     ;; ====================
     ;; case: "void"
     ;; ====================
     (if (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 4)) 4))) "void") true (setq _ip _ip0))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void vtyp: obj: Term: true Constant: true) )
            (if _verbose
                (writeRule
                     {MAIN: "void" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "void"
     ;; ====================
     ;; case: "nil"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (mid $IN (iadd _ip 1) (begin (setq _ip (iadd _ip 3)) 3))) "nil") true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkASIS _tkch #void vtyp: obj: Term: true Constant: true) )
            (if _verbose
                (writeRule
                     {MAIN: "nil" << ($ASIS $ch #void vtyp: obj: Term: true Constant: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "nil"
     ;; ====================
     ;; case: DQuote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NotDQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotDQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: DQuote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_DQuote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch _tk2 String: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: DQuote NotDQuote* DQuote << ($ASIS $ch $2 String: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : DQuote
           ) ; end begin
         ) ; end case : NotDQuote*
       ) ; end begin
     ) ; end case : DQuote
     ;; ====================
     ;; case: Quote
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NotQuote*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotQuote[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Quote
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Quote[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; *********************************************************
                 ;; RULE: MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (_tkASIS _tkch (makeQuotedSymbol _tk2) Symbol: true Term: true Constant: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Quote NotQuote* Quote << ($ASIS $ch (makeQuotedSymbol $2) Symbol: true Term: true Constant: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Quote
           ) ; end begin
         ) ; end case : NotQuote*
       ) ; end begin
     ) ; end case : Quote
     ;; ====================
     ;; case: NameStart
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: NameChar*
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (symbol (append _tk1 _tk2)) Name: true Term: true) )
                (if _verbose
                    (writeRule
                         {MAIN: NameStart NameChar* << ($OUT $ch (symbol (append $1 $2)) Name: true Term: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NameChar*
       ) ; end begin
     ) ; end case : NameStart
     ;; ====================
     ;; case: Digit+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Period
         ;; ====================
         (if (if (and (<> (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk2] 1)) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Digit*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Exponent
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Exponent[_tk4] 1)) true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Sign
                     ;; ====================
                     (if (if (and (<> (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Sign[_tk5] 1)) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit+
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip5)))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; *********************************************************
                             ;; RULE: MAIN: Digit+ Period Digit* Exponent Sign Digit+ << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2 _tk3 _tk4 _tk5 _tk6)) Number: true Term: true) )
                                (if _verbose
                                    (writeRule
                                         {MAIN: Digit+ Period Digit* Exponent Sign Digit+ << ($ASIS $ch (number (append $1 $2 $3 $4 $5 $6)) Number: true Term: true) >>}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
(setq _indent (isub _indent 1))
                                (goto Skip:))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : Digit+
                       ) ; end begin
                     ) ; end case : Sign
                   ) ; end begin
                 ) ; end case : Exponent
                 ;; *********************************************************
                 ;; RULE: MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2 _tk3)) Number: true Term: true) )
                    (if _verbose
                        (writeRule
                             {MAIN: Digit+ Period Digit* << ($ASIS $ch (number (append $1 $2 $3)) Number: true Term: true) >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                    (goto Skip:))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Digit*
           ) ; end begin
         ) ; end case : Period
         ;; *********************************************************
         ;; RULE: MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkASIS _tkch (integer _tk1) Number: true Integer: true Term: true) )
            (if _verbose
                (writeRule
                     {MAIN: Digit+ << ($ASIS $ch (integer $1) Number: true Integer: true Term: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Digit+
     ;; ====================
     ;; case: Period
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (and (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Period[_tk1] 1)) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Digit+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkASIS _tkch (number (append _tk1 _tk2)) Number: true Term: true) )
                (if _verbose
                    (writeRule
                         {MAIN: Period Digit+ << ($ASIS $ch (number (append $1 $2)) Number: true Term: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Digit+
       ) ; end begin
     ) ; end case : Period
     ;; ====================
     ;; case: /
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: *
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (or (<> (refString _tkIN _ip) #\*) (<> (refString _tkIN (iadd _ip 1)) #\/)) ) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: *
                 ;; ====================
                 (if (if (= (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: /
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; *********************************************************
                         ;; RULE: MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}* * / << true >>
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  true )
                            (if _verbose
                                (writeRule
                                     {MAIN: / * Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}* * / << true >>}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent 1))
                            (goto Skip:))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : /
                   ) ; end begin
                 ) ; end case : *
               ) ; end begin
             ) ; end case : Any{(or (<> (refString $IN _ip) #\*) (<> (refString $IN (iadd _ip 1)) #\/))}*
           ) ; end begin
         ) ; end case : *
         ;; ====================
         ;; case: /
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: NotEol*
             ;; ====================
             (if (begin (setq _i 0) (setq _tk3 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NotEol[_tkthis] 1)) do (begin (setq _tk3[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Eol?
                 ;; ====================
                 (if (if (and (<> (setq _tk4 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Eol[_tk4] 1)) true (begin (setq _ip (isub _ip 1)) (setq _tk4 {}) true))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; *********************************************************
                     ;; RULE: MAIN: / / NotEol* Eol? << true >>
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  true )
                        (if _verbose
                            (writeRule
                                 {MAIN: / / NotEol* Eol? << true >>}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                        (goto Skip:))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Eol?
               ) ; end begin
             ) ; end case : NotEol*
           ) ; end begin
         ) ; end case : /
       ) ; end begin
     ) ; end case : /
     ;; ====================
     ;; case: "="
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "=" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "=" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "=" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "=" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "="
     ;; ====================
     ;; case: "+"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\+) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "+" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "+" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "+"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\+) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "+" "+" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "+" "+" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "+"
         ;; *********************************************************
         ;; RULE: MAIN: "+" << ($OUT $ch (string $1) Operator: true Sign: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true Sign: true) )
            (if _verbose
                (writeRule
                     {MAIN: "+" << ($OUT $ch (string $1) Operator: true Sign: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "+"
     ;; ====================
     ;; case: "-"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\-) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "-" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "-" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "-"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\-) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "-" "-" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "-" "-" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "-"
         ;; *********************************************************
         ;; RULE: MAIN: "-" << ($OUT $ch (string $1) Operator: true Sign: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true Sign: true) )
            (if _verbose
                (writeRule
                     {MAIN: "-" << ($OUT $ch (string $1) Operator: true Sign: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "-"
     ;; ====================
     ;; case: "/"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\/) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "/" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "/" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "/" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "/" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "/"
     ;; ====================
     ;; case: "*"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\*) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "*" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "*" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "*" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "*" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "*"
     ;; ====================
     ;; case: "%"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\%) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "%" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "%" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "%" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "%" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "%"
     ;; ====================
     ;; case: "!"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\!) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "!" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "!" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "!" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "!" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "!"
     ;; ====================
     ;; case: "&"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\&) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "&" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "&" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "&"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\&) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "&" "&" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "&" "&" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "&"
         ;; *********************************************************
         ;; RULE: MAIN: "&" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "&" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "&"
     ;; ====================
     ;; case: "|"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\|) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "|" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "|" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; ====================
         ;; case: "|"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\|) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "|" "|" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "|" "|" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "|"
         ;; *********************************************************
         ;; RULE: MAIN: "|" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "|" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "|"
     ;; ====================
     ;; case: "<"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: "<" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: "<" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: "<" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "<" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "<"
     ;; ====================
     ;; case: ">"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: "="
         ;; ====================
         (if (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\=) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; *********************************************************
             ;; RULE: MAIN: ">" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_tkOUT _tkch (string (append _tk1 _tk2)) Operator: true) )
                (if _verbose
                    (writeRule
                         {MAIN: ">" "=" << ($OUT $ch (string (append $1 $2)) Operator: true) >>}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
                (goto Skip:))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : "="
         ;; *********************************************************
         ;; RULE: MAIN: ">" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: ">" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : ">"
     ;; ====================
     ;; case: "~"
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\~) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: "~" << ($OUT $ch (string $1) Operator: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (string _tk1) Operator: true) )
            (if _verbose
                (writeRule
                     {MAIN: "~" << ($OUT $ch (string $1) Operator: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : "~"
     ;; ====================
     ;; case: #
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #\#) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; ====================
         ;; case: Letter+
         ;; ====================
         (if (begin (setq _i 0) (setq _tk2 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Letter[_tkthis] 1)) do (begin (setq _tk2[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: ,
             ;; ====================
             (if (if (= (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #\,) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: Digit+
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip3)))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: ,
                     ;; ====================
                     (if (if (= (setq _tk5 $IN[(setq _ip (iadd _ip 1))]) #\,) true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit+
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip5)))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; *********************************************************
                             ;; RULE: MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (_tkASIS _tkch (date (append _tk1 _tk2 _tk3 _tk4 _tk5 _tk6)) Date: true Term: true) )
                                (if _verbose
                                    (writeRule
                                         {MAIN: # Letter+ , Digit+ , Digit+ << ($ASIS $ch (date (append $1 $2 $3 $4 $5 $6)) Date: true Term: true) >>}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
(setq _indent (isub _indent 1))
                                (goto Skip:))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : Digit+
                       ) ; end begin
                     ) ; end case : ,
                   ) ; end begin
                 ) ; end case : Digit+
               ) ; end begin
             ) ; end case : ,
           ) ; end begin
         ) ; end case : Letter+
         ;; ====================
         ;; case: <
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 $IN[(setq _ip (iadd _ip 1))]) #\<) true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip)
             ;; ====================
             ;; case: NameStart
             ;; ====================
             (if (if (and (<> (setq _tk3 $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameStart[_tk3] 1)) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip)
                 ;; ====================
                 ;; case: NameChar*
                 ;; ====================
                 (if (begin (setq _i 0) (setq _tk4 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_NameChar[_tkthis] 1)) do (begin (setq _tk4[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip)
                     ;; ====================
                     ;; case: Whitespace*
                     ;; ====================
                     (if (begin (setq _i 0) (setq _tk5 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk5[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip)
                         ;; ====================
                         ;; case: Digit*
                         ;; ====================
                         (if (begin (setq _i 0) (setq _tk6 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Digit[_tkthis] 1)) do (begin (setq _tk6[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) true)
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip)
                             ;; ====================
                             ;; case: >
                             ;; ====================
                             (if (if (= (setq _tk7 $IN[(setq _ip (iadd _ip 1))]) #\>) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip)
                                 ;; *********************************************************
                                 ;; RULE: MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_tkOUT _tkch (inspect (number _tk6)) vtyp: obj: Term: true) )
                                    (if _verbose
                                        (writeRule
                                             {MAIN: # < NameStart NameChar* Whitespace* Digit* > << ($OUT $ch (inspect (number $6)) vtyp: obj: Term: true) >>}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
(setq _indent (isub _indent 1))
                                    (goto Skip:))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : >
                           ) ; end begin
                         ) ; end case : Digit*
                       ) ; end begin
                     ) ; end case : Whitespace*
                   ) ; end begin
                 ) ; end case : NameChar*
               ) ; end begin
             ) ; end case : NameStart
           ) ; end begin
         ) ; end case : <
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: Whitespace+
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _i 0) (setq _tk1 (makeString {})) (while (and (<> (setq _tkthis $IN[(setq _ip (iadd _ip 1))]) #void) (= _LF_Whitespace[_tkthis] 1)) do (begin (setq _tk1[_i] _tkthis) (setq _i (iadd _i 1)) )) (setq _ip (isub _ip 1)) (if (> _i 0) true (setq _ip _ip0))))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Whitespace+ << true >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  true )
            (if _verbose
                (writeRule
                     {MAIN: Whitespace+ << true >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Whitespace+
     ;; ====================
     ;; case: Any
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_tkOUT _tkch (symbol (string _tk1)) Default: true) )
            (if _verbose
                (writeRule
                     {MAIN: Any << ($OUT $ch (symbol (string $1)) Default: true) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (goto Skip:))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Any
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 $IN[(setq _ip (iadd _ip 1))]) #void) true (setq _ip _ip0)))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip)
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: $LIST ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tkLIST )
            (if _verbose
                (writeRule
                     {MAIN: Eof :: $LIST ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
(setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize 
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " input: ))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseLexIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseLexCount.MAIN _verboseLexIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _LEXRULE_MAIN



















;;**EXPORTKEY**:javaScript:_SEMRULE_LAMBDA
;; ************************************************
;; LAMBDA user defined Semantic Rule implementation
;; Summary: This Lambda implements the LAMBDA
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_LAMBDA(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LAMBDA: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LAMBDA #void) 
          (setq _verboseSemCount.LAMBDA 1) 
          (setq _verboseSemCount.LAMBDA (iadd _verboseSemCount.LAMBDA 1)))

   (if (and (<> _verboseSemIn.LAMBDA #void) (> _verboseSemIn.LAMBDA -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LAMBDA Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "lambda")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "lambda"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "_x")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "_x"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; *********************************************************
                                     ;; RULE: LAMBDA: [ Any{(= _tk2 "lambda")} [ Any{(= _tk4 "_x")} ] Any Any ] :: $7 ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  _tk7 )
                                        (if _verbose 
                                            (writeRule
                                                 {LAMBDA: [ Any{(= _tk2 "lambda")} [ Any{(= _tk4 "_x")} ] Any Any ] :: $7 ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
(setq _indent (isub _indent))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "_x")}
               ) ; end begin
             ) ; end case : [
           ) ; end begin
         ) ; end case : Any{(= _tk2 "lambda")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LAMBDA on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LAMBDA -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LAMBDA _verboseSemIn.LAMBDA) (error "Count" "in Routine LAMBDA"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LAMBDA










;;**EXPORTKEY**:javaScript:_SEMRULE_LET
;; ************************************************
;; LET user defined Semantic Rule implementation
;; Summary: This Lambda implements the LET
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_LET(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LET: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LET #void) 
          (setq _verboseSemCount.LET 1) 
          (setq _verboseSemCount.LET (iadd _verboseSemCount.LET 1)))

   (if (and (<> _verboseSemIn.LET #void) (> _verboseSemIn.LET -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LET Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "let")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "let"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: LAMBDA
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip3))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: LET: [ Any{(= _tk2 "let")} Any LAMBDA ] :: (new Vector: 2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (new Vector: 2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {LET: [ Any{(= _tk2 "let")} Any LAMBDA ] :: (new Vector: 2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : LAMBDA
               ) ; end begin
             ) ; end case : Any
           ) ; end begin
         ) ; end case : Any{(= _tk2 "let")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LET on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LET -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LET _verboseSemIn.LET) (error "Count" "in Routine LET"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LET










;;**EXPORTKEY**:javaScript:_SEMRULE_LETOMIT
;; ************************************************
;; LETOMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the LETOMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_LETOMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LETOMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LETOMIT #void) 
          (setq _verboseSemCount.LETOMIT 1) 
          (setq _verboseSemCount.LETOMIT (iadd _verboseSemCount.LETOMIT 1)))

   (if (and (<> _verboseSemIn.LETOMIT #void) (> _verboseSemIn.LETOMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LETOMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFOMIT
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFOMIT)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LET
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LET)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: LETOMIT: [ REFOMIT LET ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {LETOMIT: [ REFOMIT LET ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LET
           ) ; end begin
         ) ; end case : REFOMIT
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LETOMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LETOMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LETOMIT _verboseSemIn.LETOMIT) (error "Count" "in Routine LETOMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LETOMIT










;;**EXPORTKEY**:javaScript:_SEMRULE_LETTRUNCATE
;; ************************************************
;; LETTRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the LETTRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_LETTRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: LETTRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.LETTRUNCATE #void) 
          (setq _verboseSemCount.LETTRUNCATE 1) 
          (setq _verboseSemCount.LETTRUNCATE (iadd _verboseSemCount.LETTRUNCATE 1)))

   (if (and (<> _verboseSemIn.LETTRUNCATE #void) (> _verboseSemIn.LETTRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting LETTRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFTRUNCATE
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFTRUNCATE)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LET
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LET)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: LETTRUNCATE: [ REFTRUNCATE LET ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {LETTRUNCATE: [ REFTRUNCATE LET ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LET
           ) ; end begin
         ) ; end case : REFTRUNCATE
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule LETTRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.LETTRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.LETTRUNCATE _verboseSemIn.LETTRUNCATE) (error "Count" "in Routine LETTRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_LETTRUNCATE










;;**EXPORTKEY**:javaScript:_SEMRULE_MAIN
;; ************************************************
;; MAIN user defined Semantic Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: MAIN: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.MAIN #void) 
          (setq _verboseSemCount.MAIN 1) 
          (setq _verboseSemCount.MAIN (iadd _verboseSemCount.MAIN 1)))

   (if (and (<> _verboseSemIn.MAIN #void) (> _verboseSemIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: [ Any ] ] :: $2 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk2 )
                        (if _verbose 
                            (writeRule
                                 {MAIN: [ Any ] ] :: $2 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any
         ;; ====================
         ;; case: Any{(= _tk2 |Any*|:)}
         ;; ====================
         (if (begin (setq _ip _ip1)
          (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 |Any*|:)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: [ Any{(= _tk2 |Any*|:)} ] ] :: (objectToList $2) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (objectToList _tk2) )
                        (if _verbose 
                            (writeRule
                                 {MAIN: [ Any{(= _tk2 |Any*|:)} ] ] :: (objectToList $2) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any{(= _tk2 |Any*|:)}
       ) ; end begin
     ) ; end case : [
     ;; ====================
     ;; case: Any{(= _tk1 "begin")}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken)) morphFail) true (setq _ip _ip0)) (= _tk1 "begin")))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: ]
             ;; ====================
             (if (if (_eofToken) (_popIp) false)
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; *********************************************************
                 ;; RULE: MAIN: Any{(= _tk1 "begin")} Any ] :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {MAIN: Any{(= _tk1 "begin")} Any ] :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
(setq _indent (isub _indent))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ]
           ) ; end begin
         ) ; end case : Any
         ;; ====================
         ;; case: TRUNCATE
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "begin")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "begin"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: TRUNCATE
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; ====================
                                     ;; case: ]
                                     ;; ====================
                                     (if (if (_eofToken) (_popIp) false)
                                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 (copy _ip))
                                         ;; *********************************************************
                                         ;; RULE: MAIN: Any{(= _tk1 "begin")} TRUNCATE [ Any{(= _tk4 "begin")} TRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $5)))                                           $6 $7)                                      ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list lambda: '(_x) '(onError (lambda(s) false)) (list and: _tk2 _tk5)))                                           _tk6 _tk7)                                      )
                                            (if _verbose 
                                                (writeRule
                                                     {MAIN: Any{(= _tk1 "begin")} TRUNCATE [ Any{(= _tk4 "begin")} TRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $5)))                                           $6 $7)                                      ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
(setq _indent (isub _indent))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : ]
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : TRUNCATE
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "begin")}
               ) ; end begin
             ) ; end case : [
             ;; ====================
             ;; case: TRUNCATE
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SEMRULE_TRUNCATE)) morphFail)true (setq _ip _ip2)))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} TRUNCATE TRUNCATE ] :: (list                                            '(ref cursor truncate:)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $3)))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref cursor truncate:)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list and: _tk2 _tk3)))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} TRUNCATE TRUNCATE ] :: (list                                            '(ref cursor truncate:)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list and: $2 $3)))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : TRUNCATE
           ) ; end begin
         ) ; end case : TRUNCATE
         ;; ====================
         ;; case: LETTRUNCATE
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: [
             ;; ====================
             (if (if (isPair (setq _tk3 (_getToken))) (_pushIp) (_lastIp))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "begin")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "begin"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: LETTRUNCATE
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip4))
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; ====================
                         ;; case: Any
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken)) morphFail) true (setq _ip _ip5))
                           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 (copy _ip))
                             ;; ====================
                             ;; case: Any
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken)) morphFail) true (setq _ip _ip6))
                               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 (copy _ip))
                                 ;; ====================
                                 ;; case: ]
                                 ;; ====================
                                 (if (if (_eofToken) (_popIp) false)
                                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 (copy _ip))
                                     ;; ====================
                                     ;; case: ]
                                     ;; ====================
                                     (if (if (_eofToken) (_popIp) false)
                                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 (copy _ip))
                                         ;; *********************************************************
                                         ;; RULE: MAIN: Any{(= _tk1 "begin")} LETTRUNCATE [ Any{(= _tk4 "begin")} LETTRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list (symbol "let") (ref $2 0)                                                 (list lambda: '(_x) '(onError (lambda(s) false))                                                                       (list and: (ref $2 1) (ref $5 1)))))                                            $6 $7)                                      ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list (symbol "let") (ref _tk2 0)                                                 (list lambda: '(_x) '(onError (lambda(s) false))                                                                       (list and: (ref _tk2 1) (ref _tk5 1)))))                                            _tk6 _tk7)                                      )
                                            (if _verbose 
                                                (writeRule
                                                     {MAIN: Any{(= _tk1 "begin")} LETTRUNCATE [ Any{(= _tk4 "begin")} LETTRUNCATE Any Any ] ] :: (list (symbol "begin")                                           (list                                               '(ref cursor truncate:)                                               (list (symbol "let") (ref $2 0)                                                 (list lambda: '(_x) '(onError (lambda(s) false))                                                                       (list and: (ref $2 1) (ref $5 1)))))                                            $6 $7)                                      ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
(setq _indent (isub _indent))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : ]
                                   ) ; end begin
                                 ) ; end case : ]
                               ) ; end begin
                             ) ; end case : Any
                           ) ; end begin
                         ) ; end case : Any
                       ) ; end begin
                     ) ; end case : LETTRUNCATE
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "begin")}
               ) ; end begin
             ) ; end case : [
             ;; ====================
             ;; case: LETTRUNCATE
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SEMRULE_LETTRUNCATE)) morphFail)true (setq _ip _ip2)))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} LETTRUNCATE LETTRUNCATE ] :: (list                                            '(ref cursor truncate:)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list and: (ref $2 1) (ref $3 1)))))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref cursor truncate:)                                           (list (symbol "let") (ref _tk2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list and: (ref _tk2 1) (ref _tk3 1)))))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} LETTRUNCATE LETTRUNCATE ] :: (list                                            '(ref cursor truncate:)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list and: (ref $2 1) (ref $3 1)))))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LETTRUNCATE
           ) ; end begin
         ) ; end case : LETTRUNCATE
         ;; ====================
         ;; case: OMIT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_OMIT)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: OMIT
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_OMIT)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} OMIT OMIT ] :: (list                                            '(ref cursor omit)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list or: $2 $3)))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref cursor omit)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list or: _tk2 _tk3)))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} OMIT OMIT ] :: (list                                            '(ref cursor omit)                                            (list lambda: '(_x) '(onError (lambda(s) false)) (list or: $2 $3)))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : OMIT
           ) ; end begin
         ) ; end case : OMIT
         ;; ====================
         ;; case: LETOMIT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SEMRULE_LETOMIT)) morphFail)true (setq _ip _ip1)))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LETOMIT
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LETOMIT)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: MAIN: Any{(= _tk1 "begin")} LETOMIT LETOMIT ] :: (list                                            '(ref cursor omit)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list or: (ref $2 1) (ref $3 1)))))                                      ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (list                                            '(ref cursor omit)                                           (list (symbol "let") (ref _tk2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list or: (ref _tk2 1) (ref _tk3 1)))))                                      )
                        (if _verbose 
                            (writeRule
                                 {MAIN: Any{(= _tk1 "begin")} LETOMIT LETOMIT ] :: (list                                            '(ref cursor omit)                                           (list (symbol "let") (ref $2 0)                                              (list lambda: '(_x) '(onError (lambda(s) false))                                                                    (list or: (ref $2 1) (ref $3 1)))))                                      ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LETOMIT
           ) ; end begin
         ) ; end case : LETOMIT
       ) ; end begin
     ) ; end case : Any{(= _tk1 "begin")}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.MAIN _verboseSemIn.MAIN) (error "Count" "in Routine MAIN"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_MAIN










;;**EXPORTKEY**:javaScript:_SEMRULE_OMIT
;; ************************************************
;; OMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the OMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_OMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: OMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.OMIT #void) 
          (setq _verboseSemCount.OMIT 1) 
          (setq _verboseSemCount.OMIT (iadd _verboseSemCount.OMIT 1)))

   (if (and (<> _verboseSemIn.OMIT #void) (> _verboseSemIn.OMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting OMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFOMIT
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFOMIT)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LAMBDA
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: OMIT: [ REFOMIT LAMBDA ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {OMIT: [ REFOMIT LAMBDA ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LAMBDA
           ) ; end begin
         ) ; end case : REFOMIT
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule OMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.OMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.OMIT _verboseSemIn.OMIT) (error "Count" "in Routine OMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_OMIT










;;**EXPORTKEY**:javaScript:_SEMRULE_REFOMIT
;; ************************************************
;; REFOMIT user defined Semantic Rule implementation
;; Summary: This Lambda implements the REFOMIT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_REFOMIT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFOMIT: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.REFOMIT #void) 
          (setq _verboseSemCount.REFOMIT 1) 
          (setq _verboseSemCount.REFOMIT (iadd _verboseSemCount.REFOMIT 1)))

   (if (and (<> _verboseSemIn.REFOMIT #void) (> _verboseSemIn.REFOMIT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFOMIT Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "ref")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "ref"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any{(= _tk3 "cursor")}
             ;; ====================
             (if (and (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2)) (= _tk3 "cursor"))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "omit")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "omit"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: REFOMIT: [ Any{(= _tk2 "ref")} Any{(= _tk3 "cursor")} Any{(= _tk4 "omit")} ] :: (list $2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (list _tk2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {REFOMIT: [ Any{(= _tk2 "ref")} Any{(= _tk3 "cursor")} Any{(= _tk4 "omit")} ] :: (list $2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "omit")}
               ) ; end begin
             ) ; end case : Any{(= _tk3 "cursor")}
           ) ; end begin
         ) ; end case : Any{(= _tk2 "ref")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFOMIT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.REFOMIT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.REFOMIT _verboseSemIn.REFOMIT) (error "Count" "in Routine REFOMIT"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_REFOMIT










;;**EXPORTKEY**:javaScript:_SEMRULE_REFTRUNCATE
;; ************************************************
;; REFTRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the REFTRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_REFTRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFTRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.REFTRUNCATE #void) 
          (setq _verboseSemCount.REFTRUNCATE 1) 
          (setq _verboseSemCount.REFTRUNCATE (iadd _verboseSemCount.REFTRUNCATE 1)))

   (if (and (<> _verboseSemIn.REFTRUNCATE #void) (> _verboseSemIn.REFTRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFTRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: Any{(= _tk2 "ref")}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_getToken)) morphFail) true (setq _ip _ip1)) (= _tk2 "ref"))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: Any{(= _tk3 "cursor")}
             ;; ====================
             (if (and (if (<> (setq _tk3 (_getToken)) morphFail) true (setq _ip _ip2)) (= _tk3 "cursor"))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: Any{(= _tk4 "truncate")}
                 ;; ====================
                 (if (and (if (<> (setq _tk4 (_getToken)) morphFail) true (setq _ip _ip3)) (= _tk4 "truncate"))
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; ====================
                     ;; case: ]
                     ;; ====================
                     (if (if (_eofToken) (_popIp) false)
                       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 (copy _ip))
                         ;; *********************************************************
                         ;; RULE: REFTRUNCATE: [ Any{(= _tk2 "ref")} Any{(= _tk3 "cursor")} Any{(= _tk4 "truncate")} ] :: (list $2 $3 $4) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (list _tk2 _tk3 _tk4) )
                            (if _verbose 
                                (writeRule
                                     {REFTRUNCATE: [ Any{(= _tk2 "ref")} Any{(= _tk3 "cursor")} Any{(= _tk4 "truncate")} ] :: (list $2 $3 $4) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
(setq _indent (isub _indent))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : ]
                   ) ; end begin
                 ) ; end case : Any{(= _tk4 "truncate")}
               ) ; end begin
             ) ; end case : Any{(= _tk3 "cursor")}
           ) ; end begin
         ) ; end case : Any{(= _tk2 "ref")}
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFTRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.REFTRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.REFTRUNCATE _verboseSemIn.REFTRUNCATE) (error "Count" "in Routine REFTRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_REFTRUNCATE










;;**EXPORTKEY**:javaScript:_SEMRULE_TRUNCATE
;; ************************************************
;; TRUNCATE user defined Semantic Rule implementation
;; Summary: This Lambda implements the TRUNCATE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SEMRULE_TRUNCATE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5 _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5 _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: TRUNCATE: true))
   (setq _tkn 0)
   (setq _oldIp (copy _ip))
   (setq _repeatSW true)

   (if (= _verboseSemCount.TRUNCATE #void) 
          (setq _verboseSemCount.TRUNCATE 1) 
          (setq _verboseSemCount.TRUNCATE (iadd _verboseSemCount.TRUNCATE 1)))

   (if (and (<> _verboseSemIn.TRUNCATE #void) (> _verboseSemIn.TRUNCATE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::         
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting TRUNCATE Rule on: " source:))
     (setq _ip0 (copy _ip))
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************







     ;; ====================
     ;; case: [
     ;; ====================
     (if (if (isPair (setq _tk1 (_getToken))) (_pushIp) (_lastIp))
       (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 (copy _ip))
         ;; ====================
         ;; case: REFTRUNCATE
         ;; ====================
         (if (if (<> (setq _tk2 (_SEMRULE_REFTRUNCATE)) morphFail)true (setq _ip _ip1))
           (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 (copy _ip))
             ;; ====================
             ;; case: LAMBDA
             ;; ====================
             (if (if (<> (setq _tk3 (_SEMRULE_LAMBDA)) morphFail)true (setq _ip _ip2))
               (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 (copy _ip))
                 ;; ====================
                 ;; case: ]
                 ;; ====================
                 (if (if (_eofToken) (_popIp) false)
                   (begin (setq _ruleCount (+ _ruleCount 1)) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 (copy _ip))
                     ;; *********************************************************
                     ;; RULE: TRUNCATE: [ REFTRUNCATE LAMBDA ] :: $3 ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  _tk3 )
                        (if _verbose 
                            (writeRule
                                 {TRUNCATE: [ REFTRUNCATE LAMBDA ] :: $3 ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
(setq _indent (isub _indent))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ]
               ) ; end begin
             ) ; end case : LAMBDA
           ) ; end begin
         ) ; end case : REFTRUNCATE
       ) ; end begin
     ) ; end case : [
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule TRUNCATE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Semantic Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.

   (if (> _verboseSemIn.TRUNCATE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSemCount.TRUNCATE _verboseSemIn.TRUNCATE) (error "Count" "in Routine TRUNCATE"))
       ))
   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SEMRULE_TRUNCATE










;;**EXPORTKEY**:javaScript:_SYNRULE_ARGLIST
;; ************************************************
;; ARGLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the ARGLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_ARGLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: ARGLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.ARGLIST #void) 
          (setq _verboseSynCount.ARGLIST 1) 
          (setq _verboseSynCount.ARGLIST (iadd _verboseSynCount.ARGLIST 1)))

   (if (and (<> _verboseSynIn.ARGLIST #void) (> _verboseSynIn.ARGLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting ARGLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ARGLIST: RightParen :: (setq $0.Value #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value #void) )
            (if _verbose 
                (writeRule
                     {ARGLIST: RightParen :: (setq $0.Value #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {ARGLIST: SEXPRESSION Comma ARGLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                (if _verbose 
                    (writeRule
                         {ARGLIST: SEXPRESSION RightParen :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightParen
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 137" _tk1.Charpos "Invalid argument list"))
            (if _verbose 
                (writeRule
                     {ARGLIST: Value :: (_makeError "JS 137" $1.Charpos "Invalid argument list")::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule ARGLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.ARGLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.ARGLIST _verboseSynIn.ARGLIST) (error "Count" "in Routine ARGLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_ARGLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_CFCALL
;; ************************************************
;; CFCALL user defined Syntax Rule implementation
;; Summary: This Lambda implements the CFCALL
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_CFCALL(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CFCALL: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CFCALL #void) 
          (setq _verboseSynCount.CFCALL 1) 
          (setq _verboseSynCount.CFCALL (iadd _verboseSynCount.CFCALL 1)))

   (if (and (<> _verboseSynIn.CFCALL #void) (> _verboseSynIn.CFCALL -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CFCALL Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: DotOperator
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[DotOperator:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CFCALL (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Name CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: ARGLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (sendList _tk0 _tk2.Value _ak0.Value _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {CFCALL: DotOperator Name LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ARGLIST
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Name LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 117" _tk1.Charpos "Invalid function call") )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Name LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Name
         ;; ====================
         ;; case: Reserved
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Reserved:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CFCALL (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Reserved CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CFCALL((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: ARGLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (sendList _tk0 _tk2.Value _ak0.Value _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {CFCALL: DotOperator Reserved LeftParen ARGLIST :: (sendList $0 $2.Value %0.Value $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : ARGLIST
                 ;; *********************************************************
                 ;; RULE: CFCALL: DotOperator Reserved LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 117" _tk1.Charpos "Invalid function call") )
                    (if _verbose 
                        (writeRule
                             {CFCALL: DotOperator Reserved LeftParen :: (_makeError "JS 117" $1.Charpos "Invalid function call") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Reserved
       ) ; end begin
     ) ; end case : DotOperator
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CFCALL on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CFCALL -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CFCALL _verboseSynIn.CFCALL) (error "Count" "in Routine CFCALL"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CFCALL



















;;**EXPORTKEY**:javaScript:_SYNRULE_CHILD
;; ************************************************
;; CHILD user defined Syntax Rule implementation
;; Summary: This Lambda implements the CHILD
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_CHILD(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CHILD: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CHILD #void) 
          (setq _verboseSynCount.CHILD 1) 
          (setq _verboseSynCount.CHILD (iadd _verboseSynCount.CHILD 1)))

   (if (and (<> _verboseSynIn.CHILD #void) (> _verboseSynIn.CHILD -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CHILD Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Child
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Child:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CHILD: Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {CHILD: Child :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Child
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CHILD on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CHILD -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CHILD _verboseSynIn.CHILD) (error "Count" "in Routine CHILD"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CHILD



















;;**EXPORTKEY**:javaScript:_SYNRULE_CLASS
;; ************************************************
;; CLASS user defined Syntax Rule implementation
;; Summary: This Lambda implements the CLASS
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_CLASS(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CLASS: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CLASS #void) 
          (setq _verboseSynCount.CLASS 1) 
          (setq _verboseSynCount.CLASS (iadd _verboseSynCount.CLASS 1)))

   (if (and (<> _verboseSynIn.CLASS #void) (> _verboseSynIn.CLASS -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CLASS Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Class
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Class:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CLASS: Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {CLASS: Class :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Class
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CLASS on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CLASS -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CLASS _verboseSynIn.CLASS) (error "Count" "in Routine CLASS"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CLASS



















;;**EXPORTKEY**:javaScript:_SYNRULE_CUT
;; ************************************************
;; CUT user defined Syntax Rule implementation
;; Summary: This Lambda implements the CUT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_CUT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: CUT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.CUT #void) 
          (setq _verboseSynCount.CUT 1) 
          (setq _verboseSynCount.CUT (iadd _verboseSynCount.CUT 1)))

   (if (and (<> _verboseSynIn.CUT #void) (> _verboseSynIn.CUT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting CUT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Number
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Percent
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Percent:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (foldConstants _tk0 |/|: _tk1.Value 100) )
                (if _verbose 
                    (writeRule
                         {CUT: Number Percent :: (foldConstants $0 |/|: $1.Value 100) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Percent
         ;; *********************************************************
         ;; RULE: CUT: Number :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {CUT: Number :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: CUT: SEXPRESSION :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {CUT: SEXPRESSION :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule CUT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.CUT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.CUT _verboseSynIn.CUT) (error "Count" "in Routine CUT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_CUT



















;;**EXPORTKEY**:javaScript:_SYNRULE_EXPRESSION
;; ************************************************
;; EXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the EXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_EXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: EXPRESSION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.EXPRESSION #void) 
          (setq _verboseSynCount.EXPRESSION 1) 
          (setq _verboseSynCount.EXPRESSION (iadd _verboseSynCount.EXPRESSION 1)))

   (if (and (<> _verboseSynIn.EXPRESSION #void) (> _verboseSynIn.EXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting EXPRESSION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: PHRASE
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: EXPRESSION: PHRASE Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setVTypePrecedence _tk0 (append (list _tk1 _tk2) _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {EXPRESSION: PHRASE Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : PEXPRESSION
             ;; *********************************************************
             ;; RULE: EXPRESSION: PHRASE Operator :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 102" _tk2.Charpos (append "Invalid use of " _tk2.Value " operator")) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: PHRASE Operator :: (_makeError "JS 102" $2.Charpos (append "Invalid use of " $2.Value " operator")) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Operator
         ;; *********************************************************
         ;; RULE: EXPRESSION: PHRASE :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: PHRASE :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : PHRASE
     ;; ====================
     ;; case: TERM
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: EXPRESSION: TERM Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setVTypePrecedence _tk0 (append (list _tk1 _tk2) _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {EXPRESSION: TERM Operator PEXPRESSION :: (setVTypePrecedence $0 (append (list $1 $2) $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : PEXPRESSION
             ;; *********************************************************
             ;; RULE: EXPRESSION: TERM Operator :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 103" _tk2.Charpose (append "Invalid use of " _tk2.Value " operator")) )
                (if _verbose 
                    (writeRule
                         {EXPRESSION: TERM Operator :: (_makeError "JS 103" $2.Charpose (append "Invalid use of " $2.Value " operator")) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Operator
         ;; *********************************************************
         ;; RULE: EXPRESSION: TERM :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: TERM :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : TERM
     ;; ====================
     ;; case: STATEMENT
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_STATEMENT)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: EXPRESSION: STATEMENT :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {EXPRESSION: STATEMENT :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: EXPRESSION: STATEMENT Operator SEXPRESSION :: (setExpVType $0 $1 $2 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setExpVType _tk0 _tk1 _tk2 _tk3) )
                    (if _verbose 
                        (writeRule
                             {EXPRESSION: STATEMENT Operator SEXPRESSION :: (setExpVType $0 $1 $2 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : Operator
       ) ; end begin
     ) ; end case : STATEMENT
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule EXPRESSION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.EXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.EXPRESSION _verboseSynIn.EXPRESSION) (error "Count" "in Routine EXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_EXPRESSION



















;;**EXPORTKEY**:javaScript:_SYNRULE_FIELDLIST
;; ************************************************
;; FIELDLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the FIELDLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FIELDLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FIELDLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FIELDLIST #void) 
          (setq _verboseSynCount.FIELDLIST 1) 
          (setq _verboseSynCount.FIELDLIST (iadd _verboseSynCount.FIELDLIST 1)))

   (if (and (<> _verboseSynIn.FIELDLIST #void) (> _verboseSynIn.FIELDLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FIELDLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: RightBrace
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[RightBrace:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                (if _verbose 
                    (writeRule
                         {FIELDLIST: Name RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightBrace
         ;; ====================
         ;; case: Semicolon
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Semicolon:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: FIELDLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {FIELDLIST: Name Semicolon FIELDLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : FIELDLIST
             ;; ====================
             ;; case: RightBrace
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightBrace:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (new Vector: 1 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {FIELDLIST: Name Semicolon RightBrace :: (setq $0.Value (new Vector: 1 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightBrace
           ) ; end begin
         ) ; end case : Semicolon
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: RightBrace
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightBrace:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (new Vector: 0)) )
            (if _verbose 
                (writeRule
                     {FIELDLIST: RightBrace :: (setq $0.Value (new Vector: 0)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightBrace
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 139" _tk1.Charpos "Invalid field list") )
            (if _verbose 
                (writeRule
                     {FIELDLIST: Value :: (_makeError "JS 139" $1.Charpos "Invalid field list") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FIELDLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FIELDLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FIELDLIST _verboseSynIn.FIELDLIST) (error "Count" "in Routine FIELDLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FIELDLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_FILTER
;; ************************************************
;; FILTER user defined Syntax Rule implementation
;; Summary: This Lambda implements the FILTER
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FILTER(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FILTER: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FILTER #void) 
          (setq _verboseSynCount.FILTER 1) 
          (setq _verboseSynCount.FILTER (iadd _verboseSynCount.FILTER 1)))

   (if (and (<> _verboseSynIn.FILTER #void) (> _verboseSynIn.FILTER -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FILTER Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: FSTMTLIST
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_FSTMTLIST)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (filterFinal _tk1.Value)) )
            (if _verbose 
                (writeRule
                     {FILTER: FSTMTLIST :: (setq $0.Value (filterFinal $1.Value)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FSTMTLIST
     ;; ====================
     ;; case: Filter
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Filter:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: FSTMTLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_FSTMTLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FILTER: Filter FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (filterFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {FILTER: Filter FSTMTLIST :: (setq $0.Value (filterFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : FSTMTLIST
       ) ; end begin
     ) ; end case : Filter
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FILTER on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FILTER -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FILTER _verboseSynIn.FILTER) (error "Count" "in Routine FILTER"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FILTER



















;;**EXPORTKEY**:javaScript:_SYNRULE_FRIEND
;; ************************************************
;; FRIEND user defined Syntax Rule implementation
;; Summary: This Lambda implements the FRIEND
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FRIEND(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FRIEND: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FRIEND #void) 
          (setq _verboseSynCount.FRIEND 1) 
          (setq _verboseSynCount.FRIEND (iadd _verboseSynCount.FRIEND 1)))

   (if (and (<> _verboseSynIn.FRIEND #void) (> _verboseSynIn.FRIEND -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FRIEND Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Friend
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Friend:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FRIEND: Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {FRIEND: Friend :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Friend
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FRIEND on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FRIEND -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FRIEND _verboseSynIn.FRIEND) (error "Count" "in Routine FRIEND"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FRIEND



















;;**EXPORTKEY**:javaScript:_SYNRULE_FSTATEMENT
;; ************************************************
;; FSTATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the FSTATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FSTATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FSTATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FSTATEMENT #void) 
          (setq _verboseSynCount.FSTATEMENT 1) 
          (setq _verboseSynCount.FSTATEMENT (iadd _verboseSynCount.FSTATEMENT 1)))

   (if (and (<> _verboseSynIn.FSTATEMENT #void) (> _verboseSynIn.FSTATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FSTATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Sort{(xReferentOn)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Sort:] #void) true (setq _ip _ip0)) (xReferentOn))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Backup
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Backup:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Direction
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Direction:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SEXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Sort{(xReferentOn)} Backup Direction SEXPRESSION :: (sortCut $0 $3.Lisp $4.Value -2) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (sortCut _tk0 _tk3.Lisp _tk4.Value -2) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Sort{(xReferentOn)} Backup Direction SEXPRESSION :: (sortCut $0 $3.Lisp $4.Value -2) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SEXPRESSION
               ) ; end begin
             ) ; end case : Direction
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Sort{(xReferentOn)} Backup SEXPRESSION :: (sortCut $0 |<=|: $3.Value -2) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (sortCut _tk0 |<=|: _tk3.Value -2) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Sort{(xReferentOn)} Backup SEXPRESSION :: (sortCut $0 |<=|: $3.Value -2) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : Backup
         ;; ====================
         ;; case: Direction
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Direction:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (sortCut _tk0 _tk2.Lisp _tk3.Value -1) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Sort{(xReferentOn)} Direction SEXPRESSION :: (sortCut $0 $2.Lisp $3.Value -1) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : Direction
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (sortCut _tk0 |<=|: _tk2.Value -1) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Sort{(xReferentOn)} SEXPRESSION :: (sortCut $0 |<=|: $2.Value -1) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Sort{(xReferentOn)}
     ;; ====================
     ;; case: Cut{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Cut:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CUT
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (sortCut _tk0 _tk1.Lisp _tk2.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Cut{(xReferentOn)} SEXPRESSION CUT :: (sortCut $0 $1.Lisp $2.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : CUT
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Cut{(xReferentOn)}
     ;; ====================
     ;; case: Slice{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Slice:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: CUT
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Of
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Of:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: CUT
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_CUT)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (sliceCut _tk0 _tk1.Lisp _tk2.Value _tk3.Value _tk5.Value) )
                            (if _verbose 
                                (writeRule
                                     {FSTATEMENT: Slice{(xReferentOn)} SEXPRESSION CUT Of CUT :: (sliceCut $0 $1.Lisp $2.Value $3.Value $5.Value) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : CUT
                   ) ; end begin
                 ) ; end case : Of
               ) ; end begin
             ) ; end case : CUT
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Slice{(xReferentOn)}
     ;; ====================
     ;; case: All{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[All:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Semicolon
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Semicolon:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value true) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: All{(xReferentOn)} Semicolon :: (setq $0.Value true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Semicolon
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (filterCut _tk0 _tk2.Value _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: All{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setq _tk0.Value true) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: All{(xReferentOn)} :: (setq $0.Value true) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : All{(xReferentOn)}
     ;; ====================
     ;; case: Setnr{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Setnr:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: EXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Setnr{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value false) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (filterUpdate _tk0 _tk2.Value _tk4.Value false) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Setnr{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value false) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : EXPRESSION
               ) ; end begin
             ) ; end case : InitializeOperator
             ;; ====================
             ;; case: EXPRESSION
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Setnr{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value false) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (filterUpdate _tk0 _tk2.Value _tk3.Value false) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Setnr{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value false) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : EXPRESSION
           ) ; end begin
         ) ; end case : NAME
       ) ; end begin
     ) ; end case : Setnr{(xReferentOn)}
     ;; ====================
     ;; case: Set{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Set:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: EXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: FSTATEMENT: Set{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value true) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (filterUpdate _tk0 _tk2.Value _tk4.Value true) )
                        (if _verbose 
                            (writeRule
                                 {FSTATEMENT: Set{(xReferentOn)} NAME InitializeOperator EXPRESSION :: (filterUpdate $0 $2.Value $4.Value true) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : EXPRESSION
               ) ; end begin
             ) ; end case : InitializeOperator
             ;; ====================
             ;; case: EXPRESSION
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: FSTATEMENT: Set{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value true) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (filterUpdate _tk0 _tk2.Value _tk3.Value true) )
                    (if _verbose 
                        (writeRule
                             {FSTATEMENT: Set{(xReferentOn)} NAME EXPRESSION :: (filterUpdate $0 $2.Value $3.Value true) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : EXPRESSION
           ) ; end begin
         ) ; end case : NAME
       ) ; end begin
     ) ; end case : Set{(xReferentOn)}
     ;; ====================
     ;; case: Run{(xReferentOff)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Run:] #void) true (setq _ip _ip0)) (xReferentOff)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (runFilter _tk0 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Run{(xReferentOff)} SEXPRESSION :: (runFilter $0 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Run{(xReferentOff)}
     ;; ====================
     ;; case: Restore{(xReferentOff)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Restore:] #void) true (setq _ip _ip0)) (xReferentOff)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: cursor: ''restore))) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (list (list |ref|: cursor: ''restore))) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: Restore{(xReferentOff)} :: (setq $0.Value (list (list |ref|: cursor: ''restore))) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Restore{(xReferentOff)}
     ;; ====================
     ;; case: Omit{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Omit:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Omit{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (filterCut _tk0 _tk2.Value _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Omit{(xReferentOn)} SEXPRESSION :: (filterCut $0 $2.Value $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : Omit{(xReferentOn)}
     ;; ====================
     ;; case: Check{(begin (xReferentOn) (autoCheckOn $0) true)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Check:] #void) true (setq _ip _ip0)) (begin (xReferentOn) (autoCheckOn _tk0) true)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAMELIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAMELIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: FSTATEMENT: Check{(begin (xReferentOn) (autoCheckOn $0) true)} NAMELIST :: (setq $0.Value (autoCheck)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (autoCheck)) )
                (if _verbose 
                    (writeRule
                         {FSTATEMENT: Check{(begin (xReferentOn) (autoCheckOn $0) true)} NAMELIST :: (setq $0.Value (autoCheck)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NAMELIST
       ) ; end begin
     ) ; end case : Check{(begin (xReferentOn) (autoCheckOn $0) true)}
     ;; ====================
     ;; case: Checkoff{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Checkoff:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTATEMENT: Checkoff{(xReferentOn)} :: (autoCheckOff $0) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (autoCheckOff _tk0) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: Checkoff{(xReferentOn)} :: (autoCheckOff $0) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Checkoff{(xReferentOn)}
     ;; ====================
     ;; case: Checkon{(xReferentOn)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Checkon:] #void) true (setq _ip _ip0)) (xReferentOn)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTATEMENT: Checkon{(xReferentOn)} :: (autoCheckOn $0) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (autoCheckOn _tk0) )
            (if _verbose 
                (writeRule
                     {FSTATEMENT: Checkon{(xReferentOn)} :: (autoCheckOn $0) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Checkon{(xReferentOn)}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FSTATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FSTATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FSTATEMENT _verboseSynIn.FSTATEMENT) (error "Count" "in Routine FSTATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FSTATEMENT



















;;**EXPORTKEY**:javaScript:_SYNRULE_FSTMTLIST
;; ************************************************
;; FSTMTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the FSTMTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FSTMTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FSTMTLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FSTMTLIST #void) 
          (setq _verboseSynCount.FSTMTLIST 1) 
          (setq _verboseSynCount.FSTMTLIST (iadd _verboseSynCount.FSTMTLIST 1)))

   (if (and (<> _verboseSynIn.FSTMTLIST #void) (> _verboseSynIn.FSTMTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FSTMTLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: FSTATEMENT
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_FSTATEMENT)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToBeginList _tk0 _tk1.Value) )
            (if _verbose 
                (writeRule
                     {FSTMTLIST: FSTATEMENT << (addToBeginList $0 $1.Value) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : FSTATEMENT
     ;; ====================
     ;; case: Semicolon
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Semicolon:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FSTMTLIST: Semicolon << $0 >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {FSTMTLIST: Semicolon << $0 >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : Semicolon
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FSTMTLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FSTMTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FSTMTLIST _verboseSynIn.FSTMTLIST) (error "Count" "in Routine FSTMTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FSTMTLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_FUNCTION
;; ************************************************
;; FUNCTION user defined Syntax Rule implementation
;; Summary: This Lambda implements the FUNCTION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_FUNCTION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: FUNCTION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.FUNCTION #void) 
          (setq _verboseSynCount.FUNCTION 1) 
          (setq _verboseSynCount.FUNCTION (iadd _verboseSynCount.FUNCTION 1)))

   (if (and (<> _verboseSynIn.FUNCTION #void) (> _verboseSynIn.FUNCTION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting FUNCTION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Function
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Function:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {FUNCTION: Function :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Function
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule FUNCTION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.FUNCTION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.FUNCTION _verboseSynIn.FUNCTION) (error "Count" "in Routine FUNCTION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_FUNCTION



















;;**EXPORTKEY**:javaScript:_SYNRULE_MAIN
;; ************************************************
;; MAIN user defined Syntax Rule implementation
;; Summary: This Lambda implements the MAIN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_MAIN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: MAIN: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.MAIN #void) 
          (setq _verboseSynCount.MAIN 1) 
          (setq _verboseSynCount.MAIN (iadd _verboseSynCount.MAIN 1)))

   (if (and (<> _verboseSynIn.MAIN #void) (> _verboseSynIn.MAIN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting MAIN Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: #
     ;; ====================
     (if (if (= (setq _tk1 (_getToken))[Value:] |#|:) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: "javaScript"
         ;; ====================
         (if (if (= (setq _tk2 (_getToken))[Value:] "javaScript") true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: #
             ;; ====================
             (if (if (= (setq _tk3 (_getToken))[Value:] |#|:) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: MAIN: # "javaScript" # || (= $3.Charpos 11) || << true >>
                 ;; *********************************************************
                 (if  (= _tk3.Charpos 11) 
                  (begin
                    (setq _ret  true )
                    (if _verbose 
                        (writeRule
                             {MAIN: # "javaScript" # || (= $3.Charpos 11) || << true >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (goto Skip:))

                 ) ; end case : _default
               ) ; end begin
             ) ; end case : #
           ) ; end begin
         ) ; end case : "javaScript"
         ;; ====================
         ;; case: "dataMineLib"
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (= (setq _tk2 (_getToken))[Value:] "dataMineLib") true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: #
             ;; ====================
             (if (if (= (setq _tk3 (_getToken))[Value:] |#|:) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: MAIN: # "dataMineLib" # || (= $3.Charpos 14) || << true >>
                 ;; *********************************************************
                 (if  (= _tk3.Charpos 14) 
                  (begin
                    (setq _ret  true )
                    (if _verbose 
                        (writeRule
                             {MAIN: # "dataMineLib" # || (= $3.Charpos 14) || << true >>}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (goto Skip:))

                 ) ; end case : _default
               ) ; end begin
             ) ; end case : #
           ) ; end begin
         ) ; end case : "dataMineLib"
       ) ; end begin
     ) ; end case : #
     ;; ====================
     ;; case: STMTLIST
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Eof
         ;; ====================
         (if (if (_eofToken)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Eof :: (list $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (list _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {MAIN: STMTLIST Eof :: (list $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Eof
         ;; ====================
         ;; case: Value
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Value:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 100" _tk2.Charpos "Invalid expression") )
                (if _verbose 
                    (writeRule
                         {MAIN: STMTLIST Value :: (_makeError "JS 100" $2.Charpos "Invalid expression") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Value
       ) ; end begin
     ) ; end case : STMTLIST
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 101" _tk1.Charpos "Invalid expression") )
            (if _verbose 
                (writeRule
                     {MAIN: Value :: (_makeError "JS 101" $1.Charpos "Invalid expression") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; ====================
     ;; case: Eof
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (_eofToken)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: MAIN: Eof :: (list #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (list #void) )
            (if _verbose 
                (writeRule
                     {MAIN: Eof :: (list #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Eof
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule MAIN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.MAIN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.MAIN _verboseSynIn.MAIN) (error "Count" "in Routine MAIN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_MAIN



















;;**EXPORTKEY**:javaScript:_SYNRULE_METHOD
;; ************************************************
;; METHOD user defined Syntax Rule implementation
;; Summary: This Lambda implements the METHOD
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_METHOD(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: METHOD: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.METHOD #void) 
          (setq _verboseSynCount.METHOD 1) 
          (setq _verboseSynCount.METHOD (iadd _verboseSynCount.METHOD 1)))

   (if (and (<> _verboseSynIn.METHOD #void) (> _verboseSynIn.METHOD -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting METHOD Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Method
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Method:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: METHOD: Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {METHOD: Method :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Method
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule METHOD on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.METHOD -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.METHOD _verboseSynIn.METHOD) (error "Count" "in Routine METHOD"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_METHOD



















;;**EXPORTKEY**:javaScript:_SYNRULE_NAME
;; ************************************************
;; NAME user defined Syntax Rule implementation
;; Summary: This Lambda implements the NAME
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_NAME(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: NAME: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.NAME #void) 
          (setq _verboseSynCount.NAME 1) 
          (setq _verboseSynCount.NAME (iadd _verboseSynCount.NAME 1)))

   (if (and (<> _verboseSynIn.NAME #void) (> _verboseSynIn.NAME -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting NAME Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Name{(isFieldName $0 $1)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)) (isFieldName _tk0 _tk1))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: QUALIFY((xReferent $0 $1))
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_QUALIFY (xReferent _tk0 _tk1))) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NAME: Name{(isFieldName $0 $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk2[Charpos:] _tk1.Charpos) )
                (if _verbose 
                    (writeRule
                         {NAME: Name{(isFieldName $0 $1)} QUALIFY((xReferent $0 $1)) :: (setq $2[Charpos:] $1.Charpos) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : QUALIFY((xReferent $0 $1))
         ;; *********************************************************
         ;; RULE: NAME: Name{(isFieldName $0 $1)} :: (xReferent $0 $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (xReferent _tk0 _tk1) )
            (if _verbose 
                (writeRule
                     {NAME: Name{(isFieldName $0 $1)} :: (xReferent $0 $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name{(isFieldName $0 $1)}
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: QUALIFY($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_QUALIFY _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk2[Charpos:] _tk1.Charpos) )
                (if _verbose 
                    (writeRule
                         {NAME: Name QUALIFY($1) :: (setq $2[Charpos:] $1.Charpos) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : QUALIFY($1)
         ;; *********************************************************
         ;; RULE: NAME: Name :: (setVType $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setVType _tk1) )
            (if _verbose 
                (writeRule
                     {NAME: Name :: (setVType $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule NAME on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.NAME -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.NAME _verboseSynIn.NAME) (error "Count" "in Routine NAME"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_NAME



















;;**EXPORTKEY**:javaScript:_SYNRULE_NAMELIST
;; ************************************************
;; NAMELIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the NAMELIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_NAMELIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: NAMELIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.NAMELIST #void) 
          (setq _verboseSynCount.NAMELIST 1) 
          (setq _verboseSynCount.NAMELIST (iadd _verboseSynCount.NAMELIST 1)))

   (if (and (<> _verboseSynIn.NAMELIST #void) (> _verboseSynIn.NAMELIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting NAMELIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Name{(isFieldName $0 $1)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)) (isFieldName _tk0 _tk1))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: NAMELIST: Name{(isFieldName $0 $1)} << $0 >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {NAMELIST: Name{(isFieldName $0 $1)} << $0 >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name{(isFieldName $0 $1)}
     ;; ====================
     ;; case: Nop
     ;; ====================
     (if (begin (setq _ip _ip0)
      (begin (setq _tk1 #void) true))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: NAMELIST: Nop :: $0 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {NAMELIST: Nop :: $0 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Nop
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule NAMELIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.NAMELIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.NAMELIST _verboseSynIn.NAMELIST) (error "Count" "in Routine NAMELIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_NAMELIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_ORPHAN
;; ************************************************
;; ORPHAN user defined Syntax Rule implementation
;; Summary: This Lambda implements the ORPHAN
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_ORPHAN(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: ORPHAN: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.ORPHAN #void) 
          (setq _verboseSynCount.ORPHAN 1) 
          (setq _verboseSynCount.ORPHAN (iadd _verboseSynCount.ORPHAN 1)))

   (if (and (<> _verboseSynIn.ORPHAN #void) (> _verboseSynIn.ORPHAN -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting ORPHAN Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Orphan
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Orphan:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: ORPHAN: Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (pushVars _tk0)[Charpos:] _tk1.Charpos) )
            (if _verbose 
                (writeRule
                     {ORPHAN: Orphan :: (setq (pushVars $0)[Charpos:] $1.Charpos) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Orphan
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule ORPHAN on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.ORPHAN -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.ORPHAN _verboseSynIn.ORPHAN) (error "Count" "in Routine ORPHAN"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_ORPHAN



















;;**EXPORTKEY**:javaScript:_SYNRULE_PARMLIST
;; ************************************************
;; PARMLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the PARMLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_PARMLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: PARMLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.PARMLIST #void) 
          (setq _verboseSynCount.PARMLIST 1) 
          (setq _verboseSynCount.PARMLIST (iadd _verboseSynCount.PARMLIST 1)))

   (if (and (<> _verboseSynIn.PARMLIST #void) (> _verboseSynIn.PARMLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting PARMLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PARMLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar avarVector obj: _tk1.Value (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) #void) )
                    (if _verbose 
                        (writeRule
                             {PARMLIST: Name Comma PARMLIST :: (addVar avarVector obj: $1.Value (setq $0.Value (insert $3.Value 0 $1.Value)) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : PARMLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (addVar avarVector obj: _tk1.Value (setq _tk0.Value (new Vector: 1 _tk1.Value)) #void) )
                (if _verbose 
                    (writeRule
                         {PARMLIST: Name RightParen :: (addVar avarVector obj: $1.Value (setq $0.Value (new Vector: 1 $1.Value)) #void) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightParen
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: RightParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[RightParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: PARMLIST: RightParen :: (setq $0.Value #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value #void) )
            (if _verbose 
                (writeRule
                     {PARMLIST: RightParen :: (setq $0.Value #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : RightParen
     ;; ====================
     ;; case: Type
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Type:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Comma
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Comma:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: PARMLIST: Type Name Comma PARMLIST :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (addVar avarVector _tk1.Value _tk2.Value (setq _tk0.Value (insert _tk4.Value 0 _tk2.Value)) #void) )
                        (if _verbose 
                            (writeRule
                                 {PARMLIST: Type Name Comma PARMLIST :: (addVar avarVector $1.Value $2.Value (setq $0.Value (insert $4.Value 0 $2.Value)) #void) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : Comma
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PARMLIST: Type Name RightParen :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar avarVector _tk1.Value _tk2.Value (setq _tk0.Value (new Vector: 1 _tk2.Value)) #void) )
                    (if _verbose 
                        (writeRule
                             {PARMLIST: Type Name RightParen :: (addVar avarVector $1.Value $2.Value (setq $0.Value (new Vector: 1 $2.Value)) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Name
       ) ; end begin
     ) ; end case : Type
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (error (append "Invalid argument list [" _tk1.Charpos "] " (mid _tkIN _tk1.Charpos 120))) )
            (if _verbose 
                (writeRule
                     {PARMLIST: Value :: (error (append "Invalid argument list [" $1.Charpos "] " (mid $IN $1.Charpos 120))) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule PARMLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.PARMLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.PARMLIST _verboseSynIn.PARMLIST) (error "Count" "in Routine PARMLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_PARMLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_PEXPRESSION
;; ************************************************
;; PEXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the PEXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_PEXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: PEXPRESSION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.PEXPRESSION #void) 
          (setq _verboseSynCount.PEXPRESSION 1) 
          (setq _verboseSynCount.PEXPRESSION (iadd _verboseSynCount.PEXPRESSION 1)))

   (if (and (<> _verboseSynIn.PEXPRESSION #void) (> _verboseSynIn.PEXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting PEXPRESSION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: TERM
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_TERM)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PEXPRESSION: TERM Operator PEXPRESSION :: (setq $0.Value (append (list $1 $2) $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (append (list _tk1 _tk2) _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {PEXPRESSION: TERM Operator PEXPRESSION :: (setq $0.Value (append (list $1 $2) $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : PEXPRESSION
           ) ; end begin
         ) ; end case : Operator
         ;; *********************************************************
         ;; RULE: PEXPRESSION: TERM :: (setq $0.Value (list $1)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (setq _tk0.Value (list _tk1)) )
            (if _verbose 
                (writeRule
                     {PEXPRESSION: TERM :: (setq $0.Value (list $1)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : TERM
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule PEXPRESSION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.PEXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.PEXPRESSION _verboseSynIn.PEXPRESSION) (error "Count" "in Routine PEXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_PEXPRESSION



















;;**EXPORTKEY**:javaScript:_SYNRULE_PHRASE
;; ************************************************
;; PHRASE user defined Syntax Rule implementation
;; Summary: This Lambda implements the PHRASE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_PHRASE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: PHRASE: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.PHRASE #void) 
          (setq _verboseSynCount.PHRASE 1) 
          (setq _verboseSynCount.PHRASE (iadd _verboseSynCount.PHRASE 1)))

   (if (and (<> _verboseSynIn.PHRASE #void) (> _verboseSynIn.PHRASE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting PHRASE Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Logical
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Logical:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list _tk1.Lisp _tk2.Value))[VType:] bool:) )
                (if _verbose 
                    (writeRule
                         {PHRASE: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 118" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {PHRASE: Logical :: (_makeError "JS 118" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Logical
     ;; ====================
     ;; case: Increment
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Increment:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk2 _tk1 false) )
                (if _verbose 
                    (writeRule
                         {PHRASE: Increment NAME :: (postfix $0 $2 $1 false) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NAME
         ;; *********************************************************
         ;; RULE: PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 119" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {PHRASE: Increment :: (_makeError "JS 119" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Increment
     ;; ====================
     ;; case: LeftBrace
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftBrace:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: STMTLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightBrace
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightBrace:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {PHRASE: LeftBrace STMTLIST RightBrace :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightBrace
           ) ; end begin
         ) ; end case : STMTLIST
         ;; *********************************************************
         ;; RULE: PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 120" _tk1.Charpos "Invalid statement block") )
            (if _verbose 
                (writeRule
                     {PHRASE: LeftBrace :: (_makeError "JS 120" $1.Charpos "Invalid statement block") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftBrace
     ;; ====================
     ;; case: If
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[If:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Else
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Else:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: SEXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (list |if|: _tk2.Value _tk3.Value _tk5.Value)) )
                            (if _verbose 
                                (writeRule
                                     {PHRASE: If SEXPRESSION SEXPRESSION Else SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value $5.Value)) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : SEXPRESSION
                     ;; *********************************************************
                     ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION Else :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (_makeError "JS 121" _tk1.Charpos "Invalid else statement") )
                        (if _verbose 
                            (writeRule
                                 {PHRASE: If SEXPRESSION SEXPRESSION Else :: (_makeError "JS 121" $1.Charpos "Invalid else statement") ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Else
                 ;; *********************************************************
                 ;; RULE: PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (setq _tk0.Value (list |if|: _tk2.Value _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: If SEXPRESSION SEXPRESSION :: (setq $0.Value (list |if|: $2.Value $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
             ;; *********************************************************
             ;; RULE: PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 121" _tk1.Charpos "Invalid then statement") )
                (if _verbose 
                    (writeRule
                         {PHRASE: If SEXPRESSION :: (_makeError "JS 121" $1.Charpos "Invalid then statement") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 122" _tk1.Charpos "Invalid if statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: If :: (_makeError "JS 122" $1.Charpos "Invalid if statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : If
     ;; ====================
     ;; case: While
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[While:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (list |while|: _tk2.Value _tk3.Value)) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: While SEXPRESSION SEXPRESSION :: (setq $0.Value (list |while|: $2.Value $3.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: PHRASE: While :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 123" _tk1.Charpos "Invalid while statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: While :: (_makeError "JS 123" $1.Charpos "Invalid while statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : While
     ;; ====================
     ;; case: For
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[For:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PHRASE
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Semicolon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Semicolon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: SEXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: Semicolon
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[Semicolon:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: PHRASE
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_PHRASE)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightParen
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightParen:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; ====================
                                     ;; case: SEXPRESSION
                                     ;; ====================
                                     (if (if (<> (setq _tk9 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip8))
                                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip9 _ip) 
                                         ;; *********************************************************
                                         ;; RULE: PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::
                                         ;; *********************************************************
                                         (if true
                                          (begin
                                            (setq _ret  (setq _tk0.Value (list |begin|: _tk3.Value (list |while|: _tk5.Value _tk9.Value _tk7.Value))) )
                                            (if _verbose 
                                                (writeRule
                                                     {PHRASE: For LeftParen PHRASE Semicolon SEXPRESSION Semicolon PHRASE RightParen SEXPRESSION :: (setq $0.Value (list |begin|: $3.Value (list |while|: $5.Value $9.Value $7.Value))) ::}
                                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 _tk9 #void))
                                            (setq _indent (isub _indent 1))
                                            (return _ret))
                                         ) ; end case : _default
                                       ) ; end begin
                                     ) ; end case : SEXPRESSION
                                   ) ; end begin
                                 ) ; end case : RightParen
                               ) ; end begin
                             ) ; end case : PHRASE
                           ) ; end begin
                         ) ; end case : Semicolon
                       ) ; end begin
                     ) ; end case : SEXPRESSION
                   ) ; end begin
                 ) ; end case : Semicolon
               ) ; end begin
             ) ; end case : PHRASE
           ) ; end begin
         ) ; end case : LeftParen
         ;; *********************************************************
         ;; RULE: PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 124" _tk1.Charpos "Invalid for statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: For :: (_makeError "JS 124" $1.Charpos "Invalid for statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : For
     ;; ====================
     ;; case: Var
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Var:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(varVector setq:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR varVector setq:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Var VAR(varVector setq:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Var VAR(varVector setq:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(varVector setq:)
         ;; *********************************************************
         ;; RULE: PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 125" _tk1.Charpos "Invalid var statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Var :: (_makeError "JS 125" $1.Charpos "Invalid var statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Var
     ;; ====================
     ;; case: Pvar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Pvar:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(pvarVector define:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR pvarVector define:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Pvar VAR(pvarVector define:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Pvar VAR(pvarVector define:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(pvarVector define:)
         ;; *********************************************************
         ;; RULE: PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 126" _tk1.Charpos "Invalid pvar statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Pvar :: (_makeError "JS 126" $1.Charpos "Invalid pvar statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Pvar
     ;; ====================
     ;; case: Cvar
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Cvar:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: VAR(cvarVector setq:)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_VAR cvarVector setq:)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Cvar VAR(cvarVector setq:) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : VAR(cvarVector setq:)
         ;; *********************************************************
         ;; RULE: PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 127" _tk1.Charpos "Invalid cvar statement") )
            (if _verbose 
                (writeRule
                     {PHRASE: Cvar :: (_makeError "JS 127" $1.Charpos "Invalid cvar statement") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Cvar
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: CFCALL($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_CFCALL _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: Name CFCALL($1) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {PHRASE: Name CFCALL($1) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : CFCALL($1)
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: NAME
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Increment
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Increment:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk1 _tk2 true) )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME Increment :: (postfix $0 $1 $2 true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Increment
         ;; ====================
         ;; case: MathAssignmentOperator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[MathAssignmentOperator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (assignMath _tk0 _tk2 _tk1 _tk3) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME MathAssignmentOperator SEXPRESSION :: (assignMath $0 $2 $1 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : MathAssignmentOperator
         ;; ====================
         ;; case: AssignmentOperator
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[AssignmentOperator:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (assignMe _tk0 _tk2 _tk1 _tk3) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME AssignmentOperator SEXPRESSION :: (assignMe $0 $2 $1 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
             ;; *********************************************************
             ;; RULE: PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 128" _tk2.Charpos "Invalid assignment") )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME AssignmentOperator :: (_makeError "JS 128" $2.Charpos "Invalid assignment") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : AssignmentOperator
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {PHRASE: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
             ;; *********************************************************
             ;; RULE: PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 129" _tk1.Charpos "Invalid function call") )
                (if _verbose 
                    (writeRule
                         {PHRASE: NAME LeftParen :: (_makeError "JS 129" $1.Charpos "Invalid function call") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : NAME
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule PHRASE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.PHRASE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.PHRASE _verboseSynIn.PHRASE) (error "Count" "in Routine PHRASE"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_PHRASE



















;;**EXPORTKEY**:javaScript:_SYNRULE_QUALIFY
;; ************************************************
;; QUALIFY user defined Syntax Rule implementation
;; Summary: This Lambda implements the QUALIFY
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_QUALIFY(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: QUALIFY: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.QUALIFY #void) 
          (setq _verboseSynCount.QUALIFY 1) 
          (setq _verboseSynCount.QUALIFY (iadd _verboseSynCount.QUALIFY 1)))

   (if (and (<> _verboseSynIn.QUALIFY #void) (> _verboseSynIn.QUALIFY -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting QUALIFY Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: DotOperator
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[DotOperator:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: DotOperator Name QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; *********************************************************
             ;; RULE: QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: DotOperator Name :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
         ;; ====================
         ;; case: Reserved
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Reserved:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: DotOperator Reserved QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value))) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)))
             ;; *********************************************************
             ;; RULE: QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 (makeQuotedSymbol _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: DotOperator Reserved :: (qualifyName $0 %0 $2 (makeQuotedSymbol $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Reserved
         ;; *********************************************************
         ;; RULE: QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 115" _tk1.Charpos "Invalid use of dot operator") )
            (if _verbose 
                (writeRule
                     {QUALIFY: DotOperator :: (_makeError "JS 115" $1.Charpos "Invalid use of dot operator") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : DotOperator
     ;; ====================
     ;; case: LeftBracket
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftBracket:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: REFLIST
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_REFLIST)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: QUALIFY((qualifyName $0 %0 $2 $2.Value))
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_QUALIFY (qualifyName _tk0 _ak0 _tk2 _tk2.Value))) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk3 )
                    (if _verbose 
                        (writeRule
                             {QUALIFY: LeftBracket REFLIST QUALIFY((qualifyName $0 %0 $2 $2.Value)) :: $3 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : QUALIFY((qualifyName $0 %0 $2 $2.Value))
             ;; *********************************************************
             ;; RULE: QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (qualifyName _tk0 _ak0 _tk2 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {QUALIFY: LeftBracket REFLIST :: (qualifyName $0 %0 $2 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : REFLIST
         ;; *********************************************************
         ;; RULE: QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 116" _tk1.Charpos "Invalid use of [ operator" ) )
            (if _verbose 
                (writeRule
                     {QUALIFY: LeftBracket :: (_makeError "JS 116" $1.Charpos "Invalid use of [ operator" ) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftBracket
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule QUALIFY on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.QUALIFY -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.QUALIFY _verboseSynIn.QUALIFY) (error "Count" "in Routine QUALIFY"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_QUALIFY



















;;**EXPORTKEY**:javaScript:_SYNRULE_REFLIST
;; ************************************************
;; REFLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the REFLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_REFLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: REFLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.REFLIST #void) 
          (setq _verboseSynCount.REFLIST 1) 
          (setq _verboseSynCount.REFLIST (iadd _verboseSynCount.REFLIST 1)))

   (if (and (<> _verboseSynIn.REFLIST #void) (> _verboseSynIn.REFLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting REFLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: REFLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_REFLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (setq _tk0.Value (insert _tk3.Value 0 _tk1.Value)) )
                    (if _verbose 
                        (writeRule
                             {REFLIST: SEXPRESSION Comma REFLIST :: (setq $0.Value (insert $3.Value 0 $1.Value)) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : REFLIST
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: RightBracket
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[RightBracket:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (new Vector: 1 _tk1.Value))[VType:] _tk1.VType) )
                (if _verbose 
                    (writeRule
                         {REFLIST: SEXPRESSION RightBracket :: (setq (setq $0.Value (new Vector: 1 $1.Value))[VType:] $1.VType) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : RightBracket
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Value
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Value:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (_makeError "JS 138" _tk1.Charpos "Invalid index list") )
            (if _verbose 
                (writeRule
                     {REFLIST: Value :: (_makeError "JS 138" $1.Charpos "Invalid index list") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Value
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule REFLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.REFLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.REFLIST _verboseSynIn.REFLIST) (error "Count" "in Routine REFLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_REFLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_SCORE
;; ************************************************
;; SCORE user defined Syntax Rule implementation
;; Summary: This Lambda implements the SCORE
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_SCORE(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SCORE: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SCORE #void) 
          (setq _verboseSynCount.SCORE 1) 
          (setq _verboseSynCount.SCORE (iadd _verboseSynCount.SCORE 1)))

   (if (and (<> _verboseSynIn.SCORE #void) (> _verboseSynIn.SCORE -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SCORE Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Score
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Score:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: AssignmentOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[AssignmentOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SSTATEMENT
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq _tk0.Value (appendList _tk3.Lisp _tk2.Value (list _tk4.Value))) )
                        (if _verbose 
                            (writeRule
                                 {SCORE: Score NAME AssignmentOperator SSTATEMENT :: (setq $0.Value (appendList $3.Lisp $2.Value (list $4.Value))) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SSTATEMENT
               ) ; end begin
             ) ; end case : AssignmentOperator
           ) ; end begin
         ) ; end case : NAME
         ;; ====================
         ;; case: SSTATEMENT
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (scoreFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {SCORE: Score SSTATEMENT :: (setq $0.Value (scoreFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SSTATEMENT
       ) ; end begin
     ) ; end case : Score
     ;; ====================
     ;; case: Score{(begin (pushVars $0) true)}
     ;; ====================
     (if (begin (setq _ip _ip0)
      (and (if (<> (setq _tk1 (_getToken))[Score:] #void) true (setq _ip _ip0)) (begin (pushVars _tk0) true)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION{(begin (popVars) true)}
         ;; ====================
         (if (and (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)) (begin (popVars) true))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq _tk0.Value (scoreFinal _tk2.Value)) )
                (if _verbose 
                    (writeRule
                         {SCORE: Score{(begin (pushVars $0) true)} SEXPRESSION{(begin (popVars) true)} :: (setq $0.Value (scoreFinal $2.Value)) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION{(begin (popVars) true)}
       ) ; end begin
     ) ; end case : Score{(begin (pushVars $0) true)}
     ;; ====================
     ;; case: SSTATEMENT
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SSTATEMENT)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq _tk0.Value (scoreFinal _tk1.Value)) )
            (if _verbose 
                (writeRule
                     {SCORE: SSTATEMENT :: (setq $0.Value (scoreFinal $1.Value)) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SSTATEMENT
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SCORE on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SCORE -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SCORE _verboseSynIn.SCORE) (error "Count" "in Routine SCORE"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SCORE



















;;**EXPORTKEY**:javaScript:_SYNRULE_SEXPRESSION
;; ************************************************
;; SEXPRESSION user defined Syntax Rule implementation
;; Summary: This Lambda implements the SEXPRESSION
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_SEXPRESSION(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SEXPRESSION: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SEXPRESSION #void) 
          (setq _verboseSynCount.SEXPRESSION 1) 
          (setq _verboseSynCount.SEXPRESSION (iadd _verboseSynCount.SEXPRESSION 1)))

   (if (and (<> _verboseSynIn.SEXPRESSION #void) (> _verboseSynIn.SEXPRESSION -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SEXPRESSION Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: EXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Question
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Question:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: EXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Colon
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Colon:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: EXPRESSION
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (setq _tk0.Value (list if: _tk1.Value _tk3.Value _tk5.Value)) )
                            (if _verbose 
                                (writeRule
                                     {SEXPRESSION: EXPRESSION Question EXPRESSION Colon EXPRESSION :: (setq $0.Value (list if: $1.Value $3.Value $5.Value)) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : EXPRESSION
                   ) ; end begin
                 ) ; end case : Colon
               ) ; end begin
             ) ; end case : EXPRESSION
           ) ; end begin
         ) ; end case : Question
         ;; *********************************************************
         ;; RULE: SEXPRESSION: EXPRESSION :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {SEXPRESSION: EXPRESSION :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : EXPRESSION
     ;; ====================
     ;; case: LeftParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Type
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Type:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: EXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_EXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq (setq (setq _tk4.VType _tk2.Value)[SEXPRESSION:] true)[Charpos:] _tk0.Charpos) )
                        (if _verbose 
                            (writeRule
                                 {SEXPRESSION: LeftParen Type RightParen EXPRESSION :: (setq (setq (setq $4.VType $2.Value)[SEXPRESSION:] true)[Charpos:] $0.Charpos) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : EXPRESSION
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Type
       ) ; end begin
     ) ; end case : LeftParen
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SEXPRESSION on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SEXPRESSION -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SEXPRESSION _verboseSynIn.SEXPRESSION) (error "Count" "in Routine SEXPRESSION"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SEXPRESSION



















;;**EXPORTKEY**:javaScript:_SYNRULE_SSTATEMENT
;; ************************************************
;; SSTATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the SSTATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_SSTATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: SSTATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.SSTATEMENT #void) 
          (setq _verboseSynCount.SSTATEMENT 1) 
          (setq _verboseSynCount.SSTATEMENT (iadd _verboseSynCount.SSTATEMENT 1)))

   (if (and (<> _verboseSynIn.SSTATEMENT #void) (> _verboseSynIn.SSTATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting SSTATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: ScoreCommand{(xReferentOn)}
     ;; ====================
     (if (and (if (<> (setq _tk1 (_getToken))[ScoreCommand:] #void) true (setq _ip _ip0)) (xReferentOn))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Semicolon
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Semicolon:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (scoreCut _tk0 _tk2.Value _tk1.Value) )
                    (if _verbose 
                        (writeRule
                             {SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION Semicolon :: (scoreCut $0 $2.Value $1.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Semicolon
             ;; *********************************************************
             ;; RULE: SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (scoreCut _tk0 _tk2.Value _tk1.Value) )
                (if _verbose 
                    (writeRule
                         {SSTATEMENT: ScoreCommand{(xReferentOn)} SEXPRESSION :: (scoreCut $0 $2.Value $1.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
       ) ; end begin
     ) ; end case : ScoreCommand{(xReferentOn)}
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule SSTATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.SSTATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.SSTATEMENT _verboseSynIn.SSTATEMENT) (error "Count" "in Routine SSTATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_SSTATEMENT



















;;**EXPORTKEY**:javaScript:_SYNRULE_STATEMENT
;; ************************************************
;; STATEMENT user defined Syntax Rule implementation
;; Summary: This Lambda implements the STATEMENT
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_STATEMENT(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STATEMENT: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STATEMENT #void) 
          (setq _verboseSynCount.STATEMENT 1) 
          (setq _verboseSynCount.STATEMENT (iadd _verboseSynCount.STATEMENT 1)))

   (if (and (<> _verboseSynIn.STATEMENT #void) (> _verboseSynIn.STATEMENT -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting STATEMENT Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: CHILD
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_CHILD)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 108" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: CHILD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 108" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defchild|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: CHILD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defchild|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 109" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: CHILD :: (_makeError "JS 109" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : CHILD
     ;; ====================
     ;; case: CLASS
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_CLASS)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Extends
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Extends:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Name
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Name:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: FIELDLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (fieldList _tk0 _tk2.Value _tk4.Value _tk6.Value) )
                                (if _verbose 
                                    (writeRule
                                         {STATEMENT: CLASS Name Extends Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value $4.Value $6.Value) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : FIELDLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : Name
               ) ; end begin
             ) ; end case : Extends
             ;; ====================
             ;; case: LeftBrace
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[LeftBrace:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: FIELDLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_FIELDLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (fieldList _tk0 _tk2.Value #void _tk4.Value) )
                        (if _verbose 
                            (writeRule
                                 {STATEMENT: CLASS Name LeftBrace FIELDLIST :: (fieldList $0 $2.Value #void $4.Value) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : FIELDLIST
               ) ; end begin
             ) ; end case : LeftBrace
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 114" _tk1.Charpos "Invalid class declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: CLASS :: (_makeError "JS 114" $1.Charpos "Invalid class declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : CLASS
     ;; ====================
     ;; case: FILTER
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FILTER)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STATEMENT: FILTER :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {STATEMENT: FILTER :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FILTER
     ;; ====================
     ;; case: FRIEND
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FRIEND)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 106" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FRIEND Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 106" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defriend|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: FRIEND Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defriend|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 107" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: FRIEND :: (_makeError "JS 107" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FRIEND
     ;; ====================
     ;; case: FUNCTION
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_FUNCTION)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: PARMLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftBrace
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftBrace:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: STMTLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: RightBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[RightBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (funList _tk0 #void _tk3 _tk5) )
                                (if _verbose 
                                    (writeRule
                                         {STATEMENT: FUNCTION LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 #void $3 $5) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : RightBrace
                       ) ; end begin
                     ) ; end case : STMTLIST
                   ) ; end begin
                 ) ; end case : LeftBrace
               ) ; end begin
             ) ; end case : PARMLIST
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: RightBrace
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[RightBrace:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (funList _tk0 _tk2 _tk4 _tk6) )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (funList $0 $2 $4 $6) ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : RightBrace
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (begin (setq _ip _ip6)
                              (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6)))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 104" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: FUNCTION Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 104" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 105" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: FUNCTION :: (_makeError "JS 105" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : FUNCTION
     ;; ====================
     ;; case: METHOD
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_METHOD)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 112" $7.Charpos "Invalid statement")::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 112" _tk7.Charpos "Invalid statement"))
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: METHOD Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 112" $7.Charpos "Invalid statement")::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defmethod|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |defmethod|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: METHOD Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |defmethod|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 113" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: METHOD :: (_makeError "JS 113" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : METHOD
     ;; ====================
     ;; case: ORPHAN
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_ORPHAN)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: LeftParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[LeftParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: PARMLIST
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: LeftBrace
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[LeftBrace:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: STMTLIST
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: Value
                             ;; ====================
                             (if (if (<> (setq _tk7 (_getToken))[Value:] #void) true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; *********************************************************
                                 ;; RULE: STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::
                                 ;; *********************************************************
                                 (if true
                                  (begin
                                    (setq _ret  (_makeError "JS 110" _tk7.Charpos "Invalid statement") )
                                    (if _verbose 
                                        (writeRule
                                             {STATEMENT: ORPHAN Name LeftParen PARMLIST LeftBrace STMTLIST Value :: (_makeError "JS 110" $7.Charpos "Invalid statement") ::}
                                             _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 #void #void #void))
                                    (setq _indent (isub _indent 1))
                                    (return _ret))
                                 ) ; end case : _default
                               ) ; end begin
                             ) ; end case : Value
                           ) ; end begin
                         ) ; end case : STMTLIST
                       ) ; end begin
                     ) ; end case : LeftBrace
                   ) ; end begin
                 ) ; end case : PARMLIST
               ) ; end begin
             ) ; end case : LeftParen
             ;; ====================
             ;; case: Name
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Name:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: LeftParen
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[LeftParen:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: PARMLIST
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_PARMLIST)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: LeftBrace
                         ;; ====================
                         (if (if (<> (setq _tk6 (_getToken))[LeftBrace:] #void) true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; ====================
                             ;; case: STMTLIST
                             ;; ====================
                             (if (if (<> (setq _tk7 (_SYNRULE_STMTLIST)) morphFail)true (setq _ip _ip6))
                               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip7 _ip) 
                                 ;; ====================
                                 ;; case: RightBrace
                                 ;; ====================
                                 (if (if (<> (setq _tk8 (_getToken))[RightBrace:] #void) true (setq _ip _ip7))
                                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip8 _ip) 
                                     ;; *********************************************************
                                     ;; RULE: STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |deforphan|: $0 $2 $3 $5 $7) ::
                                     ;; *********************************************************
                                     (if true
                                      (begin
                                        (setq _ret  (childList |deforphan|: _tk0 _tk2 _tk3 _tk5 _tk7) )
                                        (if _verbose 
                                            (writeRule
                                                 {STATEMENT: ORPHAN Name Name LeftParen PARMLIST LeftBrace STMTLIST RightBrace :: (childList |deforphan|: $0 $2 $3 $5 $7) ::}
                                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 _tk7 _tk8 #void #void))
                                        (setq _indent (isub _indent 1))
                                        (return _ret))
                                     ) ; end case : _default
                                   ) ; end begin
                                 ) ; end case : RightBrace
                               ) ; end begin
                             ) ; end case : STMTLIST
                           ) ; end begin
                         ) ; end case : LeftBrace
                       ) ; end begin
                     ) ; end case : PARMLIST
                   ) ; end begin
                 ) ; end case : LeftParen
               ) ; end begin
             ) ; end case : Name
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 111" _tk1.Charpos "Invalid function declaration") )
            (if _verbose 
                (writeRule
                     {STATEMENT: ORPHAN :: (_makeError "JS 111" $1.Charpos "Invalid function declaration") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : ORPHAN
     ;; ====================
     ;; case: SCORE
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_SCORE)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STATEMENT: SCORE :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {STATEMENT: SCORE :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : SCORE
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule STATEMENT on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STATEMENT -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STATEMENT _verboseSynIn.STATEMENT) (error "Count" "in Routine STATEMENT"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STATEMENT



















;;**EXPORTKEY**:javaScript:_SYNRULE_STMTLIST
;; ************************************************
;; STMTLIST user defined Syntax Rule implementation
;; Summary: This Lambda implements the STMTLIST
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_STMTLIST(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: STMTLIST: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.STMTLIST #void) 
          (setq _verboseSynCount.STMTLIST 1) 
          (setq _verboseSynCount.STMTLIST (iadd _verboseSynCount.STMTLIST 1)))

   (if (and (<> _verboseSynIn.STMTLIST #void) (> _verboseSynIn.STMTLIST -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting STMTLIST Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: SEXPRESSION
     ;; ====================
     (if (if (<> (setq _tk1 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (addToBeginList _tk0 _tk1.Value) )
            (if _verbose 
                (writeRule
                     {STMTLIST: SEXPRESSION << (addToBeginList $0 $1.Value) >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : SEXPRESSION
     ;; ====================
     ;; case: Semicolon
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Semicolon:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: STMTLIST: Semicolon << $0 >>
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  _tk0 )
            (if _verbose 
                (writeRule
                     {STMTLIST: Semicolon << $0 >>}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (goto Skip:))

         ) ; end case : _default
       ) ; end begin
     ) ; end case : Semicolon
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule STMTLIST on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.STMTLIST -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.STMTLIST _verboseSynIn.STMTLIST) (error "Count" "in Routine STMTLIST"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_STMTLIST



















;;**EXPORTKEY**:javaScript:_SYNRULE_TERM
;; ************************************************
;; TERM user defined Syntax Rule implementation
;; Summary: This Lambda implements the TERM
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_TERM(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: TERM: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.TERM #void) 
          (setq _verboseSynCount.TERM 1) 
          (setq _verboseSynCount.TERM (iadd _verboseSynCount.TERM 1)))

   (if (and (<> _verboseSynIn.TERM #void) (> _verboseSynIn.TERM -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting TERM Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Boolean
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Boolean:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setq (setq _tk0.Value _tk1.Boolean)[VType:] bool:) )
            (if _verbose 
                (writeRule
                     {TERM: Boolean :: (setq (setq $0.Value $1.Boolean)[VType:] bool:) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Boolean
     ;; ====================
     ;; case: -
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] |-|:) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Term
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Term:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list |-|: 0 _tk2.Value))[VType:] _tk2.VType) )
                (if _verbose 
                    (writeRule
                         {TERM: - Term :: (setq (setq $0.Value (list |-|: 0 $2.Value))[VType:] $2.VType) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Term
         ;; ====================
         ;; case: Number
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Number:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (foldConstants _tk0 |-|: 0 _tk2.Value) )
                (if _verbose 
                    (writeRule
                         {TERM: - Number :: (foldConstants $0 |-|: 0 $2.Value) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Number
       ) ; end begin
     ) ; end case : -
     ;; ====================
     ;; case: +
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (= (setq _tk1 (_getToken))[Value:] |+|:) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Term
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Term:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: + Term :: (setVType $2) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setVType _tk2) )
                (if _verbose 
                    (writeRule
                         {TERM: + Term :: (setVType $2) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Term
       ) ; end begin
     ) ; end case : +
     ;; ====================
     ;; case: LeftParen
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[LeftParen:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Type
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Type:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SEXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (setq (setq (setq _tk4.VType _tk2.Value)[TERM:] true)[Charpos:] _tk0.Charpos) )
                        (if _verbose 
                            (writeRule
                                 {TERM: LeftParen Type RightParen SEXPRESSION :: (setq (setq (setq $4.VType $2.Value)[TERM:] true)[Charpos:] $0.Charpos) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SEXPRESSION
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : Type
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: RightParen
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[RightParen:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: LeftParen SEXPRESSION RightParen :: $2 ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  _tk2 )
                    (if _verbose 
                        (writeRule
                             {TERM: LeftParen SEXPRESSION RightParen :: $2 ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : RightParen
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 130" _tk1.Charpos "Invalid expression") )
            (if _verbose 
                (writeRule
                     {TERM: LeftParen :: (_makeError "JS 130" $1.Charpos "Invalid expression") ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : LeftParen
     ;; ====================
     ;; case: Logical
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Logical:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: SEXPRESSION
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (setq (setq _tk0.Value (list _tk1.Lisp _tk2.Value))[VType:] bool:) )
                (if _verbose 
                    (writeRule
                         {TERM: Logical SEXPRESSION :: (setq (setq $0.Value (list $1.Lisp $2.Value))[VType:] bool:) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : SEXPRESSION
         ;; *********************************************************
         ;; RULE: TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 131" _tk1.Charpos (append "Invalid " _tk1.Value " operator")))
            (if _verbose 
                (writeRule
                     {TERM: Logical :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator"))::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Logical
     ;; ====================
     ;; case: Increment
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Increment:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: NAME
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Increment NAME :: (postfix $0 $2 $1 false) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk2 _tk1 false) )
                (if _verbose 
                    (writeRule
                         {TERM: Increment NAME :: (postfix $0 $2 $1 false) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : NAME
         ;; *********************************************************
         ;; RULE: TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (_makeError "JS 131" _tk1.Charpos (append "Invalid " _tk1.Value " operator")) )
            (if _verbose 
                (writeRule
                     {TERM: Increment :: (_makeError "JS 131" $1.Charpos (append "Invalid " $1.Value " operator")) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Increment
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: CFCALL($1)
         ;; ====================
         (if (if (<> (setq _tk2 (_SYNRULE_CFCALL _tk1)) morphFail)true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: Name CFCALL($1) :: $2 ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  _tk2 )
                (if _verbose 
                    (writeRule
                         {TERM: Name CFCALL($1) :: $2 ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : CFCALL($1)
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {TERM: Name LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
           ) ; end begin
         ) ; end case : LeftParen
       ) ; end begin
     ) ; end case : Name
     ;; ====================
     ;; case: NAME
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_SYNRULE_NAME)) morphFail)true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: LeftParen
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[LeftParen:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: ARGLIST
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_ARGLIST)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (argList _tk0 _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {TERM: NAME LeftParen ARGLIST :: (argList $0 $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : ARGLIST
             ;; *********************************************************
             ;; RULE: TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 132" _tk1.Charpos "Invalid function call") )
                (if _verbose 
                    (writeRule
                         {TERM: NAME LeftParen :: (_makeError "JS 132" $1.Charpos "Invalid function call") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : LeftParen
         ;; ====================
         ;; case: Increment
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Increment:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: TERM: NAME Increment :: (postfix $0 $1 $2 true) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (postfix _tk0 _tk1 _tk2 true) )
                (if _verbose 
                    (writeRule
                         {TERM: NAME Increment :: (postfix $0 $1 $2 true) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Increment
         ;; *********************************************************
         ;; RULE: TERM: NAME :: $1 ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  _tk1 )
            (if _verbose 
                (writeRule
                     {TERM: NAME :: $1 ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : NAME
     ;; ====================
     ;; case: Number
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Number:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Operator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Operator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: Number
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[Number:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (foldConstants _tk0 _tk2.Lisp _tk1.Value _tk3.Value) )
                    (if _verbose 
                        (writeRule
                             {TERM: Number Operator Number :: (foldConstants $0 $2.Lisp $1.Value $3.Value) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Number
           ) ; end begin
         ) ; end case : Operator
       ) ; end begin
     ) ; end case : Number
     ;; ====================
     ;; case: Term
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Term:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; *********************************************************
         ;; RULE: TERM: Term :: (setVType $1) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ret  (setVType _tk1) )
            (if _verbose 
                (writeRule
                     {TERM: Term :: (setVType $1) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Term
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule TERM on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.TERM -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.TERM _verboseSynIn.TERM) (error "Count" "in Routine TERM"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_TERM



















;;**EXPORTKEY**:javaScript:_SYNRULE_VAR
;; ************************************************
;; VAR user defined Syntax Rule implementation
;; Summary: This Lambda implements the VAR
;;          user defined rule. Each rule test is
;;          marked with a boxed comment line for
;;          ease of human understanding.
;; Note: This code was machine generated by ParseLib.
;; ************************************************
(defchild javaScript:_SYNRULE_VAR(...)
   ;; The token object _io is a persistent variable
   ;; The token pointer _ip is a persistent variable
   ;; All getToken logic increments _ip on each token fetch.
   ;; The return value from the rule is stored in _ret.
   ;; Remember that this rule may repeat depending on _repeatSW.
   vars:(_tk0 _tk1 _tk2 _tk3 _tk4  _tk5  _i
         _tk6 _tk7 _tk8 _tk9 _tkn  _repeatSW
         _ak0 _ak1 _ak2 _ak3 _ak4  _ak5  _tkthis
         _ak6 _ak7 _ak8 _ak9 _ret  _oldIp
         _ip0 _ip1 _ip2 _ip3 _ip4  _ip5
         _ip6 _ip7 _ip8 _ip9 _tkn  
         _verboseSave       
        ) ; end temporary variables
   ;; Collect any arguments which may have been passed to this rule
   (if (> (setq _tkn (argCount)) 0)
       (begin (setq _ak0 (argFetch 0))
          (if (> _tkn 1) 
              (begin (setq _ak1 (argFetch 1))
                 (if (> _tkn 2) 
                     (begin (setq _ak2 (argFetch 2))
                        (if (> _tkn 3) 
                            (begin (setq _ak3 (argFetch 3))
                               (if (> _tkn 4) 
                                   (begin (setq _ak4 (argFetch 4))
                                      (if (> _tkn 5) 
                                          (begin (setq _ak5 (argFetch 5))
                                             (if (> _tkn 6) 
                                                 (begin (setq _ak6 (argFetch 6))
                                                    (if (> _tkn 7) 
                                                        (begin (setq _ak7 (argFetch 7))
                                                           (if (> _tkn 8) 
                                                               (begin (setq _ak8 (argFetch 8))
                                                               (if (> _tkn 9) (setq _ak9 (argFetch 9))
                                                           ))))))))))))))))))) ; end argument collection
   ;; The default structure is given the named rule attribute
   (setq _tk0 (new Structure: VAR: true  ))
   (setq _tkn 0)
   (setq _oldIp _ip)
   (setq _repeatSW true)

   (if (= _verboseSynCount.VAR #void) 
          (setq _verboseSynCount.VAR 1) 
          (setq _verboseSynCount.VAR (iadd _verboseSynCount.VAR 1)))

   (if (and (<> _verboseSynIn.VAR #void) (> _verboseSynIn.VAR -1))
       (begin (setq _verboseSave _verbose) (setq _verbose true))) 

   ;; Save the old token pointer and test for user defined rules
   Skip::
     (setq _indent (iadd _indent 1))
     (if _verbose (_logLine "Attempting VAR Rule on: " source:))
     (setq _ip0 _ip)
     (++ _tkn)
     (setq _repeatSW false)

     ;; *****************************************
     ;; Begin testing for each user defined rule.
     ;; *****************************************
     ;; ====================
     ;; case: Type
     ;; ====================
     (if (if (<> (setq _tk1 (_getToken))[Type:] #void) true (setq _ip _ip0))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: InitializeOperator
             ;; ====================
             (if (if (<> (setq _tk3 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: SEXPRESSION
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: Comma
                     ;; ====================
                     (if (if (<> (setq _tk5 (_getToken))[Comma:] #void) true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; ====================
                         ;; case: VAR(%0 %1)
                         ;; ====================
                         (if (if (<> (setq _tk6 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip5))
                           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip6 _ip) 
                             ;; *********************************************************
                             ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::
                             ;; *********************************************************
                             (if true
                              (begin
                                (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value (addToBeginList _tk0 (appendList _ak1 _tk2.Value (list _tk4.Value))) _tk6) )
                                (if _verbose 
                                    (writeRule
                                         {VAR: Type Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) $6) ::}
                                         _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 _tk6 #void #void #void #void))
                                (setq _indent (isub _indent 1))
                                (return _ret))
                             ) ; end case : _default
                           ) ; end begin
                         ) ; end case : VAR(%0 %1)
                         ;; *********************************************************
                         ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ip _ip5)
                            (setq _ret  (_makeError "JS 135" _tk5.Charpos "Invalid var statement") )
                            (if _verbose 
                                (writeRule
                                     {VAR: Type Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 135" $5.Charpos "Invalid var statement") ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : Comma
                     ;; *********************************************************
                     ;; RULE: VAR: Type Name InitializeOperator SEXPRESSION :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value (addToBeginList _tk0 (appendList _ak1 _tk2.Value (list _tk4.Value))) #void) )
                        (if _verbose 
                            (writeRule
                                 {VAR: Type Name InitializeOperator SEXPRESSION :: (addVar %0 $1.Value $2.Value (addToBeginList $0 (appendList %1 $2.Value (list $4.Value))) #void) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : SEXPRESSION
               ) ; end begin
             ) ; end case : InitializeOperator
             ;; ====================
             ;; case: Comma
             ;; ====================
             (if (begin (setq _ip _ip2)
              (if (<> (setq _tk3 (_getToken))[Comma:] #void) true (setq _ip _ip2)))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: VAR(%0 %1)
                 ;; ====================
                 (if (if (<> (setq _tk4 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; *********************************************************
                     ;; RULE: VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value _tk0 _tk4) )
                        (if _verbose 
                            (writeRule
                                 {VAR: Type Name Comma VAR(%0 %1) :: (addVar %0 $1.Value $2.Value $0 $4) ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : VAR(%0 %1)
                 ;; *********************************************************
                 ;; RULE: VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (_makeError "JS 136" _tk3.Charpos "Invalid var statement") )
                    (if _verbose 
                        (writeRule
                             {VAR: Type Name Comma :: (_makeError "JS 136" $3.Charpos "Invalid var statement") ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : Comma
             ;; *********************************************************
             ;; RULE: VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (addVar _ak0 _tk1.Value _tk2.Value _tk0 #void) )
                (if _verbose 
                    (writeRule
                         {VAR: Type Name :: (addVar %0 $1.Value $2.Value $0 #void) ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
       ) ; end begin
     ) ; end case : Type
     ;; ====================
     ;; case: Name
     ;; ====================
     (if (begin (setq _ip _ip0)
      (if (<> (setq _tk1 (_getToken))[Name:] #void) true (setq _ip _ip0)))
       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip1 _ip) 
         ;; ====================
         ;; case: InitializeOperator
         ;; ====================
         (if (if (<> (setq _tk2 (_getToken))[InitializeOperator:] #void) true (setq _ip _ip1))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: SEXPRESSION
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_SEXPRESSION)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; ====================
                 ;; case: Comma
                 ;; ====================
                 (if (if (<> (setq _tk4 (_getToken))[Comma:] #void) true (setq _ip _ip3))
                   (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip4 _ip) 
                     ;; ====================
                     ;; case: VAR(%0 %1)
                     ;; ====================
                     (if (if (<> (setq _tk5 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip4))
                       (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip5 _ip) 
                         ;; *********************************************************
                         ;; RULE: VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::
                         ;; *********************************************************
                         (if true
                          (begin
                            (setq _ret  (addVar _ak0 obj: _tk1.Value (addToBeginList _tk0 (appendList _ak1 _tk1.Value (list _tk3.Value))) _tk5) )
                            (if _verbose 
                                (writeRule
                                     {VAR: Name InitializeOperator SEXPRESSION Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) $5) ::}
                                     _ret  _tk0 _tk1 _tk2 _tk3 _tk4 _tk5 #void #void #void #void #void))
                            (setq _indent (isub _indent 1))
                            (return _ret))
                         ) ; end case : _default
                       ) ; end begin
                     ) ; end case : VAR(%0 %1)
                     ;; *********************************************************
                     ;; RULE: VAR: Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::
                     ;; *********************************************************
                     (if true
                      (begin
                        (setq _ip _ip4)
                        (setq _ret  (_makeError "JS 133" _tk4.Charpos "Invalid var statement") )
                        (if _verbose 
                            (writeRule
                                 {VAR: Name InitializeOperator SEXPRESSION Comma :: (_makeError "JS 133" $4.Charpos "Invalid var statement") ::}
                                 _ret  _tk0 _tk1 _tk2 _tk3 _tk4 #void #void #void #void #void #void))
                        (setq _indent (isub _indent 1))
                        (return _ret))
                     ) ; end case : _default
                   ) ; end begin
                 ) ; end case : Comma
                 ;; *********************************************************
                 ;; RULE: VAR: Name InitializeOperator SEXPRESSION :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ip _ip3)
                    (setq _ret  (addVar _ak0 obj: _tk1.Value (addToBeginList _tk0 (appendList _ak1 _tk1.Value (list _tk3.Value))) #void) )
                    (if _verbose 
                        (writeRule
                             {VAR: Name InitializeOperator SEXPRESSION :: (addVar %0 obj: $1.Value (addToBeginList $0 (appendList %1 $1.Value (list $3.Value))) #void) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : SEXPRESSION
           ) ; end begin
         ) ; end case : InitializeOperator
         ;; ====================
         ;; case: Comma
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Comma:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; ====================
             ;; case: VAR(%0 %1)
             ;; ====================
             (if (if (<> (setq _tk3 (_SYNRULE_VAR _ak0 _ak1)) morphFail)true (setq _ip _ip2))
               (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip3 _ip) 
                 ;; *********************************************************
                 ;; RULE: VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::
                 ;; *********************************************************
                 (if true
                  (begin
                    (setq _ret  (addVar _ak0 obj: _tk1.Value _tk0 _tk3) )
                    (if _verbose 
                        (writeRule
                             {VAR: Name Comma VAR(%0 %1) :: (addVar %0 obj: $1.Value $0 $3) ::}
                             _ret  _tk0 _tk1 _tk2 _tk3 #void #void #void #void #void #void #void))
                    (setq _indent (isub _indent 1))
                    (return _ret))
                 ) ; end case : _default
               ) ; end begin
             ) ; end case : VAR(%0 %1)
             ;; *********************************************************
             ;; RULE: VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ip _ip2)
                (setq _ret  (_makeError "JS 134" _tk2.Charpos "Invalid var statement") )
                (if _verbose 
                    (writeRule
                         {VAR: Name Comma :: (_makeError "JS 134" $2.Charpos "Invalid var statement") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Comma
         ;; ====================
         ;; case: Name
         ;; ====================
         (if (begin (setq _ip _ip1)
          (if (<> (setq _tk2 (_getToken))[Name:] #void) true (setq _ip _ip1)))
           (begin (++ _ruleCount) (if (and (> _verboseTrigger 0) (> _ruleCount _verboseTrigger) (not _verbose)) (_startLog)) (setq _ip2 _ip) 
             ;; *********************************************************
             ;; RULE: VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::
             ;; *********************************************************
             (if true
              (begin
                (setq _ret  (_makeError "JS 136" _tk1.Charpos "Invalid var type") )
                (if _verbose 
                    (writeRule
                         {VAR: Name Name :: (_makeError "JS 136" $1.Charpos "Invalid var type") ::}
                         _ret  _tk0 _tk1 _tk2 #void #void #void #void #void #void #void #void))
                (setq _indent (isub _indent 1))
                (return _ret))
             ) ; end case : _default
           ) ; end begin
         ) ; end case : Name
         ;; *********************************************************
         ;; RULE: VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::
         ;; *********************************************************
         (if true
          (begin
            (setq _ip _ip1)
            (setq _ret  (addVar _ak0 obj: _tk1.Value _tk0 #void) )
            (if _verbose 
                (writeRule
                     {VAR: Name :: (addVar %0 obj: $1.Value $0 #void) ::}
                     _ret  _tk0 _tk1 #void #void #void #void #void #void #void #void #void))
            (setq _indent (isub _indent 1))
            (return _ret))
         ) ; end case : _default
       ) ; end begin
     ) ; end case : Name
     ;; **************************************************
     ;; DEFAULT (if we get to here we failed to recognize)
     ;; Note:       (at least on this repetition)
     ;; **************************************************
     (begin
        (if (= _tkn 1)
            ;; If we have never recognized any token on previous repetitions 
            (begin
               (setq _ip _oldIp)     
               (if _verbose (_logLine "Rejecting Rule VAR on: " source:))
               (setq _indent (isub _indent 1))
               (setq _ret morphFail)
               ) ; end begin then
            else
            ;; If we have recognized some tokens on previous repetitions, then return $0
            ;; Note: In Syntax Rules, we do not fail the rule if it has 
            ;;       recognized a token in one or more repetitions of the rule. 
            (begin
               (setq _ip _ip0)
               (setq _ret _tk0)
               ) ; end begin else
            ) ; end if
        ) ; end of DEFAULT

   ;; End of tests for user defined rules.
   
   (if (> _verboseSynIn.VAR -1)
       (begin
          (setq _verbose _verboseSave)
          (if (>= _verboseSynCount.VAR _verboseSynIn.VAR) (error "Count" "in Routine VAR"))
       ))

   ;; Repeat or return to caller is handled here.
   _ret) ;; end _SYNRULE_VAR


















